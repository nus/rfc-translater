<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8252 - OAuth 2.0 for Native Apps 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8252</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8252 - OAuth 2.0 for Native Apps 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8252">
              https://tools.ietf.org/html/rfc8252
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8252 - ネイティブアプリのOAuth 2.0</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                        W. Denniss
Request for Comments: 8252                                        Google
BCP: 212                                                      J. Bradley
Updates: 6749                                              Ping Identity
Category: Best Current Practice                             October 2017
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       OAuth 2.0 for Native Apps
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OAuth 2.0 authorization requests from native apps should only be made through external user-agents, primarily the user&#39;s browser. This specification details the security and usability reasons why this is the case and how native apps and authorization servers can implement this best practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネイティブアプリケーションからOAuth 2.0の認証要求は、外部ユーザーエージェント、主にユーザーのブラウザを介して行われるべきです。この仕様は、このような場合は、どのようにネイティブアプリケーションと許可サーバこのベストプラクティスを実装することができ、なぜセキュリティと使いやすさの理由を詳しく説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This memo documents an Internet Best Current Practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモはインターネット最も良い現在の練習を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on BCPs is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 BCPの詳細については、RFC 7841のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8252.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttps://www.rfc-editor.org/info/rfc8252で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（https://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Notational Conventions  . . . . . . . . . . . . . . . . . . .   3
   3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3
   4.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   4
     4.1.  Authorization Flow for Native Apps Using the Browser  . .   5
   5.  Using Inter-App URI Communication for OAuth . . . . . . . . .   6
   6.  Initiating the Authorization Request from a Native App  . . .   6
   7.  Receiving the Authorization Response in a Native App  . . . .   7
     7.1.  Private-Use URI Scheme Redirection  . . . . . . . . . . .   8
     7.2.  Claimed &#34;https&#34; Scheme URI Redirection  . . . . . . . . .   9
     7.3.  Loopback Interface Redirection  . . . . . . . . . . . . .   9
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  10
     8.1.  Protecting the Authorization Code . . . . . . . . . . . .  10
     8.2.  OAuth Implicit Grant Authorization Flow . . . . . . . . .  11
     8.3.  Loopback Redirect Considerations  . . . . . . . . . . . .  11
     8.4.  Registration of Native App Clients  . . . . . . . . . . .  12
     8.5.  Client Authentication . . . . . . . . . . . . . . . . . .  12
     8.6.  Client Impersonation  . . . . . . . . . . . . . . . . . .  13
     8.7.  Fake External User-Agents . . . . . . . . . . . . . . . .  13
     8.8.  Malicious External User-Agents  . . . . . . . . . . . . .  14
     8.9.  Cross-App Request Forgery Protections . . . . . . . . . .  14
     8.10. Authorization Server Mix-Up Mitigation  . . . . . . . . .  14
     8.11. Non-Browser External User-Agents  . . . . . . . . . . . .  15
     8.12. Embedded User-Agents  . . . . . . . . . . . . . . . . . .  15
   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  16
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  16
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  16
     10.2.  Informative References . . . . . . . . . . . . . . . . .  17
   Appendix A.  Server Support Checklist . . . . . . . . . . . . . .  18
   Appendix B.  Platform-Specific Implementation Details . . . . . .  18
     B.1.  iOS Implementation Details  . . . . . . . . . . . . . . .  18
     B.2.  Android Implementation Details  . . . . . . . . . . . . .  19
     B.3.  Windows Implementation Details  . . . . . . . . . . . . .  19
     B.4.  macOS Implementation Details  . . . . . . . . . . . . . .  20
     B.5.  Linux Implementation Details  . . . . . . . . . . . . . .  21
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  21
   Authors&#39; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  21
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 9 of the OAuth 2.0 authorization framework [RFC6749] documents two approaches for native apps to interact with the authorization endpoint: an embedded user-agent and an external user-agent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
埋め込まれたユーザ・エージェントおよび外部ユーザーエージェント：OAuth 2.0の承認フレームワークのセクション9は、[RFC6749]の文書がネイティブアプリケーションのための2つのアプローチが許可エンドポイントと相互作用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This best current practice requires that only external user-agents like the browser are used for OAuth by native apps. It documents how native apps can implement authorization flows using the browser as the preferred external user-agent as well as the requirements for authorization servers to support such usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この現在のベストプラクティスは、ブラウザのような唯一の外部ユーザーエージェントは、ネイティブアプリケーションでOAuthのた​​めに使用されていることが必要です。これは、ネイティブアプリが承認は、そのような使用をサポートするために有利な外部のユーザーエージェントとしてブラウザだけでなく、認可サーバの要件を使用してフローを実装する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This practice is also known as the &#34;AppAuth pattern&#34;, in reference to open-source libraries [AppAuth] that implement it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この方法はまた、「AppAuthパターン」、それを実装基準にするオープンソースのライブラリ[AppAuth]として知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Notational Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.表記規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、 &#34;SHALL&#34;、 &#34;SHOULD&#34;、 &#34;ないもの&#34;、 &#34;推奨&#34; &#34;ない（SHOULD NOT）&#34;、 &#34;MAY&#34;、 &#34;推奨NOT&#34;、および「OPTIONAL BCP 14に記載されているように「この文書に解釈されるべきである[RFC2119]、[RFC8174]と、ここで示されるように、それらは、すべて大文字で表示された場合にのみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the terms defined in referenced specifications, this document uses the following terms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照仕様で定義された用語に加えて、この文書は、次の用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;native app&#34; An app or application that is installed by the user to their device, as distinct from a web app that runs in the browser context only. Apps implemented using web-based technology but distributed as a native app, so-called &#34;hybrid apps&#34;, are considered equivalent to native apps for the purpose of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ネイティブアプリケーション」のみブラウザコンテキストで実行するWebアプリケーションとは異なるように、それらのデバイスにユーザによってインストールされるアプリケーションやアプリケーション。アプリは、Webベースの技術を使用して実装が、ネイティブアプリとして配布、いわゆる「ハイブリッドアプリケーション」、本明細書の目的のためのネイティブアプリケーションと同等であると考えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;app&#34; A &#34;native app&#34; unless further specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、指定されない限り、「アプリ」「ネイティブアプリ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;app store&#34; An e-commerce store where users can download and purchase apps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「アプリストア」ユーザーがアプリをダウンロードして購入することができ、eコマースストア。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;OAuth&#34; Authorization protocol specified by the OAuth 2.0 Authorization Framework [RFC6749].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OAuth 2.0の認証フレームワーク[RFC6749]で指定された「OAuthの」認可プロトコル。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;external user-agent&#34; A user-agent capable of handling the authorization request that is a separate entity or security domain to the native app making the request, such that the app cannot access the cookie storage, nor inspect or modify page content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「外部ユーザー・エージェント」アプリは、クッキーストレージにアクセス、また検査やページのコンテンツを変更できないように、要求を、作るネイティブアプリとは別のエンティティまたはセキュリティドメインで認証要求を処理できるユーザーエージェント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;embedded user-agent&#34; A user-agent hosted by the native app making the authorization request that forms a part of the app or shares the same security domain such that the app can access the cookie storage and/or inspect or modify page content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「組み込みユーザーエージェント」のアプリやアプリはクッキーストレージにアクセスおよび/または点検やページのコンテンツを変更することができ、同じセキュリティドメインように株式の一部を構成する認証要求を行うネイティブアプリによってホストされているユーザエージェント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;browser&#34; The default application launched by the operating system to handle &#34;http&#34; and &#34;https&#34; scheme URI content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ブラウザ」「http」と「https」スキームURIのコンテンツを処理するために、オペレーティング・システムによって起動デフォルトアプリケーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;in-app browser tab&#34; A programmatic instantiation of the browser that is displayed inside a host app but that retains the full security properties and authentication state of the browser. It has different platform-specific product names, several of which are detailed in Appendix B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「アプリ内のブラウザタブ」ホストアプリ内で表示されますが、それは完全なセキュリティ特性やブラウザの認証状態を保持しているブラウザのプログラムでインスタンス化。これは、付録Bで詳しく説明されているそのうちのいくつかの異なるプラットフォーム固有の製品名を、持っています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;web-view&#34; A web browser UI (user interface) component that is embedded in apps to render web pages under the control of the app.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ウェブビュー」アプリケーションの制御下でウェブページをレンダリングするアプリケーションに埋め込まれているウェブブラウザUI（ユーザインタフェース）コンポーネント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;inter-app communication&#34; Communication between two apps on a device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デバイス上の2つのアプリケーション間の「相互のアプリ通信」の通信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;claimed &#34;https&#34; scheme URI&#34; Some platforms allow apps to claim an &#34;https&#34; scheme URI after proving ownership of the domain name. URIs claimed in such a way are then opened in the app instead of the browser.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のプラットフォームでは、アプリは、ドメイン名の所有権を証明した後に「https」のスキームURIを請求することができます。https「スキームURI 『を』主張」。 URIは、代わりに、ブラウザのアプリで開くように主張しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;private-use URI scheme&#34; As used by this document, a URI scheme defined by the app (following the requirements of Section 3.8 of [RFC7595]) and registered with the operating system. URI requests to such schemes launch the app that registered it to handle the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「私的利用URIスキーム」この文書で使用されるように、URIスキームは（[RFC7595]のセクション3.8の要件以下）アプリケーションによって定義され、オペレーティングシステムに登録されました。そのようなスキームのURI要求は、要求を処理するために、それを登録してアプリを起動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;reverse domain name notation&#34; A naming convention based on the domain name system, but one where the domain components are reversed, for example, &#34;app.example.com&#34; becomes &#34;com.example.app&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「逆ドメイン名表記」ドメインネームシステムに基づく命名規則が、ドメイン成分は、例えば、反転された1つは、「app.example.com」は「com.example.app」となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For authorizing users in native apps, the best current practice is to perform the OAuth authorization request in an external user-agent (typically the browser) rather than an embedded user-agent (such as one implemented with web-views).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネイティブアプリケーションでユーザーを認証するために、現在のベストプラクティスは、外部のユーザーエージェントでのOAuth認証要求（通常はブラウザ）ではなく、埋め込まれたユーザエージェント（ウェブビューで実装のようなもの）を実行することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Previously, it was common for native apps to use embedded user-agents (commonly implemented with web-views) for OAuth authorization requests. That approach has many drawbacks, including the host app being able to copy user credentials and cookies as well as the user needing to authenticate from scratch in each app. See Section 8.12
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネイティブアプリがOAuthの認証要求のために（一般のWebビューで実装）埋め込まれたユーザーエージェントを使用するために以前は、それが一般的でした。このアプローチは、ホストアプリがユーザーの資格情報やクッキーなど、各アプリでゼロからの認証に必要ユーザーをコピーすることができることなど、多くの欠点を持っています。セクション8.12を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
for a deeper analysis of the drawbacks of using embedded user-agents for OAuth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OAuthのた​​めの組み込みユーザーエージェントを使用しての欠点のより深い分析のため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Native app authorization requests that use the browser are more secure and can take advantage of the user&#39;s authentication state. Being able to use the existing authentication session in the browser enables single sign-on, as users don&#39;t need to authenticate to the authorization server each time they use a new app (unless required by the authorization server policy).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブラウザを使用して、ネイティブアプリの認証要求は、より安全であり、利用者の認証状態を利用することができます。 （認証サーバポリシーによって要求されない限り）ユーザーは認証サーバに、彼らは新しいアプリを使用するたびに認証する必要がないので、ブラウザで既存の認証セッションを使用できることは、シングルサインオンを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Supporting authorization flows between a native app and the browser is possible without changing the OAuth protocol itself, as the OAuth authorization request and response are already defined in terms of URIs. This encompasses URIs that can be used for inter-app communication. Some OAuth server implementations that assume all clients are confidential web clients will need to add an understanding of public native app clients and the types of redirect URIs they use to support this best practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証をサポートするネイティブアプリケーションとの間に流れ、ブラウザが既にURIの用語で定義されているOAuthの認可リクエストとレスポンスとして、OAuthプロトコル自体を変更することなく可能です。これは、インターアプリケーション通信のために使用することができるURIを包含する。すべてのクライアントが機密ウェブクライアントであると仮定し、一部のOAuthサーバの実装は、パブリックネイティブアプリのクライアントと彼らはこのベストプラクティスをサポートするために使用したリダイレクトURIの種類の理解を追加する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Authorization Flow for Native Apps Using the Browser
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。ブラウザを使用したネイティブアプリの承認フロー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
  |          User Device          |
  |                               |
  | +--------------------------+  | (5) Authorization  +---------------+
  | |                          |  |     Code           |               |
  | |        Client App        |----------------------&gt;|     Token     |
  | |                          |&lt;----------------------|    Endpoint   |
  | +--------------------------+  | (6) Access Token,  |               |
  |   |             ^             |     Refresh Token  +---------------+
  |   |             |             |
  |   |             |             |
  |   | (1)         | (4)         |
  |   | Authorizat- | Authoriza-  |
  |   | ion Request | tion Code   |
  |   |             |             |
  |   |             |             |
  |   v             |             |
  | +---------------------------+ | (2) Authorization  +---------------+
  | |                           | |     Request        |               |
  | |          Browser          |---------------------&gt;| Authorization |
  | |                           |&lt;---------------------|    Endpoint   |
  | +---------------------------+ | (3) Authorization  |               |
  |                               |     Code           +---------------+
  +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1: Native App Authorization via an External User-Agent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1：外部のUser-Agentを経由してネイティブアプリの認証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1 illustrates the interaction between a native app and the browser to authorize the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1は、ネイティブアプリケーションとユーザを認証するためのブラウザとの間の相互作用を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) Client app opens a browser tab with the authorization request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）クライアントアプリは、認証要求とブラウザのタブを開きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) Authorization endpoint receives the authorization request, authenticates the user, and obtains authorization. Authenticating the user may involve chaining to other authentication systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）認可エンドポイントは、認証要求を受信するユーザを認証し、認証を取得します。ユーザを認証すると、他の認証システムに連鎖することを含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) Authorization server issues an authorization code to the redirect URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）認証サーバは、リダイレクトURIに認証コードを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) Client receives the authorization code from the redirect URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）クライアントは、リダイレクトURIから認証コードを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(5) Client app presents the authorization code at the token endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（5）クライアントアプリはトークンエンドポイントで認証コードを提示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(6) Token endpoint validates the authorization code and issues the tokens requested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（6）トークンエンドポイントは、認証コードを検証し、要求されたトークンを発行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Using Inter-App URI Communication for OAuth
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. OAuthのた​​めのInter-アプリのURI通信を使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Just as URIs are used for OAuth 2.0 [RFC6749] on the web to initiate the authorization request and return the authorization response to the requesting website, URIs can be used by native apps to initiate the authorization request in the device&#39;s browser and return the response to the requesting native app.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIは、認証要求を開始し、要求ウェブサイトへの許可応答を返すために、ウェブ上でのOAuth 2.0 [RFC6749]のために使用されているのと同じように、URIは、デバイスのブラウザに認証リクエストを開始し、への応答を返すために、ネイティブアプリケーションで使用することができます要求してネイティブアプリ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By adopting the same methods used on the web for OAuth, benefits seen in the web context like the usability of a single sign-on session and the security of a separate authentication context are likewise gained in the native app context. Reusing the same approach also reduces the implementation complexity and increases interoperability by relying on standards-based web flows that are not specific to a particular platform.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OAuthのた​​めにウェブ上で使用したのと同じ方法を採用することにより、セッションシングルサインオンと独立した認証コンテキストのセキュリティの利便性などのWebコンテキストで見られる利点は、同様に、ネイティブアプリケーションのコンテキストで獲得されています。同じアプローチを再利用することも、実装の複雑さを低減し、特定のプラットフォームに固有ではない標準ベースのウェブ・フローに依存することによって、相互運用性を増加させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To conform to this best practice, native apps MUST use an external user-agent to perform OAuth authorization requests. This is achieved by opening the authorization request in the browser (detailed in Section 6) and using a redirect URI that will return the authorization response back to the native app (defined in Section 7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このベストプラクティスに準拠するには、ネイティブアプリケーションは、OAuthの認証要求を実行するために外部のユーザーエージェントを使用しなければなりません。これは、（第6節に詳述）ブラウザで認証要求を開き、ネイティブアプリに戻って許可応答を返すだろうリダイレクトURIを使用することにより達成される（セクション7で定義されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Initiating the Authorization Request from a Native App
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.ネイティブアプリから認証要求を開始
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Native apps needing user authorization create an authorization request URI with the authorization code grant type per Section 4.1 of OAuth 2.0 [RFC6749], using a redirect URI capable of being received by the native app.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザ認証を必要とするネイティブアプリケーションは、ネイティブアプリケーションによって受信可能なリダイレクトURIを使用して、OAuth 2.0の[RFC6749]のセクション4.1あたり認可コードグラントタイプの許可要求URIを作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The function of the redirect URI for a native app authorization request is similar to that of a web-based authorization request. Rather than returning the authorization response to the OAuth client&#39;s server, the redirect URI used by a native app returns the response to the app. Several options for a redirect URI that will return the authorization response to the native app in different platforms are documented in Section 7. Any redirect URI that allows the app to receive the URI and inspect its parameters is viable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネイティブアプリの認証要求のリダイレクトURIの機能は、Webベースの認証要求の場合と同様です。むしろのOAuthクライアントのサーバーに許可応答を返すよりも、ネイティブアプリで使用されるリダイレクトURIは、アプリへの応答を返します。異なるプラットフォームでのネイティブアプリに許可応答を返しますリダイレクトURIのためのいくつかのオプションは、どれがそのパラメータをURIを受信して​​検査するアプリが実行可能であることができますURIをリダイレクトセクション7に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Public native app clients MUST implement the Proof Key for Code Exchange (PKCE [RFC7636]) extension to OAuth, and authorization servers MUST support PKCE for such clients, for the reasons detailed in Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
公共のネイティブアプリのクライアントはOAuthのた​​めのコード取引所（PKCE [RFC7636]）の拡張、および承認サーバー用の証明キーを実装しなければならない8.1節で詳述する理由のために、そのようなクライアントのためにPKCEをサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After constructing the authorization request URI, the app uses platform-specific APIs to open the URI in an external user-agent. Typically, the external user-agent used is the default browser, that is, the application configured for handling &#34;http&#34; and &#34;https&#34; scheme URIs on the system; however, different browser selection criteria and other categories of external user-agents MAY be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認可リクエストURIを構築した後、アプリが外部のユーザーエージェントでURIを開くには、プラットフォーム固有のAPIを使用しています。典型的には、使用される外部ユーザー・エージェントがデフォルトのブラウザであり、それは、システム上で「HTTP」と「HTTPS」スキームURIを処理するために構成されたアプリケーションです。しかし、別のブラウザ選択基準と外部のユーザーエージェントの他のカテゴリを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This best practice focuses on the browser as the RECOMMENDED external user-agent for native apps. An external user-agent designed specifically for user authorization and capable of processing authorization requests and responses like a browser MAY also be used. Other external user-agents, such as a native app provided by the authorization server may meet the criteria set out in this best practice, including using the same redirection URI properties, but their use is out of scope for this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このベストプラクティスは、ネイティブアプリケーションのための推奨外部ユーザーエージェントとしてブラウザに焦点を当てています。ユーザー認証やブラウザなどの認証要求と応答を処理できるために特別に設計された外部ユーザーエージェントを使用することもできます。そのような認証サーバが提供するネイティブアプリケーションのような他の外部ユーザーエージェントは、同じリダイレクトURIプロパティの使用を含め、このベスト・プラクティスに定める基準を満たすかもしれないが、その使用はこの仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some platforms support a browser feature known as &#34;in-app browser tabs&#34;, where an app can present a tab of the browser within the app context without switching apps, but still retain key benefits of the browser such as a shared authentication state and security context. On platforms where they are supported, it is RECOMMENDED, for usability reasons, that apps use in-app browser tabs for the authorization request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のプラットフォームでは、このような共有の認証状態やセキュリティなどのアプリがアプリケーションを切り替えることなく、アプリケーションのコンテキスト内でブラウザのタブを提示するが、それでもブラウザの主要な利点を保持できる「アプリ内のブラウザタブ」、として知られているブラウザの機能をサポート状況。彼らはサポートされているプラ​​ットフォームでは、アプリが認証要求のためのアプリ内ブラウザのタブを使用していること、ユーザビリティ上の理由から、推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Receiving the Authorization Response in a Native App
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.ネイティブAppで認証応答を受信します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are several redirect URI options available to native apps for receiving the authorization response from the browser, the availability and user experience of which varies by platform.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プラットフォームによって異なり可用性とユーザー体験そのブラウザからの許可応答を受信するためのネイティブアプリケーションに利用可能ないくつかのリダイレクトURIのオプションがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To fully support this best practice, authorization servers MUST offer at least the three redirect URI options described in the following subsections to native apps. Native apps MAY use whichever redirect option suits their needs best, taking into account platform-specific implementation details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全にこのベストプラクティスをサポートするために、認証サーバは、少なくとも3つのネイティブアプリケーションに以下のサブセクションで説明したURIオプションをリダイレクト提供しなければなりません。ネイティブアプリケーションは、オプションをリダイレクトする方使用するかもしれアカウントのプラットフォーム固有の実装の詳細を考慮して、最高の自分のニーズに合いました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Private-Use URI Scheme Redirection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。プライベート-使用URIスキームのリダイレクト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Many mobile and desktop computing platforms support inter-app communication via URIs by allowing apps to register private-use URI schemes (sometimes colloquially referred to as &#34;custom URL schemes&#34;) like &#34;com.example.app&#34;. When the browser or another app attempts to load a URI with a private-use URI scheme, the app that registered it is launched to handle the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多くのモバイルおよびデスクトップコンピューティング・プラットフォームは、アプリは「com.example.app」のような（時には口語的に「カスタムURLスキーム」と呼ばれる）私的利用のURIスキームを登録できるようにすることで、URIを介して、相互のアプリの通信をサポートします。ブラウザや他のアプリが民間使用URIスキームでURIをロードしようとすると、それを登録アプリは、要求を処理するために起動されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To perform an OAuth 2.0 authorization request with a private-use URI scheme redirect, the native app launches the browser with a standard authorization request, but one where the redirection URI utilizes a private-use URI scheme it registered with the operating system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
URIスキームがリダイレクト私的利用とOAuth 2.0の認証要求を実行するには、ネイティブアプリは、標準の認証要求でブラウザを起動しますが、リダイレクトURIが、それは、オペレーティングシステムに登録された私的使用URIスキームを利用するもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When choosing a URI scheme to associate with the app, apps MUST use a URI scheme based on a domain name under their control, expressed in reverse order, as recommended by Section 3.8 of [RFC7595] for private-use URI schemes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリに関連付けるURIスキームを選択するとき、アプリケーションは、その管理下にドメイン名に基づいてURIスキームを使用しなければならない私的利用のURIスキームのために[RFC7595]のセクション3.8で推奨されているように、逆の順序で表現。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, an app that controls the domain name &#34;app.example.com&#34; can use &#34;com.example.app&#34; as their scheme. Some authorization servers assign client identifiers based on domain names, for example, &#34;client1234.usercontent.example.net&#34;, which can also be used as the domain name for the scheme when reversed in the same manner. A scheme such as &#34;myapp&#34;, however, would not meet this requirement, as it is not based on a domain name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
たとえば、ドメイン名をコントロールアプリ「app.example.comは、」彼らのスキームとして「com.example.app」を使用することができます。いくつかの認可サーバも同様に逆転スキームのためのドメイン名として使用することができ、例えば、「client1234.usercontent.example.net」、ドメイン名に基づいてクライアント識別子を割り当てます。それは、ドメイン名に基づいていないような「myappに」などのスキームは、しかし、この要件を満たしていないだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When there are multiple apps by the same publisher, care must be taken so that each scheme is unique within that group. On platforms that use app identifiers based on reverse-order domain names, those identifiers can be reused as the private-use URI scheme for the OAuth redirect to help avoid this problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じ出版社によって複数のアプリケーションがある場合、それぞれの方式は、そのグループ内で一意になるように、注意しなければなりません。逆順ドメイン名に基づいてアプリの識別子を使用するプラットフォームでは、これらの識別子は、この問題を避けるためにリダイレクトOAuthのた​​めの私的利用URIスキームとして再利用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Following the requirements of Section 3.2 of [RFC3986], as there is no naming authority for private-use URI scheme redirects, only a single slash (&#34;/&#34;) appears after the scheme component. A complete example of a redirect URI utilizing a private-use URI scheme is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リダイレクトなし命名機関が民間使用URIスキームのために存在しないとして、[RFC3986]のセクション3.2の要件に続いて、単一のスラッシュ（「/」）方式の構成要素の後に表示されます。私的使用のURIスキームを活用し、リダイレクトURIの完全な例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
com.example.app:/oauth2redirect/example-provider
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
こｍ。えぁｍｐぇ。あっｐ：／おあうｔｈ２れぢれｃｔ／えぁｍｐぇーｐろゔぃでｒ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the authorization server completes the request, it redirects to the client&#39;s redirection URI as it would normally. As the redirection URI uses a private-use URI scheme, it results in the operating system launching the native app, passing in the URI as a launch parameter. Then, the native app uses normal processing for the authorization response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証サーバは要求を完了すると、それは通常どおり、それは、クライアントのリダイレクトURIにリダイレクトします。リダイレクトURIが私的利用URIスキームを使用するので、それが起動パラメータとしてURIを渡し、ネイティブアプリを起動し、オペレーティング・システムになります。その後、ネイティブアプリは許可応答のための通常の処理を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Claimed &#34;https&#34; Scheme URI Redirection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。 「https」のスキームURIリダイレクトを主張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some operating systems allow apps to claim &#34;https&#34; scheme [RFC7230] URIs in the domains they control. When the browser encounters a claimed URI, instead of the page being loaded in the browser, the native app is launched with the URI supplied as a launch parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一部のオペレーティングシステムは、アプリは、彼らが制御ドメインで「https」のスキーム[RFC7230] URIを主張することができます。ブラウザがブラウザにロードされている主張URI、代わりのページに遭遇したときにURIが起動パラメータとして供給して、ネイティブアプリが起動されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Such URIs can be used as redirect URIs by native apps. They are indistinguishable to the authorization server from a regular web-based client redirect URI. An example is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなURIは、ネイティブアプリケーションによるリダイレクトのURIとして使用することができます。彼らは、URIをリダイレクトし、通常のWebベースのクライアントから認証サーバへの見分けがつきません。例は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
https://app.example.com/oauth2redirect/example-provider
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ｈっｔｐｓ：／／あっｐ。えぁｍｐぇ。こｍ／おあうｔｈ２れぢれｃｔ／えぁｍｐぇーｐろゔぃでｒ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As the redirect URI alone is not enough to distinguish public native app clients from confidential web clients, it is REQUIRED in Section 8.4 that the client type be recorded during client registration to enable the server to determine the client type and act accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一人でリダイレクトURIが機密Webクライアントからパブリックネイティブアプリのクライアントを区別するのに十分ではないとして、それは、クライアントタイプは、クライアントの種類を決定し、それに応じて行動するサーバーを可能にするために、クライアントの登録時に記録されることセクション8.4で必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
App-claimed &#34;https&#34; scheme redirect URIs have some advantages compared to other native app redirect options in that the identity of the destination app is guaranteed to the authorization server by the operating system. For this reason, native apps SHOULD use them over the other options where possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
App-主張し、「https」のスキームは、URIが他のネイティブアプリに比べていくつかの利点が先アプリの識別は、オペレーティング・システムによって認証サーバーに保証されていることでオプションをリダイレクトしていリダイレクト。このため、ネイティブアプリケーションは、可能な場合、他のオプションの上にそれらを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Loopback Interface Redirection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。ループバックインターフェイスのリダイレクト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Native apps that are able to open a port on the loopback network interface without needing special permissions (typically, those on desktop operating systems) can use the loopback interface to receive the OAuth redirect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別な権限を必要とせずにループバックネットワークインタフェース上のポートを開くことができるネイティブアプリケーションは、（典型的には、デスクトップオペレーティングシステム上のもの）のOAuthリダイレクトを受信するためにループバックインターフェースを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Loopback redirect URIs use the &#34;http&#34; scheme and are constructed with the loopback IP literal and whatever port the client is listening on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ループバックは、URIが「HTTP」スキームを使用して、リテラルとクライアントが待機しているものは何でもポートループバックIPで構築されているリダイレクト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
That is, &#34;http://127.0.0.1:{port}/{path}&#34; for IPv4, and &#34;http://[::1]:{port}/{path}&#34; for IPv6. An example redirect using the IPv4 loopback interface with a randomly assigned port:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すなわち、IPv4の &#34;http://127.0.0.1:{port}/{path}&#34; であり、 &#34;HTTP：// [:: 1]：{ポート} / {パス}の&#34; IPv6のため。例では、ランダムに割り当てられたポートとIPv4のループバック・インターフェースを使用してリダイレクトします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
http://127.0.0.1:51004/oauth2redirect/example-provider
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ｈっｔｐ：／／１２７。０。０。１：５１００４／おあうｔｈ２れぢれｃｔ／えぁｍｐぇーｐろゔぃでｒ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example redirect using the IPv6 loopback interface with a randomly assigned port:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例は、ランダムに割り当てられたポートを持つIPv6ループバックインタフェースを使用してリダイレクトします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
http://[::1]:61023/oauth2redirect/example-provider
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
http：// [:: 1]：61023 / oauth2redirect /例-プロバイダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The authorization server MUST allow any port to be specified at the time of the request for loopback IP redirect URIs, to accommodate clients that obtain an available ephemeral port from the operating system at the time of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証サーバは、要求時にオペレーティングシステムから利用できる一時的なポートを取得するクライアントに対応するために、任意のポートがループバックIPは、URIをリダイレクトするための要求時に指定できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients SHOULD NOT assume that the device supports a particular version of the Internet Protocol. It is RECOMMENDED that clients attempt to bind to the loopback interface using both IPv4 and IPv6 and use whichever is available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、デバイスがインターネットプロトコルの特定のバージョンをサポートしていることを仮定するべきではありません。クライアントが利用できる方、IPv4とIPv6と使用の両方を使用してループバックインターフェイスにバインドしようとしていることを推奨します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Protecting the Authorization Code
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。認証コードを保護します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The redirect URI options documented in Section 7 share the benefit that only a native app on the same device or the app&#39;s own website can receive the authorization code, which limits the attack surface. However, code interception by a different native app running on the same device may be possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第7節のシェアで、同じデバイス上のネイティブアプリやアプリの自身のウェブサイトが攻撃面を制限し、認証コードを受け取ることができるという利点を文書化URIオプションをリダイレクトします。しかし、同じデバイス上で実行中の異なるネイティブアプリケーションによってコード傍受が可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A limitation of using private-use URI schemes for redirect URIs is that multiple apps can typically register the same scheme, which makes it indeterminate as to which app will receive the authorization code. Section 1 of PKCE [RFC7636] details how this limitation can be used to execute a code interception attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リダイレクトURIの私的利用URIスキームを使用することの制限は、複数のアプリケーションは、典型的には、アプリケーションが認証コードを受信するためにどのようにそれが不確定になり、同じスキームを登録することができるということです。 PKCE [RFC7636]のセクション1は、この制限は、コード傍受攻撃を実行するために使用することができる方法を詳述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Loopback IP-based redirect URIs may be susceptible to interception by other apps accessing the same loopback interface on some operating systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ループバックIPベースのリダイレクトURIはいくつかのオペレーティングシステム上の同じループバック・インターフェースにアクセスする他のアプリケーションによって傍受の影響を受けやすいかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
App-claimed &#34;https&#34; scheme redirects are less susceptible to URI interception due to the presence of the URI authority, but the app is still a public client; further, the URI is sent using the operating system&#39;s URI dispatch handler with unknown security properties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
App-主張し、「https」のスキームのリダイレクトが原因URIの権限の有無にURIの傍受を受けにくいですが、アプリはまだパブリッククライアントです。さらに、URIは、未知のセキュリティプロパティを持つオペレーティング・システムのURIディスパッチハンドラを使用して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PKCE [RFC7636] protocol was created specifically to mitigate this attack. It is a proof-of-possession extension to OAuth 2.0 that protects the authorization code from being used if it is intercepted. To provide protection, this extension has the client generate a secret verifier; it passes a hash of this verifier in the initial authorization request, and must present the unhashed verifier when redeeming the authorization code. An app that intercepted the authorization code would not be in possession of this secret, rendering the code useless.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PKCE [RFC7636]プロトコルは、この攻撃を軽減するために特別に作成されました。それが傍受された場合に使用されてから認証コードを保護するのOAuth 2.0プルーフ・オブ・所持拡張です。保護を提供するために、この拡張機能は、クライアントが秘密の検証を生成しています。それが最初の認証要求は、この検証のハッシュを通過し、認証コードを償還する際未ハッシュ検証を提示しなければなりません。認証コードを傍受アプリは役に立たないコードをレンダリング、この秘密を所有してはならないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 6 requires that both clients and servers use PKCE for public native app clients. Authorization servers SHOULD reject authorization requests from native apps that don&#39;t use PKCE by returning an error message, as defined in Section 4.4.1 of PKCE [RFC7636].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第6章では、クライアントとサーバーの両方が公共のネイティブアプリのクライアントに対してPKCEを使用する必要があります。認証サーバは、PKCE [RFC7636]のセクション4.4.1で定義され、エラーメッセージを返すことによってPKCEを使用していないネイティブアプリケーションからの認証要求を拒否すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. OAuth Implicit Grant Authorization Flow
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。 OAuthの暗黙のグラント承認フロー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The OAuth 2.0 implicit grant authorization flow (defined in Section 4.2 of OAuth 2.0 [RFC6749]) generally works with the practice of performing the authorization request in the browser and receiving the authorization response via URI-based inter-app communication. However, as the implicit flow cannot be protected by PKCE [RFC7636] (which is required in Section 8.1), the use of the Implicit Flow with native apps is NOT RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（OAuth 2.0の[RFC6749]のセクション4.2で定義される）OAuth 2.0の暗黙的な許可承認フローは、一般に、ブラウザに認証要求を行い、URIベースの間アプリ通信を介して許可応答を受信するの実践で動作します。暗黙的な流れは（セクション8.1で必要とされる）PKCE [RFC7636]で保護することができないようしかし、ネイティブアプリケーションと暗黙的フローを使用することは推奨されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Access tokens granted via the implicit flow also cannot be refreshed without user interaction, making the authorization code grant flow -- which can issue refresh tokens -- the more practical option for native app authorizations that require refreshing of access tokens.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リフレッシュトークンを発行することができます -   - アクセストークンのさわやか必要とネイティブアプリの承認のためのより実用的なオプションも暗黙の流れを経て許可されたアクセストークンは、認証コードの助成金の流れを作り、ユーザーの操作なしにリフレッシュすることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Loopback Redirect Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。ループバックリダイレクトの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Loopback interface redirect URIs use the &#34;http&#34; scheme (i.e., without Transport Layer Security (TLS)). This is acceptable for loopback interface redirect URIs as the HTTP request never leaves the device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ループバックインターフェイスは、URIは「HTTP」の方式（すなわち、トランスポート層セキュリティ（TLS）なし）を使用してリダイレクトします。 HTTPリクエストがデバイスを離れることはありませんとしてループバックインターフェイスは、URIをリダイレクトするためにこれが許容可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients should open the network port only when starting the authorization request and close it once the response is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、認証要求を開始する場合にのみ、ネットワークポートを開いて、応答が返されると、それを閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clients should listen on the loopback network interface only, in order to avoid interference by other network actors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、他のネットワーク主体による干渉を回避するために、専用のループバックネットワークインタフェースをリッスンする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While redirect URIs using localhost (i.e., &#34;http://localhost:{port}/{path}&#34;) function similarly to loopback IP redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED. Specifying a redirect URI with the loopback IP literal rather than localhost avoids inadvertently listening on network interfaces other than the loopback interface. It is also less susceptible to client-side firewalls and misconfigured host name resolution on the user&#39;s device.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ローカルホストを使用してURIをリダイレクトしながら（すなわち、「HTTP：// localhostの：{ポート} / {パス}」）同様にIPループバック機能7.3節で説明リダイレクト、ローカルホストを使用することは推奨されません。むしろローカルホストよりリテラルループバックIPとリダイレクトURIを指定すると、誤ってループバックインタフェース以外のネットワークインタフェースをリッスン回避します。また、クライアント側のファイアウォールやユーザーのデバイスに誤って設定ホスト名解決の影響を受けにくいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. Registration of Native App Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4。ネイティブアプリケーションのクライアントの登録
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Except when using a mechanism like Dynamic Client Registration [RFC7591] to provision per-instance secrets, native apps are classified as public clients, as defined by Section 2.1 of OAuth 2.0 [RFC6749]; they MUST be registered with the authorization server as such. Authorization servers MUST record the client type in the client registration details in order to identify and process requests accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OAuth 2.0の[RFC6749]のセクション2.1で定義されるよう規定インスタンスごとの秘密に動的クライアントの登録[RFC7591]のようなメカニズムを使用する場合を除いて、ネイティブアプリケーションは、公共のクライアントとして分類されます。彼らは、次のような認証サーバに登録しなければなりません。認証サーバは、それに応じて要求を識別し、処理するために、クライアント登録の詳細をクライアントタイプを記録しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authorization servers MUST require clients to register their complete redirect URI (including the path component) and reject authorization requests that specify a redirect URI that doesn&#39;t exactly match the one that was registered; the exception is loopback redirects, where an exact match is required except for the port URI component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証サーバは、（パスコンポーネントを含む）が完全なリダイレクトURIを登録して、正確に登録されたものと一致しませんリダイレクトURIを指定する認証要求を拒否するようにクライアントに要求しなければなりません。例外は、正確な一致がポートURI成分を除いて必要とされるループバックリダイレクト、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For private-use URI scheme-based redirects, authorization servers SHOULD enforce the requirement in Section 7.1 that clients use schemes that are reverse domain name based. At a minimum, any private-use URI scheme that doesn&#39;t contain a period character (&#34;.&#34;) SHOULD be rejected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私的使用のURIスキームに基づくリダイレ​​クトするために、認証サーバは、クライアントがベースの逆ドメイン名ですスキームを使用する7.1節で要件を適用すべきです。最低でも、ピリオド文字が含まれていない任意の私的使用のURIスキームは（「」）拒絶されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the collision-resistant properties, requiring a URI scheme based on a domain name that is under the control of the app can help to prove ownership in the event of a dispute where two apps claim the same private-use URI scheme (where one app is acting maliciously). For example, if two apps claimed &#34;com.example.app&#34;, the owner of &#34;example.com&#34; could petition the app store operator to remove the counterfeit app. Such a petition is harder to prove if a generic URI scheme was used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
衝突耐性の特性に加えて、アプリの制御下にあるドメイン名に基づいてURIスキームを必要とすると、2つのアプリはURIスキーム（同じプライベート利用を主張する紛争が生じた場合に所有権を証明するために助けることができます1つのアプリ）が悪意を持って行動しています。 2つのアプリケーションが「com.example.app」を主張した場合、例えば、「example.com」の所有者が偽造アプリケーションを削除するためにアプリケーションストア演算子を請願ができました。このような請願書は、一般的なURIスキームが使用された場合を証明するのは難しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authorization servers MAY request the inclusion of other platform-specific information, such as the app package or bundle name, or other information that may be useful for verifying the calling app&#39;s identity on operating systems that support such functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証サーバは、このような機能をサポートするオペレーティングシステム上で呼び出すアプリの身元を確認するために有用である可能性があるアプリのパッケージまたはバンドル名、またはその他の情報などの他のプラットフォーム固有の情報、を含めることを要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5. Client Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5。クライアント認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Secrets that are statically included as part of an app distributed to multiple users should not be treated as confidential secrets, as one user may inspect their copy and learn the shared secret. For this reason, and those stated in Section 5.3.1 of [RFC6819], it is NOT RECOMMENDED for authorization servers to require client authentication of public native apps clients using a shared secret, as this serves little value beyond client identification which is already provided by the &#34;client_id&#34; request parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1人のユーザーが自分のコピーを検査し、共有秘密を学ぶことのように静的に複数のユーザーに配布アプリの一部として含まれている秘密は、機密秘密として扱われるべきではありません。これは、すでに提供されているクライアントの識別を超えてほとんど価値を提供していますように、この理由、および[RFC6819]のセクション5.3.1で述べられているものについては、共有秘密を使用してパブリックネイティブアプリケーションのクライアントのクライアント認証を要求するように、認証サーバにはお勧めしません「CLIENT_ID」リクエストパラメータによって。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authorization servers that still require a statically included shared secret for native app clients MUST treat the client as a public client (as defined by Section 2.1 of OAuth 2.0 [RFC6749]), and not accept the secret as proof of the client&#39;s identity. Without additional measures, such clients are subject to client impersonation (see Section 8.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まだネイティブアプリクライアントの静的共有含ま秘密を必要とする認証サーバは、（OAuth 2.0の[RFC6749]のセクション2.1で定義されている）パブリッククライアントとしてクライアントを扱い、クライアントの身元の証明として秘密を受け入れてはいけません。追加的な措置がなければ、このようなクライアントは、クライアントの偽装（8.6節を参照）の対象となっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6. Client Impersonation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.6。クライアントの偽装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As stated in Section 10.2 of OAuth 2.0 [RFC6749], the authorization server SHOULD NOT process authorization requests automatically without user consent or interaction, except when the identity of the client can be assured. This includes the case where the user has previously approved an authorization request for a given client id -- unless the identity of the client can be proven, the request SHOULD be processed as if no previous request had been approved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OAuth 2.0の[RFC6749]のセクション10.2で述べたように、認証サーバは、クライアントのアイデンティティを確保することができる場合を除き、ユーザーの同意または相互作用することなく、自動的に認証要求を処理しないでください。これは、ユーザーが以前に与えられたクライアントIDの認証要求を承認した場合も含まれる - クライアントの身元を証明できない限り、要求が以前の要求が承認されなかったかのように処理されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Measures such as claimed &#34;https&#34; scheme redirects MAY be accepted by authorization servers as identity proof. Some operating systems may offer alternative platform-specific identity features that MAY be accepted, as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このよう主張し、「https」のスキームのリダイレクトなどの対策は身分証として認可サーバによって受け入れられます。一部のオペレーティングシステムは、必要に応じて、受け入れられる代替プラットフォーム固有の識別機能を提供することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7. Fake External User-Agents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.7。フェイク外部ユーザーエージェント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The native app that is initiating the authorization request has a large degree of control over the user interface and can potentially present a fake external user-agent, that is, an embedded user-agent made to appear as an external user-agent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
許可要求を開始しているネイティブアプリケーションは、ユーザインタフェースの制御の大きい度を有し、潜在的に、埋め込まれたユーザーエージェントは、外部ユーザ・エージェントとして表示するように構成されている偽の外部ユーザーエージェントを提示することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When all good actors are using external user-agents, the advantage is that it is possible for security experts to detect bad actors, as anyone faking an external user-agent is provably bad. On the other hand, if good and bad actors alike are using embedded user-agents, bad actors don&#39;t need to fake anything, making them harder to detect. Once a malicious app is detected, it may be possible to use this knowledge to blacklist the app&#39;s signature in malware scanning software, take removal action (in the case of apps distributed by app stores) and other steps to reduce the impact and spread of the malicious app.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての良い俳優が外部のユーザーエージェントを使用している場合は、利点は、外部のユーザーエージェントを偽造誰が証明可能不良であるとして、セキュリティの専門家は、悪役を検出することが可能であるということです。一方、良い面と悪い俳優が似て埋め込まれたユーザーエージェントを使用している場合は、悪役を検出するのが、彼らが難しくなって、偽何もする必要はありません。悪意のあるアプリケーションが検出されると、の影響と拡散を低減するために、マルウェアスキャンソフトウェアでアプリの署名をブラックリストには、この知識を使用して、他のステップ（アプリストアによって分散アプリケーションの場合）の除去アクションを実行することも可能です悪質なアプリ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authorization servers can also directly protect against fake external user-agents by requiring an authentication factor only available to true external user-agents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証サーバは、直接真の外部ユーザー・エージェントのみが利用できる認証要素を必要とすることによって、偽の外部のユーザーエージェントから保護することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Users who are particularly concerned about their security when using in-app browser tabs may also take the additional step of opening the request in the full browser from the in-app browser tab and complete the authorization there, as most implementations of the in-app browser tab pattern offer such functionality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリ内ブラウザのタブを使用している場合、セキュリティについて特に懸念しているユーザーはまた、アプリ内ブラウザタブから、フルブラウザでリクエストを開く追加のステップを取ると、そこに認証を完了し、アプリ内のほとんどの実装としてもブラウザタブパターンは、このような機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8. Malicious External User-Agents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.8。悪意のある外部ユーザーエージェント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a malicious app is able to configure itself as the default handler for &#34;https&#34; scheme URIs in the operating system, it will be able to intercept authorization requests that use the default browser and abuse this position of trust for malicious ends such as phishing the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
悪質なアプリは、オペレーティング・システムの「https」のスキームのURIのデフォルトハンドラとして自身を構成することが可能であるならば、デフォルトのブラウザを使用して認証要求をインターセプトし、このようなフィッシングなどの悪意のある両端の信頼のこの位置を濫用することができるようになりますユーザー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This attack is not confined to OAuth; a malicious app configured in this way would present a general and ongoing risk to the user beyond OAuth usage by native apps. Many operating systems mitigate this issue by requiring an explicit user action to change the default handler for &#34;http&#34; and &#34;https&#34; scheme URIs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この攻撃は、OAuthのに限定されません。このように構成された悪質なアプリがネイティブアプリケーションによってはOAuthの使用量を超えたユーザーへの一般的な、継続的なリスクを提示します。多くのオペレーティングシステムは、「http」と「https」スキームのURIのためのデフォルトのハンドラを変更するには、明示的なユーザーのアクションを必要とすることにより、この問題を軽減します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9. Cross-App Request Forgery Protections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.9。クロスアプリケーションリクエストフォージェリの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 5.3.5 of [RFC6819] recommends using the &#34;state&#34; parameter to link client requests and responses to prevent CSRF (Cross-Site Request Forgery) attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6819]のセクション5.3.5は、CSRF（クロスサイトリクエストフォージェリ）攻撃を防ぐために、クライアントの要求と応答をリンクする「状態」パラメータを使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To mitigate CSRF-style attacks over inter-app URI communication channels (so called &#34;cross-app request forgery&#34;), it is similarly RECOMMENDED that native apps include a high-entropy secure random number in the &#34;state&#34; parameter of the authorization request and reject any incoming authorization responses without a state value that matches a pending outgoing authorization request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（いわゆる「クロスアプリリクエストフォージェリ」と呼ばれる）間のアプリURIの通信チャネルを介してCSRFスタイルの攻撃を軽減するために、同様にネイティブアプリは、高エントロピーが認可要求の「状態」パラメータで乱数を確保含めることが推奨されますそして、保留中の発信承認要求に合致する状態値なしの着信の許可応答を拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10. Authorization Server Mix-Up Mitigation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.10。認証サーバーミックスアップの軽減
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To protect against a compromised or malicious authorization server attacking another authorization server used by the same app, it is REQUIRED that a unique redirect URI is used for each authorization server used by the app (for example, by varying the path component), and that authorization responses are rejected if the redirect URI they were received on doesn&#39;t match the redirect URI in an outgoing authorization request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じアプリケーションで使用される別の認証サーバを攻撃損なわまたは悪意のある認証サーバから保護するために、それが必要であることURIは、アプリケーションによって使用される各認証サーバに使用される一意のリダイレクト（例えば、パス成分を変化させることにより）、そのURIは、彼らが上で受信したリダイレクトは、発信認証要求にリダイレクトURIと一致しない場合は、許可応答が拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The native app MUST store the redirect URI used in the authorization request with the authorization session data (i.e., along with &#34;state&#34; and other related data) and MUST verify that the URI on which the authorization response was received exactly matches it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネイティブアプリケーションは、URIが（「状態」および他の関連データと共にすなわち、）承認セッションデータとの認可要求に使用されるリダイレクトを格納しなければならないし、許可応答が受信されたURIが正確に一致することを確認しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requirement of Section 8.4, specifically that authorization servers reject requests with URIs that don&#39;t match what was registered, is also required to prevent such attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション8.4の要件、特にその認証サーバが登録されたものと一致していないのURIで要求を拒否は、また、そのような攻撃を防ぐために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.11. Non-Browser External User-Agents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.11。非ブラウザ外部のユーザーエージェント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This best practice recommends a particular type of external user-agent: the user&#39;s browser. Other external user-agent patterns may also be viable for secure and usable OAuth. This document makes no comment on those patterns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーのブラウザ：このベストプラクティスは、外部のユーザーエージェントの特定のタイプをお勧めします。その他の外部ユーザーエージェントパターンも安全で使用可能なOAuthのた​​めの実行可能なことがあります。この文書では、これらのパターンには何のコメントも行いません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.12. Embedded User-Agents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.12。組み込みユーザーエージェント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 9 of OAuth 2.0 [RFC6749] documents two approaches for native apps to interact with the authorization endpoint. This best current practice requires that native apps MUST NOT use embedded user-agents to perform authorization requests and allows that authorization endpoints MAY take steps to detect and block authorization requests in embedded user-agents. The security considerations for these requirements are detailed herein.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OAuth 2.0ののセクション9 [RFC6749]は認可エンドポイントと対話するネイティブアプリケーションのための2つのアプローチを説明します。この現在のベストプラクティスは、ネイティブアプリが承認要求を実行するために埋め込まれたユーザーエージェントを使用してはならないことを要求し、承認エンドポイントが埋め込まれたユーザーエージェントでの認証要求を検出し、ブロックするための措置をとるかもしれないことができます。これらの要件のためのセキュリティの考慮事項は、本明細書に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Embedded user-agents are an alternative method for authorizing native apps. These embedded user-agents are unsafe for use by third parties to the authorization server by definition, as the app that hosts the embedded user-agent can access the user&#39;s full authentication credential, not just the OAuth authorization grant that was intended for the app.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
組み込みユーザーエージェントは、ネイティブアプリケーションを承認するための別の方法です。これらの組み込みユーザーエージェントは、ユーザーの完全な認証資格情報、アプリのために意図されただけでなく、OAuthの認証許可をアクセスすることができ組み込みユーザーエージェントをホストするアプリケーションとして、定義により、認証サーバへの第三者による使用のために安全ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In typical web-view-based implementations of embedded user-agents, the host application can record every keystroke entered in the login form to capture usernames and passwords, automatically submit forms to bypass user consent, and copy session cookies and use them to perform authenticated actions as the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
組み込みユーザーエージェントの一般的なウェブ・ビューベースの実装では、ホストアプリケーションは自動的にユーザーの同意をバイパスするフォームを送信し、セッションクッキーをコピーして、認証を実行するためにそれらを使用し、ユーザ名とパスワードをキャプチャするために、ログインフォームに入力されたすべてのキーストロークを記録することができますユーザーなどのアクション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Even when used by trusted apps belonging to the same party as the authorization server, embedded user-agents violate the principle of least privilege by having access to more powerful credentials than they need, potentially increasing the attack surface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証サーバーと同じパーティーに属している、信頼できるアプリケーションで使用される場合でも、埋め込まれたユーザーエージェントは、潜在的に攻撃面を増加、彼らが必要とするよりも、より強力な資格情報へのアクセスを持つことにより、最小限の特権の原則に違反します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Encouraging users to enter credentials in an embedded user-agent without the usual address bar and visible certificate validation features that browsers have makes it impossible for the user to know if they are signing in to the legitimate site; even when they are, it trains them that it&#39;s OK to enter credentials without validating the site first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
通常のアドレスバーとブラウザが、それは不可能彼らは合法的なサイトにサインインしている場合、ユーザーが知るようになり持っている目に見える、証明書の検証機能せずに埋め込まれたユーザーエージェントで資格情報を入力するようユーザーに奨励。彼らは場合でも、それは最初のサイトを検証せずに資格情報を入力し、[OKだとそれらを訓練します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside from the security concerns, embedded user-agents do not share the authentication state with other apps or the browser, requiring the user to log in for every authorization request, which is often considered an inferior user experience.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別にセキュリティ上の懸念から、埋め込まれたユーザーエージェントは、多くの場合、劣ったユーザーエクスペリエンスと考えられているすべての認証要求のためにログインするユーザーを必要とする、他のアプリやブラウザを使用して認証状態を共有することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document does not require any IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントは、IANAのアクションを必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 7.1 specifies how private-use URI schemes are used for inter-app communication in OAuth protocol flows. This document requires in Section 7.1 that such schemes are based on domain names owned or assigned to the app, as recommended in Section 3.8 of [RFC7595]. Per Section 6 of [RFC7595], registration of domain-based URI schemes with IANA is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7.1節は、プライベート利用URIスキームはOAuthプロトコル・フローの間アプリの通信に使用される方法を指定します。 [RFC7595]のセクション3.8で推奨されているようにこの文書では、このようなスキームが所有または、アプリに割り当てられたドメイン名に基づいていることセクション7.1で必要です。 [RFC7595]のセクション6当たり、IANAとドメインベースのURIスキームの登録が必要とされません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, &lt;https://www.rfc-editor.org/info/rfc3986&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 &#34;ユニフォームリソース識別子（URI）：汎用構文&#34;、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月&lt;HTTPS：/ /www.rfc-editor.org/info/rfc3986&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6749] Hardt, D., Ed., &#34;The OAuth 2.0 Authorization Framework&#34;, RFC 6749, DOI 10.17487/RFC6749, October 2012, &lt;https://www.rfc-editor.org/info/rfc6749&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6749]ハルト、D.編、 &#34;OAuth 2.0の認証フレームワーク&#34;、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、&lt;https://www.rfc-editor.org/info/rfc6749&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&#34;, RFC 7230, DOI 10.17487/RFC7230, June 2014, &lt;https://www.rfc-editor.org/info/rfc7230&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 &#34;ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング&#34;、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、&lt;https://www.rfc-editor.org/info/ rfc7230&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7595] Thaler, D., Ed., Hansen, T., and T. Hardie, &#34;Guidelines and Registration Procedures for URI Schemes&#34;, BCP 35, RFC 7595, DOI 10.17487/RFC7595, June 2015, &lt;https://www.rfc-editor.org/info/rfc7595&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7595]ターラー、D.、エド、ハンセン、T.、およびT.ハーディ、 &#34;URIスキームのためのガイドラインと登録手順&#34;、BCP 35、RFC 7595、DOI 10.17487 / RFC7595、2015年6月、&lt;HTTPS：// www.rfc-editor.org/info/rfc7595&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7636] Sakimura, N., Ed., Bradley, J., and N. Agarwal, &#34;Proof Key for Code Exchange by OAuth Public Clients&#34;, RFC 7636, DOI 10.17487/RFC7636, September 2015, &lt;https://www.rfc-editor.org/info/rfc7636&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7636] Sakimura、N.、エド、ブラッドリー、J.、およびN. Agarwalさん、 &#34;OAuthの公共のクライアントによってコードExchange用の証明キー&#34;、RFC 7636、DOI 10.17487 / RFC7636、2015年9月、&lt;HTTPS：// WWW .rfc-editor.org /情報/ rfc7636&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC8174] Leiba、B.、 &#34;RFC 2119個のキーワードに小文字VS大文字の曖昧さ&#34;、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6819] Lodderstedt, T., Ed., McGloin, M., and P. Hunt, &#34;OAuth 2.0 Threat Model and Security Considerations&#34;, RFC 6819, DOI 10.17487/RFC6819, January 2013, &lt;https://www.rfc-editor.org/info/rfc6819&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6819] Lodderstedt、T.、エド、McGloin、M.、およびP.ハント、 &#34;OAuth 2.0の脅威モデルおよびセキュリティに関する注意事項&#34;、RFC 6819、DOI 10.17487 / RFC6819、2013年1月、&lt;HTTPS：。//www.rfc -editor.org/info/rfc6819&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7591] Richer, J., Ed., Jones, M., Bradley, J., Machulak, M., and P. Hunt, &#34;OAuth 2.0 Dynamic Client Registration Protocol&#34;, RFC 7591, DOI 10.17487/RFC7591, July 2015, &lt;https://www.rfc-editor.org/info/rfc7591&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC7591]豊かな、J.、編、ジョーンズ、M.、ブラッドリー、J.、Machulak、M.、およびP.ハント、 &#34;OAuth 2.0のダイナミッククライアント登録プロトコル&#34;、RFC 7591、DOI 10.17487 / RFC7591、2015年7月、&lt;https://www.rfc-editor.org/info/rfc7591&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AppAuth] OpenID Connect Working Group, &#34;AppAuth&#34;, September 2017, &lt;https://openid.net/code/AppAuth&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AppAuth] OpenIDの接続ワーキンググループ、 &#34;AppAuth&#34;、2017年9月、&lt;https://openid.net/code/AppAuth&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AppAuth.iOSmacOS] Wright, S., Denniss, W., et al., &#34;AppAuth for iOS and macOS&#34;, February 2016, &lt;https://openid.net/code/AppAuth-iOS&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【AppAuth.iOSmacOS】ライト、S.、Denniss、W.ら、 &#34;AppAuth iOSとMacOSのための&#34;、2016年2月、&lt;https://openid.net/code/AppAuth-iOS&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[AppAuth.Android] McGinniss, I., Denniss, W., et al., &#34;AppAuth for Android&#34;, February 2016, &lt;https://openid.net/code/AppAuth-Android&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【AppAuth.Android] McGinniss、I.、Denniss、W.ら、 &#34;アンドロイド用AppAuth&#34;、2016年2月、&lt;https://openid.net/code/AppAuth-Android&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SamplesForWindows] Denniss, W., &#34;OAuth for Apps: Samples for Windows&#34;, July 2016, &lt;https://openid.net/code/sample-oauth-apps-for-windows&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SamplesForWindows] Denniss、W.、 &#34;アプリのOAuth：Windows用のサンプル&#34;、2016年7月、&lt;https://openid.net/code/sample-oauth-apps-for-windows&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. Server Support Checklist
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A.サーバーサポートのチェックリスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OAuth servers that support native apps must:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネイティブアプリケーションをサポートするのOAuthサーバーには、次の条件を満たす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. Support private-use URI scheme redirect URIs. This is required to support mobile operating systems. See Section 7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.サポート私的使用のURIスキームはURIをリダイレクトします。これは、モバイルオペレーティングシステムをサポートするために必要です。 7.1節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Support &#34;https&#34; scheme redirect URIs for use with public native app clients. This is used by apps on advanced mobile operating systems that allow app-claimed &#34;https&#34; scheme URIs. See Section 7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.サポート「https」を体系は、公共のネイティブアプリのクライアントで使用するURIをリダイレクトします。これは、アプリ-主張「https」のスキームのURIを許可する高度なモバイルオペレーティングシステム上のアプリケーションで使用されています。 7.2節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Support loopback IP redirect URIs. This is required to support desktop operating systems. See Section 7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.サポートループバックIP URIをリダイレクトします。これは、デスクトップオペレーティングシステムをサポートするために必要です。 7.3節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Not assume that native app clients can keep a secret. If secrets are distributed to multiple installs of the same native app, they should not be treated as confidential. See Section 8.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.ネイティブアプリのクライアントが秘密を保つことができることを前提としていません。秘密は同じネイティブアプリの複数のインストールに配布されている場合、それらは機密として扱われるべきではありません。セクション8.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Support PKCE [RFC7636]. Required to protect authorization code grants sent to public clients over inter-app communication channels. See Section 8.1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5.サポートPKCE [RFC7636]。間アプリの通信チャネルを介して公衆のクライアントに送信される認証コードの助成金を保護するために必要。 8.1節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Platform-Specific Implementation Details
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録B.プラットフォーム固有の実装の詳細
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document primarily defines best practices in a generic manner, referencing techniques commonly available in a variety of environments. This non-normative section documents implementation details of the best practice for various operating systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、主に、さまざまな環境で一般的に利用可能な技術を参照し、一般的な方法でのベストプラクティスを定義します。これは、非規範的部分文書さまざまなオペレーティングシステムのためのベストプラクティスの実装の詳細を。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The implementation details herein are considered accurate at the time of publishing but will likely change over time. It is hoped that such a change won&#39;t invalidate the generic principles in the rest of the document and that those principles should take precedence in the event of a conflict.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装の詳細は、本明細書出版の時点で正確と考えられているが、そう時間をかけて変化します。このような変更は、文書の残りの部分で一般的な原理を無効にし、これらの原則は、紛争が発生した場合に優先すべきことではないだろうことが期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1. iOS Implementation Details
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1。 iOSの実装の詳細
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Apps can initiate an authorization request in the browser, without the user leaving the app, through the &#34;SFSafariViewController&#34; class or its successor &#34;SFAuthenticationSession&#34;, which implement the in-app browser tab pattern. Safari can be used to handle requests on old versions of iOS without in-app browser tab functionality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリは、ユーザーが「SFSafariViewController」クラスまたはアプリ内ブラウザタブパターンを実装し、その後継者「SFAuthenticationSession」を通じて、アプリを離れることなく、ブラウザでの認証要求を開始することができます。 Safariはアプリ内ブラウザのタブ機能のないのiOSの古いバージョンの要求を処理するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To receive the authorization response, both private-use URI scheme (referred to as &#34;custom URL scheme&#34;) redirects and claimed &#34;https&#34; scheme URIs (known as &#34;Universal Links&#34;) are viable choices. Apps can claim private-use URI schemes with the &#34;CFBundleURLTypes&#34; key in the application&#39;s property list file, &#34;Info.plist&#34;, and &#34;https&#34; scheme URIs using the Universal Links feature with an entitlement file in the app and an association file hosted on the domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
許可応答を受信するには、（「カスタムURLスキーム」と呼ばれる）の両方の私的利用URIスキームはリダイレクトし、（「ユニバーサルリンク」として知られている）「https」のスキームのURIを主張は、実行可能な選択肢です。アプリは、アプリでエンタイトルメントファイルとホストされた関連ファイルとユニバーサルリンク機能を使用して「CFBundleURLTypes」アプリケーションのプロパティリストファイルのキー、「Info.plistファイル」、および「https」のスキームのURIを持つプライベート・使用URIスキームを請求することができますドメイン上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Claimed &#34;https&#34; scheme URIs are the preferred redirect choice on iOS 9 and above due to the ownership proof that is provided by the operating system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「HTTPS」スキームURIはIOSの9上の好ましいリダイレクト選択であり、上記により、オペレーティングシステムによって提供された所有権の証拠と主張しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A complete open-source sample is included in the AppAuth for iOS and macOS [AppAuth.iOSmacOS] library.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全なオープンソースのサンプルは、iOSとMacOSの[AppAuth.iOSmacOS]ライブラリのAppAuthに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2. Android Implementation Details
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2。 Androidの実装の詳細
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Apps can initiate an authorization request in the browser, without the user leaving the app, through the Android Custom Tab feature, which implements the in-app browser tab pattern. The user&#39;s default browser can be used to handle requests when no browser supports Custom Tabs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリは、ユーザーがアプリ内ブラウザタブパターンを実装してAndroidのカスタムタブの機能を通じて、アプリを離れることなく、ブラウザでの認証要求を開始することができます。ユーザーのデフォルトのブラウザにはブラウザがカスタムタブをサポートしていないときに要求を処理するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Android browser vendors should support the Custom Tabs protocol (by providing an implementation of the &#34;CustomTabsService&#34; class), to provide the in-app browser tab user-experience optimization to their users. Chrome is one such browser that implements Custom Tabs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Androidのブラウザベンダーがユーザーにアプリ内のブラウザタブユーザーエクスペリエンスの最適化を実現するために、（「CustomTabsService」クラスの実装を提供することで）カスタムタブのプロトコルをサポートする必要があります。 Chromeはカスタムタブを実装してそのようなブラウザです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To receive the authorization response, private-use URI schemes are broadly supported through Android Implicit Intents. Claimed &#34;https&#34; scheme redirect URIs through Android App Links are available on Android 6.0 and above. Both types of redirect URIs are registered in the application&#39;s manifest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
許可応答を受信するには、私的使用のURIスキームは広くAndroidの暗黙インテントを介してサポートされています。 「https」のスキームは、Androidアプリのリンクを介してURIをリダイレクト主張することはアンドロイド6.0以上でご利用いただけます。リダイレクトURIの両方のタイプは、アプリケーションのマニフェストに登録されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A complete open-source sample is included in the AppAuth for Android [AppAuth.Android] library.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全なオープンソースのサンプルは、Androidの[AppAuth.Android]ライブラリのAppAuthに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3. Windows Implementation Details
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3。 Windowsの実装の詳細
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Both traditional and Universal Windows Platform (UWP) apps can perform authorization requests in the user&#39;s browser. Traditional apps typically use a loopback redirect to receive the authorization response, and listening on the loopback interface is allowed by default firewall rules. When creating the loopback network socket, apps SHOULD set the &#34;SO_EXCLUSIVEADDRUSE&#34; socket option to prevent other apps binding to the same socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どちらも伝統的なユニバーサルのWindowsプラットフォーム（UWP）のアプリがユーザーのブラウザに認証要求を行うことができます。従来のアプリケーションは通常、許可応答を受け取るために、ループバックのリダイレクトを使用して、ループバックインターフェイスをリッスンし、デフォルトのファイアウォールルールで許可されています。ループバックネットワークソケットを作成する場合、アプリケーションは、同じソケットに結合する他のアプリを防ぐために、「SO_EXCLUSIVEADDRUSE」ソケットオプションを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
UWP apps can use private-use URI scheme redirects to receive the authorization response from the browser, which will bring the app to the foreground. Known on the platform as &#34;URI Activation&#34;, the URI scheme is limited to 39 characters in length, and it may include the &#34;.&#34; character, making short reverse domain name based schemes (as required in Section 7.1) possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UWPのアプリはURIスキームがフォアグラウンドにアプリをもたらすブラウザからの許可応答を受け取るためにリダイレクト私的利用を使用することができます。 「URIのアクティベーション」などのプラットフォーム上で知られている、URIスキームは、長さが39文字に制限され、それが含まれます「」文字、（セクション7.1で必要とされる）可能性、短い逆ドメイン名ベースのスキームを作ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
UWP apps can alternatively use the Web Authentication Broker API in Single Sign-on (SSO) mode, which is an external user-agent designed for authorization flows. Cookies are shared between invocations of the broker but not the user&#39;s preferred browser, meaning the user will need to log in again, even if they have an active session in their browser; but the session created in the broker will be available to subsequent apps that use the broker. Personalizations the user has made to their browser, such as configuring a password manager, may not be available in the broker. To qualify as an external user-agent, the broker MUST be used in SSO mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UWPのアプリケーションは、代わりに承認フローのために設計された外部ユーザエージェントでのシングルサインオン（SSO）モードでWeb認証ブローカーのAPIを使用することができます。クッキーは、ユーザーが彼らのブラウザでアクティブなセッションを持っている場合でも、再度ログインする必要がありますを意味し、ブローカーの呼び出しではなく、ユーザの好みのブラウザ間で共有されています。しかし、ブローカーで作成されたセッションは、ブローカーを使用し、後続のアプリケーションに利用できるようになります。ユーザーは、このようなパスワードマネージャを設定すると、そのブラウザに行われたパーソナライズは、ブローカーでは利用できない場合があります。外部ユーザー・エージェントとしての資格には、ブローカーは、SSOモードで使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To use the Web Authentication Broker in SSO mode, the redirect URI must be of the form &#34;msapp://{appSID}&#34; where &#34;{appSID}&#34; is the app&#39;s security identifier (SID), which can be found in the app&#39;s registration information or by calling the &#34;GetCurrentApplicationCallbackUri&#34; method. While Windows enforces the URI authority on such redirects, ensuring that only the app with the matching SID can receive the response on Windows, the URI scheme could be claimed by apps on other platforms without the same authority present; thus, this redirect type should be treated similarly to private-use URI scheme redirects for security purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSOモードでWeb認証ブローカを使用するように、リダイレクトURIの形式でなければなりません「msapp：// {appSID}」ここで、「{appSID}は」アプリの登録中に見出すことができるアプリケーションのセキュリティ識別子（SID）、あります情報または「GetCurrentApplicationCallbackUri」メソッドを呼び出すことによって。 Windowsが一致するSIDを持つ唯一のアプリケーションは、Windows上の応答を受信できることを保証する、そのようなリダイレクトURIに権限を適用しながら、URIスキームは、同じ権限が存在しない他のプラットフォーム上のアプリケーションによって要求され得ます。したがって、このリダイレクトの種類はURIスキームは、セキュリティ目的のためにリダイレクト私的利用と同様に扱われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An open-source sample demonstrating these patterns is available [SamplesForWindows].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのパターンを示すオープンソースのサンプルは、利用可能な[SamplesForWindows]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.4. macOS Implementation Details
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.4。 MacOSの実装の詳細
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Apps can initiate an authorization request in the user&#39;s default browser using platform APIs for opening URIs in the browser.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリは、ブラウザでURIを開くためのプラットフォームAPIを使用して、ユーザーの既定のブラウザに認証要求を開始することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To receive the authorization response, private-use URI schemes are a good redirect URI choice on macOS, as the user is returned right back to the app they launched the request from. These are registered in the application&#39;s bundle information property list using the &#34;CFBundleURLSchemes&#34; key. Loopback IP redirects are another viable option, and listening on the loopback interface is allowed by default firewall rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーはすぐに戻ってアプリに返され、彼らはからの要求を開始したとして、許可応答を受信するには、私的使用のURIスキームは、MacOSで良いリダイレクトURIの選択です。これらは、「CFBundleURLSchemes」キーを使用して、アプリケーションのバンドル情報プロパティリストに登録されています。ループバックIPリダイレクトは、別の実行可能な選択肢であり、ループバックインターフェイスをリッスンし、デフォルトのファイアウォールルールで許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A complete open-source sample is included in the AppAuth for iOS and macOS [AppAuth.iOSmacOS] library.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全なオープンソースのサンプルは、iOSとMacOSの[AppAuth.iOSmacOS]ライブラリのAppAuthに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.5. Linux Implementation Details
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.5。 Linuxの実装の詳細
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Opening the authorization request in the user&#39;s default browser requires a distro-specific command: &#34;xdg-open&#34; is one such tool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ユーザーのデフォルトのブラウザで認証要求を開くと、ディストリビューション固有のコマンドが必要です「のxdg-openが、」そのようなツールです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The loopback redirect is the recommended redirect choice for desktop apps on Linux to receive the authorization response. Apps SHOULD NOT set the &#34;SO_REUSEPORT&#34; or &#34;SO_REUSEADDR&#34; socket options in order to prevent other apps binding to the same socket.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ループバックリダイレクトは許可応答を受信するためにLinux上でデスクトップアプリケーションのための推奨されるリダイレクトの選択肢です。アプリは、同じソケットに結合する他のアプリを防ぐために「SO_REUSEPORT」または「SO_REUSEADDR」ソケットオプションを設定しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The authors would like to acknowledge the work of Marius Scurtescu and Ben Wiley Sittler, whose design for using private-use URI schemes in native app OAuth 2.0 clients at Google formed the basis of Section 7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者は、マリウスScurtescuとその設計2.0クライアントGoogleのネイティブアプリのOAuthのプライベート利用のURIスキームを使用するためのセクション7.1の基礎を形成ベン・ワイリーSittler、の作業を確認したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following individuals contributed ideas, feedback, and wording that shaped and formed the final specification:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の個人は形のアイデア、フィードバック、および文言に貢献し、最終的な仕様を形成しました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Andy Zmolek, Steven E. Wright, Brian Campbell, Nat Sakimura, Eric Sachs, Paul Madsen, Iain McGinniss, Rahul Ravikumar, Breno de Medeiros, Hannes Tschofenig, Ashish Jain, Erik Wahlstrom, Bill Fisher, Sudhi Umarji, Michael B. Jones, Vittorio Bertocci, Dick Hardt, David Waite, Ignacio Fiorentino, Kathleen Moriarty, and Elwyn Davies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アンディZmolek、スティーブン・E.ライト、ブライアン・キャンベル、ナットSakimura、エリック・サックス、ポール・マドセン、イアンMcGinniss、ラーフルRavikumar、Breno・デ・メデイロス、ハンネスTschofenig、アシシュジャイナ教、エリックWahlstrom、ビル・フィッシャー、Sudhi Umarji、マイケルB.ジョーンズ、ヴィットリオBertocci、ディック・ハート、デイビット・ウェイト、イグナシオ・フィオレンティーノ、キャスリーン・モリアーティ、およびエルウィン・デイヴィス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
William Denniss Google 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウィリアムDenniss Googleのアメリカの1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Email: rfc8252@wdenniss.com URI: http://wdenniss.com/appauth
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メール：rfc8252@wdenniss.com URI：http://wdenniss.com/appauth
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
John Bradley Ping Identity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジョン・ブラッドリーピング・アイデンティティ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 202-630-5272 Email: rfc8252@ve7jtb.com URI: http://www.thread-safe.com/p/appauth.html
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 202-630-5272電子メール：rfc8252@ve7jtb.com URI：http://www.thread-safe.com/p/appauth.html
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
