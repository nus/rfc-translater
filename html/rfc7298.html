<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7298 - Babel Hashed Message Authentication Code (HMAC) Cryptographic Authentication 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7298</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc7298">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7298 - Babel Hashed Message Authentication Code (HMAC) Cryptographic Authentication 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7298">
              https://tools.ietf.org/html/rfc7298
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7298 - バベルハッシュメッセージ認証コード（HMAC）暗号化認証</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Independent Submission                                       D. Ovsienko
Request for Comments: 7298                                        Yandex
Updates: 6126                                                  July 2014
Category: Experimental
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Babel Hashed Message Authentication Code (HMAC)
                      Cryptographic Authentication
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes a cryptographic authentication mechanism for the Babel routing protocol. This document updates RFC 6126. The mechanism allocates two new TLV types for the authentication data, uses Hashed Message Authentication Code (HMAC), and is both optional and backward compatible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、バベルのルーティングプロトコルの暗号認証メカニズムを説明しています。この文書の更新RFC 6126は、機構は、認証データのための2つの新たなTLVタイプを割り当て、ハッシュメッセージ認証コード（HMAC）を使用し、任意および下位互換性の両方です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7298.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7298で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................3
      1.1. Requirements Language ......................................5
   2. Cryptographic Aspects ...........................................5
      2.1. Mandatory-to-Implement and Optional Hash Algorithms ........5
      2.2. Definition of Padding ......................................6
      2.3. Cryptographic Sequence Number Specifics ....................8
      2.4. Definition of HMAC .........................................9
   3. Updates to Protocol Data Structures ............................11
      3.1. RxAuthRequired ............................................11
      3.2. LocalTS ...................................................11
      3.3. LocalPC ...................................................11
      3.4. MaxDigestsIn ..............................................11
      3.5. MaxDigestsOut .............................................12
      3.6. ANM Table .................................................12
      3.7. ANM Timeout ...............................................13
      3.8. Configured Security Associations ..........................14
      3.9. Effective Security Associations ...........................16
   4. Updates to Protocol Encoding ...................................17
      4.1. Justification .............................................17
      4.2. TS/PC TLV .................................................19
      4.3. HMAC TLV ..................................................20
   5. Updates to Protocol Operation ..................................21
      5.1. Per-Interface TS/PC Number Updates ........................21
      5.2. Deriving ESAs from CSAs ...................................23
      5.3. Updates to Packet Sending .................................25
      5.4. Updates to Packet Receiving ...............................28
      5.5. Authentication-Specific Statistics Maintenance ............30
   6. Implementation Notes ...........................................31
      6.1. Source Address Selection for Sending ......................31
      6.2. Output Buffer Management ..................................31
      6.3. Optimizations of Deriving Procedure for ESAs ..............32
      6.4. Duplication of Security Associations ......................33
   7. Network Management Aspects .....................................34
      7.1. Backward Compatibility ....................................34
      7.2. Multi-Domain Authentication ...............................35
      7.3. Migration to and from Authenticated Exchange ..............36
      7.4. Handling of Authentication Key Exhaustion .................37
   8. Security Considerations ........................................38
   9. IANA Considerations ............................................43
   10. Acknowledgements ..............................................43
   11. References ....................................................44
      11.1. Normative References .....................................44
      11.2. Informative References ...................................44
   Appendix A. Figures and Tables ....................................47
   Appendix B. Test Vectors ..........................................52
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authentication of routing protocol exchanges is a common means of securing computer networks. The use of protocol authentication mechanisms helps in ascertaining that only the intended routers participate in routing information exchange and that the exchanged routing information is not modified by a third party.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ルーティングプロトコル交換の認証は、コンピュータ・ネットワークを確保する一般的な手段です。プロトコルの認証メカニズムを使用することのみを意図ルータが情報交換をルーティングおよび交換ルーティング情報が第三者によって改変されていないことを参加することを確認するのに役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL] (&#34;the original specification&#34;) defines data structures, encoding, and the operation of a basic Babel routing protocol instance (&#34;instance of the original protocol&#34;). This document (&#34;this specification&#34;) defines data structures, encoding, and the operation of an extension to the Babel protocol -- an authentication mechanism (&#34;this mechanism&#34;). Both the instance of the original protocol and this mechanism are mostly self-contained and interact only at coupling points defined in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL（「元の仕様」）は、データ構造、符号化、および基本的なバベルルーティングプロトコルインスタンス（「オリジナルプロトコルのインスタンス」）の動作を定義します。認証メカニズム（「このメカニズム」） - この文書（「本明細書」）は、データ構造、符号化、およびバベルプロトコルの拡張の動作を定義します。両方の元のプロトコルとこの機構の例は、主に自己完結型であり、本明細書で定義されている結合点でのみ相互作用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A major design goal of this mechanism is transparency to operators that is not affected by implementation and configuration specifics. A complying implementation makes all meaningful details of authentication-specific processing clear to the operator, even when some of the operational parameters cannot be changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムの主要な設計目標は、実装と構成の仕様に影響されない事業者に対する透明性です。準拠実装では、動作パラメータの一部を変更することができない場合でも、オペレータへの認証に固有の処理の全ての意味の詳細が明らかになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The currently established (see [RIP2-AUTH], [OSPF2-AUTH], [ISIS-AUTH-A], [RFC6039], and [OSPF3-AUTH-BIS]) approach to an authentication mechanism design for datagram-based routing protocols such as Babel relies on two principal data items embedded into protocol packets, typically as two integral parts of a single data structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在確立された（[RFC6039]、[ISIS-AUTH-A]、[OSPF2-AUTH]、[RIP2-AUTH]を参照し、[OSPF3-AUTH-BIS]）データグラムベースのルーティングプロトコルのための認証メカニズムの設計へのアプローチバベルは、2つの主要なデータ項目に依存しているような、典型的には単一のデータ構造の2つの一体的な部品として、プロトコルパケットに埋め込ま。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A fixed-length unsigned integer, typically called a cryptographic sequence number, used in replay attack protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O固定長符号なし整数は、典型的には、リプレイ攻撃からの保護に使用される、暗号化シーケンス番号と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A variable-length sequence of octets, a result of the Hashed Message Authentication Code (HMAC) construction (see [RFC2104]) computed on meaningful data items of the packet (including the cryptographic sequence number) on one hand and a secret key on the other, used in proving that both the sender and the receiver share the same secret key and that the meaningful data was not changed in transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oオクテットの可変長配列、ハッシュメッセージ認証コード（HMAC）構造の結果は、（参照[RFC2104]）一方で（暗号化シーケンス番号を含む）パケットの意味のあるデータ項目および秘密鍵に基づいて計算証明に使用される、他のその送信者と受信者を共有同じ秘密鍵と意味のあるデータが送信中に変更されなかったことの両方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the design specifics, either all protocol packets or only those packets protecting the integrity of protocol exchange are authenticated. This mechanism authenticates all protocol packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設計仕様に応じて、すべてのプロトコルパケットまたはプロトコル交換の整合性を保護するパケットのみのどちらかが認証されています。このメカニズムは、すべてのプロトコルパケットを認証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the HMAC construction is just one of many possible approaches to cryptographic authentication of packets, this mechanism makes use of relevant prior experience by using HMAC as well, and its solution space correlates with the solution spaces of the mechanisms above. At the same time, it allows for a future extension that treats HMAC as a particular case of a more generic mechanism. Practical experience with the mechanism defined herein should be useful in designing such a future extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMACの建設は、パケットの暗号化認証に多くの可能なアプローチのひとつですが、このメカニズムは、同様にHMACを使用することによって、関連する以前の経験を利用して、その解空間は、上記のメカニズムの解スペースと相関します。同時に、それはより一般的なメカニズムの特定のケースとしてHMACを扱い、将来の拡張が可能になります。本明細書に定義される機構を備えた実用的な経験は、このような将来の拡張を設計する上で有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines the use of the cryptographic sequence number in detail sufficient to make replay attack protection strength predictable. That is, an operator can tell the strength from the declared characteristics of an implementation and, if the implementation allows the changing of relevant parameters, the effect of a reconfiguration as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、リプレイ攻撃に対する防御力が予測できるように十分な詳細の暗号化シーケンス番号の使用を定義します。実装は同様に、再構成の影響を関連パラメータの変更を可能にする場合、すなわち、操作者は、実装の宣言された特性からの強度を伝えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This mechanism explicitly allows for multiple HMAC results per authenticated packet. Since meaningful data items of a given packet remain the same, each such HMAC result stands for a different secret key and/or a different hash algorithm. This enables a simultaneous, independent authentication within multiple domains. This specification is not novel in this regard; for example, the Layer 2 Tunneling Protocol (L2TPv3) allows for one or two results per authenticated packet ([RFC3931] Section 5.4.1), and Mobile Ad Hoc Network (MANET) protocols allow for several ([RFC7183] Section 6.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムは、明示的に認証されたパケットごとに複数のHMAC結果が可能になります。所与のパケットの意味のあるデータ項目が同一のままであるので、このような各HMAC結果は、異なる秘密鍵および/または異なるハッシュアルゴリズムを表します。これは、複数のドメイン内での同時、独立した認証が可能になります。この仕様は、この点では小説ではありません。例えば、レイヤ2トンネリングプロトコル（L2TPv3の）が認証パケットごとに1つのまたは2つの結果（[RFC3931]セクション5.4.1）を可能にし、モバイルアドホックネットワーク（MANET）プロトコルは、いくつかの（[RFC7183]セクション6.1）を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An important concern addressed by this mechanism is limiting the amount of HMAC computations done per authenticated packet, independently for sending and receiving. Without these limits, the number of computations per packet could be as high as the number of configured authentication keys (in the sending case) or as high as the number of keys multiplied by the number of supplied HMAC results (in the receiving case).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムによって対処の重要な関心事は、独立して送信と受信のために、認証されたパケットごとに行わHMAC計算の量を制限しています。これらの制限なしに、パケットあたりの計算の数は、（送信の場合に）構成された認証キーの数ほど高いまたは（受信場合）に供給されたHMAC結果の数を乗じたキーの数ほど高くなり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These limits establish a basic competition between the configured keys and (in the receiving case) an additional competition between the supplied HMAC results. This specification defines related data structures and procedures in a way to make such competition transparent and predictable for an operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの制限は、設定キー間及び供給HMAC結果の間に追加の競合（受信場合）基本的な競争を確立します。この仕様は、オペレータのために、このような競争は、透明性と予測可能にする方法に関連するデータ構造と手順を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wherever this specification mentions the operator reading or changing a particular data structure, variable, parameter, or event counter &#34;at runtime&#34;, it is up to the implementor how this is to be done. For example, the implementation can employ an interactive command line interface (CLI), a management protocol such as the Simple Network Management Protocol (SNMP), a means of inter-process communication such as a local socket, or a combination of these.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、オペレータの読み取りまたは「実行時に」特定のデータ構造、変数、パラメータ、またはイベントカウンタを変更するに言及どこ、これが行われることになっている方法実装次第です。例えば、実装は、ローカルソケット、又はこれらの組み合わせなどの対話型コマンドラインインターフェイス（CLI）、簡易ネットワーク管理プロトコル（SNMP）、プロセス間通信の手段として、このような管理プロトコルを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますBCP 14 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Cryptographic Aspects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.暗号側面
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Mandatory-to-Implement and Optional Hash Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.  -実装するには、必須およびオプションのハッシュアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104] defines HMAC as a construction that can use any cryptographic hash algorithm with a known digest length and internal block size. This specification preserves this property of HMAC by defining data processing that itself does not depend on any particular hash algorithm either. However, since this mechanism is a protocol extension case, there are relevant design considerations to take into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104]は既知の長さ及び内部ブロックサイズダイジェストを有する任意の暗号化ハッシュアルゴリズムを使用することができる構成としてHMACを定義します。この仕様は、それ自体がいずれかの任意の特定のハッシュアルゴリズムに依存しないデータの処理を定義することによってHMACのこの特性を保存します。このメカニズムは、プロトコル拡張ケースであるので、考慮すべき関連する設計上の考慮事項があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 4.5 of [RFC6709] suggests selecting one hash algorithm as mandatory to implement for the purpose of global interoperability (Section 3.2 of [RFC6709]) and selecting another of distinct lineage as recommended for implementation for the purpose of cryptographic agility. This specification makes the latter property guaranteed, rather than probable, through an elevation of the requirement level. There are two mandatory-to-implement hash algorithms; each is unambiguously defined and generally available in multiple implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6709]のセクション4.5は、暗号敏捷性の目的のための実装のために推奨されているように世界的な相互運用性（[RFC6709]の3.2節）と明確な系統の別を選択する目的のために実装する義務として、1つのハッシュアルゴリズムを選択示唆しています。本明細書は後者のプロパティは、要求レベルの上昇を介して、むしろ予想よりも、保証させます。 2実装に必須のハッシュアルゴリズムがあります。各々が明確に定義され、複数の実装で一般的に利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation of this mechanism MUST include support for two hash algorithms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムの実装は、2つのハッシュアルゴリズムのサポートを含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RIPEMD-160 (160-bit digest)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RIPEMD-160（160ビットのダイジェスト）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHA-1 (160-bit digest)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SHA-1（160ビットのダイジェスト）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Besides that, an implementation of this mechanism MAY include support for additional hash algorithms, provided each such algorithm is publicly and openly specified and its digest length is 128 bits or more (to meet the constraint implied in Section 2.2). Implementors SHOULD consider strong, well-known hash algorithms as additional implementation options and MUST NOT consider a hash algorithm if meaningful attacks exist for it or it is commonly viewed as deprecated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それに加えて、このメカニズムの実装は、追加のハッシュアルゴリズムのためのサポートを含んでいてもよく、それぞれのそのようなアルゴリズムは、公的かつ公然と指定され、そのダイジェスト長が128ビット以上で提供（2.2節で暗黙の制約を満たすために）。実装者は、追加の実装オプションとして、強力な、よく知られたハッシュアルゴリズムを検討すべきであるし、意味のある攻撃がそれのために存在するか、廃止予定としては、一般的に観察された場合は、ハッシュアルゴリズムを検討してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the latter case, it is important to take into account considerations both common (such as those made in [RFC4270]) and specific to the HMAC application of the hash algorithm. For example, [RFC6151] considers MD5 collisions and concludes that new protocol designs should not use HMAC-MD5, while [RFC6194] includes a comparable analysis of SHA-1 that finds HMAC-SHA-1 secure for the same purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後者の場合には、（例えば、[RFC4270]で作られたもののような）一般的なハッシュアルゴリズムのHMACのアプリケーションに固有の両方のアカウントに考慮することが重要です。例えば、[RFC6151]はMD5の衝突を考慮して、[RFC6194]は、同じ目的のための安全なHMAC-SHA-1を発見SHA-1の同等の分析を含むが、新しいプロトコルの設計は、HMAC-MD5を使用するべきではないと結論づけています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the following hash algorithms meet these requirements at the time of this writing (in alphabetical order):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、以下のハッシュアルゴリズムは、（アルファベット順で）これを書いている時点で、これらの要件を満たします：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o GOST R 34.11-94 (256-bit digest)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O GOST R 34.11から94（256ビットのダイジェスト）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHA-224 (224-bit digest, SHA-2 family)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SHA-224（224ビットのダイジェスト、SHA-2ファミリー）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHA-256 (256-bit digest, SHA-2 family)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SHA-256（256ビットのダイジェスト、SHA-2ファミリー）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHA-384 (384-bit digest, SHA-2 family)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SHA-384（384ビットのダイジェスト、SHA-2ファミリー）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHA-512 (512-bit digest, SHA-2 family)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SHA-512（512ビットのダイジェスト、SHA-2ファミリー）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Tiger (192-bit digest)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイガーO（192ビットのダイジェスト）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whirlpool (512-bit digest, 2nd rev., 2003)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oワールプール（512ビットのダイジェスト、第2 REV。、2003）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of hash algorithms available in an implementation MUST be clearly stated. When known weak authentication keys exist for a hash algorithm used in the HMAC construction, an implementation MUST deny the use of such keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装で利用可能なハッシュアルゴリズムのセットが明確に記載しなければなりません。既知の弱い認証キーはHMACの構築に使用されるハッシュアルゴリズムのために存在する場合、実装は、そのようなキーの使用を拒否しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Definition of Padding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. パディングの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many practical applications of HMAC for authentication of datagram-based network protocols (including routing protocols) involve the padding procedure, a design-specific conditioning of the message that both the sender and the receiver perform before the HMAC computation. The specific padding procedure of this mechanism addresses the following needs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ルーティングプロトコルを含む）データグラムベースのネットワークプロトコルの認証のためのHMACの多くの実用的なアプリケーションでは、パディング手順、送信者と受信者の両方がHMAC計算の前に行うメッセージの設計に固有のコンディショニングを含みます。このメカニズムの具体的なパディング手順は、次の必要性に対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Data Initialization
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oデータの初期化
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A design that places the HMAC result(s) computed for a message inside that same message after the computation has to have previously (i.e., before the computation) allocated in that message some data unit(s) purposed specifically for those HMAC result(s) (in this mechanism, it is the HMAC TLV(s); see Section 4.3). The padding procedure sets the respective octets of the data unit(s), in the simplest case to a fixed value known as the padding constant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
計算が以前に（すなわち、演算前の）いくつかのデータユニット（単数または複数）が、それらのHMAC結果（秒具体的目的と、そのメッセージに割り当てられたなければならない後に、同じメッセージ内のメッセージについて計算HMAC結果（複数可）を配置する設計）（このメカニズムでは、HMAC TLV（sで）; 4.3節を参照）。パディング手順はパディング定数として知られている固定値に最も簡単な場合には、データ部（S）の各オクテットを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The particular value of the constant is specific to each design. For instance, in [RIP2-AUTH] as well as works derived from it ([ISIS-AUTH-B], [OSPF2-AUTH], and [OSPF3-AUTH-BIS]), the value is 0x878FE1F3. In many other designs (for instance, [RFC3315], [RFC3931], [RFC4030], [RFC4302], [RFC5176], and [ISIS-AUTH-A]), the value is 0x00.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
一定の特定の値は、各設計に固有です。例えば、[RIP2-AUTH]ならびにそれから誘導される作品（[ISIS-AUTH-B]、[OSPF2-AUTH]、および[OSPF3-AUTH-BIS]）で、値が0x878FE1F3あります。多くの他の設計（例えば、[RFC3315]、[RFC3931]、[RFC4030]、[RFC4302]、[RFC5176]、および[ISIS-AUTH-A]）で、値が0x00です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
However, the HMAC construction is defined on the basis of a cryptographic hash algorithm, that is, an algorithm meeting a particular set of requirements made for any input message. Thus, any padding constant values, whether single- or multiple-octet, as well as any other message-conditioning methods, don&#39;t affect cryptographic characteristics of the hash algorithm and the HMAC construction, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
しかし、HMAC構造は暗号ハッシュアルゴリズムに基づいて定義されている、すなわち、いずれかの入力メッセージのために作られた要件の特定のセットを満たすアルゴリズムです。したがって、任意のパディング定数値、単一または複数のオクテットかどうか、ならびに任意の他のメッセージコンディショニング方法は、それぞれ、ハッシュアルゴリズムとHMAC構造の暗号化特性に影響を及ぼしません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Source Address Protection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oソースアドレス保護
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the specific case of datagram-based routing protocols, the protocol packet (that is, the message being authenticated) often does not include network-layer addresses, although the source and (to a lesser extent) the destination address of the datagram may be meaningful in the scope of the protocol instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
データグラムのソース及び（より少ない程度に）宛先アドレスがあってもよいが、データグラムベースのルーティングプロトコルの特定の場合には、プロトコルパケット（すなわち、認証されるメッセージである）は、多くの場合、ネットワーク層アドレスが含まれていませんプロトコルインスタンスの範囲において有意義。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In Babel, the source address may be used as a prefix next hop (see Section 3.5.3 of [BABEL]). A well-known (see Section 2.3 of [OSPF3-AUTH-BIS]) solution to the source address protection problem is to set the first respective octets of the data unit(s) above to the source address (yet setting the rest of the octets to the padding constant). This procedure adapts this solution to the specifics of Babel, which allows for the exchange of protocol packets using both IPv4 and IPv6 datagrams (see Section 4 of [BABEL]). Even though in the case of IPv6 exchange a Babel speaker currently uses only link-local source addresses (Section 3.1 of [BABEL]), this procedure protects all octets of an arbitrary given source address for the reasons of future extensibility. The procedure implies that future Babel extensions will never use an IPv4-mapped IPv6 address as a packet source address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
バベルでは、送信元アドレス、プレフィックス、ネクストホップとして使用することができる（[BABEL]のセクション3.5.3を参照）。ソースアドレス保護の問題によく知られている（第2.3節を参照の[OSPF3-AUTH-BIS]）溶液は、まだ残りの設定（送信元アドレスに上記データユニット（複数可）の最初の各オクテットを設定することですパディング定数オクテット）。この手順は、IPv4とIPv6の両方のデータグラムを使用して、プロトコルパケット（[BABEL]のセクション4を参照）の交換を可能にバベルの仕様にこの溶液を適応させます。 IPv6の交換の場合にバベルスピーカーは、現在のみリンクローカル送信元アドレス（[BABEL]のセクション3.1）を使用しても、この手順は、将来の拡張性の理由のために、任意の所与の送信元アドレスのすべてのオクテットを保護します。手順は、将来のバベルの拡張は、パケットの送信元アドレスとしてIPv4射影IPv6アドレスを使用しないことを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This procedure does not protect the destination address, which is currently considered meaningless (Section 3.1 of [BABEL]) in the same scope. A future extension that looks to add such protection would likely use a new TLV or sub-TLV to include the destination address in the protocol packet (see Section 4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この手順は、現在、同じスコープ内の無意味（[BABEL]のセクション3.1）であると考えられる宛先アドレスを、保護しません。そうなプロトコルパケットの宛先アドレスが含まれるように、新たなTLVまたはサブTLVを使用することになり、このような保護機能を追加することになります将来の拡張は（セクション4.1を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Description of the padding procedure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディング手順の説明：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set the first 16 octets of the Digest field of the given HMAC TLV to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.与えられたHMAC TLVのダイジェストフィールドの最初の16個のオクテットを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* the given source address, if it is an IPv6 address, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*与えられた送信元アドレスを、それがIPv6アドレスである場合、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* the IPv4-mapped IPv6 address (per Section 2.5.5.2 of [RFC4291]) holding the given source address, if it is an IPv4 address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
それはIPv4アドレスである場合*（[RFC4291]のセクション2.5.5.2当たり）IPv4射影IPv6アドレスは、所定の送信元アドレスを保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set the remaining (TLV Length - 18) octets of the Digest field of the given HMAC TLV to 0x00 each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.残り（TLVの長さ -  18）設定された所定のHMAC TLVのダイジェストフィールドのオクテットをそれぞれ0x00に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For an example of a Babel packet with padded HMAC TLVs, see Table 3 in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディングされたHMACのTLVとバベルパケットの例については、付録Aの表3参照
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Cryptographic Sequence Number Specifics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. 暗号シーケンス番号細目
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operation of this mechanism may involve multiple local and multiple remote cryptographic sequence numbers, each essentially being a 48-bit unsigned integer. This specification uses the term &#34;TS/PC number&#34; to avoid confusion with the route&#39;s (Section 2.5 of [BABEL]) or node&#39;s (Section 3.2.1 of [BABEL]) sequence numbers of the original Babel specification and to stress the fact that there are two distinguished parts of this 48-bit number, each handled in its specific way (see Section 5.1):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この機構の動作は、それぞれが実質的に48ビットの符号なし整数である、複数のローカルおよび複数のリモート暗号化シーケンス番号を含むことができます。この仕様は、ルートの（[BABEL]の2.5節）、またはノードの（[BABEL]のセクション3.2.1）元バベル仕様のシーケンス番号との混同を避けるためにしているという事実を強調するために用語「TS / PC番号」を使用していますこの48ビットの数の2つの識別部分、その特定の方法で扱う各（セクション5.1を参照）があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1     2 3                   4
    0 1 2 3 4 5 6 7 8 9 0 //  9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         TS         //         |              PC               |
   +-+-+-+-+-+-+-+-+-+-//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                      //
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The high-order 32 bits are called &#34;timestamp&#34; (TS), and the low-order 16 bits are called &#34;packet counter&#34; (PC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上位32ビットは、「タイムスタンプ」（TS）と呼ばれ、下位16ビットは、「パケットカウント」（PC）と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This mechanism stores, updates, compares, and encodes each TS/PC number as two independent unsigned integers -- TS and PC, respectively. Such a comparison of TS/PC numbers, as performed in item 3 of Section 5.4, is algebraically equivalent to a comparison of the respective 48-bit unsigned integers. Any byte order conversion, when required, is performed on TS and PC parts independently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムを格納、更新は、比較し、それぞれが、2つの独立した符号なし整数として/ PC番号をTSエンコード -  TSとPC、それぞれ。 TS / PC番号のような比較は、セクション5.4の項目3で行ったように、それぞれの48ビット符号なし整数の比較に代数的に等価です。任意のバイトオーダー変換は、必要なときに、独立してTSとPCパーツで行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. Definition of HMAC
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4.  HMACの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm description below uses the following nomenclature, which is consistent with [FIPS-198]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズム記述は、以下の[FIPS-198]と一致している以下の用語を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Text The data on which the HMAC is calculated (note item (b) of Section 8). In this specification, it is the contents of a Babel packet ranging from the beginning of the Magic field of the Babel packet header to the end of the last octet of the Packet Body field, as defined in Section 4.2 of [BABEL] (see Figure 2 in Appendix A).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMACを計算されたテキストデータ（第8項の項目（B）に注意してください）。 [BABEL]のセクション4.2で定義されるように、本明細書では、（図を参照して、バベルパケットヘッダのマジック・フィールドの先頭からパケットボディフィールドの最後のオクテットの終わりまでの範囲バベルパケットの内容であります付録Aで2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
H The specific hash algorithm (see Section 2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
H特定のハッシュアルゴリズム（セクション2.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
K A sequence of octets of an arbitrary, known length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意の、既知の長さのオクテットのシーケンスをK。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ko The cryptographic key used with the hash algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コハッシュアルゴリズムで使用される暗号鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B The block size of H, measured in octets rather than bits. Note that B is the internal block size, not the digest length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HのブロックサイズB、オクテットよりむしろビットで測定。 Bは、内部ブロック・サイズではなく、ダイジェストの長さであることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
L The digest length of H, measured in octets rather than bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オクテットよりむしろビットで測定されたHのLザダイジェスト長。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XOR The bitwise exclusive-or operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
排他的論理和演算ビット単位のXOR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Opad The hexadecimal value 0x5C repeated B times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B回繰り返し0x5Cを16進数の値をOPAD。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ipad The hexadecimal value 0x36 repeated B times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリは、16進数の値0x36がB回繰り返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm below is the original, unmodified HMAC construction as defined in both [RFC2104] and [FIPS-198]; hence, it is different from the algorithms defined in [RIP2-AUTH], [ISIS-AUTH-B], [OSPF2-AUTH], and [OSPF3-AUTH-BIS] in exactly two regards:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104]と[FIPS-198]の両方で定義されるように以下のアルゴリズムは、元の、非修飾HMAC構造です。したがって、[OSPF2-AUTH]、[ISIS-AUTH-B]、[RIP2-AUTH]で定義されたアルゴリズムとは異なる、とちょうど二つの点で[OSPF3-AUTH-BIS]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The algorithm below sets the size of Ko to B, not to L (L is not greater than B). This resolves both ambiguity in XOR expressions and incompatibility in the handling of keys that have length greater than L but not greater than B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oアルゴリズムは、以下（LはBより大きくない）がLに、Bにコのサイズを設定します。これは、Lよりも大きいが、Bよりも大きくない長さを持つキーの取り扱いにXOR式の曖昧さとの非互換性の両方を解決します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The algorithm below does not change the value of Text before or after the computation. Padding a Babel packet before the computation and placing the result inside the packet are both performed elsewhere.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oアルゴリズムは、以下の前または演算後のテキストの値を変更しません。計算前バベルパケットをパディングし、パケット内の結果を確定すると、両方の他の場所で行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intent of this is to enable the most straightforward use of cryptographic libraries by implementations of this specification. At the time of this writing, implementations of the original HMAC construction coupled with hash algorithms of choice are generally available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これの目的は、この仕様の実装によって暗号化ライブラリの最も簡単な使用を可能にするためです。この記事の執筆時点では、選択肢のハッシュアルゴリズムと相まって、オリジナルHMAC工事の実装が一般的に利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Description of the algorithm:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムの説明：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Preparation of the Key
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
キーの調製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       In this application, Ko is always B octets long.  If K is B
       octets long, then Ko is set to K.  If K is more than B octets
       long, then Ko is set to H(K) with the necessary amount of zeroes
       appended to the end of H(K), such that Ko is B octets long.  If K
       is less than B octets long, then Ko is set to K with zeroes
       appended to the end of K, such that Ko is B octets long.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. First-Hash
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
まず、ハッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       A First-Hash, also known as the inner hash, is computed
       as follows:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
First-Hash = H(Ko XOR Ipad || Text)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
一ハッシュ= H（KO XOR ipadと||テキスト）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Second-Hash
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.セカンドハッシュ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       A Second-Hash, also known as the outer hash, is computed
       as follows:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Second-Hash = H(Ko XOR Opad || First-Hash)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
第二ハッシュ= H（KO XOR OPAD ||まず、ハッシュ）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Result
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.結果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       The resulting Second-Hash becomes the authentication data that is
       returned as the result of HMAC calculation.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in the case of Babel the Text parameter will never exceed a few thousand octets in length. In this specific case, the optimization discussed in Section 6 of [FIPS-198] applies, namely, for a given K that is more than B octets long, the following associated intermediate results may be precomputed only once: Ko, (Ko XOR Ipad), and (Ko XOR Opad).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バベルの場合にテキストパラメータは、長さが数千オクテットを超えることはありませんので注意してください。コ、（KO XOR計算された：この特定の場合では、[FIPS-198]のセクション6で説明した最適化、すなわち、Bが長いオクテットより多い所与のkについて、次の関連する中間結果は一度だけ事前に計算されてもよい、適用します）、及び（KO XOR OPAD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Updates to Protocol Data Structures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
プロトコル・データ構造へ3.アップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. RxAuthRequired
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.  RxAuthRequired
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RxAuthRequired is a boolean parameter. Its default value MUST be TRUE. An implementation SHOULD make RxAuthRequired a per-interface parameter but MAY make it specific to the whole protocol instance. The conceptual purpose of RxAuthRequired is to enable a smooth migration from an unauthenticated Babel packet exchange to an authenticated Babel packet exchange and back (see Section 7.3). The current value of RxAuthRequired directly affects the receiving procedure defined in Section 5.4. An implementation SHOULD allow the operator to change the RxAuthRequired value at runtime or by means of a Babel speaker restart. An implementation MUST allow the operator to discover the effective value of RxAuthRequired at runtime or from the system documentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RxAuthRequiredはブール・パラメータです。デフォルト値はTRUEでなければなりません。実装はRxAuthRequiredにインタフェース毎のパラメータを確認する必要がありますが、全体プロトコルインスタンスにそれが特定のかもしれません。 RxAuthRequiredの概念の目的は、認証されたバベルパケット交換とバック（セクション7.3を参照）に認証されていないバベルパケット交換機からのスムーズな移行を可能にすることです。 RxAuthRequiredの電流値は、直接セクション5.4で定義された受信手順に影響を与えます。実装は、オペレータが実行時またはバベルスピーカーの再起動によってRxAuthRequired値を変更できるようにする必要があります。実装は、オペレータが、実行時またはシステムのマニュアルからRxAuthRequiredの実効値を発見するために許容しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. LocalTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.  LocalTS
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LocalTS is a 32-bit unsigned integer variable. It is the TS part of a per-interface TS/PC number. LocalTS is a strictly per-interface variable not intended to be changed by the operator. Its initialization is explained in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LocalTSは、32ビットの符号なし整数変数です。これは、インターフェイスTS / PC数のTSの一部です。 LocalTSは、オペレータによって変更されるものではない厳密ごとインターフェース変数です。その初期化はセクション5.1で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. LocalPC
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.  LocalPC
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LocalPC is a 16-bit unsigned integer variable. It is the PC part of a per-interface TS/PC number. LocalPC is a strictly per-interface variable not intended to be changed by the operator. Its initialization is explained in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LocalPCは、16ビットの符号なし整数変数です。これは、インターフェイスTS / PC数のPCの一部です。 LocalPCは、オペレータによって変更されるものではない厳密ごとインターフェース変数です。その初期化はセクション5.1で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. MaxDigestsIn
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.  MaxDigestsIn
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDigestsIn is an unsigned integer parameter conceptually purposed for limiting the amount of CPU time spent processing a received authenticated packet. The receiving procedure performs the most CPU-intensive operation -- the HMAC computation -- only at most MaxDigestsIn (Section 5.4 item 7) times for a given packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDigestsIn概念的受信した認証パケットの処理に費やされるCPU時間の量を制限するための目的と符号なし整数パラメータです。 HMAC計算 -   - のみ与えられたパケットのための最もMaxDigestsIn（5.4項目7）時間で受信手順は、ほとんどのCPU集約型の動作を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MaxDigestsIn value MUST be at least 2. An implementation SHOULD make MaxDigestsIn a per-interface parameter but MAY make it specific to the whole protocol instance. An implementation SHOULD allow the operator to change the value of MaxDigestsIn at runtime or by means of a Babel speaker restart. An implementation MUST allow the operator to discover the effective value of MaxDigestsIn at runtime or from the system documentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDigestsIn値は少なくとも2でなければなりません実装ごとのインターフェイスパラメータをMaxDigestsInすべきであるが、全体のプロトコルインスタンスに特定のかもしれません。実装は、オペレータが実行時またはバベルスピーカーの再起動によってMaxDigestsInの値を変更できるようにする必要があります。実装は、オペレータが、実行時またはシステムのマニュアルからMaxDigestsInの実効値を発見するために許容しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. MaxDigestsOut
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.  MaxDigestsOut
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDigestsOut is an unsigned integer parameter conceptually purposed for limiting the amount of a sent authenticated packet&#39;s space spent on authentication data. The sending procedure adds at most MaxDigestsOut (Section 5.3 item 5) HMAC results to a given packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDigestsOutは概念的に認証データに費やさ送られ、認証パケットのスペースの量を制限するための目的と符号なし整数パラメータです。送信の手順は、与えられたパケットに最もMaxDigestsOut（5.3節項目5）HMAC結果に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MaxDigestsOut value MUST be at least 2. An implementation SHOULD make MaxDigestsOut a per-interface parameter but MAY make it specific to the whole protocol instance. An implementation SHOULD allow the operator to change the value of MaxDigestsOut at runtime or by means of a Babel speaker restart, in a safe range. The maximum safe value of MaxDigestsOut is implementation specific (see Section 6.2). An implementation MUST allow the operator to discover the effective value of MaxDigestsOut at runtime or from the system documentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDigestsOut値は、少なくとも2実装ごとのインターフェイスパラメータをMaxDigestsOutすべきであるが、全体のプロトコルインスタンスにそれが特定行うことができるなければなりません。実装は、オペレータが安全な範囲で、実行時またはバベルスピーカーの再起動によってMaxDigestsOutの値を変更できるようにする必要があります。 MaxDigestsOutの最大安全値は実装固有の（6.2節を参照）です。実装は、オペレータが、実行時またはシステムのマニュアルからMaxDigestsOutの実効値を発見するために許容しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. ANM Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.  ANM表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ANM (Authentic Neighbours Memory) table resembles the neighbour table defined in Section 3.2.3 of [BABEL]. Note that the term &#34;neighbour table&#34; means the neighbour table of the original Babel specification, and the term &#34;ANM table&#34; means the table defined herein. Indexing of the ANM table is done in exactly the same way as indexing of the neighbour table, but its purpose, field set, and associated procedures are different.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANM（本物ネイバーメモリ）テーブルには、[BABEL]のセクション3.2.3で定義されたネイバーテーブルに似ています。用語「隣接テーブル」は、元のバベル仕様のネイバーテーブルを意味し、用語「ANMテーブル」は、本明細書に定義されたテーブルを意味することに留意されたいです。 ANMテーブルのインデックスは、ネイバーテーブルのインデックスとまったく同じように行われますが、その目的、フィールドセット、および関連する手順が異なりますされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The conceptual purpose of the ANM table is to provide longer-term replay attack protection than would be possible using the neighbour table. Expiry of an inactive entry in the neighbour table depends on the last received Hello Interval of the neighbour and typically stands for tens to hundreds of seconds (see Appendixes A and B of [BABEL]). Expiry of an inactive entry in the ANM table depends only on the local speaker&#39;s configuration. The ANM table retains (for at least the amount of seconds set by the ANM timeout parameter as defined in Section 3.7) a copy of the TS/PC number advertised in authentic packets by each remote Babel speaker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANMテーブルの概念目的は、ネイバーテーブルを使用して可能であるよりも長期リプレイ攻撃からの保護を提供することです。ネイバーテーブル内の非アクティブなエントリの有効期限は、最後に依存隣人のハロー間隔を受け、通常は（[BABEL]の付録AとBを参照）秒の数十〜数百の略です。 ANMテーブルの非アクティブなエントリの有効期限は、ローカルスピーカーの設定に依存します。 ANMテーブル（ANMタイムアウトパラメータで設定された秒の少なくとも量については、セクション3.7で定義されるように）各リモートバベルスピーカーによって本物のパケットでアドバタイズTS / PCの数のコピーを保持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ANM table is indexed by pairs of the form (Interface, Source). Every table entry consists of the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANMテーブルは、フォーム（インタフェース、ソース）の対により索引付けされます。すべてのテーブルのエントリには、以下のフィールドから構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Interface
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oインタフェース
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An implementation-specific reference to the local node&#39;s interface through which the authentic packet was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
本物のパケットを受信したを通じてローカルノードのインタフェースに実装固有参照。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Source
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
お そうｒせ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The source address of the Babel speaker from which the authentic packet was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
本物のパケットを受信したバベルスピーカーの送信元アドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LastTS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O LastTS
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A 32-bit unsigned integer -- the TS part of a remote TS/PC number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
32ビット符号なし整数 - リモートTS / PC番号のTSの一部。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LastPC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LastPC上
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A 16-bit unsigned integer -- the PC part of a remote TS/PC number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
16ビット符号なし整数 - リモートTS / PCの数のPC部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ANM table entry has an associated aging timer, which is reset by the receiving procedure (Section 5.4 item 9). If the timer expires, the entry is deleted from the ANM table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ANMテーブルエントリは、受信手順（セクション5.4項目9）によってリセットされた関連エージングタイマーを有しています。タイマーが期限切れになった場合、エントリはANMテーブルから削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation SHOULD use persistent memory (NVRAM) to retain the contents of the ANM table across restarts of the Babel speaker, but only as long as both the Interface field reference and expiry of the aging timer remain correct. An implementation MUST be clear regarding if and how persistent memory is used for the ANM table. An implementation SHOULD allow the operator to retrieve the current contents of the ANM table at runtime. An implementation SHOULD allow the operator to remove some or all ANM table entries at runtime or by means of a Babel speaker restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、バベルスピーカーの再起動を横切っANMテーブルの内容を保持する持続性メモリ（NVRAM）を使用する必要があり、のみ限りInterfaceフィールド参照エージングタイマーの満了の両方として正しいままです。実装があれば、どのように永続メモリANMテーブルのために使用さに関して明確でなければなりません。実装は、オペレータが、実行時にANMテーブルの現在の内容を取得できるようにする必要があります。実装は、オペレータが実行時またはバベルスピーカーの再起動によって、一部またはすべてANMテーブルエントリを削除できるようにする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. ANM Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7.  ANMタイムアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANM timeout is an unsigned integer parameter. An implementation SHOULD make ANM timeout a per-interface parameter but MAY make it specific to the whole protocol instance. ANM timeout is conceptually purposed for limiting the maximum age (in seconds) of entries in the ANM table that stand for inactive Babel speakers. The maximum age is immediately related to replay attack protection strength. The strongest protection is achieved with the maximum possible value of ANM timeout set, but it may not provide the best overall result for specific network segments and implementations of this mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANMのタイムアウトは、符号なし整数パラメータです。実装は、インターフェースごとのパラメータANMのタイムアウトをしなければならないが、全体のプロトコルインスタンスにそれが特定のかもしれません。 ANMのタイムアウトは、概念的には、非アクティブバベルのスピーカー用スタンドANMテーブルのエントリ（秒）の最大年齢を制限するために目的とされます。最大年齢は、直ちに攻撃防御力を再生することが関係しています。最も強力な保護はANMタイムアウトセットの可能な最大値で達成されるが、それは、特定のネットワークセグメントと、このメカニズムの実装のための最良の全体的な結果を提供しないかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, implementations unable to maintain the local TS/PC number strictly increasing across Babel speaker restarts will reuse the advertised TS/PC numbers after each restart (see Section 5.1). The neighbouring speakers will treat the new packets as replayed and discard them until the aging timer of the respective ANM table entry expires or the new TS/PC number exceeds the one stored in the entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体的には、厳密にバベルのスピーカー再起動しても増加ローカルTS / PCの数を維持することができないの実装は（セクション5.1を参照）、各再起動後に広告を出してTS / PC番号を再利用します。近隣のスピーカーが再生される新しいパケットを処理し、それぞれのANMテーブルエントリのエージングタイマーが期限切れになったり、新しいTS / PCの数は、エントリに格納されている1つを超えるまで、それらを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another possible, but less probable, case could be an environment that uses IPv6 for the exchange of Babel datagrams and that involves physical moves of network-interface hardware between Babel speakers. Even when performed without restarting the speakers, these physical moves would cause random drops of the TS/PC number advertised for a given (Interface, Source) index, as viewed by neighbouring speakers, since IPv6 link-local addresses are typically derived from interface hardware addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の可能な、あまり可能性、ケースは、バベルデータグラムの交換のためのIPv6を使用する環境であることができ、それは、バベルのスピーカーとの間のネットワークインタフェースハードウェアの物理的な移動を伴います。スピーカーを再起動せずに行った場合でも、IPv6リンクローカルアドレスは通常、インターフェース・ハードウェアから派生しているので、これらの物理的な動きは、近隣のスピーカーで見られるように、与えられた（インタフェース、出所）インデックスのために宣伝TS / PC番号のランダムドロップを引き起こしますアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming that in such cases the operators would prefer to use a lower ANM timeout value to let the entries expire on their own rather than having to manually remove them from the ANM table each time, an implementation SHOULD set the default value of ANM timeout to a value between 30 and 300 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような場合には、オペレータがエントリが自分で期限が切れるようにする下ANMタイムアウト値を使用することを好むと仮定するというより、手動ANMテーブルから毎回それらを削除する必要が、実装はにANMタイムアウトのデフォルト値を設定する必要があります30〜300秒の間の値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the same time, network segments may exist with every Babel speaker having its advertised TS/PC number strictly increasing over the deployed lifetime. Assuming that in such cases the operators would prefer using a much higher ANM timeout value, an implementation SHOULD allow the operator to change the value of ANM timeout at runtime or by means of a Babel speaker restart. An implementation MUST allow the operator to discover the effective value of ANM timeout at runtime or from the system documentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同時に、ネットワークセグメントは、すべてのバベルのスピーカーは、厳密に展開生涯にわたり増加し、その広告を出しTS / PC番号を持つ存在してもよいです。このような場合には、オペレータがはるかに高いANMのタイムアウト値を使用して好むと仮定すると、実装は、オペレータは、実行時またはバベルスピーカーの再起動によって、ANMのタイムアウトの値を変更できるようにする必要があります。実装は、オペレータが、実行時またはシステムのドキュメントからANMタイムアウトの実効値を発見するために許容しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. Configured Security Associations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. 設定されたセキュリティアソシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Configured Security Association (CSA) is a data structure conceptually purposed for associating authentication keys and hash algorithms with Babel interfaces. All CSAs are managed in finite sequences, one sequence per interface (hereafter referred to as &#34;interface&#39;s sequence of CSAs&#34;). Each interface&#39;s sequence of CSAs, as an integral part of the Babel speaker configuration, MAY be intended for persistent storage as long as this conforms with the implementation&#39;s key-management policy. The default state of an interface&#39;s sequence of CSAs is empty, which has a special meaning of no authentication configured for the interface. The sending (Section 5.3 item 1) and the receiving (Section 5.4 item 1) procedures address this convention accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
設定されたセキュリティ協会（CSA）概念的バベルインタフェースと認証キーとハッシュアルゴリズムを関連付ける目的とデータ構造です。すべてのCSAは、インターフェイスごとに1つの配列が（以下、「のCSAのインターフェースの配列」と呼ばれる）、有限系列で管理されています。 CSAの各インターフェイスのシーケンスは、バベルのスピーカー構成の不可欠な部分として、限り、これは実装のキー管理ポリシーに準拠して永続的な記憶のために意図され得ます。 CSAのインタフェースのシーケンスのデフォルトの状態は、インターフェイスに設定され、認証なしの特別な意味を持っている、空です。送信（5.3節項目1）および受信（5.4項目1）手順は、それに応じてこの規則に対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single CSA structure consists of the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一CSAの構造は、次のフィールドで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o HashAlgo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O HashAlgo
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An implementation-specific reference to one of the hash algorithms supported by this implementation (see Section 2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この実装でサポートされているハッシュアルゴリズムの一つに実装固有の基準（セクション2.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o KeyChain
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oキーホルダー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A finite sequence of elements (hereafter referred to as &#34;KeyChain sequence&#34;) representing authentication keys, each element being a structure consisting of the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
認証キーを表す要素の有限のシーケンス（以下、「キーチェーン配列」と呼ぶ）、各要素は、以下のフィールドからなる構造です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* LocalKeyID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* LocalKeyID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
An unsigned integer of an implementation-specific bit length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
実装固有のビット長の符号なし整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* AuthKeyOctets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* AuthKeyOctets
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
A sequence of octets of an arbitrary, known length to be used as the authentication key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
認証キーとして使用される任意の、既知の長さのオクテットのシーケンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* KeyStartAccept
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* KeyStartAccept
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The time that this Babel speaker will begin considering this authentication key for accepting packets with authentication data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
このバベルのスピーカーは、認証データのパケットを受け入れるため、この認証キーを考慮し始めます時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* KeyStartGenerate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* KeyStartGenerate
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The time that this Babel speaker will begin considering this authentication key for generating packet authentication data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
このバベルのスピーカーは、パケットの認証データを生成するため、この認証キーを考慮し始めます時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* KeyStopGenerate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* KeyStopGenerate
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The time that this Babel speaker will stop considering this authentication key for generating packet authentication data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
このバベルのスピーカーは、パケットの認証データを生成するため、この認証キーを考慮停止する時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* KeyStopAccept
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* KeyStopAccept
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The time that this Babel speaker will stop considering this authentication key for accepting packets with authentication data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
このバベルのスピーカーは、認証データのパケットを受け入れるため、この認証キーを考慮停止する時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since there is no limit imposed on the number of CSAs per interface, but the number of HMAC computations per sent/received packet is limited (through MaxDigestsOut and MaxDigestsIn, respectively), it may appear that only a fraction of the associated keys and hash algorithms are used in the process. The ordering of elements within a sequence of CSAs and within a KeyChain sequence is important to make the association selection process deterministic and transparent. Once this ordering is deterministic at the Babel interface level, the intermediate data derived by the procedure defined in Section 5.2 will be deterministically ordered as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そこインタフェース当たりのCSAの数に課される制限はありませんが、送信/受信パケット当たりHMAC計算の数は、（それぞれMaxDigestsOutとMaxDigestsIn、によって）制限され、それが関連するキーとハッシュアルゴリズムの一部のみが表示されることがあるのでプロセスで使用されています。 CSAのシーケンス内のキーチェーンシーケンス内の要素の順序は、関連選択プロセスは、決定論的かつ透明にすることが重要です。この順序はバベルのインターフェイスレベルで確定的になったら、5.2節で定義された手順により得られた中間データが決定論的にも注文することになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation SHOULD allow an operator to set any arbitrary order of elements within a given interface&#39;s sequence of CSAs and within the KeyChain sequence of a given CSA. Regardless of whether this requirement is or isn&#39;t met, the implementation MUST provide a means to discover the actual element order used. Whichever order is used by an implementation, it MUST be preserved across Babel speaker restarts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、オペレータが所与のCSAのインターフェイスの配列内の、与えられたCSAのキーチェーン配列内の要素の任意の順序を設定することが可能にすべきです。かかわらず、この要件があるか、または満たされていないかどうかの、実装が実際に使用される要素の順序を発見する手段を提供しなければなりません。どちらの順序は実装によって使用され、それはバベルスピーカ再起動して保存されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that none of the CSA structure fields is constrained to contain unique values. Section 6.4 explains this in more detail. It is possible for the KeyChain sequence to be empty, although this is not the intended manner of using CSAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSA構造体のフィールドのいずれもユニークな値を含むように制約されていないことに注意してください。 6.4節は、これをより詳細に説明します。キーチェーンシーケンスが空であるために、これはのCSAを使用することの意図される様式ではないが、それは、可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The KeyChain sequence has a direct prototype, which is the &#34;key chain&#34; syntax item of some existing router configuration languages. If an implementation already implements this syntax item, it is suggested that the implementation reuse it, that is, implement a CSA syntax item that refers to a key chain item rather than reimplement the latter in full.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーホルダーシーケンスは、いくつかの既存のルータの設定言語の「キーチェーン」構文項目で直接プロトタイプを、持っています。実装は既に、この構文アイテムを実装する場合、それは実装がそれを再利用することが示唆されている、すなわち、キーチェーン項目を指すのではなく完全に後者を再実装CSA構文アイテムを実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. Effective Security Associations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. 効果的なセキュリティアソシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Effective Security Association (ESA) is a data structure immediately used in sending (Section 5.3) and receiving (Section 5.4) procedures. Its conceptual purpose is to determine a runtime interface between those procedures and the deriving procedure defined in Section 5.2. All ESAs are temporary data units managed as elements of finite sequences that are not intended for persistent storage. Element ordering within each such finite sequence (hereafter referred to as &#34;sequence of ESAs&#34;) MUST be preserved as long as the sequence exists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
効果的なセキュリティ協会（ESA）のすぐ（5.4節）の手順（5.3節）を送信および受信に使用されるデータ構造です。その概念の目的は、セクション5.2で定義された手順と導出手順の間のランタイム・インターフェースを決定することです。すべてのESAは、永続的な記憶のために意図されていない有限のシーケンスの要素として管理一時的なデータ単位です。各そのような有限のシーケンス内順序付け要素があれば、シーケンスが存在するように保存されなければならない（以下、「のESAの配列」と呼ばれます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single ESA structure consists of the following fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一ESAの構造は、次のフィールドで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o HashAlgo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O HashAlgo
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An implementation-specific reference to one of the hash algorithms supported by this implementation (see Section 2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この実装でサポートされているハッシュアルゴリズムの一つに実装固有の基準（セクション2.1を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o KeyID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O鍵ID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A 16-bit unsigned integer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
16ビット符号なし整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o AuthKeyOctets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AuthKeyOctets O
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A sequence of octets of an arbitrary, known length to be used as the authentication key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
認証キーとして使用される任意の、既知の長さのオクテットのシーケンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that among the protocol data structures introduced by this mechanism, the ESA structure is the only one not directly interfaced with the system operator (see Figure 1 in Appendix A); it is not immediately present in the protocol encoding, either. However, the ESA structure is not just a possible implementation technique but an integral part of this specification: the deriving (Section 5.2), the sending (Section 5.3), and the receiving (Section 5.4) procedures are defined in terms of the ESA structure and its semantics provided herein. The ESA structure is as meaningful for a correct implementation as the other protocol data structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（付録Aで図1を参照）は、この機構によって導入されたプロトコル・データ構造のうち、ESA構造を直接システムオペレータとインターフェースしない唯一のものであることに留意されたいです。それはどちらか、プロトコル・エンコーディングで直ちに存在しません。しかし、ESAの構造は、単に可能な実装技術が、本明細書の不可欠な部分ではない。導出（セクション5.2）、送信（セクション5.3）、および受信（5.4）の手順は、ESAの構造的に定義されていますそしてその意味は、本明細書に提供します。 ESA構造は、他のプロトコルのデータ構造として正しい実装用として意味があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Updates to Protocol Encoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
プロトコルエンコーディング4.アップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Justification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 正当化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice of encoding is very important in the long term. The protocol encoding limits various authentication mechanism designs and encodings, which in turn limit future developments of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンコードの選択は、長期的には非常に重要です。プロトコル符号化は、順番に、プロトコルの将来の発展を制限する様々な認証メカニズムの設計およびエンコーディングを、制限します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering existing implementations of the Babel protocol instance itself and related modules of packet analysers, the current encoding of Babel allows for compact and robust decoders. At the same time, this encoding allows for future extensions of Babel by three (not excluding each other) principal means as defined in Sections 4.2 and 4.3 of [BABEL] and further discussed in [BABEL-EXTENSION]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バベルプロトコルインスタンス自体とパケットアナライザの関連モジュールの既存の実装を考慮すると、バベルの現在の符号化は、コンパクトかつ堅牢なデコーダを可能にします。同時に、この符号化三（互いを排除しない）プリンシパルによってバベルの将来の拡張を可能にすることはセクション4.2および[BABEL] 4.3で定義され、さらに[BABEL-EXTENSION]で議論するように意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. A Babel packet consists of a four-octet header followed by a packet body, that is, a sequence of TLVs (see Figure 2 in Appendix A). Besides the header and the body, an actual Babel
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A。バベルパケットは、のTLV（付録Aで図2を参照）の配列であるパケット本体に続く4オクテットのヘッダから成ります。ヘッダとボディ、実際のバベル以外
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       datagram may have an arbitrary amount of trailing data between
       the end of the packet body and the end of the datagram.  An
       instance of the original protocol silently ignores such trailing
       data.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. The packet body uses a binary format allowing for 256 TLV types and imposing no requirements on TLV ordering or number of TLVs of a given type in a packet. [BABEL] allocates TLV types 0 through 10 (see Table 1 in Appendix A), defines the TLV body structure for each, and establishes the requirement for a Babel protocol instance to ignore any unknown TLV types silently. This makes it possible to examine a packet body (to validate the framing and/or to pick particular TLVs for further processing), taking into account only the type (to distinguish between a Pad1 TLV and any other TLV) and the length of each TLV, regardless of whether any additional TLV types are eventually deployed (and if so, how many).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B。パケット本体は256のTLVタイプを可能にし、パケットにTLVの順序または特定のタイプのTLVの数には要件を課すことないバイナリ形式を使用しています。 [BABEL] TLVタイプ10を介して0を割り当てるには、（付録Aの表1参照）、それぞれについてTLV体構造を定義し、静かに未知のTLVのタイプを無視するバベルプロトコルインスタンスの要件を確立します。これは、アカウントにのみタイプ（パッド1 TLV及び他のTLVを区別する）と、各TLVの長さを取る、（フレーミングを検証するために、および/またはさらなる処理のために特定のTLVを選択する）、パケット本体を検査することができます関係なく、任意の追加のTLVタイプが最終的に展開されているかどうかの（もしそうなら、どのように多くの）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. Within each TLV of the packet body, there may be some extra data after the expected length of the TLV body. An instance of the original protocol silently ignores any such extra data. Note that any TLV types without the expected length defined (such as the PadN TLV) cannot be extended with the extra data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C。パケットボディの各TLV内、TLV体の予想される長さの後に、いくつかの余分なデータがあってもよいです。元のプロトコルのインスタンスは静かにそのような余分なデータを無視します。 （例えばパッドN TLVとして）定義された予想長せず、任意のTLVタイプは余分なデータで拡張することができないことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering each of these three principal extension means for the specific purpose of adding authentication data items to each protocol packet, the following arguments can be made:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これら三つの主要な拡張のそれぞれを考慮すると、各プロトコルパケットに認証データ項目を追加する特定の目的のために、次の引数を行うことができることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of the TLV extra data of some existing TLV type would not be a solution, since no particular TLV type is guaranteed to be present in a Babel packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特にTLVタイプがバベルパケットの中に存在することが保証されないので、いくつかの既存のTLVタイプのTLV余分なデータの利用O、溶液ではないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of the TLV extra data could also conflict with future developments of the protocol encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TLV余分なデータの使用はまた、プロトコルのエンコーディングの今後の展開と競合する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Since the packet trailing data is currently unstructured, using it would involve defining an encoding structure and associated procedures; this would add to the complexity of both specification and implementation and would increase exposure to protocol attacks such as fuzzing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oパケット末尾データは、現在、それは符号化構造および関連する手順を定義伴うだろう使用して、構造化されていないからです。これは、仕様と実装の両方の複雑さに追加すると、このようなファジングなどのプロトコル攻撃への露出を増加するであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A naive use of the packet trailing data would make it unavailable to any future extension of Babel. Since this mechanism is possibly not the last extension and since some other extensions may allow no other embedding means except the packet trailing data, the defined encoding structure would have to enable the multiplexing of data items belonging to different extensions. Such a definition is out of the scope of this work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oパケット末尾のデータの素朴な使用はバベルの任意の将来の拡張にそれが使用できなくなるだろう。このメカニズムは、おそらく最後の拡張ではなく、いくつかの他の拡張機能ので、データを後続のパケットを除く他の埋め込み手段を可能にしないかもしれないので、定義された符号化構造は、異なる拡張子に属するデータの多重化を可能にしなければなりません。このような定義は、この作業の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Deprecating an extension (or only its protocol encoding) that uses purely purpose-allocated TLVs is as simple as deprecating the TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O純粋目的割り当てのTLVは、TLVを廃止するだけで簡単に使用する拡張（または唯一のプロトコル符号化）を廃止。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of purpose-allocated TLVs is transparent for both the original protocol and any its future extensions, regardless of the embedding technique(s) used by the latter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O目的割り当てのTLVの使用にかかわらず、後者で使用される埋め込み技術（単数または複数）の、元のプロトコルと任意の将来の拡張の両方に対して透明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering all of the above, this mechanism uses neither the packet trailing data nor the TLV extra data but uses two new TLV types: type 11 for a TS/PC number and type 12 for an HMAC result (see Table 1 in Appendix A).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（付録Aの表1を参照）HMAC結果のためにTS / PC番号のタイプ11とタイプ12：上記のすべてを考慮すると、このメカニズムは、データを後続のパケットもTLV余分なデータも使用しないが、2つの新しいTLVタイプを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. TS/PC TLV
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.  TS / PC TLV
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of a TS/PC TLV is to store a single TS/PC number. There is exactly one TS/PC TLV in an authenticated Babel packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TS / PC TLVの目的は、単一のTS / PC番号を格納することです。正確に一つのTS / PC TLVは、認証されたバベルのパケットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Type = 11   |     Length    |         PacketCounter         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールド：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Set to 11 to indicate a TS/PC TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプは、TS / PC TLVを示すために11に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Length The length, in octets, of the body, exclusive of the Type and Length fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さタイプと長さフィールドの排他的な身体のオクテットの長さ、、、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PacketCounter A 16-bit unsigned integer in network byte order -- the PC part of a TS/PC number stored in this TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PacketCounter 16ビット符号なし整数ネットワークバイト順に - このTLVに格納されたTS / PCの数のPC部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timestamp A 32-bit unsigned integer in network byte order -- the TS part of a TS/PC number stored in this TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムスタンプネットワークバイト順に32ビット符号なし整数 - このTLVに格納されたTS / PC番号のTSの一部。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the ordering of PacketCounter and Timestamp in the TLV structure is the opposite of the ordering of TS and PC in the TS/PC number and the 48-bit equivalent (see Section 2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLV構造でPacketCounterとタイムスタンプの順序がTSの順序とPC TS / PCの数は、48ビット相当の反対であることに注意してください（2.3節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering the expected length and the extra data as mentioned in Section 4.3 of [BABEL], the expected length of a TS/PC TLV body is unambiguously defined as 6 octets. The receiving procedure would correctly process any TS/PC TLV with body length not less than the expected length, ignoring any extra data (Section 5.4 items 3 and 9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL]のセクション4.3で述べたように、予想される長さと余分なデータを考慮すると、TS / PC TLV体の予想される長さを一義的6つのオクテットとして定義されます。受信手順が正常に余分なデータ（5.4節項目3と9）を無視して、予想される長さよりも小さくない体の長さを持つ任意のTS / PC TLVを処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sending procedure produces a TS/PC TLV with body length equal to the expected length and the Length field, respectively, set as described in Section 5.3 item 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信手順は、第5.3節項目3に記載のように設定され、それぞれ、予想される長さと長さフィールドに等しい体長とTS / PC TLVを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future Babel extensions (such as sub-TLVs) MAY modify the sending procedure to include the extra data after the fixed-size TS/PC TLV body defined herein, making adjustments to the Length TLV field, the &#34;Body length&#34; packet header field, and output buffer management (as explained in Section 6.2) necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（例えば、サブTLVのような）未来のバベル拡張は、長TLVフィールドの調整を行う、本明細書で定義される固定サイズTS / PC TLV体後、余分なデータを含むように「身体長さ」パケットヘッダフィールドの送信手順を変更することができます出力バッファ管理（セクション6.2で説明したように）必要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. HMAC TLV
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.  HMAC TLV
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of an HMAC TLV is to store a single HMAC result. To assist a receiver in reproducing the HMAC computation, LocalKeyID modulo 2^16 of the authentication key is also provided in the TLV. There is at least one HMAC TLV in an authenticated Babel packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC TLVの目的は、単一のHMAC結果を格納することです。 HMAC計算の再生中に受信機を支援するために、認証キーのLocalKeyIDモジュロ2 ^ 16はまた、TLVに設けられています。少なくとも一つのHMAC TLVは、認証されたバベルのパケットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Type = 12   |    Length     |             KeyID             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Digest...
   +-+-+-+-+-+-+-+-+-+-+-+-
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fields:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィールド：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Set to 12 to indicate an HMAC TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプは、HMAC TLVを示すために12に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Length The length, in octets, of the body, exclusive of the Type and Length fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
長さタイプと長さフィールドの排他的な身体のオクテットの長さ、、、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
KeyID A 16-bit unsigned integer in network byte order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークバイト順に16ビットの符号なし整数をKEYID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Digest A variable-length sequence of octets that is at least 16 octets long (see Section 2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも16オクテット長であるオクテットの可変長配列を消化（セクション2.2を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering the expected length and the extra data as mentioned in Section 4.3 of [BABEL], the expected length of an HMAC TLV body is not defined. The receiving and padding procedures process every octet of the Digest field, deriving the field boundary from the Length field value (Section 5.4 item 7 and Section 2.2, respectively). The sending procedure produces HMAC TLVs with the Length field precisely sizing the Digest field to match the digest length of the hash algorithm used (Section 5.3 items 5 and 8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL]のセクション4.3で述べたように、予想される長さと余分なデータを考慮すると、HMAC TLV体の予想される長さが定義されていません。受信及びパディングの手順は、長さフィールドの値（それぞれ、5.4項目7と2.2節）からフィールド境界を導出する、ダイジェストフィールドのすべてのオクテットを処理します。送信手順は、Lengthフィールドを正確に使用されるハッシュアルゴリズムのダイジェストの長さと一致するダイジェストフィールドサイズ（5.3節項目5および8）とHMAC TLVを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HMAC TLV structure defined herein is final. Future Babel extensions MUST NOT extend it with any extra data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本明細書で定義されるHMAC TLV構造が最終。将来のバベルの拡張子は、余分なデータとそれを拡張してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Updates to Protocol Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
プロトコル動作5.アップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Per-Interface TS/PC Number Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. インターフェースごとのTS / PC数を更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LocalTS and LocalPC interface-specific variables constitute the TS/PC number of a Babel interface. This number is advertised in the TS/PC TLV of authenticated Babel packets sent from that interface. There is only one property that is mandatory for the advertised TS/PC number: its 48-bit equivalent (see Section 2.3) MUST be strictly increasing within the scope of a given interface of a Babel speaker as long as the protocol instance is continuously operating. This property, combined with ANM tables of neighbouring Babel speakers, provides them with the most basic replay attack protection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LocalTSとLocalPCインターフェイス固有の変数は、バベルインターフェースのTS / PC番号を構成します。この番号は、そのインターフェイスから送信され、認証さバベルパケットのTS / PC TLVでアドバタイズされます。アドバタイズされたTS / PCの数のために必須であり、一つの特性のみがある：その48ビット相当（セクション2.3を参照）プロトコルインスタンスが連続的に動作している限り、バベルスピーカーの所定のインターフェイスの範囲内で増加する厳密でなければなりません。隣接バベルスピーカーのANMテーブルと組み合わせて、このプロパティは、最も基本的なリプレイ攻撃からの保護とそれらを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialization and increment are two principal updates performed on an interface TS/PC number. The initialization is performed when a new interface becomes a part of a Babel protocol instance. The increment is performed by the sending procedure (Section 5.3 item 2) before advertising the TS/PC number in a TS/PC TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期化と増分はインタフェースTS / PCの数に実施された2つの主要なアップデートです。新しいインターフェイスはバベルプロトコルインスタンスの一部になったときに初期化が行われます。増分はTS / PC TLVにおけるTS / PC番号を公示する前に送信する手順（5.3節項目2）によって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the particular implementation method of these two updates, the advertised TS/PC number may possess additional properties that improve the replay attack protection strength. This includes, but is not limited to, the methods below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの2回の更新の特定の実装方法に応じて、広告を出してTS / PCの数は、リプレイ攻撃に対する防御力を向上させる追加のプロパティを有することができます。これには、以下の方法に限定されるものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. The most straightforward implementation would use LocalTS as a plain wrap counter, defining the updates as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A。最も簡単な実装では、次のように更新を定義し、プレーンなラップカウンタとしてLocalTSを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
initialization Set LocalPC to 0, and set LocalTS to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
初期設定は0にLocalPCを設定し、0にLocalTSを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
increment Increment LocalPC by 1. If LocalPC wraps (0xFFFF + 1 = 0x0000), increment LocalTS by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LocalPCを1（0xFFFFの+ 1 = 0000）、インクリメントLocalTSをラップする場合1だけインクリメントLocalPCをインクリメントします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, the advertised TS/PC numbers would be reused after each Babel protocol instance restart, making neighbouring speakers reject authenticated packets until the respective ANM table entries expire or the new TS/PC number exceeds the old (see Sections 3.6 and 3.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この場合、広告を出してTS / PC番号は（セクション3.6と3.7を参照）、それぞれのANMテーブルのエントリが期限切れか、新しいTS / PCの数が古いを超えるまで、隣接するスピーカーは、認証済みパケットを拒否すること、各バベルプロトコルインスタンスの再起動後に再利用されるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. A more advanced implementation could make use of any 32-bit unsigned integer timestamp (number of time units since an arbitrary epoch), such as the UNIX timestamp, if the timestamp itself spans a reasonable time range and is guaranteed against a decrease (such as one resulting from network time use). The updates would be defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B。タイムスタンプ自体が妥当な時間範囲に及ぶと（例えば、減少に対して保証されている場合は、より高度な実装では、そのようなUNIXタイムスタンプとして、（任意のエポックからの時間単位の数）は、任意の32ビット符号なし整数のタイムスタンプを使用することができネットワーク時間の使用から生じた1）。次のようにアップデートが定義されます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
initialization Set LocalPC to 0, and set LocalTS to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
初期設定は0にLocalPCを設定し、0にLocalTSを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
increment If the current timestamp is greater than LocalTS, set LocalTS to the current timestamp and LocalPC to 0, then consider the update complete. Otherwise, increment LocalPC by 1, and if LocalPC wraps, increment LocalTS by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
インクリメント現在のタイムスタンプがLocalTSよりも大きい場合は、アップデートが完了検討し、その後、0に現在のタイムスタンプとLocalPCにLocalTSを設定します。それ以外の場合は、1でLocalPCをインクリメントし、LocalPCは1で、インクリメントLocalTSをラップしている場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, the advertised TS/PC number would remain unique across the speaker&#39;s deployed lifetime without the need for any persistent storage. However, a suitable timestamp source is not available in every implementation case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この場合、広告を出してTS / PCの数は、任意の永続ストレージを必要とせずに、話し手の展開生涯にわたって一意残ります。しかしながら、適切なタイムスタンプのソースでは、すべての実装の場合には使用できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. Another advanced implementation could use LocalTS in a way similar to the &#34;wrap/boot count&#34; suggested in Section 4.1 of [OSPF3-AUTH-BIS], defining the updates as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C。別の高度な実装は、次のように更新を定義し、[OSPF3-AUTH-BIS]の4.1節で提案「ラップ/ブート・カウント」と同様にLocalTSを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       initialization  Set LocalPC to 0.  If there is a TS value stored
                       in NVRAM for the current interface, set LocalTS
                       to the stored TS value, then increment the stored
                       TS value by 1.  Otherwise, set LocalTS to 0, and
                       set the stored TS value to 1.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
increment Increment LocalPC by 1. If LocalPC wraps, set LocalTS to the TS value stored in NVRAM for the current interface, then increment the stored TS value by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
LocalPCラップ場合1だけインクリメントLocalPCをインクリメントし、現在のインターフェイスのためのNVRAMに格納されたTS値にLocalTSを設定し、次に1によって記憶されたTS値をインクリメント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In this case, the advertised TS/PC number would also remain unique across the speaker&#39;s deployed lifetime, relying on NVRAM for storing multiple TS numbers, one per interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
この場合、広告を出してTS / PCの数は、複数のTS番号、インターフェイスごとに1つを格納するためにNVRAMに頼って、話し手の展開生涯にわたって一意残ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As long as the TS/PC number retains its mandatory property stated above, it is up to the implementor to determine which methods of TS/ PC number updates are available and whether the operator can configure the method per interface and/or at runtime. However, an implementation MUST disclose the essence of each update method it includes, in a comprehensible form such as natural language description, pseudocode, or source code. An implementation MUST allow the operator to discover which update method is effective for any given interface, either at runtime or from the system documentation. These requirements are necessary to enable the optimal (see Section 3.7) management of ANM timeout in a network segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TS / PCの数は上述の必須の特性を保持する限り、それは決定するために実装次第これはTS / PC番号の更新の方法が利用可能であり、オペレータおよび/または実行時インタフェース当たり方式を設定できるかどうか。しかし、実装は、そのような自然言語記述、擬似コード、またはソースコードとして理解できる形で、含む各更新方法の本質を開示しなければなりません。実装は、オペレータがランタイム時またはシステムのマニュアルのいずれかから、任意のインターフェイスのために有効である更新方法を発見することを可能にしなければなりません。これらの要件は、ネットワークセグメントに最適な（セクション3.7を参照）ANMタイムアウトの管理を可能にするのに必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that wrapping (0xFFFFFFFF + 1 = 0x00000000) of LastTS is unlikely, but possible, causing the advertised TS/PC number to be reused. Resolving this situation requires replacing all authentication keys of the involved interface. In addition to that, if the wrap was caused by a timestamp reaching its end of epoch, using this mechanism will be impossible for the involved interface until some different timestamp or update implementation method is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LastTSのラッピング（0xFFFFFFFFの+ 1 = 0x00000000の）を再利用することにアドバタイズTS / PC番号を引き起こす可能性は低いが、可能であることに注意してください。この状況を解決することは、関係インターフェースのすべての認証キーを交換する必要があります。ラップは、エポックの終わりに到達するタイムスタンプによって引き起こされた場合、いくつかの異なるタイムスタンプまたは更新の実装方法が使用されるまで、それに加えて、このメカニズムを使用して関与インタフェースは不可能であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Deriving ESAs from CSAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.  CSAからのESAの導出
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neither receiving nor sending procedures work with the contents of an interface&#39;s sequence of CSAs directly; both (Section 5.4 item 4 and Section 5.3 item 4, respectively) derive a sequence of ESAs from the sequence of CSAs and use the derived sequence (see Figure 1 in Appendix A). There are two main goals achieved through this indirection:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どちらも受信も送信する手順は、直接のCSAのインタフェースのシーケンスの内容で動作します。両方（5.4アイテム4とそれぞれ5.3節項目4は、）のCSAの配列からのESAのシーケンスを導出し（付録Aで図1を参照）由来の配列を使用します。この間接を通じて達成二つの主な目標があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Elimination of expired authentication keys and deduplication of security associations. This is done as early as possible to keep subsequent procedures focused on their respective tasks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
期限切れの認証キーおよびセキュリティアソシエーションの重複排除のOの除去。これは、それぞれのタスクに焦点を当て、その後の手続きを維持するために可能な限り早期に行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Maintenance of particular ordering within the derived sequence of ESAs. The ordering deterministically depends on the ordering within the interface&#39;s sequence of CSAs and the ordering within the KeyChain sequence of each CSA. The particular correlation maintained by this procedure implements a concept of fair (independent of the number of keys contained by each) competition between CSAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのESAの誘導された配列内の特定の順序のメンテナンス。順序は決定論のCSAのインターフェースの配列内に発注し、各CSAのキーチェーンシーケンス内の順序に依存します。この手順によって維持特定の相関関係は、のCSA間の公正（それぞれに含まれるキーの数とは無関係に）競合の概念を実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The deriving procedure uses the following input arguments:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
導出手順は、次の入力引数を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o input sequence of CSAs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSAのO入力シーケンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o direction (sending or receiving)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O方向（送信または受信）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o current time (CT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O現在の時刻（CT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The processing of input arguments begins with an empty output sequence of ESAs and consists of the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入力引数の処理のESAの空の出力シーケンスで始まり、以下のステップから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Make a temporary copy of the input sequence of CSAs.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.のCSAの入力シーケンスの一時的なコピーを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Remove all expired authentication keys from each KeyChain sequence of the copy, that is, any keys such that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.任意のキーように、つまり、コピーの各キーチェーンシーケンスからすべての期限切れの認証キーを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       *  for receiving: KeyStartAccept is greater than CT or
          KeyStopAccept is less than CT
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* for sending: KeyStartGenerate is greater than CT or KeyStopGenerate is less than CT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*送信する：KeyStartGenerateはCTよりも大きいかKeyStopGenerateはCTよりも小さいです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note well that there are no special exceptions. Remove all expired keys, even if there are no keys left after that (see Section 7.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
特別な例外が存在しないことを十分に注意してください。その後残されたキーが存在しない場合でも、期限切れのすべてのキーを削除（7.4節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Use the copy to populate the output sequence of ESAs as follows:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.次のようにのESAの出力シーケンスを移入するためにコピーを使用します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       3.1.  When the KeyChain sequence of the first CSA contains at
             least one key, use its first key to produce an ESA with
             fields set as follows:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
HashAlgo Set to HashAlgo of the current CSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
HashAlgoは、現在のCSAのHashAlgoに設定してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
KeyID Set to LocalKeyID modulo 2^16 of the current key of the current CSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
現在のCSAの現在のキーのLocalKeyIDモジュロ2 ^ 16に設定しますKEYID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
AuthKeyOctets Set to AuthKeyOctets of the current key of the current CSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
現在のCSAの現在のキーのAuthKeyOctetsに設定AuthKeyOctets。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Append this ESA to the end of the output sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
出力シーケンスの最後に、このESAを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.2. When the KeyChain sequence of the second CSA contains at least one key, use its first key the same way, and so forth until all first keys of the copy are processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.2. 二CSAのキーチェーンシーケンスは少なくとも1つのキーが含まれている場合は、その最初のキーと同じ方法を使用して、などのコピーのすべての最初のキーが処理されるまで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.3. When the KeyChain sequence of the first CSA contains at least two keys, use its second key the same way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.3. 最初のCSAのキーチェーンシーケンスは、少なくとも2つのキーを含んでいる場合、その2番目のキーと同じ方法を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.4. When the KeyChain sequence of the second CSA contains at least two keys, use its second key the same way, and so forth until all second keys of the copy are processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.4. 二CSAのキーチェーンシーケンスは、少なくとも2つのキーを含む場合はコピーの全ての第2のキーが処理されるまで、等々その2番目のキーと同じ方法を使用し、そして。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.5. ...and so forth, until all keys of all CSAs of the copy are processed, exactly once each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.5.  ...など、コピーのすべてのCSAのすべてのキーが処理されるまで、正確に一度各。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In the description above, the ordinals (&#34;first&#34;, &#34;second&#34;, and so on) with regard to keys stand for an element position after the removal of expired keys, not before. For example, if a KeyChain sequence was { Ka, Kb, Kc, Kd } before the removal and became { Ka, Kd } after, then Ka would be the &#34;first&#34; element and Kd would be the &#34;second&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
上記の説明では、序数（「第1」、「第2」など）キーに関してない前に期限切れのキーを除去した後の素子の位置を表します。キーチェーン配列は除去前{カ、KB、Kcを、Kdを}であり、後{のKa、Kdは}となった場合、例えば、その後のKaは、「最初の」要素であろうとKdは「秒」であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Deduplicate the ESAs in the output sequence; that is, wherever two or more ESAs exist that share the same (HashAlgo, KeyID, AuthKeyOctets) triplet value, remove all of these ESAs except the one closest to the beginning of the sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前記出力シーケンス内のESAを重複排除。二つ以上のESAが同じ（HashAlgo、KeyIDを、AuthKeyOctets）トリプレット値をその共有存在どこ即ち、配列の先頭に最も近いものを除き、これらのESAをすべて削除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resulting sequence will contain zero or more unique ESAs, ordered in a way deterministically correlated with the ordering of CSAs within the original input sequence of CSAs and the ordering of keys within each KeyChain sequence. This ordering maximizes the probability of having an equal amount of keys per original CSA in any N first elements of the resulting sequence. Possible optimizations of this deriving procedure are outlined in Section 6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
得られた配列は、決定論のCSAの元の入力シーケンスと各シーケンスキーチェーン内のキーの順序内のCSAの順序と相関するように命じたゼロ個以上の一意のESAを含むであろう。この順序は、得られた配列の任意のN個の第1の要素の元のCSAあたりのキーの等量を有する確率を最大にします。この導出手順の可能な最適化は、6.3節で概説されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Updates to Packet Sending
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. パケット送信するアップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Perform the following authentication-specific processing after the instance of the original protocol considers an outgoing Babel packet ready for sending, but before the packet is actually sent (see Figure 1 in Appendix A). After that, send the packet, regardless of whether the authentication-specific processing modified the outgoing packet or left it intact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
元のプロトコルのインスタンスが送信するための発信バベルパケットの準備ができ考慮した後、次の認証特有の処理を行うが、パケットが実際に送信される前に（付録Aの図1を参照）。その後、関係なく認証特有の処理は、発信パケットを変更または無傷それを残したかどうか、パケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the current outgoing interface&#39;s sequence of CSAs is empty, finish authentication-specific processing and consider the packet ready for sending.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CSAの現在の発信インターフェイスのシーケンスが空の場合1.認証固有の処理を終了し、送信するためのパケットの準備ができて考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Increment the TS/PC number of the current outgoing interface, as explained in Section 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.インクリメント現在の発信インターフェイスのTS / PC番号、セクション5.1で説明したように。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Add to the packet body (see the note at the end of this section) a TS/PC TLV with fields set as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.次のように設定されたフィールドを持つパケット本体（このセクションの最後にある注を参照してください）TS / PC TLVに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Type Set to 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
タイプは11に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Length Set to 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
長さは6に設定してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PacketCounter Set to the current value of the LocalPC variable of the current outgoing interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PacketCounter現在の発信インターフェイスのLocalPC変数の現在の値に設定してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Timestamp Set to the current value of the LocalTS variable of the current outgoing interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
現在の発信インターフェイスのLocalTS変数の現在の値に設定されたタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that the current step may involve byte order conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
現在のステップがバイトオーダー変換を伴うことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Derive a sequence of ESAs, using the procedure defined in Section 5.2, with the current interface&#39;s sequence of CSAs as the input sequence of CSAs, the current time as CT, and &#34;sending&#34; as the direction. Proceed to the next step even if the derived sequence is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.のCSAの入力シーケンスとしてのCSAの現在のインタフェースの配列と、セクション5.2で定義された手順を使用して、CTのような現在の時間のESAのシーケンスを導出し、方向として「送信」。由来の配列が空の場合でも、次のステップに進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Iterate over the derived sequence, using its ordering. For each ESA, add to the packet body (see the note at the end of this section) an HMAC TLV with fields set as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由来の配列を超える5.反復、その順序付けを使用します。各ESAについては、次のように設定されたフィールドを持つパケット本体（このセクションの最後にある注を参照してください）HMAC TLVに追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Type Set to 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
タイプは12に設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Length Set to 2 plus the digest length of HashAlgo of the current ESA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
長さは2に設定してプラス現在のESAのHashAlgoのダイジェスト長。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
KeyID Set to KeyID of the current ESA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
現在のESAの鍵IDに設定しKEYID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Digest Size exactly equal to the digest length of HashAlgo of the current ESA. Pad (see Section 2.2), using the source address of the current packet (see Section 6.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
現在のESAのHashAlgoのダイジェスト長に正確に等しいダイジェストサイズ。パッド（6.1節を参照してください）現在のパケットの送信元アドレスを使用して、（2.2節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
As soon as there are MaxDigestsOut HMAC TLVs added to the current packet body, immediately proceed to the next step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
すぐMaxDigestsOut HMACのTLVは、現在のパケット本体に付加があるので、すぐに次のステップに進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that the current step may involve byte order conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
現在のステップがバイトオーダー変換を伴うことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Increment the &#34;Body length&#34; field value of the current packet header by the total length of TS/PC and HMAC TLVs appended to the current packet body so far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TS / PC及びHMACのTLVの長さの合計によって前記インクリメント現在のパケットヘッダの「身体長さ」フィールドの値は、これまで、現在のパケットの本体に付加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that the current step may involve byte order conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
現在のステップがバイトオーダー変換を伴うことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Make a temporary copy of the current packet.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.現在のパケットの一時的なコピーを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Iterate over the derived sequence again, using the same order and number of elements. For each ESA (and, respectively, for each HMAC TLV recently appended to the current packet body), compute an HMAC result (see Section 2.4), using the temporary copy (not the original packet) as Text, HashAlgo of the current ESA as H, and AuthKeyOctets of the current ESA as K. Write the HMAC result to the Digest field of the current HMAC TLV (see Table 4 in Appendix A) of the current packet (not the copy).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ順序と要素の数を使用して再び誘導された配列上8反復、。 （最近、現在のパケット本体に添付さ各HMAC TLVのためのそれぞれと、）各ESA、HMACの結果を計算するためのテキストとして一時的なコピー（ない元のパケット）を使用して、（2.4節を参照）、現在のESAなどのHashAlgo現在のパケット（コピーではなく）のH、及びK.、現在のHMAC TLVのダイジェストフィールドにHMAC結果を書くように、現在のESAのAuthKeyOctets（付録Aの表4を参照されたいです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. After this point, allow no more changes to the current packet header and body, and consider it ready for sending.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9.この時点の後、現在のパケットのヘッダとボディへのより多くの変更を許可しない、および送信するためには準備ができて考えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that even when the derived sequence of ESAs is empty, the packet is sent anyway, with only a TS/PC TLV appended to its body. Although such a packet would not be authenticated, the presence of the sole TS/PC TLV would indicate authentication key exhaustion to operators of neighbouring Babel speakers. See also Section 7.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ESAの由来の配列が空の場合でも、パケットはその本体に添付さだけTS / PCのTLVで、とにかく送られることに注意してください。このようなパケットが認証されないが、唯一のTS / PC TLVの存在は、隣接バベルスピーカーの事業者に認証キー枯渇を示すことになります。また、セクション7.4を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also note that it is possible to place the authentication-specific TLVs in the packet&#39;s sequence of TLVs in a number of different valid ways so long as there is exactly one TS/PC TLV in the sequence and the ordering of HMAC TLVs relative to each other, as produced in step 5 above, is preserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、正確に一つのTS / PCシーケンスのTLVと互いにHMACのTLVの相対的な順序がある限り、異なる有効ないくつかの方法でのTLVのパケットのシーケンスで認証固有のTLVを配置することが可能であることに注意してください、上記ステップ5で製造され、保存されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, see Figure 2 in Appendix A. The diagrams represent a Babel packet without (D1) and with (D2, D3, D4) authentication-specific TLVs. The optional trailing data block that is present in D1 is preserved in D2, D3, and D4. Indexing (1, 2, ..., n) of the HMAC TLVs means the order in which the sending procedure produced them (and, respectively, the HMAC results). In D2, the added TLVs are appended: the previously existing TLVs are followed by the TS/PC TLV, which is followed by the HMAC TLVs. In D3, the added TLVs are prepended: the TS/PC TLV is the first and is followed by the HMAC TLVs, which are followed by the previously existing TLVs. In D4, the added TLVs are intermixed with the previously existing TLVs and the TS/PC TLV is placed after the HMAC TLVs. All three packets meet the requirements above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、図は、（D1）がなく、（D2、D3、D4）認証固有のTLVとバベルパケットを表す付録Aの図2を参照。 D1に存在する任意後続データブロックがD2、D3、及びD4に保存されています。 HMACのTLVの割出し（1、2、...、n）は（HMACの結果、それぞれ、と）送信手順は、それらを生成する順序を意味します。 D2において、追加のTLVは、添付されている：既存のTLVは、HMACのTLVに続いてTS / PC TLV、が続きます。 D3では、追加のTLVが付加されている：TS / PC TLVが最初であり、既存のTLVが続くHMACのTLVが続きます。 D4では、追加のTLVは、既存のTLVと混合され、TS / PC TLVは、HMACのTLVの後に置かれています。すべての3つのパケットは、上記の要件を満たしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementors SHOULD use appending (D2) for adding the authentication-specific TLVs to the sequence; this is expected to result in more straightforward implementation and troubleshooting in most use cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、配列への認証固有のTLVを追加する（D2）を追加使用する必要があります。これは、ほとんどのユースケースで、より簡単な実装とトラブルシューティングをもたらすことが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Updates to Packet Receiving
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. パケット受信の更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Perform the following authentication-specific processing after an incoming Babel packet is received from the local network stack but before it is acted upon by the Babel protocol instance (see Figure 1 in Appendix A). The final action conceptually depends not only upon the result of the authentication-specific processing but also on the current value of the RxAuthRequired parameter. Immediately after any processing step below accepts or refuses the packet, either deliver the packet to the instance of the original protocol (when the packet is accepted or RxAuthRequired is FALSE) or discard it (when the packet is refused and RxAuthRequired is TRUE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
着信バベルパケットがローカルネットワークスタックから受信された後、次の認証特有の処理を行うが、それは、バベルプロトコルインスタンスが作用する前に（付録Aの図1を参照）。最終的なアクションは、概念的に認証特有の処理の結果にもRxAuthRequiredパラメータの現在の値だけでなく依存します。任意の処理ステップは、以下の、受け入れまたはパケットを拒否した直後に、元のプロトコルのインスタンスにパケットを届ける（パケットが受け入れられるか、RxAuthRequiredがFALSEである）、またはそれを破棄（パケットが拒否された場合にRxAuthRequiredがTRUEである）のいずれか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the current incoming interface&#39;s sequence of CSAs is empty, accept the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.のCSAの現在の着信インターフェイスのシーケンスが空の場合、パケットを受け入れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the current packet does not contain exactly one TS/PC TLV, refuse it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.現在のパケットが正確に一つのTS / PC TLVが含まれていない場合は、それを拒否。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Perform a lookup in the ANM table for an entry having Interface equal to the current incoming interface and Source equal to the source address of the current packet. If such an entry does not exist, immediately proceed to the next step. Otherwise, compare the entry&#39;s LastTS and LastPC field values with the Timestamp and PacketCounter values, respectively, of the TS/PC TLV of the packet. That is, refuse the packet if at least one of the following two conditions is true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.現在の着信インターフェイスと現在のパケットの送信元アドレスに等しい送信元と同じインタフェースを有するエントリのANMテーブルのルックアップを実行します。そのようなエントリが存在しない場合は、すぐに次のステップに進みます。それ以外の場合は、パケットのTS / PC TLVの、それぞれ、タイムスタンプとPacketCounter値でエントリーのLastTSとLastPCフィールドの値を比較します。次の2つの条件のうち少なくともいずれかに該当する場合には、パケットを拒否されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* Timestamp is less than LastTS
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
*タイムスタンプはLastTS未満であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
* Timestamp is equal to LastTS and PacketCounter is not greater than LastPC
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
*タイムスタンプはLastTSに等しく、PacketCounterはLastPCより大きくありません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Note that the current step may involve byte order conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
現在のステップがバイトオーダー変換を伴うことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Derive a sequence of ESAs, using the procedure defined in Section 5.2, with the current interface&#39;s sequence of CSAs as the input sequence of CSAs, current time as CT, and &#34;receiving&#34; as the direction. If the derived sequence is empty, refuse the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.のCSA、CTとして現在時刻の入力シーケンスとしてのCSAの現在のインタフェースの配列と、セクション5.2で定義された手順を使用して、のESAのシーケンスを導出し、方向として「受信」。由来の配列が空の場合、パケットを拒否。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Make a temporary copy of the current packet.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.現在のパケットの一時的なコピーを作成します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Pad (see Section 2.2) every HMAC TLV present in the temporary copy (not the original packet), using the source address of the original packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オリジナルのパケットの送信元アドレスを使用して6パッド（2.2節を参照）一時的なコピー（ない元のパケット）内のすべてのHMAC TLVの存在、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Iterate over all the HMAC TLVs of the original input packet (not the copy), using their order of appearance in the packet. For each HMAC TLV, look up all ESAs in the derived sequence such that 2 plus the digest length of HashAlgo of the ESA is equal to Length of the TLV and KeyID of the ESA is equal to the value of KeyID of the TLV. Iterate over these ESAs in the relative order of their appearance on the full sequence of ESAs. Note that nesting the iterations the opposite way (over ESAs, then over HMAC TLVs) would be wrong.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上7.反復すべての元の入力パケットのHMACのTLV（コピーではなく）、パケット内の出現の順序を使用して。各HMAC TLVのために、ESAのHashAlgoのダイジェスト長さプラス2はESAのTLVとKeyIDをの長さに等しくなるように誘導された配列内のすべてのESAをルックアップするTLVのKeyIDをの値に等しいです。 ESAの全配列に、その外観の相対的な順序でこれらのESAを反復。イテレーションを逆方向をネスト（ESAの上では、その後、HMACのTLVを超える）間違っていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        For each of these ESAs, compute an HMAC result (see
        Section 2.4), using the temporary copy (not the original packet)
        as Text, HashAlgo of the current ESA as H, and AuthKeyOctets of
        the current ESA as K.  If the current HMAC result exactly
        matches the contents of the Digest field of the current HMAC
        TLV, immediately proceed to the next step.  Otherwise, if the
        number of HMAC computations done for the current packet so far
        is equal to MaxDigestsIn, immediately proceed to the next step.
        Otherwise, follow the normal order of iterations.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Note that the current step may involve byte order conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
現在のステップがバイトオーダー変換を伴うことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Refuse the input packet unless there was a matching HMAC result in the previous step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マッチングHMAC結果が前の手順であった場合を除き8入力パケットを拒否する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Modify the ANM table, using the same index as for the entry lookup above, to contain an entry with LastTS set to the value of Timestamp and LastPC set to the value of PacketCounter fields of the TS/PC TLV of the current packet. That is, either add a new ANM table entry or update the existing one, depending on the result of the entry lookup above. Reset the entry&#39;s aging timer to the current value of ANM timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9.タイムスタンプとLastPCの値に設定さLastTSのエントリを含むように、上記のエントリの検索と同じインデックスを使用して、ANMテーブルを変更し、現在のパケットのTS / PC TLVのPacketCounterフィールドの値に設定します。それは、新しいANMテーブルエントリを追加するか、上記のエントリ検索の結果に応じて、既存のものを更新するのいずれか、です。 ANMのタイムアウトの現在の値にエントリのエージングタイマーをリセットします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Note that the current step may involve byte order conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
現在のステップがバイトオーダー変換を伴うことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Accept the input packet.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.入力パケットを受け入れます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before performing the authentication-specific processing above, an implementation SHOULD perform those basic procedures of the original protocol that don&#39;t take any protocol actions on the contents of the packet but that will discard the packet if it is not sufficiently well formed for further processing. Although the exact composition of such procedures belongs to the scope of the original protocol, it seems reasonable to state that a packet SHOULD be discarded early, regardless of whether any authentication-specific processing is due, unless its source address conforms to Section 3.1 of [BABEL] and is not the receiving speaker&#39;s own address (see item (e) of Section 8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記認証特有の処理を行う前に、実装は、パケットの内容に任意のプロトコル・アクションを取らない独自プロトコルのこれらの基本的な手順を実行する必要があり、それは、十分にさらなる処理のために形成されない場合にはパケットを破棄します。このような手順の正確な組成は、元のプロトコルの範囲に属しているが、パケットに関係なく、その送信元アドレスがセクション3.1に準拠していない限り、任意の認証特有の処理が原因であるかどうかの早期廃棄されるべきであることを述べるために妥当と思われます[ BABEL]と受信話し手自身のアドレスではありません（8節の項目（e）を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that RxAuthRequired affects only the final action but not the defined flow of authentication-specific processing. The purpose of this is to preserve authentication-specific processing feedback (such as log messages and event-counter updates), even with RxAuthRequired set to FALSE. This allows an operator to predict the effect of changing RxAuthRequired from FALSE to TRUE during a migration scenario (Section 7.3) implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RxAuthRequired認証特有の処理の定義されたフローだけ最終動作に影響はなく、ことに留意されたいです。この目的はRxAuthRequiredがFALSEに設定されさえして、（例えばログメッセージとイベントカウンタの更新など）の認証特有の処理のフィードバックを保存することです。これは、オペレータが移行シナリオ（セクション7.3）の実装時にfalseからtrueにRxAuthRequiredを変化させる効果を予測することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Authentication-Specific Statistics Maintenance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. 認証固有の統計情報のメンテナンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Babel speaker implementing this mechanism SHOULD maintain a set of counters for the following events, per protocol instance and per interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルインスタンスごとおよびインターフェイスごとに、次のイベントのカウンタのセットを維持する必要があり、この機構を実装バベルスピーカー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. Sending an unauthenticated Babel packet through an interface having an empty sequence of CSAs (Section 5.3 item 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A。 CSA（5.3節項目1）の空の配列を有するインタフェースを介して認証されていないバベルパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. Sending an unauthenticated Babel packet with a TS/PC TLV but without any HMAC TLVs, due to an empty derived sequence of ESAs (Section 5.3 item 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B。原因のESAの空由来の配列（セクション5.3項目4）に、TS / PCのTLVを有するが、任意のHMACのTLVなしで認証されていないバベルパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. Sending an authenticated Babel packet containing both TS/PC and HMAC TLVs (Section 5.3 item 9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C。 TS / PCおよびHMACのTLV（5.3節項目9）の両方を含む、認証バベルパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. Accepting a Babel packet received through an interface having an empty sequence of CSAs (Section 5.4 item 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
D。バベルパケットを受け入れることのCSAの空のシーケンス（5.4アイテム1）を有するインタフェースを介して受信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. Refusing a received Babel packet due to an empty derived sequence of ESAs (Section 5.4 item 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電子。原因のESA（5.4アイテム4）の空由来の配列に受信バベルパケットを拒否する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
f. Refusing a received Babel packet that does not contain exactly one TS/PC TLV (Section 5.4 item 2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F。正確に一つのTS / PC TLV（5.4節の項目2）を含まない受信バベルパケットを拒否。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
g. Refusing a received Babel packet due to the TS/PC TLV failing the ANM table check (Section 5.4 item 3). With possible future extensions in mind, in implementations of this mechanism, this event SHOULD leave out some small amount, per current (Interface, Source, LastTS, LastPC) tuple, of the packets refused due to the Timestamp value being equal to LastTS and the PacketCounter value being equal to LastPC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グラム。 ANMテーブルのチェックを失敗によるTS / PC TLVに受信バベルパケットを拒否（5.4節項目3）。心の中で将来の拡張では、このメカニズムの実装では、このイベントはいくつかの小さな量を除外すべきで、現在（インタフェース、ソース、LastTS、LastPC）タプルごとに、パケットのため、Timestamp値はLastTSとに等しいを拒否PacketCounter値LastPCに等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h. Refusing a received Babel packet missing any HMAC TLVs (Section 5.4 item 8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時間。任意のHMACのTLV（5.4節項目8）を欠落している受信バベルパケットを拒否。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
i. Refusing a received Babel packet due to none of the processed HMAC TLVs passing the ESA check (Section 5.4 item 8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私。 ESAによるチェック（5.4節項目8）を通過する処理HMACのTLVのどれに受信バベルパケットを拒否する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
j. Accepting a received Babel packet having both TS/PC and HMAC TLVs (Section 5.4 item 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
J。 TS / PC及びHMACのTLV（5.4アイテム10）の両方を有する受信バベルパケットを受け入れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
k. Delivery of a refused packet to the instance of the original protocol due to the RxAuthRequired parameter being set to FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
K。 FALSEに設定されRxAuthRequiredパラメータによる独自プロトコルのインスタンスへの拒否パケットの配信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the terms &#34;accepting&#34; and &#34;refusing&#34; are used in the sense of the receiving procedure; that is, &#34;accepting&#34; does not mean a packet delivered to the instance of the original protocol purely because the RxAuthRequired parameter is set to FALSE. Event-counter readings SHOULD be available to the operator at runtime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用語「受け入れ」と受信手続きの意味で使用される「拒否」ことに留意されたいです。つまり、「受け入れる」RxAuthRequiredパラメータがFALSEに設定されている純粋なので、元のプロトコルのインスタンスに送達パケットを意味するものではありません。イベント・カウンタの測定値は、実行時にオペレータに利用可能であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Implementation Notes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.実装の注意事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Source Address Selection for Sending
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 送信のためのソースアドレス選択
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 3.1 of [BABEL] allows for the exchange of protocol datagrams, using IPv4, IPv6, or both. The source address of the datagram is a unicast (link-local in the case of IPv6) address. Within an address family used by a Babel speaker, there may be more than one address eligible for the exchange and assigned to the same network interface. The original specification considers this case out of scope and leaves it up to the speaker&#39;s network stack to select one particular address as the datagram source address, but the sending procedure requires (Section 5.3 item 5) exact knowledge of the packet source address for proper padding of HMAC TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL]のセクション3.1は、IPv4、IPv6の、または両方を使用して、プロトコルデータグラムの交換を可能にします。データグラムの送信元アドレスは、ユニキャスト（リンクローカルIPv6の場合）アドレスです。バベルのスピーカーで使用されるアドレスファミリの中で、交換の対象と同じネットワークインタフェースに割り当てられた複数のアドレスがあるかもしれません。元の仕様では、範囲外この場合を考慮し、データグラムの送信元アドレスとして一つの特定のアドレスを選択するために、話者のネットワークスタックにそれを残すが、送信手順（セクション5.3項目5）適切なパディング用パケットの送信元アドレスの正確な知識を必要としますHMACのTLVの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As long as a network interface has more than one address eligible for the exchange within the same address family, the Babel speaker SHOULD internally choose one of those addresses for Babel packet sending purposes and then indicate this choice to both the sending procedure and the network stack (see Figure 1 in Appendix A). Wherever this requirement cannot be met, this limitation MUST be clearly stated in the system documentation to allow an operator to plan network address management accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークインタフェースが同じアドレスファミリ内の交換のための複数のアドレスの資格を持っている限り、バベルのスピーカーは、内部バベルパケット送信の目的のために、これらのアドレスのいずれかを選択してから送信する手順と、ネットワークスタックの両方にこの選択肢を示すべきです（付録Aで図1を参照）。この要件を満たすことができない限り、この制限は、明らかに、オペレータがそれに応じてネットワークアドレスの管理を計画することを可能にするシステムのマニュアルに記載されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Output Buffer Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 出力バッファの管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An instance of the original protocol will buffer produced TLVs until the buffer becomes full or a delay timer has expired. This is performed independently for each Babel interface, with each buffer sized according to the interface MTU (see Sections 3.1 and 4 of [BABEL]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファがいっぱいになるか、遅延タイマーが満了するまで、元のプロトコルのインスタンスが生成さTLVをバッファリングします。これは、インターフェースのMTUに応じて大き各バッファと、各バベルインターフェイスに対して独立して実行される（[BABEL]のセクション3.1および4を参照されたいです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since TS/PC TLVs, HMAC TLVs, and any other TLVs -- and most likely the TLVs of the original protocol -- share the same packet space (see Figure 2 in Appendix A) and, respectively, the same buffer space, a particular portion of each interface buffer needs to be reserved for one TS/PC TLV and up to MaxDigestsOut HMAC TLVs. The amount (R) of this reserved buffer space is calculated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そして、元のプロトコルの最も可能性が高いのTLV  -   -  TS / PCのTLV、HMACのTLV、及び任意の他のTLVので、それぞれ同じパケット空間（付録Aで図2を参照）と、同一のバッファスペース、特定の共有各インタフェース・バッファの部分は、1つのTS / PCのTLVおよびMaxDigestsOut HMACのTLVまでに予約する必要があります。次のようにこの予約済みバッファスペースの量（R）が計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                    R = St + MaxDigestsOut * Sh
                    R = 8  + MaxDigestsOut * (4 + Lmax)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
St The size of a TS/PC TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セントTS / PC TLVのサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sh The size of an HMAC TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC TLVの大きさをSH。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lmax The maximum possible digest length in octets for a particular interface. It SHOULD be calculated based on the particular interface&#39;s sequence of CSAs but MAY be taken as the maximum digest length supported by a particular implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大可能LMAX特定のインターフェイスのためのオクテットの長さを消化。それのCSAの特定のインターフェイスの配列に基づいて計算されるべきであるが、特定の実装によってサポートされる最大ダイジェスト長さとしてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation allowing for a per-interface value of MaxDigestsOut or Lmax has to account for a different value of R across different interfaces, even interfaces having the same MTU. An implementation allowing for a runtime change to the value of R (due to MaxDigestsOut or Lmax) has to take care of the TLVs already buffered by the time of the change -- specifically, when the value of R increases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDigestsOut又はLmaxとのインターフェースごとの値を可能にする実装も同じMTUを有するインターフェイス、異なるインターフェースを横切るRの異なる値を考慮しなければなりません。具体的には、Rの値が大きくなる - （起因MaxDigestsOut又は値Lmaxまで）Rの値にランタイムの変更を可能にする実装が既に変化の時間でバッファリングのTLVの世話をしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The maximum safe value of the MaxDigestsOut parameter depends on the interface MTU and maximum digest length used. In general, at least 200-300 octets of a Babel packet should always be available to data other than TS/PC and HMAC TLVs. An implementation following the requirements of Section 4 of [BABEL] would send packets of 512 octets or larger. If, for example, the maximum digest length is 64 octets and the MaxDigestsOut value is 4, the value of R would be 280, leaving less than half of a 512-octet packet for any other TLVs. As long as the interface MTU is larger or the digest length is smaller, higher values of MaxDigestsOut can be used safely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MaxDigestsOutパラメータの最大安全値が使用されるインターフェイスMTU最大ダイジェストの長さに依存します。一般的には、バベルパケットの少なくとも200〜300個のオクテットは、常にTS / PCおよびHMACのTLV以外のデータが利用できるようにすべきです。 [BABEL]の第4の要件を以下の実装は、512オクテット以上のパケットを送信することになります。例えば、最大ダイジェストの長さは64個のオクテットであり、MaxDigestsOut値が4である、場合は、Rの値は、他のTLVのために512オクテットのパケットの半分未満を残し、280あろう。限りインタフェースMTUが大きい又はダイジェストの長さが小さいほど、MaxDigestsOutのより高い値は、安全に使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Optimizations of Deriving Procedure for ESAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.  ESAのための導出手順の最適化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following optimizations of the deriving procedure for ESAs can reduce the amount of CPU time consumed by authentication-specific processing, preserving an implementation&#39;s effective behaviour.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ESAのための導出手順の次の最適化は、実装の効果的な行動を維持し、認証特有の処理で消費されるCPU時間の量を減らすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. The most straightforward implementation would treat the deriving procedure as a per-packet action, but since the procedure is deterministic (its output depends on its input only), it is possible to significantly reduce the number of times the procedure is performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A。 、大幅に手続きが行われた回数を削減することができる最も簡単な実装では、パケットごとのアクションとして導出手順を扱っていましたが、手順は決定論的であるので、（その出力はその入力に依存します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       The procedure would obviously return the same result for the same
       input arguments (sequence of CSAs, direction, CT) values.
       However, it is possible to predict when the result will remain
       the same, even for a different input.  That is, when the input
       sequence of CSAs and the direction both remain the same but CT
       changes, the result will remain the same as long as CT&#39;s order on
       the time axis (relative to all critical points of the sequence of
       CSAs) remains unchanged.  Here, the critical points are
       KeyStartAccept and KeyStopAccept (for the receiving direction),
       and KeyStartGenerate and KeyStopGenerate (for the sending
       direction), of all keys of all CSAs of the input sequence.  In
       other words, in this case the result will remain the same as long
       as (1) none of the active keys expire and (2) none of the
       inactive keys enter into operation.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
An implementation optimized in this way would perform the full deriving procedure for a given (interface, direction) pair only after an operator&#39;s change to the interface&#39;s sequence of CSAs or after reaching one of the critical points mentioned above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
このように最適化されたインプリメンテーションのみのCSAのインターフェイスの配列または上記臨界点のいずれかに到達した後、オペレータの変更後所定の（インタフェース、方向）一対の完全な導出手順を実行することになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. Considering that the sending procedure iterates over at most MaxDigestsOut elements of the derived sequence of ESAs (Section 5.3 item 5), there would be little sense, in the case of the sending direction, in returning more than MaxDigestsOut ESAs in the derived sequence. Note that a similar optimization would be relatively difficult in the case of the receiving direction, since the number of ESAs actually used in examining a particular received packet (not to be confused with the number of HMAC computations) depends on additional factors besides just MaxDigestsIn.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B。 ESA（5.3節項目5）の誘導された配列の多くともMaxDigestsOut要素にわたって送信手順の反復は、誘導された配列にMaxDigestsOutのESA以上に戻る際に、送信方向の場合には、ほとんど意味があるであろうことを考慮。実際に特定の受信したパケットを検査に使用されるのESAの数は（HMAC計算の数と混同すべきではない）だけMaxDigestsIn以外に追加の要因に依存するので、同様の最適化は、受信方向の場合には比較的困難であることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Duplication of Security Associations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. セキュリティアソシエーションの複製
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines three data structures as finite sequences: a KeyChain sequence, an interface&#39;s sequence of CSAs, and a sequence of ESAs. There are associated semantics to take into account during implementation, in that the same element can appear multiple times at different positions of the sequence. In particular, none of the CSA structure fields (including HashAlgo, LocalKeyID, and AuthKeyOctets), alone or in a combination, have to be unique within a given CSA, or within a given sequence of CSAs, or within all sequences of CSAs of a Babel speaker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーチェーンシーケンス、のCSAのインタフェースのシーケンス、およびのESAのシーケンス：この仕様は、有限配列のような3つのデータ構造を定義します。同じ要素がシーケンスの異なる位置に複数回表示されることができるで、実装時に考慮すべき関連するセマンティクスがあります。具体的には、単独または組み合わせて、（HashAlgo、LocalKeyID、及びAuthKeyOctets含む）CSA構造体のフィールドのどれが所与CSA内で一意でなければならない、またはのCSAの所与の配列内、またはのCSAのすべての配列内バベルスピーカー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the CSA space defined in this way, for any two authentication keys, their one field (in)equality would not imply another field (in)equality. In other words, it is acceptable to have more than one authentication key with the same LocalKeyID or the same AuthKeyOctets, or both at a time. It is a conscious design decision that CSA semantics allow for duplication of security associations. Consequently, ESA semantics allow for duplication of intermediate ESAs in the sequence until the explicit deduplication (Section 5.2 item 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意の2つの認証キーのために、このように定義されたCSAスペースでは、その一つのフィールド（中）平等は、別のフィールド（中）平等を意味するものではありません。換言すれば、一度に同じLocalKeyID又は同じAuthKeyOctets、またはその両方で複数の認証キーを有することが許容されます。これは、CSAのセマンティクスはセキュリティアソシエーションの重複を可能に配慮した設計上の決定です。したがって、ESAのセマンティクスは、明示的な重複排除（5.2節項目4）までシーケンスにおける中間のESAの複製を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the intentions of this is to define the security association management in a way that allows the addressing of some specifics of Babel as a mesh routing protocol. For example, a system operator configuring a Babel speaker to participate in more than one administrative domain could find each domain using its own authentication key (AuthKeyOctets) under the same LocalKeyID value, e.g., a &#34;well-known&#34; or &#34;default&#34; value like 0 or 1. Since reconfiguring the domains to use distinct LocalKeyID values isn&#39;t always feasible, the multi-domain Babel speaker, using several distinct authentication keys under the same LocalKeyID, would make a valid use case for such duplication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この意図の一つは、メッシュルーティングプロトコルとしてバベルのいくつかの詳細のアドレス指定を可能にするようにセキュリティアソシエーション管理を定義することです。たとえば、複数の管理ドメインに参加するバベルのスピーカーを構成するシステムオペレータは、同じLocalKeyID値の下で独自の認証キー（AuthKeyOctets）を使用して各ドメインを見つけることができる、のような例えば、「既知の」または「デフォルト」値0または1別個LocalKeyID値を使用するようにドメインを再構成することは常に可能ではないので、同じLocalKeyID下でいくつかの異なる認証鍵を用いたマルチドメインバベルスピーカは、そのような複製のために有効なユースケースになるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, if the operator decided in this situation to migrate one of the domains to a different LocalKeyID value in a seamless way, the respective Babel speakers would use the same authentication key (AuthKeyOctets) under two different LocalKeyID values for the time of the transition (see also item (f) of Section 8). This would make a similar use case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペレータは、シームレスな方法で異なるLocalKeyID値にドメインのいずれかに移行するために、このような状況で決定した場合、さらに、それぞれのバベルスピーカー（遷移の時間のための2つの異なるLocalKeyID値の下で同じ認証キー（AuthKeyOctets）を使用します）また、第8の項目（F）を参照してください。これは、同様のユースケースになるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another intention of this design decision is to decouple security association management from authentication key management as much as possible, so that the latter, be it manual keying or a key-management protocol, could be designed and implemented independently (as the respective reasoning made in Section 3.1 of [RIP2-AUTH] still applies). This way, the additional key-management constraints, if any, would remain out of the scope of this authentication mechanism. A similar thinking justifies the LocalKeyID field having a bit length in an ESA structure definition, but not in that of the CSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
後者はで行われ、それぞれの推論としては、手動キーまたはキー管理プロトコル、設計することができること及び（独立に実装されるように、この設計上の決定の別の目的は、可能な限り、認証鍵管理からセキュリティアソシエーションの管理を分離することです[RIP2-AUTH]のセクション3.1はまだ適用されます）。この方法では、追加のキー管理の制約は、もしあれば、この認証メカニズムの範囲外のままとなります。同様の考え方はなく、CSAの点で、ESA構造定義のビット長を有するLocalKeyIDフィールドを正当化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Network Management Aspects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.ネットワークの管理面
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Backward Compatibility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 下位互換性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Support of this mechanism is optional. It does not change the default behaviour of a Babel speaker and causes no compatibility issues with speakers properly implementing the original Babel specification. Given two Babel speakers -- one implementing this mechanism and configured for authenticated exchange (A) and another not implementing it (B) -- these speakers would not distribute routing information unidirectionally, form a routing loop, or experience other protocol logic issues specific purely to the use of this mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムのサポートはオプションです。これはバベルスピーカーのデフォルトの動作を変更し、スピーカーが正しく元バベル仕様の実装には互換性の問題が発生しません。所与2つのバベルスピーカー - このメカニズムを実装する一方と認証交換（A）用に構成し、別のそれ（B）を実装しない - これらのスピーカーは、一方向ルーティング情報を配布しないであろう、ルーティングループを形成する、または経験他のプロトコルロジックの問題特定純粋このメカニズムを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Babel design requires a bidirectional neighbour reachability condition between two given speakers for a successful exchange of routing information. Apparently, neighbour reachability would be unidirectional in the case above. The presence of TS/PC and HMAC TLVs in Babel packets sent by A would be transparent to B, but a lack of authentication data in Babel packets sent by B would make them effectively invisible to the instance of the original protocol of A. Unidirectional links are not specific to the use of this mechanism; they naturally exist on their own and are properly detected and coped with by the original protocol (see Section 3.4.2 of [BABEL]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バベルのデザインは、ルーティング情報の交換が成功するための2つの与えられたスピーカー間の双方向ネイバー到達可能性の条件が必要です。どうやら、ネイバーの到達可能性は、上記の場合には、単方向になります。送信されたバベルパケットでTS / PCおよびHMACのTLVの存在は、Bに対して透過的になりますが、Bによって送信されたバベルパケット内の認証データの欠如はA.単方向リンクの元のプロトコルのインスタンスにそれらを効果的に見えなくなるだろうこのメカニズムの使用に固有のものではありません。彼らは自然に自分の上に存在し、適切に検出され、元のプロトコル（[BABEL]のセクション3.4.2を参照）ことで対処しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Multi-Domain Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. マルチドメイン認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiving procedure treats a packet as authentic as soon as one of its HMAC TLVs passes the check against the derived sequence of ESAs. This allows for packet exchange authenticated with multiple (hash algorithm, authentication key) pairs simultaneously, in combinations as arbitrary as permitted by MaxDigestsIn and MaxDigestsOut.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信手順は、すぐにそのHMACのTLVの一つはのESAの由来の配列に対するチェックを通過すると、本物のようにパケットを処理します。これはMaxDigestsInとMaxDigestsOutによって許可限り、任意の組み合わせで、同時に複数の（ハッシュアルゴリズム、認証鍵）ペアで認証パケット交換を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider three Babel speakers with one interface each, configured with the following CSAs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、次のCSAで構成された一つのインタフェースそれぞれで3つのバベルスピーカーを検討してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o speaker A: (hash algorithm H1; key SK1), (hash algorithm H1; key SK2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OスピーカーA：（ハッシュアルゴリズムH1、鍵SK1）、（ハッシュアルゴリズムH1;キーSK2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o speaker B: (hash algorithm H1; key SK1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OスピーカーB：（ハッシュアルゴリズムH1、鍵SK1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o speaker C: (hash algorithm H1; key SK2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OスピーカーC：（ハッシュアルゴリズムH1;キーSK2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets sent by A would contain two HMAC TLVs each. Packets sent by B and C would contain one HMAC TLV each. A and B would authenticate the exchange between themselves, using H1 and SK1; A and C would use H1 and SK2; B and C would discard each other&#39;s packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Aによって送信されたパケットは、それぞれ2つのHMAC TLVを含んでいるでしょう。 B及びCによって送信されたパケットはそれぞれHMAC TLVを含むであろう。 A及びBは、H1とSK1を使用して、それらの間の交換を認証することになります。 AとCは、H1及びSK2を使用します。 BとCは互いのパケットを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a similar set of speakers configured with different CSAs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なるのCSAで構成されたスピーカーの同様のセットを考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o speaker D: (hash algorithm H2; key SK3), (hash algorithm H3; key SK4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OスピーカーD：（ハッシュアルゴリズムH2;キーSK3）、（ハッシュアルゴリズムH3;キーSK4）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o speaker E: (hash algorithm H2; key SK3), (hash algorithm H4; keys SK5 and SK6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OスピーカーE：（ハッシュアルゴリズムH2;キーSK3）、（ハッシュアルゴリズムH4;キーSK5とSK6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o speaker F: (hash algorithm H3; keys SK4 and SK7), (hash algorithm H5; key SK8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OスピーカF：（ハッシュアルゴリズムH3;キーSK4とSK7）、（ハッシュアルゴリズムH5;キーSK8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets sent by D would contain two HMAC TLVs each. Packets sent by E and F would contain three HMAC TLVs each. D and E would authenticate the exchange between themselves, using H2 and SK3; D and F would use H3 and SK4; E and F would discard each other&#39;s packets. The simultaneous use of H4, SK5, and SK6 by E, as well as the use of SK7, H5, and SK8 by F (for their own purposes), would remain insignificant to D.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dによって送信されたパケットは、それぞれ2つのHMAC TLVを含んでいるでしょう。 EとFによって送信されたパケットは、それぞれ3つのHMAC TLVを含んでいるでしょう。 DとEはH2とSK3を使用して、それらの間で交換を認証します。 DおよびFは、H3とSK4を使用します。 EとFは互いのパケットを破棄します。 EによってH4、SK5、SK6との同時使用、だけでなく、（自分自身の目的のために）FによってSK7、H5、およびSK8の使用は、Dに重要でないままであろう
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An operator implementing multi-domain authentication should keep in mind that values of MaxDigestsIn and MaxDigestsOut may be different both within the same Babel speaker and across different speakers. Since the minimum value of both parameters is 2 (see Sections 3.4 and 3.5), when more than two authentication domains are configured simultaneously it is advisable to confirm that every involved speaker can handle a sufficient number of HMAC results for both sending and receiving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチドメイン認証を実装する作業はMaxDigestsInとMaxDigestsOutの値が同じバベルスピーカー内および各スピーカー間の両方で異なる場合がありますことを心に留めておく必要があります。 、（セクション3.4および3.5を参照）両方のパラメータの最小値は2であるのでつ以上の認証ドメインが同時に設定されている場合、すべての関与スピーカが送信と受信の両方のためのHMAC結果の十分な数を処理できることを確認することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The recommended method of Babel speaker configuration for multi-domain authentication is to not only use a different authentication key for each domain but also a separate CSA for each domain, even when hash algorithms are the same. This allows for fair competition between CSAs and sometimes limits the consequences of a possible misconfiguration to the scope of one CSA. See also item (f) of Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチドメイン認証用バベルスピーカ構成の推奨される方法は、ハッシュアルゴリズムが同じであっても、ドメインごとに異なる認証キーだけでなく、ドメインごとに別々のCSAを使用しないだけです。これは、CSAの間の公正な競争を可能にし、時には1つのCSAの範囲に可能な設定ミスの影響を制限します。また、第8項の項目（F）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Migration to and from Authenticated Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 認証取引所へとからの移行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is common in practice to consider a migration to the authenticated exchange of routing information only after the network has already been deployed and put into active use. Performing the migration in a way without regular traffic interruption is typically demanded, and this specification allows a smooth migration using the RxAuthRequired interface parameter defined in Section 3.1. This measure is similar to the &#34;transition mode&#34; suggested in Section 5 of [OSPF3-AUTH-BIS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、ネットワークが既に展開し、積極的な活用に置かれた後にのみ、ルーティング情報の認証された交換機への移行を検討するために、実際に一般的です。通常のトラフィックを中断することなく、道での移行の実行は、一般的に要求され、そしてこの仕様は、3.1節で定義されたRxAuthRequiredインタフェースパラメータを使用してのスムーズな移行を可能にします。この尺度は、[OSPF3-AUTH-BIS]のセクション5で提案されている「遷移モード」と同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An operator performing the migration needs to arrange configuration changes as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移行を実行するオペレータは、次のように設定変更を配置する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Decide on particular hash algorithm(s) and key(s) to be used.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.特定のハッシュアルゴリズム（複数可）及び使用される鍵（単数または複数）を決定。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Identify all speakers and their involved interfaces that need to be migrated to authenticated exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.すべてのスピーカーと認証されたExchangeに移行する必要が彼らの関与のインターフェイスを識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. For each of the speakers and the interfaces to be reconfigured, first set the RxAuthRequired parameter to FALSE, then configure necessary CSA(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スピーカーとインターフェースのそれぞれについて3を再構成するには、まず、次いで必要CSA（S）を構成FALSEにRxAuthRequiredパラメータを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Examine the speakers to confirm that Babel packets are successfully authenticated according to the configuration (for instance, by examining ANM table entries and authentication-specific statistics; see Figure 1 in Appendix A), and address any discrepancies before proceeding further.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、さらに進む前に、任意の不一致に対処する; 4.バベルパケットが正常（付録Aで図1を参照して、例えば、ANMテーブルエントリと認証固有の統計を調べることによって）構成に従って認証されることを確認するためにスピーカーを調べ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. For each of the speakers and the reconfigured interfaces, set the RxAuthRequired parameter to TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スピーカー及び再構成インターフェースの各々について5は、TRUEにRxAuthRequiredパラメータを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Likewise, temporarily setting RxAuthRequired to FALSE can be used to migrate smoothly from an authenticated packet exchange back to an unauthenticated one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、一時的にFALSEにRxAuthRequired設定認証されていないものに戻って認証パケット交換から円滑に移行するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Handling of Authentication Key Exhaustion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 認証キー枯渇の取扱い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification employs a common concept of multiple authentication keys coexisting for a given interface, with two independent lifetime ranges associated with each key (one for sending and another for receiving). It is typically recommended that the keys be configured using finite lifetimes, adding new keys before the old keys expire. However, it is obviously possible for all keys to expire for a given interface (for sending, receiving, or both). Possible ways of addressing this situation raise their own concerns:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、各キーに関連付けられた2つの独立した寿命の範囲（受信のために送信用と別の）と、特定のインターフェイスのために共存する複数の認証キーの共通の概念を採用しています。通常、古いキーの有効期限が切れる前に新しいキーを追加し、有限の寿命を使用して、キーを構成することをお勧めします。すべてのキーが（送信、受信、または両方のために）特定のインターフェイスのために期限切れになるようにするためしかし、それは明らかに可能です。このような状況に対処する可能性のある方法は、自分の懸念を提起します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Automatic switching to unauthenticated protocol exchange. This behaviour invalidates the initial purposes of authentication and is commonly viewed as unacceptable ([RIP2-AUTH] Section 5.1, [OSPF2-AUTH] Section 3.2, and [OSPF3-AUTH-BIS] Section 3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O自動認証されていないプロトコル交換に切り替えます。この現象は、認証の初期の目的を無効にし、一般的に受け入れられない（[RIP2-AUTH]セクション5.1、[OSPF2-AUTH]セクション3.2、および[OSPF3-AUTH-BIS]セクション3）と見なされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stopping routing information exchange over the interface. This behaviour is likely to impact regular traffic routing and is commonly viewed as &#34;not advisable&#34; ([RIP2-AUTH], [OSPF2-AUTH], and [OSPF3-AUTH]), although [OSPF3-AUTH-BIS] is different in this regard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターフェイス上のルーティング情報の交換を停止O。 [OSPF3-AUTH-BISは]で異なっているが、この現象は、通常のトラフィックのルーティングに影響する可能性があり、一般に &#34;望ましくない&#34; として見られる（[RIP2-AUTH]、[OSPF2-AUTH]、および[OSPF3-AUTH]）この点について。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The use of the &#34;most recently expired&#34; key over its intended lifetime range. This behaviour is recommended for implementation in [RIP2-AUTH], [OSPF2-AUTH], and [OSPF3-AUTH] but not in [OSPF3-AUTH-BIS]. Such use of this key may become a problem, due to an offline cryptographic attack (see item (f) of Section 8) or a compromise of the key. In addition, distinguishing a recently expired key from a key that has never been used may be impossible after a router restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その意図した生涯範囲にわたって、「最近期限切れ」キーの使用O。この動作は、[OSPF3-AUTH-BIS]で、[RIP2-AUTH]での実装を推奨[OSPF2-AUTH]、および[OSPF3-AUTH]が、されていません。このキーのような使用は、オフラインでの暗号攻撃（セクション8の項目（F）を参照）またはキーの妥協点に、問題になることがあります。また、使用されていないキーから最近期限切れの鍵を区別することは、ルータの再起動後にできない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The design of this mechanism prevents automatic switching to unauthenticated exchange and is consistent with similar authentication mechanisms in this regard, but since the best choice between two other options depends on local site policy, this decision is left up to the operator rather than the implementor (in a way resembling the &#34;fail secure&#34; configuration knob described in Section 5.1 of [RIP2-AUTH]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムの設計は、認証されていない交換機への自動切り替えを防止し、この点で類似した認証メカニズムと一致しているが、他の二つの選択肢の間で最良の選択は、ローカルサイトのポリシーに依存するため、この決定は、オペレータではなく、実装者（に任されていますように）RIP2-AUTH]のセクション5.1に記載された「安全な失敗」設定ノブに似ています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the deriving procedure does not allow for any exceptions in the filtering of expired keys (Section 5.2 item 2), the operator can trivially enforce one of the two remaining behaviour options through local key-management procedures. In particular, when using the key over its intended lifetime is preferable to regular traffic disruption, the operator would explicitly leave the old key expiry time open until the new key is added to the router configuration. In the opposite case, the operator would always configure the old key with a finite lifetime and bear associated risks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
導出手順は、期限切れのキー（5.2節項目2）のフィルタリングに例外を許容しないが、オペレータは自明ローカル鍵管理手順を介して、残りの2つの動作オプションのいずれかを適用することができます。具体的には、その意図する寿命にわたってキーを使用している場合は、通常のトラフィックを中断することが好ましい、新しいキーは、ルータの設定に追加されるまで、明示的に開いて、古いキーの有効期限の時間を残して作業。逆の場合には、オペレータは、常に有限の寿命を持つ古いキーを設定し、関連するリスクを負担します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of this mechanism implies requirements common to the use of shared authentication keys, including, but not limited to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムの使用は、以下を含む共有認証キーの使用に共通の要件を意味し、これらに限定されません：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o holding the keys secret,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
秘密鍵を保持して、O、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o including sufficient amounts of random bits into each key,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各キーへのランダムビットの十分な量を含む、O、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o rekeying on a regular basis, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定期的に再入力、およびO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o never reusing a used key for a different purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O異なる目的のために使用されるキーを再利用することはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That said, proper design and implementation of a key-management policy are out of the scope of this work. Many publications on this subject exist and should be used for this purpose (BCP 107 [RFC4107], BCP 132 [RFC4962], and [RFC6039] are suggested as starting points).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いえ、適切な設計とキー管理ポリシーの実装は、この作業の範囲外です。この主題に関する多くの刊行物が存在すると（出発点として示唆されているBCP 107 [RFC4107]、BCP 132 [RFC4962]及び[RFC6039]）は、この目的のために使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible for a network that exercises rollover of authentication keys to experience accidental expiration of all the keys for a network interface, as discussed at greater length in Section 7.4. With that and the guidance of Section 5.1 of [RIP2-AUTH] in mind, in such an event the Babel speaker MUST send a &#34;last key expired&#34; notification to the operator (e.g., via syslog, SNMP, and/or other implementation-specific means), most likely in relation to item (b) of Section 5.5. Also, any actual occurrence of an authentication key expiration MUST cause a security event to be logged by the implementation. The log item MUST include at least a note that the authentication key has expired, the Babel routing protocol instance(s) affected, the network interface(s) affected, the LocalKeyID that is affected, and the current date/time. Operators are encouraged to check such logs as an operational security practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、7.4節でより詳細に論じとして、ネットワーク・インターフェースのためにすべてのキーを誤って有効期限を体験するための認証キーのロールオーバーを行使するネットワークが可能です。このことを念頭に置いて、[RIP2-AUTH]のセクション5.1の指導では、バベルのスピーカーが送らなければなりません、そのような場合に、オペレータに通知を「最後のキーを期限切れ」（例えば、Syslog経由、SNMP、および/または他のインプリメンテーション5.5節の項目との関係（b）の中で最も可能性の高い具体的な手段）、。また、認証キーの有効期限のいずれかの実際の発生は、セキュリティイベントは、実装によってログに記録させなければなりません。ログ項目が認証キーの有効期限が切れていること少なくとも音符を含まなければなりません、バベルルーティングプロトコルインスタンス（複数可）の影響を受け、ネットワークインターフェース（単数または複数）の影響を受け、影響を受けLocalKeyID、現在の日付/時刻。オペレータは、運用上のセキュリティプラクティスとして、このようなログをチェックすることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering particular attacks being in scope or out of scope on one hand and measures taken to protect against particular in-scope attacks on the other, the original Babel protocol and this authentication mechanism are in line with similar datagram-based routing protocols and their respective mechanisms. In particular, the primary concerns addressed are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
範囲内または範囲外の一方及び他方の上の特定のスコープ内の攻撃から保護するための措置である特定の攻撃を考慮すると、元のバベルプロトコルとこの認証メカニズムは、同様のデータグラムベースのルーティングプロトコルとそれらのそれぞれのメカニズムと一致しています。特に、対処主な関心事は、以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. Peer Entity Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A。エンティティ認証ピア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       The Babel speaker authentication mechanism defined herein is
       believed to be as strong as the class itself to which it belongs.
       This specification is built on fundamental concepts implemented
       for authentication of similar routing protocols: per-packet
       authentication, the use of the HMAC construction, and the use of
       shared keys.  Although this design approach does not address all
       possible concerns, it is so far known to be sufficient for most
       practical cases.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. Data Integrity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B。データの整合性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Meaningful parts of a Babel datagram are the contents of the
       Babel packet (in the definition of Section 4.2 of [BABEL]) and
       the source address of the datagram (Section 3.5.3 of [BABEL]).
       This mechanism authenticates both parts, using the HMAC
       construction, so that making any meaningful change to an
       authenticated packet after it has been emitted by the sender
       should be as hard as attacking the HMAC construction itself or
       successfully recovering the authentication key.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note well that any trailing data of the Babel datagram is not meaningful in the scope of the original specification and does not belong to the Babel packet. Integrity of the trailing data is thus not protected by this mechanism. At the same time, although any TLV extra data is also not meaningful in the same scope, its integrity is protected, since this extra data is a part of the Babel packet (see Figure 2 in Appendix A).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
バベルデータグラムの末尾データは元の仕様の範囲に意味がないとバベルパケットに属していないことを十分に注意してください。後続データの整合性は、このように、このメカニズムによって保護されていません。任意TLVエクストラデータも同じ範囲に意味がありませんが、この追加データは、バベルパケット（付録Aで図2を参照）の一部であるので、同時に、その完全性が保護されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. Denial of Service
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C。サービス拒否
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Proper deployment of this mechanism in a Babel network
       significantly increases the efforts required for an attacker to
       feed arbitrary Babel packets into a protocol exchange (with the
       intent of attacking a particular Babel speaker or disrupting the
       exchange of regular traffic in a routing domain).  It also
       protects the neighbour table from being flooded with forged
       speaker entries.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
At the same time, this protection comes with a price of CPU time being spent on HMAC computations. This may be a concern for low-performance CPUs combined with high-speed interfaces, as sometimes seen in embedded systems and hardware routers. The MaxDigestsIn parameter, which is used to limit the maximum amount of CPU time spent on a single received Babel packet, addresses this concern to some extent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
同時に、この保護は、HMAC計算に費やされたCPU時間の価格が付属しています。これは、時々、組み込みシステムとハードウェアのルータに見られる高速インタフェースと組み合わせる低性能のCPUのための懸念であってもよいです。単一受信バベルパケットに費やされたCPU時間の最大量を制限するために使用されるMaxDigestsInパラメータは、ある程度この問題に対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. Reflection Attacks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
D。リフレクション攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Given the approach discussed in item (b), the only potential
       reflection attack on this mechanism could be replaying exact
       copies of Babel packets back to the sender from the same source
       address.  The mitigation in this case is straightforward and is
       discussed in Section 5.4.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following in-scope concern is only partially addressed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のスコープ内の関心は、部分的にしか扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. Replay Attacks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電子。リプレイ攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       This specification establishes a basic replay protection measure
       (see Section 3.6), defines a timeout parameter affecting its
       strength (see Section 3.7), and outlines implementation methods
       also affecting protection strength in several ways (see
       Section 5.1).  The implementor&#39;s choice of the timeout value and
       particular implementation methods may be suboptimal due to, for
       example, insufficient hardware resources of the Babel speaker.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Furthermore, it may be possible that an operator configures the timeout and the methods to address particular local specifics, and this further weakens the protection. An operator concerned about replay attack protection strength should understand these factors and their meaning in a given network segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
また、オペレータがタイムアウトと特定のローカル仕様に対処する方法を構成し、これはさらなる保護を弱めることが可能であってもよいです。リプレイ攻撃防御力を懸念オペレータは、特定のネットワークセグメントにこれらの要因とその意味を理解しておく必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
That said, a particular form of replay attack on this mechanism remains possible anyway. Whether there are two or more network segments using the same CSA and there is an adversary that captures Babel packets on one segment and replays on another (and vice versa, due to the bidirectional reachability requirement for neighbourship), some of the speakers on one such segment will detect the &#34;virtual&#34; neighbours from another and may prefer them for some destinations. This applies even more so as Babel doesn&#39;t require a common pre-configured network prefix between neighbours.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
つまり、このメカニズムのリプレイ攻撃の特定の形態は、とにかく可能のまま、と述べました。スピーカーの一部、1つには、同一のCSAを使用して2つの以上のネットワークセグメントが存在し、（neighbourshipための双方向到達可能性要件に起因し、その逆の）一つのセグメントとリプレイ別上にバベルパケットをキャプチャ敵が存在するか否かセグメントは、別の「仮想」隣人を検出し、いくつかの目的地のためにそれらを好むかもしれません。バベルは、近隣諸国との間の共通事前に構成されたネットワークプレフィックスを必要としないので、これはそれ以上に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
A reliable solution to this particular problem, which Section 4.5 of [RFC7186] discusses as well, is not currently known. It is recommended that the operators use distinct CSAs for distinct network segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
[RFC7186]のセクション4.5は、同様に説明し、この特定の問題に信頼性の高いソリューションは、現在知られていません。事業者が別個のネットワークセグメントに対して個別のCSAを使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following in-scope concerns are not addressed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のスコープ内の懸念に対処されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
f. Offline Cryptographic Attacks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F。オフライン暗号攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       This mechanism is obviously subject to offline cryptographic
       attacks.  As soon as an attacker has obtained a copy of an
       authenticated Babel packet of interest (which gets easier to do
       in wireless networks), he has all of the parameters of the
       authentication-specific processing performed by the sender,
       except for authentication key(s) and the choice of particular
       hash algorithm(s).  Since digest lengths of common hash
       algorithms are well known and can be matched with those seen in
       the packet, the complexity of this attack is essentially that of
       the authentication key attack.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Viewing the cryptographic strength of particular hash algorithms as a concern of its own, the main practical means of resisting offline cryptographic attacks on this mechanism are periodic rekeying and the use of strong keys with a sufficient number of random bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
独自の懸念として、特定のハッシュアルゴリズムの暗号強度を表示し、この機構にオフライン暗号攻撃に抵抗する主な実用的な手段は、定期的なリキーとランダム十分なビット数との強いキーの使用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
It is important to understand that in the case of multiple keys being used within a single interface (for multi-domain authentication or during a key rollover) the strength of the combined configuration would be that of the weakest key, since only one successful HMAC test is required for an authentic packet. Operators concerned about offline cryptographic attacks should enforce the same strength policy for all keys used for a given interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
唯一の成功したHMAC試験ので、（マルチドメイン認証用またはキーロールオーバ時）は、単一のインタフェース内で使用されている複数のキーの場合に合わせた構成の強度が最も弱いキーのものであろうことを理解することが重要です本物のパケットのために必要とされます。オフライン暗号攻撃を懸念オペレータは、特定のインターフェイスのために使用されるすべてのキーの同じ強さのポリシーを適用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that a special pathological case is possible with this mechanism. Whenever two or more authentication keys are configured for a given interface such that all keys share the same AuthKeyOctets and the same HashAlgo, but LocalKeyID modulo 2^16 is different for each key, these keys will not be treated as duplicate (Section 5.2 item 4), but an HMAC result computed for a given packet will be the same for each of these keys. In the case of the sending procedure, this can produce multiple HMAC TLVs with exactly the same value of the Digest field but different values of the KeyID field. In this case, the attacker will see that the keys are the same, even without knowledge of the key itself. The reuse of authentication keys is not the intended use case of this mechanism and should be strongly avoided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
特別な病的な場合は、このメカニズムで可能であることに注意してください。二つ以上の認証鍵は、すべてのキーが同じAuthKeyOctetsと同じHashAlgoを共有するが、モジュロ2 ^ 16は、各キーごとに異なるLocalKeyIDように、所定のインターフェイスのために設定されているときはいつでも、これらのキーは（重複セクション5.2項目4として扱われることはありません）、所与のパケットに対して計算が、HMAC結果は、これらのキーの各々に対して同じです。送信手順の場合、これは正確ダイジェストフィールドの同じ値が、KeyIDをフィールドの異なる値を持つ複数のHMAC TLVを生成することができます。この場合、攻撃者はさらに、キー自体の知識がなくても、キーが同じであることがわかります。認証キーの再利用は、このメカニズムの使用目的の場合ではないと強く避けるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
g. Non-repudiation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グラム。否認防止
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       This specification relies on the use of shared keys.  There is no
       timestamp infrastructure and no key-revocation mechanism defined
       to address the compromise of a shared key.  Establishing the time
       that a particular authentic Babel packet was generated is thus
       not possible.  Proving that a particular Babel speaker had
       actually sent a given authentic packet is also impossible as soon
       as the shared key is claimed compromised.  Even if the shared key
       is not compromised, reliably identifying the speaker that had
       actually sent a given authentic Babel packet is not possible.
       Since any of the speakers sharing a key can impersonate any other
       speaker sharing the same key, it is only possible to prove that
       the speaker belongs to the group sharing the key.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h. Confidentiality Violations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
時間。守秘義務違反
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       The original Babel protocol does not encrypt any of the
       information contained in its packets.  The contents of a Babel
       packet are trivial to decode and thus can reveal network topology
       details.  This mechanism does not improve this situation in any
       way.  Since routing protocol messages are not the only kind of
       information subject to confidentiality concerns, a complete
       solution to this problem is likely to include measures based on
       the channel security model, such as IPsec and Wi-Fi Protected
       Access 2 (WPA2) at the time of this writing.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
i. Key Management
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私。キー管理
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Any authentication key exchange/distribution concerns are out of
       scope.  However, the internal representation of authentication
       keys (see Section 3.8) allows implementations to use such diverse
       key-management techniques as manual configuration, a provisioning
       system, a key-management protocol, or any other means that comply
       with this specification.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
j. Message Deletion
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
J。メッセージの削除
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Any message deletion attacks are out of scope.  Since a datagram
       deleted by an attacker cannot be distinguished from a datagram
       naturally lost in transmission, and since datagram-based routing
       protocols are designed to withstand a certain loss of packets, the currently established practice is treating authentication
       purely as a per-packet function, without any added detection of
       lost packets.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the time of publication of this document, the Babel TLV Types namespace did not have an IANA registry. TLV types 11 and 12 were assigned (see Table 1 in Appendix A) to the TS/PC and HMAC TLV types by Juliusz Chroboczek, designer of the original Babel protocol. Therefore, this document has no IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの公開時点で、バベルTLVタイプの名前空間はIANAレジストリを持っていませんでした。 TLVタイプ11及び12は、TS / PCとはJuliusz Chroboczek、オリジナルバベルプロトコルの設計者によってHMAC TLVタイプに（付録Aの表1参照）を割り当てました。したがって、このドキュメントには、IANAのアクションを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Randall Atkinson and Matthew Fanto for their comprehensive work on [RIP2-AUTH] that initiated a series of publications on routing protocol authentication, including this one. This specification adopts many concepts belonging to the whole series.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この1を含むルーティングプロトコル認証の出版物のシリーズを開始した[RIP2-AUTH]で自分の包括的な仕事のためのランドール・アトキンソンとマシューFantoに感謝します。この仕様は、全シリーズに属する多くの概念を採用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Juliusz Chroboczek, Gabriel Kerneis, and Matthieu Boutier. This document incorporates many technical and editorial corrections based on their feedback. Thanks to all contributors to Babel, because this work would not be possible without the prior works. Thanks to Dominic Mulligan for editorial proofreading of this document. Thanks to Riku Hietamaki for suggesting the test vectors section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Juliusz Chroboczek、ガブリエルKerneis、そしてマシューBoutierに感謝します。この文書では、彼らのフィードバックに基づいて、多くの技術的、編集上の修正が組み込まれています。バベルのすべての貢献のおかげで、この作品は前作品なしには不可能であろうからです。このドキュメントの編集校正のためのドミニク・マリガンに感謝します。テストベクトルのセクションを示唆ためのリクHietamakiに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Joel Halpern, Jim Schaad, Randall Atkinson, and Stephen Farrell for providing (in chronological order) valuable feedback on earlier versions of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの以前のバージョンで（古い順に）貴重なフィードバックを提供するためのジョエル・ハルパーン、ジムSchaad、ランドール・アトキンソン、そしてステファン・ファレルに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Jim Gettys and Dave Taht for developing the CeroWrt wireless router project and collaborating on many integration issues. A practical need for Babel authentication emerged during research based on CeroWrt that eventually became the very first use case of this mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CeroWrt無線ルータのプロジェクトを開発し、多くの統合問題を共同のためのジム・ゲティーズとDave Tahtに感謝します。バベル認証のための実用的な必要性は、最終的には、このメカニズムの非常に最初のユースケースとなりましたCeroWrtに基づいて研究中に現れました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Kunihiro Ishiguro and Paul Jakma for establishing the GNU Zebra and Quagga routing software projects, respectively. Thanks to Werner Koch, the author of Libgcrypt. The very first implementation of this mechanism was made on a base of Quagga and Libgcrypt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それぞれ、GNU ZebraのとのQuaggaルーティングソフトウェアプロジェクトを確立するための国広石黒とポールJakmaに感謝します。ワーナー・コック、あるlibgcryptの作者に感謝します。この機構の非常に最初の実装は、Quaggaのとあるlibgcryptのベースに作られました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 &#34;HMAC：メッセージ認証のための鍵付きハッシュ化&#34;、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4291] Hinden, R. and S. Deering, &#34;IP Version 6 Addressing Architecture&#34;, RFC 4291, February 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4291] HindenとR.とS.デアリング、 &#34;IPバージョン6アドレッシング体系&#34;、RFC 4291、2006年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS-198] National Institute of Standards and Technology, &#34;The Keyed-Hash Message Authentication Code (HMAC)&#34;, FIPS PUB 198-1, July 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FIPS-198]アメリカ国立標準技術研究所、 &#34;鍵付きハッシュメッセージ認証コード（HMAC）&#34;、FIPS PUBの198から1、2008年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL] Chroboczek, J., &#34;The Babel Routing Protocol&#34;, RFC 6126, April 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL] Chroboczek、J.、 &#34;バベルルーティングプロトコル&#34;、RFC 6126、2011年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3315] Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, &#34;Dynamic Host Configuration Protocol for IPv6 (DHCPv6)&#34;, RFC 3315, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3315] Droms、R.、バウンド、J.、フォルツ、B.、レモン、T.、パーキンス、C.、およびM.カーニー、 &#34;IPv6のための動的ホスト構成プロトコル（DHCPv6）&#34;、RFC 3315、2003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3931] Lau, J., Townsley, M., and I. Goyret, &#34;Layer Two Tunneling Protocol - Version 3 (L2TPv3)&#34;, RFC 3931, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3931]ラウ、J.、Townsley、M.、およびI. Goyret、 &#34;レイヤ2トンネリングプロトコル - バージョン3（L2TPv3の）&#34;、RFC 3931、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4030] Stapp, M. and T. Lemon, &#34;The Authentication Suboption for the Dynamic Host Configuration Protocol (DHCP) Relay Agent Option&#34;, RFC 4030, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4030]スタップ、M.とT.レモン、「認証サブオプション動的ホスト構成プロトコル（DHCP）リレーエージェントオプション」、RFC 4030、2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4107] Bellovin, S. and R. Housley, &#34;Guidelines for Cryptographic Key Management&#34;, BCP 107, RFC 4107, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4107] Bellovin氏、S.とR. Housley氏、 &#34;暗号鍵管理のためのガイドライン&#34;、BCP 107、RFC 4107、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4270] Hoffman, P. and B. Schneier, &#34;Attacks on Cryptographic Hashes in Internet Protocols&#34;, RFC 4270, November 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4270]ホフマン、P.とB.シュナイアー、 &#34;インターネットプロトコルで暗号化ハッシュに対する攻撃&#34;、RFC 4270、2005年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302]ケント、S.、 &#34;IP認証ヘッダー&#34;、RFC 4302、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RIP2-AUTH] Atkinson, R. and M. Fanto, &#34;RIPv2 Cryptographic Authentication&#34;, RFC 4822, February 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RIP2-AUTH]アトキンソン、R.とM. Fanto、 &#34;RIPv2の暗号化認証&#34;、RFC 4822、2007年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4962] Housley, R. and B. Aboba, &#34;Guidance for Authentication, Authorization, and Accounting (AAA) Key Management&#34;, BCP 132, RFC 4962, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4962] Housley氏、R。およびB. Aboba、 &#34;認証、許可、アカウンティング（AAA）キー管理のための指針&#34;、BCP 132、RFC 4962、2007年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5176] Chiba, M., Dommety, G., Eklund, M., Mitton, D., and B. Aboba, &#34;Dynamic Authorization Extensions to Remote Authentication Dial In User Service (RADIUS)&#34;, RFC 5176, January 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、RFC 5176、2008年1月[RFC5176]千葉、M.、Dommety、G.、エクランド、M.、ミトン、D.、およびB. Aboba、 &#34;ユーザーサービス（RADIUS）でリモート認証ダイヤルへのダイナミックな承認拡張機能&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISIS-AUTH-A] Li, T. and R. Atkinson, &#34;IS-IS Cryptographic Authentication&#34;, RFC 5304, October 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISIS-AUTH-A]のLi、T.及びR.アトキンソン、 &#34;ISIS暗号化認証&#34;、RFC 5304、2008年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISIS-AUTH-B] Bhatia, M., Manral, V., Li, T., Atkinson, R., White, R., and M. Fanto, &#34;IS-IS Generic Cryptographic Authentication&#34;, RFC 5310, February 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISIS-AUTH-B] Bhatiaは、M.、Manral、V.、李、T.、アトキンソン、R.、ホワイト、R.、およびM. Fanto、 &#34;ISIS汎用暗号化認証&#34;、RFC 5310年2月2009。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OSPF2-AUTH] Bhatia, M., Manral, V., Fanto, M., White, R., Barnes, M., Li, T., and R. Atkinson, &#34;OSPFv2 HMAC-SHA Cryptographic Authentication&#34;, RFC 5709, October 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OSPF2-AUTH] Bhatiaは、M.、Manral、V.、Fanto、M.、ホワイト、R.、バーンズ、M.、李、T.、およびR.アトキンソン、 &#34;OSPFv2のHMAC-SHA暗号化認証&#34;、RFC 5709、2009年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6039] Manral, V., Bhatia, M., Jaeggli, J., and R. White, &#34;Issues with Existing Cryptographic Protection Methods for Routing Protocols&#34;, RFC 6039, October 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6039] Manral、V.、バティア、M.、Jaeggli、J.、およびR.ホワイト、 &#34;ルーティングプロトコルのための既存の暗号化保護方法の問題&#34;、RFC 6039、2010年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6151] Turner, S. and L. Chen, &#34;Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms&#34;, RFC 6151, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6151]ターナー、S.とL.チェン、 &#34;MD5メッセージダイジェストとHMAC-MD5アルゴリズムのための更新されたセキュリティ上の考慮事項&#34;、RFC 6151、2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6194] Polk, T., Chen, L., Turner, S., and P. Hoffman, &#34;Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms&#34;, RFC 6194, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6194]ポーク、T.、陳、L.、ターナー、S.、およびP.ホフマン、 &#34;SHA-0およびSHA-1メッセージダイジェストアルゴリズムのためのセキュリティの考慮事項&#34;、RFC 6194、2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OSPF3-AUTH] Bhatia, M., Manral, V., and A. Lindem, &#34;Supporting Authentication Trailer for OSPFv3&#34;, RFC 6506, February 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OSPF3-AUTH] Bhatiaは、M.、Manral、V.、およびA. Lindem、 &#34;OSPFv3のための支持認証トレーラー&#34;、RFC 6506、2012年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6709] Carpenter, B., Aboba, B., and S. Cheshire, &#34;Design Considerations for Protocol Extensions&#34;, RFC 6709, September 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6709]大工、B.、Aboba、B.、およびS.チェシャー、 &#34;プロトコル拡張のための設計上の考慮事項&#34;、RFC 6709、2012年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL-EXTENSION] Chroboczek, J., &#34;Extension Mechanism for the Babel Routing Protocol&#34;, Work in Progress, June 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BABEL-EXTENSION] Chroboczek、J.、 &#34;バベルルーティングプロトコルのための拡張機構&#34;、進歩、2014年6月に働いています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OSPF3-AUTH-BIS] Bhatia, M., Manral, V., and A. Lindem, &#34;Supporting Authentication Trailer for OSPFv3&#34;, RFC 7166, March 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OSPF3-AUTH-BIS] Bhatiaは、M.、Manral、V.、およびA. Lindem、 &#34;OSPFv3のための支持認証トレーラー&#34;、RFC 7166、2014年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7183] Herberg, U., Dearlove, C., and T. Clausen, &#34;Integrity Protection for the Neighborhood Discovery Protocol (NHDP) and Optimized Link State Routing Protocol Version 2 (OLSRv2)&#34;, RFC 7183, April 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7183] Herberg、U.、Dearlove、C.、およびT.クラウゼン、 &#34;近所Discovery Protocolのための完全性保護（NHDP）と最適化されたリンクステートルーティングプロトコルバージョン2（OLSRv2）&#34;、RFC 7183、2014年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7186] Yi, J., Herberg, U., and T. Clausen, &#34;Security Threats for the Neighborhood Discovery Protocol (NHDP)&#34;, RFC 7186, April 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7186]李、J.、Herberg、U.、およびT. Clausenの、 &#34;近隣探索プロトコル（NHDP）のセキュリティの脅威&#34;、RFC 7186、2014年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Figures and Tables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A.の図表
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-------------------------------------------------------------+
      |              authentication-specific statistics             |
      +-------------------------------------------------------------+
        ^                            |                            ^
        |                            v                            |
        |    +-----------------------------------------------+    |
        |    |                system operator                |    |
        |    +-----------------------------------------------+    |
        |        ^ |      ^ |       ^ |       ^ |      ^ |        |
        |        | v      | |       | |       | |      | v        |
      +---+  +---------+  | |       | |       | |  +---------+  +---+
      |   |-&gt;|   ANM   |  | |       | |       | |  | LocalTS |-&gt;|   |
      | R |&lt;-|  table  |  | |       | |       | |  | LocalPC |&lt;-| T |
      | x |  +---------+  | v       | v       | v  +---------+  | x |
      |   |  +----------------+ +---------+ +----------------+  |   |
      | p |  | MaxDigestsIn   | |         | | MaxDigestsOut  |  | p |
      | r |&lt;-| ANM timeout    | |  CSAs   | |                |-&gt;| r |
      | o |  | RxAuthRequired | |         | |                |  | o |
      | c |  +----------------+ +---------+ +----------------+  | c |
      | e |  +-------------+     |       |     +-------------+  | e |
      | s |  |   Rx ESAs   |     |       |     |   Tx ESAs   |  | s |
      | s |&lt;-| (temporary) |&lt;----+       +----&gt;| (temporary) |-&gt;| s |
      | i |  +-------------+                   +-------------+  | i |
      | n |  +------------------------------+----------------+  | n |
      | g |  |     instance of              | output buffers |=&gt;| g |
      |   |=&gt;|     the original             +----------------+  |   |
      |   |  |     protocol                 | source address |-&gt;|   |
      +---+  +------------------------------+----------------+  +---+
       /\                                            |            ||
       ||                                            v            \/
      +-------------------------------------------------------------+
      |                        network stack                        |
      +-------------------------------------------------------------+
         /\ ||       /\ ||                       /\ ||       /\ ||
         || \/       || \/                       || \/       || \/
      +---------+ +---------+                 +---------+ +---------+
      | speaker | | speaker |       ...       | speaker | | speaker |
      +---------+ +---------+                 +---------+ +---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Flow of control data           : ---&gt;
      Flow of Babel datagrams/packets: ===&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Figure 1: Interaction Diagram
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
図1：相互作用図
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  P
   |&lt;----------------------------&gt;|                                 (D1)
   |                B             |
   |  |&lt;-------------------------&gt;|
   |  |                           |
   +--+-----+-----+...+-----+-----+--+   P: Babel packet
   |H |some |some |   |some |some |T |   H: Babel packet header
   |  |TLV  |TLV  |   |TLV  |TLV  |  |   B: Babel packet body
   |  |     |     |   |     |     |  |   T: optional trailing data block
   +--+-----+-----+...+-----+-----+--+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                               P
   |&lt;-----------------------------------------------------&gt;|        (D2)
   |                             B                         |
   |  |&lt;--------------------------------------------------&gt;|
   |  |                                                    |
   +--+-----+-----+...+-----+-----+------+------+...+------+--+
   |H |some |some |   |some |some |TS/PC |HMAC  |   |HMAC  |T |
   |  |TLV  |TLV  |   |TLV  |TLV  |TLV   |TLV 1 |   |TLV n |  |
   |  |     |     |   |     |     |      |      |   |      |  |
   +--+-----+-----+...+-----+-----+------+------+...+------+--+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                               P
   |&lt;-----------------------------------------------------&gt;|        (D3)
   |                             B                         |
   |  |&lt;--------------------------------------------------&gt;|
   |  |                                                    |
   +--+------+------+...+------+-----+-----+...+-----+-----+--+
   |H |TS/PC |HMAC  |   |HMAC  |some |some |   |some |some |T |
   |  |TLV   |TLV 1 |   |TLV n |TLV  |TLV  |   |TLV  |TLV  |  |
   |  |      |      |   |      |     |     |   |     |     |  |
   +--+------+------+...+------+-----+-----+...+-----+-----+--+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                  P
   |&lt;------------------------------------------------------------&gt;| (D4)
   |                                B                             |
   |  |&lt;---------------------------------------------------------&gt;|
   |  |                                                           |
   +--+-----+------+-----+------+...+-----+------+...+------+-----+--+
   |H |some |HMAC  |some |HMAC  |   |some |HMAC  |   |TS/PC |some |T |
   |  |TLV  |TLV 1 |TLV  |TLV 2 |   |TLV  |TLV n |   |TLV   |TLV  |  |
   |  |     |      |     |      |   |     |      |   |      |     |  |
   +--+-----+------+-----+------+...+-----+------+...+------+-----+--+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Figure 2: Babel Datagram Structure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
図2：バベルデータグラムの構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            +-------+-------------------------+---------------+
            | Value | Name                    | Reference     |
            +-------+-------------------------+---------------+
            |     0 | Pad1                    | [BABEL]       |
            |     1 | PadN                    | [BABEL]       |
            |     2 | Acknowledgement Request | [BABEL]       |
            |     3 | Acknowledgement         | [BABEL]       |
            |     4 | Hello                   | [BABEL]       |
            |     5 | IHU                     | [BABEL]       |
            |     6 | Router-Id               | [BABEL]       |
            |     7 | Next Hop                | [BABEL]       |
            |     8 | Update                  | [BABEL]       |
            |     9 | Route Request           | [BABEL]       |
            |    10 | Seqno Request           | [BABEL]       |
            |    11 | TS/PC                   | this document |
            |    12 | HMAC                    | this document |
            +-------+-------------------------+---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Table 1: Babel TLV Types 0 through 12
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
表1：バベルTLVタイプ12 0〜
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    +--------------+-----------------------------+-------------------+
    | Packet field | Packet octets (hexadecimal) | Meaning (decimal) |
    +--------------+-----------------------------+-------------------+
    | Magic        | 2a                          | 42                |
    | Version      | 02                          | version 2         |
    | Body length  | 00:14                       | 20 octets         |
    | [TLV] Type   | 04                          | 4 (Hello)         |
    | [TLV] Length | 06                          | 6 octets          |
    | Reserved     | 00:00                       | no meaning        |
    | Seqno        | 09:25                       | 2341              |
    | Interval     | 01:90                       | 400 (4.00 s)      |
    | [TLV] Type   | 08                          | 8 (Update)        |
    | [TLV] Length | 0a                          | 10 octets         |
    | AE           | 00                          | 0 (wildcard)      |
    | Flags        | 40                          | default router-id |
    | Plen         | 00                          | 0 bits            |
    | Omitted      | 00                          | 0 bits            |
    | Interval     | ff:ff                       | infinity          |
    | Seqno        | 68:21                       | 26657             |
    | Metric       | ff:ff                       | infinity          |
    +--------------+-----------------------------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Table 2: A Babel Packet without Authentication TLVs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
テーブル2：認証のTLVなしにバベルパケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------+-------------------------------+-------------------+
   | Packet field  | Packet octets (hexadecimal)   | Meaning (decimal) |
   +---------------+-------------------------------+-------------------+
   | Magic         | 2a                            | 42                |
   | Version       | 02                            | version 2         |
   | Body length   | 00:4c                         | 76 octets         |
   | [TLV] Type    | 04                            | 4 (Hello)         |
   | [TLV] Length  | 06                            | 6 octets          |
   | Reserved      | 00:00                         | no meaning        |
   | Seqno         | 09:25                         | 2341              |
   | Interval      | 01:90                         | 400 (4.00 s)      |
   | [TLV] Type    | 08                            | 8 (Update)        |
   | [TLV] Length  | 0a                            | 10 octets         |
   | AE            | 00                            | 0 (wildcard)      |
   | Flags         | 40                            | default router-id |
   | Plen          | 00                            | 0 bits            |
   | Omitted       | 00                            | 0 bits            |
   | Interval      | ff:ff                         | infinity          |
   | Seqno         | 68:21                         | 26657             |
   | Metric        | ff:ff                         | infinity          |
   | [TLV] Type    | 0b                            | 11 (TS/PC)        |
   | [TLV] Length  | 06                            | 6 octets          |
   | PacketCounter | 00:01                         | 1                 |
   | Timestamp     | 52:1d:7e:8b                   | 1377664651        |
   | [TLV] Type    | 0c                            | 12 (HMAC)         |
   | [TLV] Length  | 16                            | 22 octets         |
   | KeyID         | 00:c8                         | 200               |
   | Digest        | fe:80:00:00:00:00:00:00:0a:11 | padding           |
   |               | 96:ff:fe:1c:10:c8:00:00:00:00 |                   |
   | [TLV] Type    | 0c                            | 12 (HMAC)         |
   | [TLV] Length  | 16                            | 22 octets         |
   | KeyID         | 00:64                         | 100               |
   | Digest        | fe:80:00:00:00:00:00:00:0a:11 | padding           |
   |               | 96:ff:fe:1c:10:c8:00:00:00:00 |                   |
   +---------------+-------------------------------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 3: A Babel Packet with Each HMAC TLV Padded Using IPv6 Address fe80::0a11:96ff:fe1c:10c8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表3：96ff：fe1c：10c8のIPv6アドレスFE80 :: 0a11を使用して、各HMAC TLVパッド入りでバベルパケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------+-------------------------------+-------------------+
   | Packet field  | Packet octets (hexadecimal)   | Meaning (decimal) |
   +---------------+-------------------------------+-------------------+
   | Magic         | 2a                            | 42                |
   | Version       | 02                            | version 2         |
   | Body length   | 00:4c                         | 76 octets         |
   | [TLV] Type    | 04                            | 4 (Hello)         |
   | [TLV] Length  | 06                            | 6 octets          |
   | Reserved      | 00:00                         | no meaning        |
   | Seqno         | 09:25                         | 2341              |
   | Interval      | 01:90                         | 400 (4.00 s)      |
   | [TLV] Type    | 08                            | 8 (Update)        |
   | [TLV] Length  | 0a                            | 10 octets         |
   | AE            | 00                            | 0 (wildcard)      |
   | Flags         | 40                            | default router-id |
   | Plen          | 00                            | 0 bits            |
   | Omitted       | 00                            | 0 bits            |
   | Interval      | ff:ff                         | infinity          |
   | Seqno         | 68:21                         | 26657             |
   | Metric        | ff:ff                         | infinity          |
   | [TLV] Type    | 0b                            | 11 (TS/PC)        |
   | [TLV] Length  | 06                            | 6 octets          |
   | PacketCounter | 00:01                         | 1                 |
   | Timestamp     | 52:1d:7e:8b                   | 1377664651        |
   | [TLV] Type    | 0c                            | 12 (HMAC)         |
   | [TLV] Length  | 16                            | 22 octets         |
   | KeyID         | 00:c8                         | 200               |
   | Digest        | c6:f1:06:13:30:3c:fa:f3:eb:5d | HMAC result       |
   |               | 60:3a:ed:fd:06:55:83:f7:ee:79 |                   |
   | [TLV] Type    | 0c                            | 12 (HMAC)         |
   | [TLV] Length  | 16                            | 22 octets         |
   | KeyID         | 00:64                         | 100               |
   | Digest        | df:32:16:5e:d8:63:16:e5:a6:4d | HMAC result       |
   |               | c7:73:e0:b5:22:82:ce:fe:e2:3c |                   |
   +---------------+-------------------------------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 4: A Babel Packet with Each HMAC TLV Containing an HMAC Result
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表4：HMACの結果を含む各HMAC TLVとバベルパケット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix B. Test Vectors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録B.テストベクトル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The test vectors below may be used to verify the correctness of some procedures performed by an implementation of this mechanism, namely:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下テストベクトル、すなわち、このメカニズムの実装によって実行されるいくつかの手順の正当性を検証するために使用されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o appending TS/PC and HMAC TLVs to the Babel packet body,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バベルパケット本体にTS / PCとHMAC TLVを追加し、O、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o padding the HMAC TLV(s),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC TLV（単数または複数）をパディングO、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o computation of the HMAC result(s), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC結果（単数または複数）のO計算、及び
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o placement of the result(s) in the TLV(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLV（S）における結果（単数または複数）のO配置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This verification isn&#39;t exhaustive. There are other important implementation aspects that would require testing methods of their own.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この検証は網羅的なものではありません。自分自身の試験方法を必要とする他の重要なインプリメンテーションの側面があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The test vectors were produced as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにテストベクトルを作製しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A Babel speaker with a network interface with IPv6 link-local address fe80::0a11:96ff:fe1c:10c8 was configured to use two CSAs for the interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6リンクローカルアドレスFE80 :: 0a11とのネットワークインタフェース1. Aバベルスピーカー：96ff：fe1c：10c8は、インタフェースのための2つのCSAを使用するように構成されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       *  CSA1={HashAlgo=RIPEMD-160, KeyChain={{LocalKeyID=200,
          AuthKeyOctets=Key26}}}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* CSA2={HashAlgo=SHA-1, KeyChain={{LocalKeyId=100, AuthKeyOctets=Key70}}}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* CSA2 = {HashAlgo = SHA-1キーチェーン= {{LocalKeyId = 100、AuthKeyOctets = Key70}}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The authentication keys above are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
上記認証キーは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Key26 in ASCII:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* ASCIIでKey26：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
ABCDEFGHIJKLMNOPQRSTUVWXYZ
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
ABCDEFGHIJKLMNOPQRSTUVWXYZ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Key26 in hexadecimal:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 16進数でKey26：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
41:42:43:44:45:46:47:48:49:4a:4b:4c:4d:4e:4f:50 51:52:53:54:55:56:57:58:59:5a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
41：42：NF：HH：45：CHSH：chsht：48：chya：チャ：BW：chts：CHD：その：PRS：50 51：52：53：54：55：56：57：58：59：5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Key70 in ASCII:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* ASCIIでKey70：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
This=key=is=exactly=70=octets=long.=ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
これは、キー= = =で正確に= 70 =オクテット=長い。= ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Key70 in hexadecimal:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 16進数でKey70：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
54:68:69:73:3d:6b:65:79:3d:69:73:3d:65:78:61:63 74:6c:79:3d:37:30:3d:6f:63:74:65:74:73:3d:6c:6f 6e:67:2e:3d:41:42:43:44:45:46:47:48:49:4a:4b:4c 4d:4e:4f:50:51:52:53:54:55:56:57:58:59:5a:30:31 32:33:34:35:36:37
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
54：68：69：73：3D：6B：65：79：3D：69：73：3D：65：78：61：63 74：6C：79：3D：37：30：3D：6F：63：74 ：65：74：73：3D：6C：6Fの6E：67：2E：3D：41：42：43：44：45：46：47：48：49：4A：図4b：4cは4D：4E：4F：50 ：51：52：53：54：55：56：57：58：59：5A：30：31 32：33：34：35：36：37
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The length of each key was picked to relate (using the terms listed in Section 2.4) to the properties of its respective hash algorithm as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
各キーの長さは、以下のようにそれぞれのハッシュアルゴリズムの特性（2.4節に記載されている用語を使用して）関連付けるために選ばれました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* the digest length (L) of both RIPEMD-160 and SHA-1 is 20 octets,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* RIPEMD-160およびSHA-1の両方のダイジェスト長さ（L）は、20オクテットであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* the internal block size (B) of both RIPEMD-160 and SHA-1 is 64 octets,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* RIPEMD-160およびSHA-1の両方の内部ブロックサイズ（B）は、64オクテットであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* the length of Key26 (26) is greater than L but less than B, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Key26（26）の長さがLより大きくB以下である、及び
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* the length of Key70 (70) is greater than B (and thus greater than L).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Key70（70）の長さBよりも（したがって、より大きいLより）大きいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
KeyStartAccept, KeyStopAccept, KeyStartGenerate, and KeyStopGenerate were set to make both authentication keys valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
KeyStartAccept、KeyStopAccept、KeyStartGenerate、およびKeyStopGenerateは、両方の認証キーが有効にするために設定しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The instance of the original protocol of the speaker produced a Babel packet (PktO) to be sent from the interface. Table 2 provides a decoding of PktO, the contents of which are below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.スピーカーの独自プロトコルのインスタンスは、インタフェースから送信されるバベルパケット（PktO）を生成しました。表2は、PktOの復号化を提供する、その内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       2a:02:00:14:04:06:00:00:09:25:01:90:08:0a:00:40
       00:00:ff:ff:68:21:ff:ff
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The authentication mechanism appended one TS/PC TLV and two HMAC TLVs to the packet body, updated the &#34;Body length&#34; packet header field, and padded the Digest field of the HMAC TLVs, using the link-local IPv6 address of the interface and the necessary amount of zeroes. Table 3 provides a decoding of the resulting temporary packet (PktT), the contents of which are below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.認証機構「は、身体の長さ」パケットヘッダフィールドを更新し、パケットボディ1つのTS / PCのTLV二HMAC TLVを添付し、インターフェイスのリンクローカルIPv6アドレスを使用して、HMACのTLVのダイジェストフィールドを埋めそして、ゼロの必要量。表3は、得られた仮のパケット（PktT）の復号化を提供する、の内容は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       2a:02:00:4c:04:06:00:00:09:25:01:90:08:0a:00:40
       00:00:ff:ff:68:21:ff:ff:0b:06:00:01:52:1d:7e:8b
       0c:16:00:c8:fe:80:00:00:00:00:00:00:0a:11:96:ff
       fe:1c:10:c8:00:00:00:00:0c:16:00:64:fe:80:00:00
       00:00:00:00:0a:11:96:ff:fe:1c:10:c8:00:00:00:00
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The authentication mechanism produced two HMAC results, performing the computations as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.認証メカニズムは次のように計算を実行する、2つのHMACの結果が得られました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* For H=RIPEMD-160, K=Key26, and Text=PktT, the HMAC result is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*についてH = RIPEMD-160、K = Key26、テキスト= PktT、HMAC結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
c6:f1:06:13:30:3c:fa:f3:eb:5d:60:3a:ed:fd:06:55 83:f7:ee:79
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Shatt：P午前1時06分13秒：30：巣：中：効果：イッブ：頬：60：アモス：として：解像度：06：G場所：審査：A：右
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* For H=SHA-1, K=Key70, and Text=PktT, the HMAC result is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*についてH = SHA-1、K = Key70、テキスト= PktT、HMAC結果です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
df:32:16:5e:d8:63:16:e5:a6:4d:c7:73:e0:b5:22:82 ce:fe:e2:3c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
デイブ：32：16：X：リング：63：16：ブラザー：フレームワーク：4 D：のKh：73：J 0：潮吹き：22：光Q：で：DONC：ネスト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. The authentication mechanism placed each HMAC result into its respective HMAC TLV, producing the final authenticated Babel packet (PktA), which was eventually sent from the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前記認証メカニズムは、最終的にインターフェイスから送信された最終的な認証バベルパケット（PktA）を生成し、そのそれぞれのHMAC TLVに各HMAC結果を置きました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Table 4 provides a decoding of PktA, the contents of which are
       below:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2a:02:00:4c:04:06:00:00:09:25:01:90:08:0a:00:40 00:00:ff:ff:68:21:ff:ff:0b:06:00:01:52:1d:7e:8b 0c:16:00:c8:c6:f1:06:13:30:3c:fa:f3:eb:5d:60:3a ed:fd:06:55:83:f7:ee:79:0c:16:00:64:df:32:16:5e d8:63:16:e5:a6:4d:c7:73:e0:b5:22:82:ce:fe:e2:3c
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
図2a：02：00：4C：04：06：00：00：09：25：01：90：08：0A：00：40 00：00：FF：FF：68：21：FF：FF：0B：06 ：00：52：01 1D：7E：8B 0C：00：16：C8：C6：F1：06：13：30：3C：FA：F3：EB：5D：60：3（a）のED：FD：55：06 ：83：F7：EE：79：0C：16：00：64：DF：32：16：5EのD8：63：16：E5：A6：4D：C7：73：E0：B5：22：82：CE： FE：E2：図3c
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interpretation of this process is to be done differently for the sending and receiving directions (see Figure 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このプロセスの解釈は、送受信方向（図1参照）に対して異なる行われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the sending direction, given a Babel speaker configured using the IPv6 address and the sequence of CSAs as described above, the implementation SHOULD (see notes in Section 5.3) produce exactly the temporary packet PktT if the original protocol instance produces exactly the packet PktO to be sent from the interface. If the temporary packet exactly matches PktT, the HMAC results computed afterwards MUST exactly match the respective results above, and the final authenticated packet MUST exactly match PktA above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信方向のために、上記のようにバベルスピーカーは、IPv6アドレスとのCSAのシーケンスを使用して設定された所定の実装（セクション5.3のメモを参照）SHOULD元のプロトコルインスタンスが正確にパケットPktOを生成する場合、正確に一時的なパケットPktTを生成インターフェイスから送信され。一時的なパケットが正確にPktTと一致した場合、その後の計算HMAC結果は正確に上記のそれぞれの結果と一致しなければならない、そして最終的に認証されたパケットは、まさに上記のPktAと一致しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the receiving direction, given a Babel speaker configured using the sequence of CSAs as described above (but a different IPv6 address), the implementation MUST (assuming that the TS/PC check didn&#39;t fail) produce exactly the temporary packet PktT above if its network stack receives through the interface exactly the packet PktA above from the source IPv6 address above. The first HMAC result computed afterwards MUST match the first result above. The receiving procedure doesn&#39;t compute the second HMAC result in this case, but if the implementor decides to compute it anyway for verification purposes, it MUST exactly match the second result above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バベルスピーカは、上述したようのCSAの配列を使用して構成（異なるIPv6アドレス）指定された受信方向については、実装は（TS / PCチェックが失敗しなかったと仮定して）必要がある場合、上記正確一時パケットPktTを生成そのネットワークスタックは、上記送信元IPv6アドレスから上記正確パケットPktAインターフェースを介して受信します。その後、計算された最初のHMAC結果は、前述の第1の結果と一致しなければなりません。受信手順は、この場合、第2のHMAC結果を計算しませんが、実装は、検証目的のためにとにかくそれを計算することを決定した場合、それは正確に上記の2番目の結果と一致しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Denis Ovsienko Yandex 16, Leo Tolstoy St. Moscow 119021 Russia
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デニスOvsienko Yandexの16、トルストイセントモスクワ119021ロシア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: infrastation@yandex.ru
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：infrastation@yandex.ru
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
