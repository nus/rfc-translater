<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 5246 - The Transport Layer Security (TLS) Protocol Version 1.2 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">5246</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc5246">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 5246 - The Transport Layer Security (TLS) Protocol Version 1.2 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc5246">
              https://tools.ietf.org/html/rfc5246
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 5246 - トランスポート層セキュリティ（TLS）プロトコルバージョン1.2</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                          T. Dierks
Request for Comments: 5246                                   Independent
Obsoletes: 3268, 4346, 4366                                  E. Rescorla
Updates: 4492                                                 RTFM, Inc.
Category: Standards Track                                    August 2008
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              The Transport Layer Security (TLS) Protocol
                              Version 1.2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications security over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、トランスポート層セキュリティ（TLS）プロトコルのバージョン1.2を指定します。 TLSプロトコルは、インターネット上の通信のセキュリティを提供します。プロトコルは、クライアント/サーバアプリケーションは、盗聴、改ざん、またはメッセージ偽造を防ぐために設計された方法で通信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
      1.1. Requirements Terminology ...................................5
      1.2. Major Differences from TLS 1.1 .............................5
   2. Goals ...........................................................6
   3. Goals of This Document ..........................................7
   4. Presentation Language ...........................................7
      4.1. Basic Block Size ...........................................7
      4.2. Miscellaneous ..............................................8
      4.3. Vectors ....................................................8
      4.4. Numbers ....................................................9
      4.5. Enumerateds ................................................9
      4.6. Constructed Types .........................................10
           4.6.1. Variants ...........................................10
      4.7. Cryptographic Attributes ..................................12
      4.8. Constants .................................................14
   5. HMAC and the Pseudorandom Function .............................14
   6. The TLS Record Protocol ........................................15
      6.1. Connection States .........................................16
      6.2. Record Layer ..............................................19
           6.2.1. Fragmentation ......................................19
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           6.2.2. Record Compression and Decompression ...............20
           6.2.3. Record Payload Protection ..........................21
                  6.2.3.1. Null or Standard Stream Cipher ............22
                  6.2.3.2. CBC Block Cipher ..........................22
                  6.2.3.3. AEAD Ciphers ..............................24
      6.3. Key Calculation ...........................................25
   7. The TLS Handshaking Protocols ..................................26
      7.1. Change Cipher Spec Protocol ...............................27
      7.2. Alert Protocol ............................................28
           7.2.1. Closure Alerts .....................................29
           7.2.2. Error Alerts .......................................30
      7.3. Handshake Protocol Overview ...............................33
      7.4. Handshake Protocol ........................................37
           7.4.1. Hello Messages .....................................38
                  7.4.1.1. Hello Request .............................38
                  7.4.1.2. Client Hello ..............................39
                  7.4.1.3. Server Hello ..............................42
                  7.4.1.4. Hello Extensions ..........................44
                           7.4.1.4.1. Signature Algorithms ...........45
           7.4.2. Server Certificate .................................47
           7.4.3. Server Key Exchange Message ........................50
           7.4.4. Certificate Request ................................53
           7.4.5. Server Hello Done ..................................55
           7.4.6. Client Certificate .................................55
           7.4.7. Client Key Exchange Message ........................57
                  7.4.7.1. RSA-Encrypted Premaster Secret Message ....58
                  7.4.7.2. Client Diffie-Hellman Public Value ........61
           7.4.8. Certificate Verify .................................62
           7.4.9. Finished ...........................................63
   8. Cryptographic Computations .....................................64
      8.1. Computing the Master Secret ...............................64
           8.1.1. RSA ................................................65
           8.1.2. Diffie-Hellman .....................................65
   9. Mandatory Cipher Suites ........................................65
   10. Application Data Protocol .....................................65
   11. Security Considerations .......................................65
   12. IANA Considerations ...........................................65
   Appendix A. Protocol Data Structures and Constant Values ..........68
      A.1. Record Layer ..............................................68
      A.2. Change Cipher Specs Message ...............................69
      A.3. Alert Messages ............................................69
      A.4. Handshake Protocol ........................................70
           A.4.1. Hello Messages .....................................71
           A.4.2. Server Authentication and Key Exchange Messages ....72
           A.4.3. Client Authentication and Key Exchange Messages ....74
           A.4.4. Handshake Finalization Message .....................74
      A.5. The Cipher Suite ..........................................75
      A.6. The Security Parameters ...................................77
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      A.7. Changes to RFC 4492 .......................................78
   Appendix B. Glossary ..............................................78
   Appendix C. Cipher Suite Definitions ..............................83
   Appendix D. Implementation Notes ..................................85
      D.1. Random Number Generation and Seeding ......................85
      D.2. Certificates and Authentication ...........................85
      D.3. Cipher Suites .............................................85
      D.4. Implementation Pitfalls ...................................85
   Appendix E. Backward Compatibility ................................87
      E.1. Compatibility with TLS 1.0/1.1 and SSL 3.0 ................87
      E.2. Compatibility with SSL 2.0 ................................88
      E.3. Avoiding Man-in-the-Middle Version Rollback ...............90
   Appendix F. Security Analysis .....................................91
      F.1. Handshake Protocol ........................................91
           F.1.1. Authentication and Key Exchange ....................91
                  F.1.1.1. Anonymous Key Exchange ....................91
                  F.1.1.2. RSA Key Exchange and Authentication .......92
                  F.1.1.3. Diffie-Hellman Key Exchange with
                           Authentication ............................92
           F.1.2. Version Rollback Attacks ...........................93
           F.1.3. Detecting Attacks Against the Handshake Protocol ...94
           F.1.4. Resuming Sessions ..................................94
      F.2. Protecting Application Data ...............................94
      F.3. Explicit IVs ..............................................95
      F.4. Security of Composite Cipher Modes ........................95
      F.5. Denial of Service .........................................96
      F.6. Final Notes ...............................................96
   Normative References ..............................................97
   Informative References ............................................98
   Working Group Information ........................................101
   Contributors .....................................................101
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary goal of the TLS protocol is to provide privacy and data integrity between two communicating applications. The protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP [TCP]), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSプロトコルの主な目的は、2つの通信アプリケーション間のプライバシーとデータの整合性を提供することです。 TLSレコードプロトコルとTLSハンドシェイクプロトコル：プロトコルは二つの層から構成されています。最下位レベルでは、いくつかの信頼性の高いトランスポートプロトコル（例えば、TCP [TCP]）の上に積層、TLSレコード・プロトコルです。 TLSレコードプロトコルは、2つの基本的な性質を持っている接続のセキュリティを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The connection is private. Symmetric cryptography is used for data encryption (e.g., AES [AES], RC4 [SCH], etc.). The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another protocol (such as the TLS Handshake Protocol). The Record Protocol can also be used without encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 接続はプライベートです。対称暗号は、データの暗号化（例えば、AES [AES]、RC4 [SCH]、等）のために使用されます。この対称暗号化のための鍵は、接続ごとに固有に生成され、（例えば、TLSハンドシェイクプロトコルのような）別のプロトコルによって交渉秘密に基づいています。レコードプロトコルは、暗号化せずに使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The connection is reliable. Message transport includes a message integrity check using a keyed MAC. Secure hash functions (e.g., SHA-1, etc.) are used for MAC computations. The Record Protocol can operate without a MAC, but is generally only used in this mode while another protocol is using the Record Protocol as a transport for negotiating security parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 接続が信頼性があります。メッセージトランスポートは、鍵付きMACを使用して、メッセージの整合性チェックが含まれています。セキュアハッシュ関数（例えば、SHA-1など）はMAC計算のために使用されます。レコードプロトコルは、MACなしで動作することができるが、他のプロトコルは、セキュリティパラメータを交渉するためのトランスポートとしてレコードプロトコルを使用している間、一般的にこのモードでのみ使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Record Protocol is used for encapsulation of various higher-level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSレコードプロトコルは、様々な上位レベルのプロトコルのカプセル化に使用されます。そのようなカプセル化されたプロトコル、TLSハンドシェイクプロトコルは、サーバーとクライアントが互いを認証し、アプリケーションプロトコルは、データの最初のバイトを送信または受信する前に、暗号化アルゴリズムと暗号鍵を交渉することを可能にします。 TLSハンドシェイクプロトコルは、3つの基本的な性質を持っている接続のセキュリティを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The peer&#39;s identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA [RSA], DSA [DSS], etc.). This authentication can be made optional, but is generally required for at least one of the peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - ピアのアイデンティティは、非対称、または公開鍵暗号（たとえば、RSA [RSA]、DSA [DSS]など）を使用して認証することができます。この認証はオプションで行うことができますが、一般的にピアの少なくとも一方のために必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 共有秘密の交渉は安全である：交渉さの秘密は、盗聴者に利用できない、と任意の認証済みの接続のために秘密であっても、接続の途中で自分自身を配置することができ、攻撃者により、得ることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 交渉は信頼性がある：なし攻撃者は、通信の当事者によって検出されることなく交渉コミュニケーションを変更できません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One advantage of TLS is that it is application protocol independent. Higher-level protocols can layer on top of the TLS protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left to the judgment of the designers and implementors of protocols that run on top of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSの利点の一つは、それが独立したアプリケーションプロトコルであることです。上位レベルのプロトコルが透過的TLSプロトコルの上の層ができます。 TLS標準は、しかし、プロトコルはTLSを使用してセキュリティを追加する方法を指定しません。 TLSハンドシェイクとどのように交換された認証証明書を解釈するを開始する方法についての決定はTLSの上で動作するプロトコルの設計者と実装者の判断に委ねられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 要件の用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [REQ].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますRFC 2119 [REQ]で説明されるように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Major Differences from TLS 1.1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.  TLS 1.1からの主な違い
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a revision of the TLS 1.1 [TLS1.1] protocol which contains improved flexibility, particularly for negotiation of cryptographic algorithms. The major changes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、特に暗号アルゴリズムのネゴシエーションのために、改善された柔軟性を含んTLS 1.1 [TLS1.1]プロトコルの改正です。主な変更点は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The MD5/SHA-1 combination in the pseudorandom function (PRF) has been replaced with cipher-suite-specified PRFs. All cipher suites in this document use P_SHA256.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 擬似ランダム関数（PRF）におけるMD5 / SHA-1の組み合わせは、暗号スイートが指定のPRFで置換されています。この文書に記載されているすべての暗号スイートはP_SHA256を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The MD5/SHA-1 combination in the digitally-signed element has been replaced with a single hash. Signed elements now include a field that explicitly specifies the hash algorithm used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - デジタル署名された要素でMD5 / SHA-1の組み合わせは、単一のハッシュで置換されています。署名された要素が明示的に使用するハッシュアルゴリズムを指定するフィールドが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Substantial cleanup to the client&#39;s and server&#39;s ability to specify which hash and signature algorithms they will accept. Note that this also relaxes some of the constraints on signature and hash algorithms from previous versions of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 彼らは受け入れるハッシュと署名アルゴリズムを指定するには、クライアントとサーバの能力にかなりのクリーンアップ。これはまた、TLSの以前のバージョンからの署名と、ハッシュアルゴリズムの制約の一部を緩和することに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Addition of support for authenticated encryption with additional data modes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 追加データモードで認証された暗号化のサポートの追加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS Extensions definition and AES Cipher Suites were merged in from external [TLSEXT] and [TLSAES].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS拡張定義とAES暗号スイートは、[TLSAES] [TLSEXT]外部から合併しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Tighter checking of EncryptedPreMasterSecret version numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 暗号化されたプレマスターシークレットバージョン番号の緊密チェック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Tightened up a number of requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 多くの要件を引き締め。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Verify_data length now depends on the cipher suite (default is still 12).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  Verify_data長は現在、暗号スイート（デフォルトはまだ12である）に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Cleaned up description of Bleichenbacher/Klima attack defenses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  Bleichenbacherの/クリマ攻撃防御の説明をクリーンアップ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Alerts MUST now be sent in many cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - アラートは、現在、多くのケースで送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- After a certificate_request, if no certificates are available, clients now MUST send an empty certificate list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 何の証明書が利用できない場合は証明書要求の後、クライアントは現在、空の証明書のリストを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS_RSA_WITH_AES_128_CBC_SHA is now the mandatory to implement cipher suite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS_RSA_WITH_AES_128_CBC_SHAは暗号スイートを実装することになりまし必須です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added HMAC-SHA256 cipher suites.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 追加されたHMAC-SHA256暗号スイート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed IDEA and DES cipher suites. They are now deprecated and will be documented in a separate document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 削除IDEAとDES暗号スイート。彼らは廃止され、別の文書に記載されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Support for the SSLv2 backward-compatible hello is now a MAY, not a SHOULD, with sending it a SHOULD NOT. Support will probably become a SHOULD NOT in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  SSLv2の後方互換性のhelloのサポートはないはずそれを送信すると、今MAY、ないはずです。サポートは、おそらく将来的にはならないとなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added limited &#34;fall-through&#34; to the presentation language to allow multiple case arms to have the same encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 複数の場合腕が同じエンコーディングを持つことができるように、プレゼンテーションの言語に限られ、「フォールスルー」を追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added an Implementation Pitfalls sections
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 実装落とし穴のセクションを追加しました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The usual clarifications and editorial work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - いつもの明確化と編集作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goals of the TLS protocol, in order of priority, are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにTLSプロトコルの目標は、優先度の高い順に、以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Cryptographic security: TLS should be used to establish a secure connection between two parties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.暗号セキュリティ：TLSは、二者間の安全な接続を確立するために使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Interoperability: Independent programmers should be able to develop applications utilizing TLS that can successfully exchange cryptographic parameters without knowledge of one another&#39;s code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.相互運用性：独立したプログラマは成功し、互いのコードの知識がなくても、暗号化パラメータを交換することができTLSを利用するアプリケーションを開発することができるはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Extensibility: TLS seeks to provide a framework into which new public key and bulk encryption methods can be incorporated as necessary. This will also accomplish two sub-goals: preventing the need to create a new protocol (and risking the introduction of possible new weaknesses) and avoiding the need to implement an entire new security library.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.拡張性：TLSは、新しい公開鍵とバルク暗号化の方法は、必要に応じて組み込むことができるにフレームワークを提供することを目的とします。これは、2つのサブ目標を達成します：新しいプロトコルを作成する必要が防止（および可能な新しい弱点の導入を危険にさらし）と全体の新しいセキュリティライブラリを実装する必要がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.相対的効率：暗号操作は、特に公開鍵操作、非常にCPU集中する傾向があります。この理由のために、TLSプロトコルは、最初から確立される必要がある接続の数を減少させる任意のセッションキャッシュ方式を組み込んでいます。さらに、ケアはネットワーク活動を減らすためにとられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Goals of This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
このドキュメントの3目標
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the TLS protocol itself are based on the SSL 3.0 Protocol Specification as published by Netscape. The differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that the various versions of TLS and SSL 3.0 do not interoperate (although each protocol incorporates a mechanism by which an implementation can back down to prior versions). This document is intended primarily for readers who will be implementing the protocol and for those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscapeが発表され、このドキュメントとTLSプロトコル自体は、SSL 3.0プロトコル仕様に基づいています。このプロトコルとSSL 3.0の違いは劇的ではありませんが、（各プロトコルは実装が以前のバージョンにダウンバックアップできるメカニズムが組み込まれている）TLSとSSL 3.0のさまざまなバージョンを相互運用していないことを十分に重要です。この文書は、主にプロトコルを実装します読者のために、それの暗号解析を行う人のためのものです。仕様では、これを念頭において書かれている、これら二つのグループのニーズを反映することを意図しています。そのため、アルゴリズム依存のデータ構造と規則の多くは、それらへの容易なアクセスを提供し、（付録のではなく）テキストの本文に含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not intended to supply any details of service definition or of interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、それらが固体安全の維持のために必要とされる、それは政策の選択領域をカバーんが、サービス定義のか、インターフェイス定義のいずれかの詳細を提供するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Presentation Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.プレゼンテーション言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document deals with the formatting of data in an external representation. The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language &#34;C&#34; in its syntax and XDR [XDR] in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only; it has no general application beyond that particular goal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、外部表現内のデータのフォーマットを扱います。以下の非常に基本的な、ややカジュアルに定義されたプレゼンテーション構文が使用されます。構文は、その構造中にいくつかのソースから描画します。それはその構文と意図の両方に[XDR]の構文とXDRでのプログラミング言語「C」に似ているが、あまりにも多くの類似点を描画することは危険だろう。このプレゼンテーション言語の目的にのみTLSを文書化することです。それは、その特定の目標を超えていない一般的なアプリケーションを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Basic Block Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 基本ブロックサイズ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The representation of all data items is explicitly specified. The basic data block size is one byte (i.e., 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the byte stream, a multi-byte item (a numeric in the example) is formed (using C notation) by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのデータ項目の表現は、明示的に指定されています。基本的なデータ・ブロック・サイズは、1バイト（すなわち、8ビット）です。上から下へ、左から右への複数バイトのデータ項目は、バイトの連結です。バイトストリームから、マルチバイト項目（例の数値）は、（C表記を使用して）することによって形成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) | ... | byte[n-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
値=（バイト[0] &lt;&lt; 8 *（N-1））| （バイト[1] &lt;&lt; 8 *（N-2））| ... |バイト[N-1]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This byte ordering for multi-byte values is the commonplace network byte order or big-endian format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチバイト値のためのこのバイト順は、平凡なネットワークバイトオーダーかビッグエンディアン形式です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Miscellaneous
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 雑多
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Comments begin with &#34;/*&#34; and end with &#34;*/&#34;.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optional components are denoted by enclosing them in &#34;[[ ]]&#34; double brackets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションのコンポーネントは、「[[]]」二重括弧で囲んで示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Single-byte entities containing uninterpreted data are of type opaque.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未解釈のデータを含むシングルバイト実体がタイプで不透明です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. ベクトル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A vector (single-dimensioned array) is a stream of homogeneous data elements. The size of the vector may be specified at documentation time or left unspecified until runtime. In either case, the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type, T&#39;, that is a fixed-length vector of type T is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ベクター（単一寸法のアレイ）は均質のデータ要素のストリームです。ベクトルの大きさは、ドキュメンテーション時に指定されるか、または実行時まで未指定のままにすることができます。いずれの場合においても、長さは、ベクター内のバイト数ではなく、要素の数を宣言する。新しいタイプ、T」を指定するための構文、それはタイプTの固定長ベクトルであります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
T T&#39;[n];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
T T &#39;[n]は、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here, T&#39; occupies n bytes in the data stream, where n is a multiple of the size of T. The length of the vector is not included in the encoded stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、T」は、nはベクトルの長さを符号化ストリームに含まれていないTのサイズの複数のデータストリームにnバイトを占めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データは9バイトの合計を消費する、三つの連続データムである次の例では、データムは、プロトコルが解釈しない三つの連続バイトであると定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* 3 consecutive 3 byte vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variable-length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation &lt;floor..ceiling&gt;. When these are encoded, the actual length precedes the vector&#39;s contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector&#39;s specified maximum (ceiling) length. A variable-length vector with an actual length field of zero is referred to as an empty vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可変長ベクトルは、表記&lt;floor..ceiling&gt;を使用して、包括的、法的な長さの部分範囲を指定することによって定義されます。これらがコード化されている場合、実際の長さはバイトストリームでベクトルのコンテンツに先行します。長さは、ベクトルの指定された最大（天井）の長さを保持するのに必要な数のバイトを消費数の形態であろう。ゼロの実際の長さフィールドを持つ可変長ベクトルは、空ベクターと呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
T T&#39;&lt;floor..ceiling&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
T T &#39;&lt;floor..ceiling&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, which is sufficient to represent the value 400 (see Section 4.4). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two-byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17-byte vector of uint16 would be illegal).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では、必須では、不透明なタイプの300と400バイトの間に含んでいなければならないベクトルです。それは空になることはありません。実際の長さフィールドは、2バイト、値400（セクション4.4を参照）を表現するのに十分であるuint16のを消費します。一方、長いデータの最大800バイト、または400個のuint16の要素を表すことができ、それが空であってもよいです。そのエンコーディングは、ベクターの先頭に追加2バイトの実際の長さフィールドが含まれます。エンコードされたベクトルの長さは、単一の要素（例えば、uint16の17バイトのベクトルが不正であろう）の長さの偶数倍でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      opaque mandatory&lt;300..400&gt;;
            /* length field is 2 bytes, cannot be empty */
      uint16 longer&lt;0..800&gt;;
            /* zero to 400 16-bit unsigned integers */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 数字
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed-length series of bytes concatenated as described in Section 4.1 and are also unsigned. The following numeric types are predefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本的な数値データ型は、符号なしバイト（uint8の）です。すべての大きな数値データ・タイプは、セクション4.1に記載し、また、符号なしであるように連結されたバイトの固定長シリーズから形成されます。以下の数値型は事前に定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All values, here and elsewhere in the specification, are stored in network byte (big-endian) order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての値は、ここおよび本明細書の他の箇所で、ネットワークバイト（ビッグエンディアン）順に格納されています。ヘクスで表さUINT32 01 02 03 04進値16909060に相当するバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in some cases (e.g., DH parameters) it is necessary to represent integers as opaque vectors. In such cases, they are represented as unsigned integers (i.e., leading zero octets are not required even if the most significant bit is set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明なベクトルとして整数を表すために必要である場合には（例えば、DHパラメータ）ことに留意されたいです。このような場合には、それらは（すなわち、先行ゼロオクテットが最上位ビットがセットされている場合でも必要とされない）の符号なし整数として表現されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Enumerateds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.  、列挙
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared. Every element of an enumerated must be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加のまばらなデータ型は、列挙型と呼ば可能です。型列挙型のフィールドが定義のみで宣言された値をとることができます。各定義は異なるタイプです。同じタイプの列挙品目のみが割り当てまたは比較することができます。次の例で示されるように列挙のすべての要素は、値が割り当てられなければなりません。列挙の要素が順序付けされていないので、彼らは任意の順序で、任意の一意の値を割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An enumerated occupies as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その最大の順序値を定義したと同じように列挙されたバイトストリームのように多くのスペースを占めています。以下の定義は、1バイトのタイプ色のフィールドを運ぶために使用されることを引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { red(3), blue(5), white(7) } Color;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つは、必要に応じて余分な要素を定義することなく、幅の定義を強制的にその関連タグなしで値を指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2, or 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の例では、味は、データストリーム内の2つのバイトを消費するだけの値1、2、または4をとることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The names of the elements of an enumeration are scoped within the defined type. In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列挙の要素の名前は、定義された型内にスコープされています。最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueあろう。割り当てのターゲットがよく指定されている場合、このような資格は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For enumerateds that are never converted to external representation, the numerical information may be omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
外部表現に変換されることはない列挙に関しては、数値情報を省略してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { low, medium, high } Amount;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Constructed Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 建設タイプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造タイプは便宜のためにプリミティブ型から構築することができます。各仕様は、新しい、ユニークなタイプを宣言します。定義の構文はCのようなくらいです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } [[T]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fields within a structure may be qualified using the type&#39;s name, with a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造内のフィールドは、列挙において利用できるように多くの構文を使用して、タイプの名前を使用して修飾することができます。例えば、T.f2は、以前の宣言の2番目のフィールドを意味します。構造体の定義が埋め込まれていてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. バリアント
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. Case arms have limited fall-through: if two case arms follow in immediate succession with no fields in between, then they both contain the same fields. Thus, in the example below, &#34;orange&#34; and &#34;banana&#34; both contain V2. Note that this is a new piece of syntax in TLS 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義された構造が環境で利用できる情報に基づいたバリエーションを有することができます。セレクタは、構造が定義可能な変形を定義する列挙型でなければなりません。選択で宣言された列挙のすべての要素のためのケースアームが存在する必要があります。ケースアームはフォールスルー制限されています：2ケースアームは、それらの両方が同じフィールドが含まれている間にフィールドのない即時連続して続く場合。したがって、以下の例では、「オレンジ」と「バナナ」の両方がV2を含みます。これはTLS 1.2の構文の新しい作品であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変異体構造の本体は、参照のためにラベルを与えることができます。バリアントは、実行時に選択されるメカニズムは、プレゼンテーションの言語で規定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          T1 f1;
          T2 f2;
          ....
          Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               case e3: case e4: Te3;
               ....
               case en: Ten;
           } [[fv]];
      } [[Tv]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { apple, orange, banana } VariantTag;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint16 number;
          opaque string&lt;0..10&gt;; /* variable length */
      } V1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint32 number;
          opaque string[10];    /* fixed length */
      } V2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (VariantTag) { /* value of selector is implicit */
              case apple:
                V1;   /* VariantBody, tag = apple */
              case orange:
              case banana:
                V2;   /* VariantBody, tag = orange or banana */
          } variant_body;       /* optional label on variant */
      } VariantRecord;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. Cryptographic Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 暗号化属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The five cryptographic operations -- digital signing, stream cipher encryption, block cipher encryption, authenticated encryption with additional data (AEAD) encryption, and public key encryption -- are designated digitally-signed, stream-ciphered, block-ciphered, aead-ciphered, and public-key-encrypted, respectively. A field&#39;s cryptographic processing is specified by prepending an appropriate key word designation before the field&#39;s type specification. Cryptographic keys are implied by the current session state (see Section 6.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5つの暗号操作 - デジタル署名は、暗号暗号化、ブロック暗号の暗号化、付加データ（AEAD）暗号化、認証、暗号化、および公開鍵暗号化ストリーム - ストリーム暗号、ブロック暗号化、AEAD、暗号化、デジタル署名された指定されています、それぞれ、公開鍵で暗号化されました。フィールドの暗号処理は、フィールドの型を指定する前に、適切なキーワードの指定を付加することによって特定されます。暗号化キーは、現在のセッション状態によって暗示されている（6.1節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A digitally-signed element is encoded as a struct DigitallySigned:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体はDigitallySignedとしてデジタル署名された要素が符号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
         SignatureAndHashAlgorithm algorithm;
         opaque signature&lt;0..2^16-1&gt;;
      } DigitallySigned;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm field specifies the algorithm used (see Section 7.4.1.4.1 for the definition of this field). Note that the introduction of the algorithm field is a change from previous versions. The signature is a digital signature using those algorithms over the contents of the element. The contents themselves do not appear on the wire but are simply calculated. The length of the signature is specified by the signing algorithm and key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムフィールドは、（このフィールドの定義については、セクション7.4.1.4.1を参照）使用するアルゴリズムを指定します。アルゴリズムフィールドの導入は、以前のバージョンからの変更であることに注意してください。署名は、要素の内容上、これらのアルゴリズムを使用してデジタル署名です。内容自体は、ワイヤ上では表示されませんが、単純に計算されます。署名の長さは、署名アルゴリズムと鍵によって指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In RSA signing, the opaque vector contains the signature generated using the RSASSA-PKCS1-v1_5 signature scheme defined in [PKCS1]. As discussed in [PKCS1], the DigestInfo MUST be DER-encoded [X680] [X690]. For hash algorithms without parameters (which includes SHA-1), the DigestInfo.AlgorithmIdentifier.parameters field MUST be NULL, but implementations MUST accept both without parameters and with NULL parameters. Note that earlier versions of TLS used a different RSA signature scheme that did not include a DigestInfo encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA署名では、不透明なベクトルは[PKCS1]で定義されたRSASSA-PKCS1-v1_5の署名方式を使用して生成された署名を含んでいます。 [PKCS1]で説明したように、DigestInfoは[X680] [X690] DER-符号化されなければなりません。 （SHA-1を含む）パラメータなしハッシュアルゴリズムのための、DigestInfo.AlgorithmIdentifier.parametersフィールドはNULLでなければならないが、実装は、パラメータなしでNULLパラメータの両方受け入れなければなりません。 TLSの以前のバージョンがDigestInfoエンコードが含まれていなかった異なるRSA署名方式を使用することに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In DSA, the 20 bytes of the SHA-1 hash are run directly through the Digital Signing Algorithm with no additional hashing. This produces two values, r and s. The DSA signature is an opaque vector, as above, the contents of which are the DER encoding of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DSAでは、SHA-1ハッシュの20のバイトはない、追加のハッシュとデジタル署名アルゴリズムを介して直接実行されます。これは、2つの値、rおよびsを生成します。 DSA署名は、上記のように、のDER符号化された内容不透明ベクトルです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Dss-Sig-Value ::= SEQUENCE {
          r INTEGER,
          s INTEGER
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: In current terminology, DSA refers to the Digital Signature Algorithm and DSS refers to the NIST standard. In the original SSL and TLS specs, &#34;DSS&#34; was used universally. This document uses &#34;DSA&#34; to refer to the algorithm, &#34;DSS&#34; to refer to the standard, and it uses &#34;DSS&#34; in the code point definitions for historical continuity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：現在の用語では、DSAは、デジタル署名アルゴリズムを参照して、DSSは、NIST標準を指します。オリジナルのSSLおよびTLSの仕様では、「DSSは、」普遍的に使用されました。この文書では、標準を参照するためのアルゴリズム、「DSS」を指すために、「DSA」を使用し、それは歴史的連続性のためのコードポイントの定義の「DSS」を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically secure keyed pseudorandom number generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ストリーム暗号の暗号化では、平文は、排他的論理和は、暗号的に安全なキー付き疑似乱数発生器から生成される出力の同じ量です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In block cipher encryption, every block of plaintext encrypts to a block of ciphertext. All block cipher encryption is done in CBC (Cipher Block Chaining) mode, and all items that are block-ciphered will be an exact multiple of the cipher block length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック暗号の暗号化では、平文のすべてのブロックは、暗号文のブロックに暗号化します。全てのブロック暗号の暗号化は、CBC（Cipher Block Chaining）モードで行われ、ブロック暗号化されているすべての項目が暗号ブロック長の正確な倍数であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In AEAD encryption, the plaintext is simultaneously encrypted and integrity protected. The input may be of any length, and aead-ciphered output is generally larger than the input in order to accommodate the integrity check value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD暗号化では、平文は同時に、暗号化と整合性が保護されています。入力は、任意の長さであってもよく、及びAEAD-暗号化出力は、完全性チェック値を収容するために、一般的に入力よりも大きくなっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In public key encryption, a public key algorithm is used to encrypt data in such a way that it can be decrypted only with the matching private key. A public-key-encrypted element is encoded as an opaque vector &lt;0..2^16-1&gt;, where the length is specified by the encryption algorithm and key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公開鍵暗号では、公開鍵アルゴリズムは、それだけで対応する秘密鍵で復号することができるような方法でデータを暗号化するために使用されます。公開鍵暗号化された要素は、長さが暗号化アルゴリズムおよび鍵によって指定された不透明なベクトル&lt;0..2 ^ 16-1&gt;としてコード化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA encryption is done using the RSAES-PKCS1-v1_5 encryption scheme defined in [PKCS1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA暗号化は[PKCS1]で定義されるRSAES-PKCS1-v1_5の暗号化方式を用いて行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例では
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      stream-ciphered struct {
          uint8 field1;
          uint8 field2;
          digitally-signed opaque {
            uint8 field3&lt;0..255&gt;;
            uint8 field4;
          };
      } UserType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the inner struct (field3 and field4) are used as input for the signature/hash algorithm, and then the entire structure is encrypted with a stream cipher. The length of this structure, in bytes, would be equal to two bytes for field1 and field2, plus two bytes for the signature and hash algorithm, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. The length of the signature is known because the algorithm and key used for the signing are known prior to encoding or decoding this structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
内部構造体（FIELD3とFIELD4）の内容は、署名/ハッシュアルゴリズムのための入力として使用され、次いで全体の構造は、ストリーム暗号で暗号化されています。この構造体の長さ（バイト単位）、フィールド1及びフィールド2用の2つのバイトに加え、署名及びハッシュアルゴリズムの2バイトに等しくなり、プラスの署名の長さ2バイト、プラス署名アルゴリズムの出力の長さ。署名に使用されるアルゴリズムと鍵を符号化するか、この構造をデコードする前に知られているので、署名の長さが知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. 定数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
型付き定数は、所望のタイプのシンボルを宣言し、それに値を割り当てることにより明細書の目的のために定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under-specified types (opaque, variable-length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アンダー指定されたタイプ（不透明、可変長ベクトル、および不透明含む構造）の値を割り当てることはできません。多素子構造又はベクターのないフィールドは省略されなくてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint8 f1;
          uint8 f2;
      } Example1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HMAC and the Pseudorandom Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HMACと擬似ランダム機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS record layer uses a keyed Message Authentication Code (MAC) to protect message integrity. The cipher suites defined in this document use a construction known as HMAC, described in [HMAC], which is based on a hash function. Other cipher suites MAY define their own MAC constructions, if needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSレコード層は、メッセージの完全性を保護するための鍵付きメッセージ認証コード（MAC）を使用しています。この文書で定義された暗号スイートは、ハッシュ関数に基づいている[HMAC]に記載HMACとして知られている構造を、使用します。必要に応じて他の暗号スイートは、自分のMAC構造を定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, a construction is required to do expansion of secrets into blocks of data for the purposes of key generation or validation. This pseudorandom function (PRF) takes as input a secret, a seed, and an identifying label and produces an output of arbitrary length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
さらに、工事が、キー生成や検証の目的のためにデータのブロックに秘密の拡張を行うために必要とされます。この擬似ランダム関数（PRF）は、入力として、秘密、種子、及び識別ラベルを取得し、任意の長さの出力を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, we define one PRF, based on HMAC. This PRF with the SHA-256 hash function is used for all cipher suites defined in this document and in TLS documents published prior to this document when TLS 1.2 is negotiated. New cipher suites MUST explicitly specify a PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a stronger standard hash function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この節では、HMACに基づいて、1 PRFを定義します。 SHA-256ハッシュ関数を持つこのPRFは、このドキュメントで前TLS 1.2がネゴシエートされ、この文書に公開TLS文書で定義されているすべての暗号スイートに使用されます。新しい暗号スイートは、明示的にPRFを指定しなければならないと、一般的には、SHA-256とTLS PRFまたはより強力な標準ハッシュ関数を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, we define a data expansion function, P_hash(secret, data), that uses a single hash function to expand a secret and seed into an arbitrary quantity of output:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、出力の任意の量に秘密と種子を展開するために、単一のハッシュ関数を使用すること、P_hash（秘密、データ）、データの拡張機能を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + HMAC_hash(secret, A(2) + seed) + HMAC_hash(secret, A(3) + seed) + ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
P_hash（秘密、種子）= HMAC_hash（秘密、A（1）+種子）+ HMAC_hash（秘密、A（2）+種子）+ HMAC_hash（秘密、A（3）+種子）+···
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where + indicates concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
+は連結を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A() is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（）のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A(0) = seed A(i) = HMAC_hash(secret, A(i-1))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（0）=シードA（I）= HMAC_hash（秘密、A（I-1））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P_hash can be iterated as many times as necessary to produce the required quantity of data. For example, if P_SHA256 is being used to create 80 bytes of data, it will have to be iterated three times (through A(3)), creating 96 bytes of output data; the last 16 bytes of the final iteration will then be discarded, leaving 80 bytes of output data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P_hashは、データの必要な量を生産するのに必要な回数だけ繰り返すことができます。 P_SHA256は、データの80のバイトを作成するために使用されている場合、例えば、それは（〜（3））を3回反復されなければならない、出力データの96のバイトを生成します。最後の反復の最後の16のバイトは、出力データの80のバイトを残して、廃棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS&#39;s PRF is created by applying P_hash to the secret as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSのPRFは次のように秘密にP_hashを適用して作成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PRF（秘密、ラベル、種子）= P_ &lt;ハッシュ&gt;（秘密、ラベル+シード）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The label is an ASCII string. It should be included in the exact form it is given without a length byte or trailing null character. For example, the label &#34;slithy toves&#34; would be processed by hashing the following bytes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラベルには、ASCII文字列です。それはそれは、長さバイトまたは末尾のヌル文字なしで指定された正確な形式に含まれるべきです。たとえば、ラベル次のバイトをハッシュすることによって処理される「slithy toves」は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
73 6C 69 74 68 79 20 74 6F 76 65 73
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
73 74 TtsのTaqポリメラーゼのTaq右2074テフはTKH 73上陸しました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. The TLS Record Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. TLSレコードプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. Received data is decrypted, verified, decompressed, reassembled, and then delivered to higher-level clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSレコードプロトコルは、階層型プロトコルです。各レイヤでは、メッセージの長さ、説明、コンテンツのためのフィールドを含むことができます。レコードプロトコルは、メッセージを送信するのにかかる管理ブロックにデータを断片化し、必要に応じてデータを圧縮し、MACを適用し、暗号化し、結果を送信します。受信したデータは、復号化された検証、解凍、再組み立て、その後、より高いレベルのクライアントに配信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Four protocols that use the record protocol are described in this document: the handshake protocol, the alert protocol, the change cipher spec protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record content types can be supported by the record protocol. New record content type values are assigned by IANA in the TLS Content Type Registry as described in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコードプロトコルを使用する4つのプロトコルは、この文書で説明されています。ハンドシェイクプロトコル、アラートのプロトコル、変化暗号仕様プロトコル、およびアプリケーションデータプロトコルを。 TLSプロトコルの拡張を可能にするために、追加のレコードのコンテンツタイプは、レコード・プロトコルによってサポートすることができます。第12節で説明したように、新しいレコードのコンテンツタイプの値は、TLSコンテンツタイプレジストリにIANAによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST NOT send record types not defined in this document unless negotiated by some extension. If a TLS implementation receives an unexpected record type, it MUST send an unexpected_message alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、いくつかの拡張によって交渉しない限り、このドキュメントで定義されていないレコードタイプを送ってはいけません。 TLSの実装が予想外のレコードタイプを受信した場合、それはunexpected_messageアラートを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any protocol designed for use over TLS must be carefully designed to deal with all possible attacks against it. As a practical matter, this means that the protocol designer must be aware of what security properties TLS does and does not provide and cannot safely rely on the latter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS以上の使用のために設計されたプロトコルは、慎重にそれに対するすべての可能な攻撃に対処するように設計されなければなりません。実際問題として、これは、プロトコル設計者がセキュリティプロパティTLSを行い、提供していないと安全に後者に頼ることができない何を知っていなければならないことを意味しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note in particular that type and length of a record are not protected by encryption. If this information is itself sensitive, application designers may wish to take steps (padding, cover traffic) to minimize information leakage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコードのタイプと長さが暗号化によって保護されていないことに特に注意してください。この情報は機密である場合には、そのアプリケーションの設計者は、情報の漏洩を最小限に抑えるための手順（パディング、カバートラフィック）を取ることを望むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Connection States
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 接続状態
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TLS connection state is the operating environment of the TLS Record Protocol. It specifies a compression algorithm, an encryption algorithm, and a MAC algorithm. In addition, the parameters for these algorithms are known: the MAC key and the bulk encryption keys for the connection in both the read and the write directions. Logically, there are always four connection states outstanding: the current read and write states, and the pending read and write states. All records are processed under the current read and write states. The security parameters for the pending states can be set by the TLS Handshake Protocol, and the ChangeCipherSpec can selectively make either of the pending states current, in which case the appropriate current state is disposed of and replaced with the pending state; the pending state is then reinitialized to an empty state. It is illegal to make a state that has not been initialized with security parameters a current state. The initial current state always specifies that no encryption, compression, or MAC will be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS接続状態はTLSレコードプロトコルの動作環境です。これは、圧縮アルゴリズム、暗号化アルゴリズム、およびMACアルゴリズムを指定します。また、これらのアルゴリズムのためのパラメータが知られている：MACキーと、読み取りと書き込みの両方向で接続するためのバルク暗号化キー。現在の読み取りおよび状態を書き、そして読み保留中と状態を記述します。論理的には、優れた4つの接続状態が常にあります。すべてのレコードは、現在の読み取りと書き込みの状態の下で処理されています。ペンディング状態のセキュリティパラメータは、TLSハンドシェイクプロトコルにより設定することができ、ChangeCipherSpecを選択的に適切な現在の状態で配置され、保留状態に置き換えた場合には、現在の保留中の状態、のいずれかを行うことができます。保留状態は、空の状態に再初期化されます。セキュリティパラメータの現在の状態に初期化されていない状態を作ることは違法です。初期の現在の状態は常に何の暗号化、圧縮、またはMACを使用しないことを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security parameters for a TLS Connection read and write state are set by providing the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS接続の読み取りと書き込み状態のためのセキュリティパラメータは、以下の値を提供することで、設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
connection end Whether this entity is considered the &#34;client&#34; or the &#34;server&#34; in this connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続は、このエンティティは、これに関連して、「クライアント」または「サーバー」と見なされているかどうかに終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRF algorithm An algorithm used to generate keys from the master secret (see Sections 5 and 6.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスタシークレットから鍵を生成するために使用されるPRFアルゴリズムアルゴリズム（セクション5と6.3を参照のこと）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bulk encryption algorithm An algorithm to be used for bulk encryption. This specification includes the key size of this algorithm, whether it is a block, stream, or AEAD cipher, the block size of the cipher (if appropriate), and the lengths of explicit and implicit initialization vectors (or nonces).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バルク暗号化アルゴリズムアルゴリズムは、バルク暗号化に使用します。この仕様は、ブロック、ストリーム、またはAEAD暗号、暗号のブロックサイズ（適切な場合）、および、明示的および暗黙的な初期化ベクトル（またはノンス）の長さであるかどうか、このアルゴリズムのキーサイズを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC algorithm An algorithm to be used for message authentication. This specification includes the size of the value returned by the MAC algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACは、メッセージの認証に使用するアルゴリズムをアルゴリズムです。この仕様は、MACアルゴリズムによって返された値の大きさを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression algorithm An algorithm to be used for data compression. This specification must include all information the algorithm requires to do compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮は、データ圧縮に使用するアルゴリズムをアルゴリズムです。この仕様はアルゴリズムが圧縮を行うために必要なすべての情報を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret A 48-byte secret shared between the two peers in the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
関連して2つのピア間で共有マスターシークレット48バイトの秘密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client random A 32-byte value provided by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントによって提供されるクライアントランダム32バイトの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server random A 32-byte value provided by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバによって提供されるサーバのランダムな32バイトの値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
These parameters are defined in the presentation language as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これらのパラメータは、次のようにプレゼンテーション言語で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { server, client } ConnectionEnd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { tls_prf_sha256 } PRFAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { null, rc4, 3des, aes }
        BulkCipherAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { stream, block, aead } CipherType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { null, hmac_md5, hmac_sha1, hmac_sha256,
           hmac_sha384, hmac_sha512} MACAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      /* The algorithms specified in CompressionMethod, PRFAlgorithm,
         BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ConnectionEnd          entity;
          PRFAlgorithm           prf_algorithm;
          BulkCipherAlgorithm    bulk_cipher_algorithm;
          CipherType             cipher_type;
          uint8                  enc_key_length;
          uint8                  block_length;
          uint8                  fixed_iv_length;
          uint8                  record_iv_length;
          MACAlgorithm           mac_algorithm;
          uint8                  mac_length;
          uint8                  mac_key_length;
          CompressionMethod      compression_algorithm;
          opaque                 master_secret[48];
          opaque                 client_random[32];
          opaque                 server_random[32];
      } SecurityParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The record layer will use the security parameters to generate the following six items (some of which are not required by all ciphers, and are thus empty):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
記録層には、以下の6つの項目を（そのうちのいくつかは、すべての暗号で必要とされるため、空になっていません）を生成するために、セキュリティパラメータを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
client write MAC key server write MAC key client write encryption key server write encryption key client write IV server write IV
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、MACキークライアントの書き込み暗号鍵サーバの書き込み暗号化キークライアント書き込みIVサーバーの書き込みIVを書くMACキーサーバを書きます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client write parameters are used by the server when receiving and processing records and vice versa. The algorithm used for generating these items from the security parameters is described in Section 6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの書き込みパラメータを記録し、その逆を受信して​​処理する場合、サーバーによって使用されています。セキュリティパラメータからこれらの項目を生成するために使用されるアルゴリズムは、セクション6.3に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states. These current states MUST be updated for each record processed. Each connection state includes the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティパラメータが設定されているとキーが生成されたら、接続状態は、それらの現在の状態作ることによってインスタンス化することができます。これらの現在の状態は、処理された各レコードに更新されなければなりません。それぞれの接続状態は、以下の要素が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression state The current state of the compression algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮は圧縮アルゴリズムの現在の状態を述べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher state The current state of the encryption algorithm. This will consist of the scheduled key for that connection. For stream ciphers, this will also contain whatever state information is necessary to allow the stream to continue to encrypt or decrypt data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号状態暗号化アルゴリズムの現在の状態。これは、その接続のためにスケジュールされたキーから構成されます。ストリーム暗号の場合、これはまた、ストリームはデータを暗号化または復号化を継続することができるようにする必要があるどんな状態の情報が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC key The MAC key for this connection, as generated above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記生成され、この接続のためのMACキーのMACキー、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence number Each connection state contains a sequence number, which is maintained separately for read and write states. The sequence number MUST be set to zero whenever a connection state is made the active state. Sequence numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do not wrap. If a TLS implementation would need to wrap a sequence number, it must renegotiate instead. A sequence number is incremented after each record: specifically, the first record transmitted under a particular connection state MUST use sequence number 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号は、各接続状態が読み取りおよび書き込み状態に対して別々に維持されているシーケンス番号を含んでいます。シーケンス番号は、接続状態がアクティブ状態にされるたびにゼロに設定しなければなりません。シーケンス番号は、タイプUINT64のものであり、2 ^ 64-1を超えてはなりません。シーケンス番号は折り返されません。 TLSの実装は、シーケンス番号をラップする必要がある場合は、代わりに再交渉しなければなりません。シーケンス番号は、各レコードの後に​​インクリメントされる。具体的には、特定の接続状態で送信された最初のレコードは、シーケンス番号0を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Record Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. レコード層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS record layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSレコード層は、任意のサイズの空でないブロック内の上位層からの未解釈のデータを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. フラグメンテーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Client message boundaries are not preserved in the record layer (i.e., multiple client messages of the same ContentType MAY be coalesced into a single TLSPlaintext record, or a single message MAY be fragmented across several records).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
記録層は2 ^ 14バイト以下のチャンクでデータを搬送するのTLSPlaintextレコードに情報ブロックをフラグメント。クライアントメッセージの境界は、記録層に保存されていない（すなわち、同一のContentTypeの複数のクライアントメッセージは、単一のTLSPlaintextレコードに合体されてもよく、または単一のメッセージは、いくつかのレコードを横切って断片化することができます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          uint8 major;
          uint8 minor;
      } ProtocolVersion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          change_cipher_spec(20), alert(21), handshake(22),
          application_data(23), (255)
      } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The higher-level protocol used to process the enclosed fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
囲まれたフラグメントを処理するために使用されるより高いレベルのプロトコルを入力します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The version of the protocol being employed. This document describes TLS Version 1.2, which uses the version { 3, 3 }. The version value 3.3 is historical, deriving from the use of {3, 1} for TLS 1.0. (See Appendix A.1.) Note that a client that supports multiple versions of TLS may not know what version will be employed before it receives the ServerHello. See Appendix E for discussion about what record layer version number should be employed for ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョン使用されているプロトコルのバージョン。この文書は、バージョン{3,3}を使用してTLSバージョン1.2を、記載されています。バージョン値3.3は、TLS 1.0の{3,1}を使用することに由来する、歴史的です。 （付録A.1を参照してください。）TLSの複数のバージョンをサポートするクライアントは、それがのServerHelloを受ける前に使用されるであろうどのバージョンを知らないかもしれないことに注意してください。記録層のバージョン番号はのClientHelloのために使用すべきかについての議論は、付録Eを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSPlaintext.fragment. The length MUST NOT exceed 2^14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のTLSPlaintext.fragmentの長さ長さ（バイト単位）。長さは2 ^ 14を超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The application data. This data is transparent and treated as an independent block to be dealt with by the higher-level protocol specified by the type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションデータを断片化。このデータは、透明で、タイプフィールドで指定されたより高いレベルのプロトコルによって対処される独立したブロックとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST NOT send zero-length fragments of Handshake, Alert, or ChangeCipherSpec content types. Zero-length fragments of Application data MAY be sent as they are potentially useful as a traffic analysis countermeasure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は握手、アラート、またはChangeCipherSpecをコンテンツタイプの長さがゼロの断片を送ってはいけません。彼らは、トラフィック分析対策として潜在的に有用であるとして、アプリケーションデータの長さがゼロのフラグメントが送信されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Data of different TLS record layer content types MAY be interleaved. Application data is generally of lower precedence for transmission than other content types. However, records MUST be delivered to the network in the same order as they are protected by the record layer. Recipients MUST receive and process interleaved application layer traffic during handshakes subsequent to the first one on a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：別のTLSレコード層コンテンツタイプのデータがインターリーブされるかもしれません。アプリケーションデータは、一般に、他のコンテンツタイプより送信に対して低い優先順位のものです。しかし、レコードは、レコード層によって保護されているのと同じ順番でネットワークに送達されなければなりません。受信者は、接続上の最初のものに続くハンドシェイク中にインターリーブアプリケーションレイヤトラフィックを受信して​​処理しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. Record Compression and Decompression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. レコード圧縮と解凍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All records are compressed using the compression algorithm defined in the current session state. There is always an active compression algorithm; however, initially it is defined as CompressionMethod.null. The compression algorithm translates a TLSPlaintext structure into a TLSCompressed structure. Compression functions are initialized with default state information whenever a connection state is made active. [RFC3749] describes compression algorithms for TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのレコードは、現在のセッション状態に定義された圧縮アルゴリズムを使用して圧縮されています。アクティブな圧縮アルゴリズムは常にあります。しかし、当初はCompressionMethod.nullと定義されます。圧縮アルゴリズムはTLSCompressed構造にのTLSPlaintext構造を変換します。圧縮機能は、接続状態がアクティブになるたびデフォルト状態の情報で初期化されています。 [RFC3749]はTLSの圧縮アルゴリズムを記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compression must be lossless and may not increase the content length by more than 1024 bytes. If the decompression function encounters a TLSCompressed.fragment that would decompress to a length in excess of 2^14 bytes, it MUST report a fatal decompression failure error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮はロスレスでなければならず、1024バイト以上で、コンテンツの長さを増加させないかもしれません。解凍機能は、2 ^ 14バイトを超える長さに解凍しまうのTLSCompressed.fragmentに遭遇した場合、それは致命的な減圧失敗誤りを報告しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ContentType type;       /* same as TLSPlaintext.type */
          ProtocolVersion version;/* same as TLSPlaintext.version */
          uint16 length;
          opaque fragment[TLSCompressed.length];
      } TLSCompressed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSCompressed.fragment. The length MUST NOT exceed 2^14 + 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のTLSCompressed.fragmentの長さ長さ（バイト単位）。長さは+ 1024 2 ^ 14を超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The compressed form of TLSPlaintext.fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSPlaintext.fragmentの圧縮形式を断片。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note: A CompressionMethod.null operation is an identity operation; no fields are altered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注意：CompressionMethod.null操作は一致演算です。分野は全く変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Implementation note: Decompression functions are responsible for ensuring that messages cannot cause internal buffer overflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
実装上の注意：解凍機能は、メッセージが内部バッファオーバーフローを引き起こさないことを保証する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. Record Payload Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. レコードのペイロードの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      The encryption and MAC functions translate a TLSCompressed
      structure into a TLSCiphertext.  The decryption functions reverse
      the process.  The MAC of the record also includes a sequence
      number so that missing, extra, or repeated messages are
      detectable.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          select (SecurityParameters.cipher_type) {
              case stream: GenericStreamCipher;
              case block:  GenericBlockCipher;
              case aead:   GenericAEADCipher;
          } fragment;
      } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type field is identical to TLSCompressed.type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプフィールドを入力してTLSCompressed.typeと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The version field is identical to TLSCompressed.version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バージョンバージョンフィールドはTLSCompressed.versionと同じです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSCiphertext.fragment. The length MUST NOT exceed 2^14 + 2048.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のTLSCiphertext.fragmentの長さ長さ（バイト単位）。長さは+ 2048 2 ^ 14を超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The encrypted form of TLSCompressed.fragment, with the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACで、のTLSCompressed.fragmentの暗号化された形式を断片化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.1. Null or Standard Stream Cipher
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.1。 NULLまたは標準ストリーム暗号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stream ciphers (including BulkCipherAlgorithm.null; see Appendix A.6) convert TLSCompressed.fragment structures to and from stream TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（BulkCipherAlgorithm.null含む;付録A.6を参照）のストリーム暗号ストリームのTLSCiphertext.fragment構造からTLSCompressed.fragment構造を変換。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      stream-ciphered struct {
          opaque content[TLSCompressed.length];
          opaque MAC[SecurityParameters.mac_length];
      } GenericStreamCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MAC is generated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACは次のように生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
MAC(MAC_write_key, seq_num + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length + TLSCompressed.fragment);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
MAC（MAC_write_key、SEQ_NUM + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length +のTLSCompressed.fragment）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where &#34;+&#34; denotes concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、「+」連結を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seq_num The sequence number for this record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このための一連番号が記録するseq_num。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC The MAC algorithm specified by SecurityParameters.mac_algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SecurityParameters.mac_algorithmで指定されたMACのMACアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the MAC is computed before encryption. The stream cipher encrypts the entire block, including the MAC. For stream ciphers that do not use a synchronization vector (such as RC4), the stream cipher state from the end of one record is simply used on the subsequent packet. If the cipher suite is TLS_NULL_WITH_NULL_NULL, encryption consists of the identity operation (i.e., the data is not encrypted, and the MAC size is zero, implying that no MAC is used). For both null and stream ciphers, TLSCiphertext.length is TLSCompressed.length plus SecurityParameters.mac_length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MACは、暗号化の前に計算されることに注意してください。ストリーム暗号はMACを含むブロック全体を、暗号化します。 （例えば、RC4など）同期ベクトルを使用しないストリーム暗号のために、一つのレコードの終わりからストリーム暗号状態は、単に次のパケットに使用されます。暗号スイートがTLS_NULL_WITH_NULL_NULLである場合、暗号化は同一の動作で構成され（すなわち、データは暗号化されず、MACサイズにはMACが使用されないことを意味し、ゼロです）。ヌルとストリームの両方の暗号について、TLSCiphertext.lengthはTLSCompressed.lengthプラスSecurityParameters.mac_lengthです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.2. CBC Block Cipher
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.2。 CBCブロック暗号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For block ciphers (such as 3DES or AES), the encryption and MAC functions convert TLSCompressed.fragment structures to and from block TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（例えば3DESやAESなどの）ブロック暗号は、暗号化とMAC機能ブロックのTLSCiphertext.fragment構造からTLSCompressed.fragment構造を変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque IV[SecurityParameters.record_iv_length];
          block-ciphered struct {
              opaque content[TLSCompressed.length];
              opaque MAC[SecurityParameters.mac_length];
              uint8 padding[GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MAC is generated as described in Section 6.2.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション6.2.3.1に記載されるようにMACが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV The Initialization Vector (IV) SHOULD be chosen at random, and MUST be unpredictable. Note that in versions of TLS prior to 1.1, there was no IV field, and the last ciphertext block of the previous record (the &#34;CBC residue&#34;) was used as the IV. This was changed to prevent the attacks described in [CBCATT]. For block ciphers, the IV length is of length SecurityParameters.record_iv_length, which is equal to the SecurityParameters.block_size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IVザ初期化ベクトル（IV）は、ランダムに選択されるべきであり、予測不可能でなければなりません。 1.1前TLSのバージョンでは、いかなるIVフィールド、およびIVとして使用した前のレコードの最後の暗号文ブロック（「CBC残基」）がなかったことに留意されたいです。これは、[CBCATT]で説明された攻撃を防ぐために変更されました。ブロック暗号では、IVの長さはSecurityParameters.block_sizeに等しい長さSecurityParameters.record_iv_length、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding Padding that is added to force the length of the plaintext to be an integral multiple of the block cipher&#39;s block length. The padding MAY be any length up to 255 bytes, as long as it results in the TLSCiphertext.length being an integral multiple of the block length. Lengths longer than necessary might be desirable to frustrate attacks on a protocol that are based on analysis of the lengths of exchanged messages. Each uint8 in the padding data vector MUST be filled with the padding length value. The receiver MUST check this padding and MUST use the bad_record_mac alert to indicate padding errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック暗号のブロック長の整数倍となるように、平文の長さを強制するために添加されるパディングパディング。パディングは、それがブロック長の整数倍であるTLSCiphertext.lengthになるように、255バイトまでの任意の長さまでであり得ます。必要以上に長い長が交換されたメッセージの長さの分析に基づいているプロトコルへの攻撃を挫折させることが望ましいかもしれません。パディングデータベクトルの各UINT8は、パディング長の値で埋めなければなりません。受信機は、このパディングをチェックしなければなりませんし、パディングエラーを示すためにbad_record_macアラートを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding_length The padding length MUST be such that the total size of the GenericBlockCipher structure is a multiple of the cipher&#39;s block length. Legal values range from zero to 255, inclusive. This length specifies the length of the padding field exclusive of the padding_length field itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
するpadding_lengthパディングの長さはのGenericBlockCipher構造体の合計サイズが暗号のブロック長の倍数であるようなものでなければなりません。有効な値は、包括的、ゼロから255までの範囲。この長さはするpadding_lengthフィールド自体の排他的なパディングフィールドの長さを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encrypted data length (TLSCiphertext.length) is one more than the sum of SecurityParameters.block_length, TLSCompressed.length, SecurityParameters.mac_length, and padding_length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化されたデータ長（TLSCiphertext.length）はSecurityParameters.block_length、TLSCompressed.length、SecurityParameters.mac_lengthとするpadding_lengthの和より1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example: If the block length is 8 bytes, the content length (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, then the length before padding is 82 bytes (this does not include the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例：ブロック長が8バイトである場合、コンテンツの長さ（TLSCompressed.length）が61バイトであり、MACの長さは20バイトであり、その後、パディング前の長さは82バイトである（これは含みません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV. Thus, the padding length modulo 8 must be equal to 6 in order to make the total length an even multiple of 8 bytes (the block length). The padding length can be 6, 14, 22, and so on, through 254. If the padding length were the minimum necessary, 6, the padding would be 6 bytes, each containing the value 6. Thus, the last 8 octets of the GenericBlockCipher before block encryption would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV。従って、パディング長モジュロ8は、全8バイト長（ブロック長）の偶数倍にするために、6に等しくなければなりません。パディング長パディングが6バイト、したがって、値6をそれぞれ含む、最後の8つのオクテットであろう、6最低限必要であればパディングの長さは254を通るように6、14、22、とすることができますxxは、MACの最後のオクテットがどこにあるのGenericBlockCipherは、ブロック暗号化の前に、06 06 06 06 06 06 06 xxをされるだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: With block ciphers in CBC mode (Cipher Block Chaining), it is critical that the entire plaintext of the record be known before any ciphertext is transmitted. Otherwise, it is possible for the attacker to mount the attack described in [CBCATT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：CBCモード（暗号ブロック連鎖）でのブロック暗号では、任意の暗号文が送信される前に、レコードの全体の平文が知られていることが重要です。攻撃者は、[CBCATT]で説明した攻撃をマウントするためにそれ以外の場合は、それが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note: Canvel et al. [CBCTIME] have demonstrated a timing attack on CBC padding based on the time required to compute the MAC. In order to defend against this attack, implementations MUST ensure that record processing time is essentially the same whether or not the padding is correct. In general, the best way to do this is to compute the MAC even if the padding is incorrect, and only then reject the packet. For instance, if the pad appears to be incorrect, the implementation might assume a zero-length pad and then compute the MAC. This leaves a small timing channel, since MAC performance depends to some extent on the size of the data fragment, but it is not believed to be large enough to be exploitable, due to the large block size of existing MACs and the small size of the timing signal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：Canvelら。 【CBCTIME】MACを計算するのに必要な時間に基づいて、CBCパディングにタイミング攻撃を実証しています。この攻撃に対して防御するために、実装は、レコードの処理時間がパディングが正しいか否か、本質的に同じであることを保証しなければなりません。一般的には、これを行うための最善の方法は、パディングが間違っている場合でも、MACを計算し、だけにしてパケットを拒否することです。パッドが正しくないと表示された場合例えば、実装は長さゼロのパッドを想定して、MACを計算することがあります。これは、既存のMACの大きいブロックサイズの小さいサイズのため、MAC性能がデータ断片のサイズにある程度依存するので、小さなタイミングチャネルを出るが、悪用することに十分な大きさではないと考えられますタイミング信号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.3. AEAD Ciphers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.3。 AEAD暗号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For AEAD [AEAD] ciphers (such as [CCM] or [GCM]), the AEAD function converts TLSCompressed.fragment structures to and from AEAD TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（例えば[CCM]または[GCM]など）AEAD [AEAD】暗号ため、AEAD機能はAEADのTLSCiphertext.fragment構造からTLSCompressed.fragment構造を変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
         opaque nonce_explicit[SecurityParameters.record_iv_length];
         aead-ciphered struct {
             opaque content[TLSCompressed.length];
         };
      } GenericAEADCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AEAD ciphers take as input a single key, a nonce, a plaintext, and &#34;additional data&#34; to be included in the authentication check, as described in Section 2.1 of [AEAD]. The key is either the client_write_key or the server_write_key. No MAC key is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【AEAD]のセクション2.1に記載されているようにAEAD暗号は、入力として単一キー、ノンス、平文、認証チェックに含まれる「追加データ」を取ります。キーはclient_write_keyかserver_write_keyのいずれかです。いいえMACキーは使用されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each AEAD cipher suite MUST specify how the nonce supplied to the AEAD operation is constructed, and what is the length of the GenericAEADCipher.nonce_explicit part. In many cases, it is appropriate to use the partially implicit nonce technique described in Section 3.2.1 of [AEAD]; with record_iv_length being the length of the explicit part. In this case, the implicit part SHOULD be derived from key_block as client_write_iv and server_write_iv (as described in Section 6.3), and the explicit part is included in GenericAEAEDCipher.nonce_explicit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各AEAD暗号スイートはAEAD操作に供給されるノンスを構築する方法を指定し、GenericAEADCipher.nonce_explicit部の長ものでなければなりません。多くの場合、[AEAD]のセクション3.2.1に記載の部分的に暗黙ナンス技術を使用することが適切です。 record_iv_lengthで明示的な部分の長さであること。この場合、暗黙的な部分（セクション6.3で説明したように）client_write_ivとserver_write_ivようなkey_blockから誘導されるべきであり、明示的な部分はGenericAEAEDCipher.nonce_explicitに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The plaintext is the TLSCompressed.fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
平文でのTLSCompressed.fragmentです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The additional authenticated data, which we denote as additional_data, is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のように我々はadditional_dataとして示す追加の認証されたデータは、定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
additional_data = seq_num + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
additional_data = SEQ_NUM + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where &#34;+&#34; denotes concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここで、「+」連結を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The aead_output consists of the ciphertext output by the AEAD encryption operation. The length will generally be larger than TLSCompressed.length, but by an amount that varies with the AEAD cipher. Since the ciphers might incorporate padding, the amount of overhead could vary with different TLSCompressed.length values. Each AEAD cipher MUST NOT produce an expansion of greater than 1024 bytes. Symbolically,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
aead_outputはAEADの暗号化操作により暗号文出力で構成されています。長さは、一般にTLSCompressed.lengthよりも大きく、しかしAEAD暗号と共に変化量だけであろう。暗号パディングを組み込むかもしれないので、オーバーヘッドの量が異なるTLSCompressed.length値で変えることができます。各AEAD暗号より大きい1024バイトの拡張を生成してはなりません。象徴、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
AEADEncrypted = AEAD-Encrypt(write_key, nonce, plaintext, additional_data)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
AEADEncrypted = AEAD暗号化（write_key、ナンス、平文、additional_data）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to decrypt and verify, the cipher takes as input the key, nonce, the &#34;additional_data&#34;, and the AEADEncrypted value. The output is either the plaintext or an error indicating that the decryption failed. There is no separate integrity check. That is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
復号化および検証するために、暗号は、入力キー、ノンス、「additional_data」、及びAEADEncrypted値としてとります。出力は、平文または復号化が失敗したことを示すエラーのいずれかです。全く別の整合性チェックはありません。あれは：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
TLSCompressed.fragment = AEAD-Decrypt(write_key, nonce, AEADEncrypted, additional_data)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
TLSCompressed.fragment = AEAD-復号化（write_key、ナンス、AEADEncrypted、additional_data）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the decryption fails, a fatal bad_record_mac alert MUST be generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
復号化に失敗した場合、致命的なbad_record_macアラートが生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Key Calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 主な計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Record Protocol requires an algorithm to generate keys required by the current connection state (see Appendix A.6) from the security parameters provided by the handshake protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコードプロトコルは、現在の接続状態によって必要なキーを生成するためのアルゴリズムを必要とするハンドシェイクプロトコルによって提供されるセキュリティパラメータから（付録A.6を参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master secret is expanded into a sequence of secure bytes, which is then split to a client write MAC key, a server write MAC key, a client write encryption key, and a server write encryption key. Each of these is generated from the byte sequence in that order. Unused values are empty. Some AEAD ciphers may additionally require a client write IV and a server write IV (see Section 6.2.3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスターシークレットは、クライアントに分割され、安全なバイトのシーケンスに展開されているサーバは、MACキー、クライアントの書き込み暗号化キー、およびサーバー書き込み暗号化キーを作成し、MACのキーを作成します。これらのそれぞれは、その順序でバイト配列から生成されます。未使用の値は空です。いくつかのAEAD暗号は、さらにクライアントの書き込みIVおよびサーバーの書き込みIV（セクション6.2.3.3を参照）を必要とするかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When keys and MAC keys are generated, the master secret is used as an entropy source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キー及びMACキーが生成されると、マスターシークレットは、エントロピー源として使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To generate the key material, compute
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーマテリアルを生成するには、計算
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
key_block = PRF(SecurityParameters.master_secret, &#34;key expansion&#34;, SecurityParameters.server_random + SecurityParameters.client_random);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
なkey_block = PRF（SecurityParameters.master_secret、 &#34;鍵拡張&#34;、SecurityParameters.server_random + SecurityParameters.client_random）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
until enough output has been generated. Then, the key_block is partitioned as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まで十分な出力が生成されています。その後、次のようになkey_blockが仕切られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
client_write_MAC_key[SecurityParameters.mac_key_length] server_write_MAC_key[SecurityParameters.mac_key_length] client_write_key[SecurityParameters.enc_key_length] server_write_key[SecurityParameters.enc_key_length] client_write_IV[SecurityParameters.fixed_iv_length] server_write_IV[SecurityParameters.fixed_iv_length]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
client_write_MAC_key [SecurityParameters.mac_key_length] server_write_MAC_key [SecurityParameters.mac_key_length] client_write_key [SecurityParameters.enc_key_length] server_write_key [SecurityParameters.enc_key_length] client_write_IV [SecurityParameters.fixed_iv_length] server_write_IV [SecurityParameters.fixed_iv_length]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Currently, the client_write_IV and server_write_IV are only generated for implicit nonce techniques as described in Section 3.2.1 of [AEAD].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【AEAD]のセクション3.2.1に記載したように、現在、client_write_IVとserver_write_IVのみ暗黙ナンス技術のために生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note: The currently defined cipher suite which requires the most material is AES_256_CBC_SHA256. It requires 2 x 32 byte keys and 2 x 32 byte MAC keys, for a total 128 bytes of key material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：ほとんどの材料を必要とし、現在定義されている暗号スイートがAES_256_CBC_SHA256です。これは、鍵データの合計128バイトのために、2×32バイトのキーと2×32バイトのMAC鍵を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. The TLS Handshaking Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. TLSハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS has three subprotocols that are used to allow peers to agree upon security parameters for the record layer, to authenticate themselves, to instantiate negotiated security parameters, and to report error conditions to each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSはピアは、記録層のためのセキュリティパラメータに合意するために自分自身を認証するために交渉セキュリティパラメータをインスタンス化するために、お互いにエラー状況を報告できるようにするために使用される3つのサブプロトコルがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Handshake Protocol is responsible for negotiating a session, which consists of the following items: session identifier An arbitrary byte sequence chosen by the server to identify an active or resumable session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクプロトコルは、以下の項目で構成されたセッションを交渉する責任がある：セッション識別子アクティブまたは再開可能なセッション状態を識別するためにサーバによって選択された任意のバイトシーケンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
peer certificate X509v3 [PKIX] certificate of the peer. This element of the state may be null.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアのピア証明書X509v3 [PKIX]証明書。状態のこの要素はnullの場合もあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression method The algorithm used to compress data prior to encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮方式暗号化の前にデータを圧縮するために使用されるアルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher spec Specifies the pseudorandom function (PRF) used to generate keying material, the bulk data encryption algorithm (such as null, AES, etc.) and the MAC algorithm (such as HMAC-SHA1). It also defines cryptographic attributes such as the mac_length. (See Appendix A.6 for formal definition.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号仕様は、擬似ランダム関数（PRF）はキーイング材料、バルクデータの暗号化アルゴリズムと（例えば、HMAC-SHA1など）MACアルゴリズム（例えばヌル、AESなど）を生成するために使用される指定します。それはまた、mac_lengthなどの暗号化属性を定義します。 （正式な定義については付録A.6を参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret 48-byte secret shared between the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバの間で共有される秘密48バイトの秘密を習得。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is resumable A flag indicating whether the session can be used to initiate new connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再開可能セッションが新しい接続を開始するために使用することができるか否かを示すフラグです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These items are then used to create security parameters for use by the record layer when protecting application data. Many connections can be instantiated using the same session through the resumption feature of the TLS Handshake Protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの項目は、アプリケーションのデータを保護する際に、記録層で使用するためのセキュリティパラメータを作成するために使用されています。多くの接続は、TLSハンドシェイクプロトコルの再開機能を使用して、同じセッションを使用してインスタンス化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Change Cipher Spec Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 暗号仕様変更プロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change cipher spec protocol exists to signal transitions in ciphering strategies. The protocol consists of a single message, which is encrypted and compressed under the current (not the pending) connection state. The message consists of a single byte of value 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
変化暗号仕様プロトコルは、暗号化戦略の遷移を通知するために存在しています。プロトコルは、（保留中ではない）現在の接続状態の下で暗号化され、圧縮された単一のメッセージからなります。メッセージは、値1の単一バイトから成ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          enum { change_cipher_spec(1), (255) } type;
      } ChangeCipherSpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ChangeCipherSpec message is sent by both the client and the server to notify the receiving party that subsequent records will be protected under the newly negotiated CipherSpec and keys. Reception of this message causes the receiver to instruct the record layer to immediately copy the read pending state into the read current state. Immediately after sending this message, the sender MUST instruct the record layer to make the write pending state the write active state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ChangeCipherSpecをメッセージは、クライアントと後続のレコードは、新たに交渉のCipherSpecと鍵の下で保護されます受信者に通知するサーバの両方で送信されます。このメッセージの受信は、受信機はすぐに読み、現在の状態に読み取り保留状態をコピーする記録層を指示する原因となります。すぐにこのメッセージを送信した後、送信者は、書き込み保留状態の書き込みアクティブ状態を作るために、記録層に指示する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(See Section 6.1.) The ChangeCipherSpec message is sent during the handshake after the security parameters have been agreed upon, but before the verifying Finished message is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（6.1節を参照してください。）ChangeCipherSpecをメッセージは、セキュリティパラメータが合意された後にハンドシェイク中に送信されますが、検証Finishedメッセージが送信される前に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: If a rehandshake occurs while data is flowing on a connection, the communicating parties may continue to send data using the old CipherSpec. However, once the ChangeCipherSpec has been sent, the new CipherSpec MUST be used. The first side to send the ChangeCipherSpec does not know that the other side has finished computing the new keying material (e.g., if it has to perform a time-consuming public key operation). Thus, a small window of time, during which the recipient must buffer the data, MAY exist. In practice, with modern machines this interval is likely to be fairly short.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：データは、接続に流れている間に再ハンドシェイクが発生した場合、通信者は古いのCipherSpecを使用してデータを送信し続ける可能性があります。 ChangeCipherSpecをが送信された後しかし、新しいのCipherSpecを使用しなければなりません。 ChangeCipherSpecをを送信する第1の側が他側は新しい合わせることの材料（例えば、それは時間のかかる公開鍵操作を実行する必要がある場合）の計算が終了したことを知りません。したがって、受信者がデータをバッファリングしなければならない時間の小さなウィンドウは、存在してもよいです。実際には、近代的な機械で、この間隔はかなり短くなる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Alert Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. アラートプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the content types supported by the TLS record layer is the alert type. Alert messages convey the severity of the message (warning or fatal) and a description of the alert. Alert messages with a level of fatal result in the immediate termination of the connection. In this case, other connections corresponding to the session may continue, but the session identifier MUST be invalidated, preventing the failed session from being used to establish new connections. Like other messages, alert messages are encrypted and compressed, as specified by the current connection state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSレコード層によってサポートされているコンテンツの種類の一つは、アラートタイプです。アラートメッセージには、メッセージ（警告または致命的な）の重症度およびアラートの説明を伝えます。接続の即時終了で致命的な結果のレベルにアラートメッセージ。この場合、セッションに対応する他の接続が継続してもよいが、セッション識別子が無効にされなければならない、新しい接続を確立するために使用されるの失敗したセッションを防止します。現在の接続状態によって指定された他のメッセージと同様に、警告メッセージは、暗号化および圧縮されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          close_notify(0),
          unexpected_message(10),
          bad_record_mac(20),
          decryption_failed_RESERVED(21),
          record_overflow(22),
          decompression_failure(30),
          handshake_failure(40),
          no_certificate_RESERVED(41),
          bad_certificate(42),
          unsupported_certificate(43),
          certificate_revoked(44),
          certificate_expired(45),
          certificate_unknown(46),
          illegal_parameter(47),
          unknown_ca(48),
          access_denied(49),
          decode_error(50),
          decrypt_error(51), export_restriction_RESERVED(60),
          protocol_version(70),
          insufficient_security(71),
          internal_error(80),
          user_canceled(90),
          no_renegotiation(100),
          unsupported_extension(110),
          (255)
      } AlertDescription;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          AlertLevel level;
          AlertDescription description;
      } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. Closure Alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. クロージャアラート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Either party may initiate the exchange of closing messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーの接続がトランケーション攻撃を避けるために終了しているという知識を共有しなければなりません。いずれの当事者から終了メッセージの交換を開始することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
close_notify This message notifies the recipient that the sender will not send any more messages on this connection. Note that as of TLS 1.1, failure to properly close a connection no longer requires that a session not be resumed. This is a change from TLS 1.0 to conform with widespread implementation practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
close_notifyこのメッセージは、送信者がこの接続上の任意の複数のメッセージを送信しません受信者に通知します。 TLS 1.1のように、適切な接続を閉じるには、障害がもはやセッションが再開されないことを必要とすることに注意してください。これは、広範囲の実装の練習に準拠するためにTLS 1.0からの変更点です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Either party may initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いずれの当事者は、は、close_notifyを送信することにより、クローズを開始することができます。閉鎖警報後に受信したデータはすべて無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless some other fatal alert has been transmitted, each party is required to send a close_notify alert before closing the write side of the connection. The other party MUST respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes. It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のいくつかの致命的なアラートが送信された場合を除き、各当事者は、接続の書き込み側を閉じる前には、close_notifyを送信するために必要とされます。他の当事者は、独自のは、close_notifyで応答し、すぐにコネクションを閉じ、保留中の書き込みを破棄しなければなりません。接続の読み取り側を閉じる前に、応答は、close_notifyを待つために近くのイニシエータは必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding close_notify alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation MAY choose to close the transport without waiting for the responding close_notify. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSを使用してアプリケーションプロトコルは、TLS接続が閉じられた後、任意のデータは、基礎となるトランスポートを介して行うことができることを提供する場合、TLSの実装は、TLS接続が終了したことをアプリケーション層に示す前に、応答は、close_notifyアラートを受信しなければなりません。アプリケーションプロトコルが追加のデータを転送することはありませんが、唯一の基礎となるトランスポート接続をクローズする場合は、その実装は、応答は、close_notifyを待たずにトランスポートを閉じるために選ぶかもしれません。この規格のいかなる部分も、TLSの使用プロファイルは、接続が開いているか閉じているときを含め、そのデータ転送を管理する方法を決定するために取られるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: It is assumed that closing a connection reliably delivers pending data before destroying the transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：接続を閉じると確実に輸送を破壊する前に、保留中のデータを配信するものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. Error Alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. エラーアラート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error handling in the TLS Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Upon transmission or receipt of a fatal alert message, both parties immediately close the connection. Servers and clients MUST forget any session-identifiers, keys, and secrets associated with a failed connection. Thus, any connection terminated with a fatal alert MUST NOT be resumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクプロトコルにおけるエラー処理は非常に簡単です。エラーが検出されると、検出当事者が他の当事者にメッセージを送信します。致命的な警告メッセージの送信または受信すると、両当事者は、直ちに接続を閉じます。サーバーとクライアントが失敗した接続に関連付けられているすべてのセッション識別子、キー、および秘密を忘れなければなりません。このように、致命的な警告で終了任意の接続が再開してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever an implementation encounters a condition which is defined as a fatal alert, it MUST send the appropriate alert prior to closing the connection. For all errors where an alert level is not explicitly specified, the sending party MAY determine at its discretion whether to treat this as a fatal error or not. If the implementation chooses to send an alert but intends to close the connection immediately afterwards, it MUST send that alert at the fatal alert level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は致命的な警告のように定義された条件に遭遇するたびに、前の接続を閉じるには、適切な警告を送らなければなりません。警戒レベルが明示的に指定されていないすべてのエラーのため、送信側は、致命的なエラーかないとしてこれを扱うかどうかをその裁量により決定することができます。実装がアラートを送信することを選択したが、直後に接続をクローズするつもりなら、それは致命的な警戒レベルでそのアラートを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an alert with a level of warning is sent and received, generally the connection can continue normally. If the receiving party decides not to proceed with the connection (e.g., after having received a no_renegotiation alert that it is not willing to accept), it SHOULD send a fatal alert to terminate the connection. Given this, the sending party cannot, in general, know how the receiving party will behave. Therefore, warning alerts are not very useful when the sending party wants to continue the connection, and thus are sometimes omitted. For example, if a peer decides to accept an expired certificate (perhaps after confirming this with the user) and wants to continue the connection, it would not generally send a certificate_expired alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
警告のレベルにアラートが送信され、受信された場合、一般的に接続が正常に継続することができます。受信者は、接続を続行しないことを決定した場合（受け入れることを望んでいないことをno_renegotiationアラートを受信した後、例えば、）、それは接続を終了するには、致命的なアラートを送信すべきです。このことを考えると、送信側は、一般的には、受信側がどのように動作するかを知ることができません。そのため、警告アラートが送信側が接続を継続したい場合に非常に有用ではないので、時々省略されています。ピアは（おそらくユーザーでこれを確認した後）期限切れの証明書を受け入れることを決定し、接続を継続したい場合たとえば、それは一般certificate_expiredアラートを送信しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following error alerts are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のエラーアラートが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unexpected_message An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unexpected_message不適切なメッセージが受信されました。このアラートは常にfatalである。適切な実装間の通信に観察すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_record_mac This alert is returned if a record is received with an incorrect MAC. This alert also MUST be returned if an alert is sent because a TLSCiphertext decrypted in an invalid way: either it wasn&#39;t an even multiple of the block length, or its padding values, when checked, weren&#39;t correct. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レコードが正しくないMACで受信された場合にbad_record_macこのアラートが返されます。アラートが送信された場合TLSCiphertextが無効な方法で復号化されたので、この警告はまた返さなければなりません：チェックすると、それは、偶数ブロック長の倍数、またはそのパディング値ではなかったのいずれか、正しくありませんでした。このメッセージは常に致命的であると（メッセージがネットワーク内に破損した場合を除く）、適切な実装の間の通信に観察すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decryption_failed_RESERVED This alert was used in some earlier versions of TLS, and may have permitted certain attacks against the CBC mode [CBCATT]. It MUST NOT be sent by compliant implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このアラートは、TLSのいくつかの以前のバージョンで使用されていた、とCBCモード[CBCATT]に対する特定の攻撃を許可している可能性がdecryption_failed_RESERVED。これは、準拠した実装で送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
record_overflow A TLSCiphertext record was received that had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
record_overflow A TLSCiphertextレコードは長さ以上2 ^ 14 + 2048バイト、または以上2 ^ 14の+ 1024バイトとTLSCompressedレコードに復号化されたレコードを有していたことを受け取りました。このメッセージは常に致命的であると（メッセージがネットワーク内に破損した場合を除く）、適切な実装の間の通信に観察すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decompression_failure The decompression function received improper input (e.g., data that would expand to excessive length). This message is always fatal and should never be observed in communication between proper implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
減圧機能decompression_failure不適切な入力（過剰な長さに拡大する、例えば、データ）を受け取りました。このメッセージは常に致命的であると適切な実装の間の通信に観察すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
handshake_failure Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
握手_警告メッセージの握手_レセプションは、送信者が利用可能なオプション特定のセキュリティパラメータの許容可能なセットを交渉することができなかったことを示しています。これは致命的なエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_certificate_RESERVED This alert was used in SSLv3 but not any version of TLS. It MUST NOT be sent by compliant implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_certificate_RESERVEDこのアラートは、TLSのいずれかのバージョンのSSLv3ではなく、使用されました。これは、準拠した実装で送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_certificate A certificate was corrupt, contained signatures that did not verify correctly, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書が破損したbad_certificate、正しく検証しませんでした署名などが含まれてい
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsupported_certificate A certificate was of an unsupported type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsupported_certificate証明書はサポートされていないタイプでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_revoked A certificate was revoked by its signer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書は、その署名者によって取り消されましたcertificate_revoked。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_expired A certificate has expired or is not currently valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書の有効期限が切れたり、現在有効ではありませんしていcertificate_expired。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_unknown Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のいくつかの（詳細不明）問題certificate_unknown容認できない、それをレンダリング、証明書の処理で生じました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
illegal_parameter A field in the handshake was out of range or inconsistent with other fields. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
握手のフィールドillegal_parameter範囲外であったか、他のフィールドと矛盾。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unknown_ca A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn&#39;t be matched with a known, trusted CA. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unknown_ca有効な証明書チェーンまたは部分的にチェーンを受信しましたが、証明書は、CA証明書が見つかりませんでしたので、受け入れられなかったか、知られている、信頼できるCAと一致することができませんでしたこのメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
access_denied A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACCESS_DENIED有効な証明書を受信しましたが、アクセス制御が適用されたとき、送信者が交渉を進めないことを決定しました。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decode_error A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal and should never be observed in communication between proper implementations (except when messages were corrupted in the network).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのフィールドは、指定された範囲外であったか、メッセージの長さが間違っていたのでdecode_errorメッセージをデコードできませんでした。このメッセージは常に致命的であると（メッセージがネットワーク内に破損した場合を除く）、適切な実装の間の通信に観察すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decrypt_error A handshake cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decrypt_errorハンドシェーク暗号操作が正しく署名を検証またはFinishedメッセージを検証できないことを含めて、失敗しました。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
export_restriction_RESERVED This alert was used in some earlier versions of TLS. It MUST NOT be sent by compliant implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
export_restriction_RESERVEDこのアラートは、TLSのいくつかの以前のバージョンで使用されていました。これは、準拠した実装で送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
protocol_version The protocol version the client has attempted to negotiate is recognized but not supported. (For example, old protocol versions might be avoided for security reasons.) This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが交渉しようとしたプロトコルバージョンをPROTOCOL_VERSION認識しますが、サポートされていません。 （例えば、古いプロトコルバージョンは、セキュリティ上の理由から回避される可能性があります。）このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
insufficient_security Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバがクライアントによってサポートされているものよりもより安全な暗号を必要とするため、交渉が具体的に失敗したときinsufficient_securityは握手_の代わりに返されます。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
internal_error An internal error unrelated to the peer or the correctness of the protocol (such as a memory allocation failure) makes it impossible to continue. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピアまたは（例えば、メモリ割り当て障害など）プロトコルの正確とは無関係INTERNAL_ERROR内部エラーが継続することを不可能にします。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
user_canceled This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
user_canceledこのハンドシェイクは、プロトコルのエラーとは関係のない理由でキャンセルされています。握手だけでは、close_notifyを送信することにより、接続を閉じる、完了した後、ユーザーが操作をキャンセルした場合、より適切です。このアラートの後には、close_notifyが続くべきです。このメッセージは、一般的警告です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_renegotiation Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert. At that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate is where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup, and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_renegotiationは、初期ハンドシェイクの後にクライアントハローに応じて、ハロー要求に応じて、クライアントまたはサーバーによって送信されます。これらのいずれかが正常に再交渉につながります。それが適切でない場合、受信者はこのアラートに応答する必要があります。その時点で、オリジナルのリクエスタは、接続を続行するかどうかを決定することができます。サーバは要求を満たすためのプロセスを生み出した場合、これは適切であろう一つの場合です。このプロセスは、起動時にセキュリティパラメータ（鍵長、認証など）を受け取るかもしれません、そして、その時点の後に、これらのパラメータの変更を通信することは困難かもしれません。このメッセージは、常に警告です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsupported_extension sent by clients that receive an extended server hello containing an extension that they did not put in the corresponding client hello. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
こんにちは、彼らはハロー対応するクライアントには入れていないという拡張子を含む拡張サーバーを受け取るクライアントから送信さunsupported_extension。このメッセージは常に致命的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New Alert values are assigned by IANA as described in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第12節で説明したように新しいアラート値は、IANAによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Handshake Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. ハンドシェイクプロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS record layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and use public-key encryption techniques to generate shared secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション状態の暗号パラメータは、TLSレコード層の上で動作TLSハンドシェイクプロトコルによって生成されます。 TLSクライアントとサーバが最初に通信を開始すると、彼らは、必要に応じて相互に認証、暗号化アルゴリズムを選択し、共有秘密を生成するために、公開鍵暗号化技術を使用し、プロトコルバージョンについては同意します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Handshake Protocol involves the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクプロトコルは、次の手順を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Exchange hello messages to agree on algorithms, exchange random values, and check for session resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 為替helloメッセージは、アルゴリズムに同意し、ランダムな値を交換し、セッション再開をチェックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Exchange the necessary cryptographic parameters to allow the client and server to agree on a premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - クライアントとサーバがプレマスター秘密に同意できるようにするために必要な暗号パラメータを交換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Exchange certificates and cryptographic information to allow the client and server to authenticate themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 為替証明書と暗号情報は、クライアントとサーバーが自分自身を認証できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Generate a master secret from the premaster secret and exchanged random values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - このpremaster_secretからマスターシークレットを生成し、ランダムな値を交換しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Provide security parameters to the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 記録層にセキュリティパラメータを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Allow the client and server to verify that their peer has calculated the same security parameters and that the handshake occurred without tampering by an attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - クライアントとサーバがそのピアが同じセキュリティパラメータを計算し、ハンドシェイクが攻撃者によって改ざんせずに発生したことをしていることを確認できるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that higher layers should not be overly reliant on whether TLS always negotiates the strongest possible connection between two peers. There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support. The protocol has been designed to minimize this risk, but there are still attacks available: for example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure in that any cipher suite offers its promised level of security: if you negotiate 3DES with a 1024-bit RSA key exchange with a host whose certificate you have verified, you can expect to be that secure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上位層は、TLSは常に2つのピア間の最強の可能な接続をネゴシエートするかどうかに過度に依存すべきではないことに注意してください。 man-in-the-middle攻撃者は2つのエンティティが、彼らがサポートする最も安全な方法まで低下させることを試みることができる多くの方法があります。プロトコルは、このリスクを最小限に抑えるように設計されていますが、利用可能な攻撃が残っています。たとえば、攻撃者がポートへのアクセスをブロックすることができ、安全なサービスが稼動する、またはピアが認証されていない接続を交渉するために取得しようとします。基本的なルールは、より高いレベルがそのセキュリティ要件が何であるかを認識することと、彼らが必要とするものよりも安全チャネルを介して情報を送信することはありませんしなければならないということです。 TLSプロトコルは、そのいずれかの暗号スイートは、セキュリティの約束のレベルを提供していますで安全である：あなたが証明書あなたが確認したホストとの1024ビットRSA鍵交換と3DESを交渉するならば、あなたはその安全であることを期待することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These goals are achieved by the handshake protocol, which can be summarized as follows: The client sends a ClientHello message to which the server must respond with a ServerHello message, or else a fatal error will occur and the connection will fail. The ClientHello and ServerHello are used to establish security enhancement capabilities between client and server. The ClientHello and ServerHello establish the following attributes: Protocol Version, Session ID, Cipher Suite, and Compression Method. Additionally, two random values are generated and exchanged: ClientHello.random and ServerHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの目標は、次のように要約することができるハンドシェイクプロトコルによって達成される：クライアントは、サーバがServerHelloメッセージで応答しなければならないにClientHelloメッセージを送信し、または他の致命的なエラーが発生し、接続は失敗します。 ClientHelloとのServerHelloは、クライアントとサーバ間のセキュリティ強化機能を確立するために使用されています。プロトコルバージョン、セッションID、暗号スイート、および圧縮方法：のClientHelloとServerHelloメッセージは、次の属性を確立します。さらに、2つのランダムな値が生成され、交換される：ClientHello.randomとしてServerHello.randomを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The actual key exchange uses up to four messages: the server Certificate, the ServerKeyExchange, the client Certificate, and the ClientKeyExchange. New key exchange methods can be created by specifying a format for these messages and by defining the use of the messages to allow the client and server to agree upon a shared secret. This secret MUST be quite long; currently defined key exchange methods exchange secrets that range from 46 bytes upwards.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバ証明書、ServerKeyExchange、クライアント証明書、およびClientKeyExchange：実際のキー交換は4つのまでのメッセージを使用しています。新しい鍵交換方法は、これらのメッセージの形式を指定することで、クライアントとサーバが共有秘密に同意できるようにするためにメッセージの使用を定義することによって作成することができます。この秘密は非常に長くする必要があります。現在、上向きに46バイトから範囲鍵交換方法交換の秘密を定義しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following the hello messages, the server will send its certificate in a Certificate message if it is to be authenticated. Additionally, a ServerKeyExchange message may be sent, if it is required (e.g., if the server has no certificate, or if its certificate is for signing only). If the server is authenticated, it may request a certificate from the client, if that is appropriate to the cipher suite selected. Next, the server will send the ServerHelloDone message, indicating that the hello-message phase of the handshake is complete. The server will then wait for a client response. If the server has sent a CertificateRequest message, the client MUST send the Certificate message. The ClientKeyExchange message is now sent, and the content of that message will depend on the public key algorithm selected between the ClientHello and the ServerHello. If the client has sent a certificate with signing ability, a digitally-signed CertificateVerify message is sent to explicitly verify possession of the private key in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それが認証される場合はhelloメッセージに続き、サーバは証明書メッセージに証明書を送信します。それが必要な場合、さらに、ServerKeyExchangeメッセージは、送信されても​​よい（例えば、サーバは全く証明書を持たない場合、またはその証明書が署名のみのためのものである場合）。サーバーが認証された場合には、選択された暗号スイートに適切であれば、それは、クライアントからの証明書を要求することができます。次に、サーバは、ハンドシェークのハロー・メッセージ・フェーズが完了したことを示す、ServerHelloDoneメッセージを送信します。その後、サーバーはクライアントの応答を待ちます。サーバがCertificateRequestメッセージを送信した場合、クライアントはCertificateメッセージを送らなければなりません。 ClientKeyExchangeメッセージは、現在送信され、そのメッセージの内容はのClientHelloとのServerHelloの間で選択された公開鍵アルゴリズムに依存します。クライアントが署名能力を持つ証明書を送信した場合、デジタル署名されたCertificateVerifyメッセージは、明示的に証明書内の秘密鍵の所有を確認するために送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, a ChangeCipherSpec message is sent by the client, and the client copies the pending Cipher Spec into the current Cipher Spec. The client then immediately sends the Finished message under the new algorithms, keys, and secrets. In response, the server will send its own ChangeCipherSpec message, transfer the pending to the current Cipher Spec, and send its Finished message under the new Cipher Spec. At this point, the handshake is complete, and the client and server may begin to exchange application layer data. (See flow chart below.) Application data MUST NOT be sent prior to the completion of the first handshake (before a cipher suite other than TLS_NULL_WITH_NULL_NULL is established).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、ChangeCipherSpecをメッセージは、現在の暗号スペックに未決の暗号スペックをクライアントから送信され、クライアントコピーされます。その後、クライアントは、直ちに新しいアルゴリズム、鍵、および秘密の下にFinishedメッセージを送信します。それに応答して、自身のChangeCipherSpecをメッセージを送信するサーバーは、現在の暗号スペックに未決を転送し、新しい暗号スペックの下でそのFinishedメッセージを送信します。この時点で、ハンドシェイクが完了し、クライアントとサーバは、アプリケーション層のデータを交換し始めるかもしれません。 （以下のフローチャートを参照してください。）アプリケーションデータ（確立さTLS_NULL_WITH_NULL_NULL以外の暗号スイートの前に）最初のハンドシェイクが完了する前に送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ClientHello                  --------&gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      Application Data             &lt;-------&gt;     Application Data
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 1. Message flow for a full handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
完全なハンドシェイクのために、図1のメッセージの流れ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Indicates optional or situation-dependent messages that are not always sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
*常に送信されていないオプションや状況依存のメッセージを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS protocol content type, and is not actually a TLS handshake message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：パイプラインの停止を避けるために、ChangeCipherSpecを、独立したTLSプロトコルコンテンツタイプであり、実際TLSハンドシェイクメッセージではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client and server decide to resume a previous session or duplicate an existing session (instead of negotiating new security parameters), the message flow is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバは、前のセッションを再開するか、（代わりに新しいセキュリティパラメータを交渉の）既存のセッションを複製することを決定した場合は、次のように、メッセージフローは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match. If a match is found, and the server is willing to re-establish the connection under the specified session state, it will send a ServerHello with the same Session ID value. At this point, both client and server MUST send ChangeCipherSpec messages and proceed directly to Finished messages. Once the re-establishment is complete, the client and server MAY begin to exchange application layer data. (See flow chart below.) If a Session ID match is not found, the server generates a new session ID, and the TLS client and server perform a full handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが再開されるセッションのセッションIDを使用してClientHelloを送信します。その後、サーバーは、一致するセッションキャッシュをチェックします。一致するものが見つかった、とサーバーが指定されたセッション状態の下でコネクションを再確立しようとした場合は、同じセッションIDの値を含めたServerHelloメッセージを送信します。この時点で、クライアントとサーバの両方がChangeCipherSpecをメッセージを送らなければなりませんし、Finishedメッセージに直接進みます。再確立が完了すると、クライアントとサーバは、アプリケーション層のデータを交換し始めるかもしれません。セッションIDの一致が見つからない場合、サーバは新しいセッションIDを生成します（下記のフローチャートを参照してください）、およびTLSクライアントとサーバは完全な握手を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントサーバー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ClientHello                   --------&gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&gt;
      Application Data              &lt;-------&gt;     Application Data
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Figure 2. Message flow for an abbreviated handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
略記ハンドシェイクのために、図2のメッセージ・フロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents and significance of each message will be presented in detail in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンテンツ及び各メッセージの意味は、以下のセクションで詳細に提示されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Handshake Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. ハンドシェイクプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Handshake Protocol is one of the defined higher-level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS record layer, where they are encapsulated within one or more TLSPlaintext structures, which are processed and transmitted as specified by the current active session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSハンドシェイクプロトコルは、TLSレコードプロトコルの定義されたより高いレベルのクライアントの一つです。このプロトコルは、セッションの安全な属性を交渉するために使用されます。ハンドシェイクメッセージは、それらが現在アクティブなセッション状態によって指定されるように処理され、送信される1つのまたは複数のTLSPlaintext構造内にカプセル化されたTLSレコード層に供給されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
          } body;
      } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake protocol messages are presented below in the order they MUST be sent; sending handshake messages in an unexpected order results in a fatal error. Unneeded handshake messages can be omitted, however. Note one exception to the ordering: the Certificate message is used twice in the handshake (from server to client, then from client to server), but described only in its first position. The one message that is not bound by these ordering rules is the HelloRequest message, which can be sent at any time, but which SHOULD be ignored by the client if it arrives in the middle of a handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
握手プロトコルメッセージは、それらが送らなければならないために、以下に提示します。致命的なエラーで予期しないため結果にハンドシェイクメッセージを送信します。不要なハンドシェイクメッセージは、しかし、省略することができます。順序に一つの例外に注意してください：Certificateメッセージは、（サーバからクライアントに、クライアントからサーバーへの）ハンドシェイクで二回使用されるが、その最初の位置にのみ記載されています。これらの発注ルールに縛られていない一つのメッセージをいつでも送信することができHelloRequestメッセージ、ですが、それは握手の途中に到着した場合、クライアントによって無視されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New handshake message types are assigned by IANA as described in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第12節で説明したように、新しいハンドシェイクメッセージタイプはIANAによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. Hello Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.  helloメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hello phase messages are used to exchange security enhancement capabilities between the client and server. When a new session begins, the record layer&#39;s connection state encryption, hash, and compression algorithms are initialized to null. The current connection state is used for renegotiation messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハロー位相メッセージは、クライアントとサーバ間のセキュリティ強化機能を交換するために使用されています。新しいセッションが始まると、記録層の接続状態の暗号化、ハッシュ、および圧縮アルゴリズムはnullに初期化されます。現在の接続状態が再交渉メッセージに使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. Hello Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1。こんにちはリクエスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The HelloRequest message MAY be sent by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HelloRequestメッセージはいつでもサーバによって送信されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HelloRequest is a simple notification that the client should begin the negotiation process anew. In response, the client should send a ClientHello message when convenient. This message is not intended to establish which side is the client or server but merely to initiate a new negotiation. Servers SHOULD NOT send a HelloRequest immediately upon the client&#39;s initial connection. It is the client&#39;s job to send a ClientHello at that time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
HelloRequestは、クライアントが新たに交渉プロセスを開始する必要があり、単純な通知です。都合のよいときに応答して、クライアントはClientHelloメッセージを送信する必要があります。このメッセージは、クライアントまたはサーバーではなく、単に新しい交渉を開始するためにどちら側を確立するものではありません。サーバーは、クライアントの初期接続後すぐにHelloRequestを送るべきではありません。その時点でのClientHelloを送信するために、クライアントの仕事です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This message will be ignored by the client if the client is currently negotiating a session. This message MAY be ignored by the client if it does not wish to renegotiate a session, or the client may, if it wishes, respond with a no_renegotiation alert. Since handshake messages are intended to have transmission precedence over application data, it is expected that the negotiation will begin before no more than a few records are received from the client. If the server sends a HelloRequest but does not receive a ClientHello in response, it may close the connection with a fatal alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントが現在のセッションを交渉している場合、このメッセージはクライアントによって無視されます。それは、セッションを再交渉したくない場合、このメッセージは、クライアントによって無視されてもよいし、クライアントは、それが希望する場合、no_renegotiationのアラートに応答することができます。ハンドシェイクメッセージは、アプリケーションデータを介した送信の優先順位を有することが意図されているので、それを超えない数のレコードがクライアントから受信される前に交渉が開始されることが期待されます。サーバがHelloRequestを送りますが、応答のClientHelloを受信しない場合、それは致命的な警告との接続を閉じることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
After sending a HelloRequest, servers SHOULD NOT repeat the request until the subsequent handshake negotiation is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
その後の握手交渉が完了するまでHelloRequestを送った後、サーバはリクエストを繰り返すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct { } HelloRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This message MUST NOT be included in the message hashes that are maintained throughout the handshake and used in the Finished messages and the certificate verify message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージは、ハンドシェイクを通じて維持し、Finishedメッセージと証明書を確認するメッセージで使用されているメッセージのハッシュに含まれてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. Client Hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2。クライアントこんにちは
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When a client first connects to a server, it is required to send the ClientHello as its first message. The client can also send a ClientHello in response to a HelloRequest or on its own initiative in order to renegotiate the security parameters in an existing connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントが最初のサーバに接続すると、その最初のメッセージとしてのClientHelloを送信するために必要とされます。クライアントはまた、HelloRequestにするか、または既存の接続におけるセキュリティパラメータを再交渉するために自発的に応じてのClientHelloを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The ClientHello message includes a random structure, which is used later in the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ClientHelloメッセージは、プロトコルの後半で使用されるランダム構造を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         struct {
             uint32 gmt_unix_time;
             opaque random_bytes[28];
         } Random;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
gmt_unix_time The current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, UTC, ignoring leap seconds) according to the sender&#39;s internal clock. Clocks are not required to be set correctly by the basic TLS protocol; higher-level or application protocols may define additional requirements. Note that, for historical reasons, the data element is named using GMT, the predecessor of the current worldwide time base, UTC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
送信者の内部クロックに従って（うるう秒を無視して、1970年1月1日、UTCを開始午前0時からの秒）の標準的なUNIX 32ビットフォーマットで現在の時刻と日付をgmt_unix_time。時計は、基本的なTLSプロトコルによって正しく設定されている必要はありません。より高いレベルまたはアプリケーション・プロトコルが追加要件を定義してもよいです。歴史的な理由のために、データ要素は、GMT、現在の世界的な時間ベース、UTCの前身を使用して名前が付けられている、ということに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
random_bytes 28 bytes generated by a secure random number generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
安全な乱数生成器によって生成された28のバイトをrandom_bytes。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ClientHello message includes a variable-length session identifier. If not empty, the value identifies a session between the same client and server whose security parameters the client wishes to reuse. The session identifier MAY be from an earlier connection, this connection, or from another currently active connection. The second option is useful if the client only wishes to update the random structures and derived values of a connection, and the third option makes it possible to establish several independent secure connections without repeating the full handshake protocol. These independent connections may occur sequentially or simultaneously; a SessionID becomes valid when the handshake negotiating it completes with the exchange of Finished messages and persists until it is removed due to aging or because a fatal error was encountered on a connection associated with the session. The actual contents of the SessionID are defined by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ClientHelloメッセージは、可変長のセッション識別子を含みます。空でない場合、値は、セキュリティパラメータ、クライアントが再利用しようと、同じクライアントとサーバ間のセッションを識別する。セッション識別子は、以前の接続、この接続から、または別の現在アクティブな接続からのものであってもよいです。クライアントのみランダム構造や接続の派生値を更新したい、そして第三の選択肢は、完全なハンドシェイクプロトコルを繰り返さずに、いくつかの独立した安全な接続を確立することを可能にする場合は、2番目のオプションが便利です。これらの独立した接続を順次又は同時に起こり得ます。それを交渉のハンドシェイクが完成メッセージの交換を完了し、それが経年や致命的なエラーがセッションに関連付けられている接続に遭遇したため、削除されるまで持続したときにセッションIDが有効になります。セッションIDの実際の内容はサーバーによって定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
opaque SessionID&lt;0..32&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
不透明なセッションID &lt;0 32&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Warning: Because the SessionID is transmitted without encryption or immediate MAC protection, servers MUST NOT place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
警告：セッションIDは、暗号化または即時MAC保護なしで送信されるため、サーバはセッション識別子に秘密情報を置くか、偽のセッション識別子の内容は、セキュリティの違反を引き起こすせてはなりません。 （ハンドシェイクの終了時に交換SessionIDを含む全体としてのハンドシェイクのコンテンツは、Finishedメッセージによって保護されることに注意してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cipher suite list, passed from the client to the server in the ClientHello message, contains the combinations of cryptographic algorithms supported by the client in order of the client&#39;s preference (favorite choice first). Each cipher suite defines a key exchange algorithm, a bulk encryption algorithm (including secret key length), a MAC algorithm, and a PRF. The server will select a cipher suite or, if no acceptable choices are presented, return a handshake failure alert and close the connection. If the list contains cipher suites the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites, and process the remaining ones as usual.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ClientHelloメッセージでクライアントからサーバに渡された暗号スイートのリストは、クライアントの好み（最初のお気に入りの選択）のために、クライアントでサポートされている暗号アルゴリズムの組み合わせが含まれています。各暗号スイートは、鍵交換アルゴリズム、（秘密鍵の長さを含む）をバルク暗号化アルゴリズム、MACアルゴリズム、およびPRFを定義します。サーバーは、暗号スイートを選択するか、受け入れ可能な選択肢が提示されていない場合、handshake_failureアラートを返して接続を閉じます。リストには、暗号スイートが含まれている場合、サーバーは、サポートを認識し、または使用することを望んでいない、サーバーはこれらの暗号スイートを無視して、いつものように残っているものを処理しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      uint8 CipherSuite[2];    /* Cryptographic suite selector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ClientHello includes a list of compression algorithms supported by the client, ordered according to the client&#39;s preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ClientHelloは、クライアントの好みに応じて注文したクライアントでサポートされている圧縮アルゴリズムのリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites&lt;2..2^16-2&gt;;
          CompressionMethod compression_methods&lt;1..2^8-1&gt;;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions&lt;0..2^16-1&gt;;
          };
      } ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS allows extensions to follow the compression_methods field in an extensions block. The presence of extensions can be detected by determining whether there are bytes following the compression_methods at the end of the ClientHello. Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS拡張機能が拡張ブロックに圧縮_フィールドを追跡することができます。拡張の存在はのClientHelloの終わりに圧縮_次のバイトが存在するかどうかを決定することによって検出することができます。任意のデータを検出するこの方法は、可変長フィールドを有する通常のTLS法とは異なるが、拡張が定義される前に、それがTLSとの互換性のために使用されることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client_version The version of the TLS protocol by which the client wishes to communicate during this session. This SHOULD be the latest (highest valued) version supported by the client. For this version of the specification, the version will be 3.3 (see Appendix E for details about backward compatibility).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがこのセッション中に通信することを希望することにより、TLSプロトコルのバージョンをクライアント_。これは、クライアントがサポートする最新（最高のもの）であるべきです。仕様のこのバージョンでは、バージョン3.3が（後方互換性の詳細については、付録Eを参照してください）となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random A client-generated random structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダムクライアントが生成したランダム構造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id The ID of a session the client wishes to use for this connection. This field is empty if no session_id is available, or if the client wishes to generate new security parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、この接続のために使用したいセッションのIDを。 session_idが利用可能でない場合、場合、またはクライアントが新しいセキュリティパラメータを生成することを希望する場合は、このフィールドは空です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suites This is a list of the cryptographic options supported by the client, with the client&#39;s first preference first. If the session_id field is not empty (implying a session resumption request), this vector MUST include at least the cipher_suite from that session. Values are defined in Appendix A.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suitesこれは、最初のクライアントの最初の好みで、クライアントによってサポートされている暗号オプションのリストです。 SESSION_IDフィールドは、（セッション再開要求を意味する）が空でない場合、このベクターは、少なくともそのセッションから暗号_スイートを含まなければなりません。値は、付録A.5で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression_methods This is a list of the compression methods supported by the client, sorted by client preference. If the session_id field is not empty (implying a session resumption request), it MUST include the compression_method from that session. This vector MUST contain, and all implementations MUST support, CompressionMethod.null. Thus, a client and server will always be able to agree on a compression method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
圧縮_これは、クライアントの好みによってソートされたクライアントによってサポートされている圧縮方法のリストです。 SESSION_IDフィールドは、（セッション再開要求を含意して）空でない場合は、そのセッションのcompression_methodを含まなければなりません。このベクターは含まなければならない、とすべての実装は、CompressionMethod.nullをサポートしなければなりません。このように、クライアントとサーバは常に圧縮方法に同意することができるようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extensions Clients MAY request extended functionality from servers by sending data in the extensions field. The actual &#34;Extension&#34; format is defined in Section 7.4.1.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張クライアントは、拡張フィールドにデータを送信することで、サーバからの拡張機能を要求することができます。実際の「拡張」フォーマットは、セクション7.4.1.4で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that a client requests additional functionality using extensions, and this functionality is not supplied by the server, the client MAY abort the handshake. A server MUST accept ClientHello messages both with and without the extensions field, and (as for all other messages) it MUST check that the amount of data in the message precisely matches one of these formats; if not, then it MUST send a fatal &#34;decode_error&#34; alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがサーバによって拡張機能を使用して追加機能を要求し、この機能が提供されていない場合には、クライアントは握手を中止することができます。サーバーは、拡張フィールドを有すると無しの両方のClientHelloメッセージを受け入れなければなりません、そして（他のすべてのメッセージのような）は、メッセージ内のデータの量を正確にこれらの形式のいずれかと一致することをチェックしなければなりません。いない場合、それは致命的な「decode_error」アラートを送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending the ClientHello message, the client waits for a ServerHello message. Any handshake message returned by the server, except for a HelloRequest, is treated as a fatal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ClientHelloメッセージを送信した後、クライアントはServerHelloメッセージを待ちます。 HelloRequestを除いて、サーバーから返された任意のハンドシェイクメッセージは、致命的なエラーとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. Server Hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3。サーバーこんにちは
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server will send this message in response to a ClientHello message when it was able to find an acceptable set of algorithms. If it cannot find such a match, it will respond with a handshake failure alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
許容できるセットのアルゴリズムを見つけることができたとき、サーバはClientHelloメッセージに応答して、このメッセージを送信します。それは、このような一致が見つからない場合は、握手故障警報で応じるでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ProtocolVersion server_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions&lt;0..2^16-1&gt;;
          };
      } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The presence of extensions can be detected by determining whether there are bytes following the compression_method field at the end of the ServerHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張機能の存在は、のServerHelloの終わりに圧縮_フィールドを次のバイトが存在するかどうかを決定することによって検出することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server_version This field will contain the lower of that suggested by the client in the client hello and the highest supported by the server. For this version of the specification, the version is 3.3. (See Appendix E for details about backward compatibility.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SERVER_VERSIONこのフィールドは、クライアントハローにクライアントによって示唆の下を含み、最高サーバによってサポートされます。仕様のこのバージョンでは、バージョンは3.3です。 （後方互換性の詳細については、付録Eを参照してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random This structure is generated by the server and MUST be independently generated from the ClientHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ランダムこの構造は、サーバーによって生成され、独立してClientHello.randomとから生成されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id This is the identity of the session corresponding to this connection. If the ClientHello.session_id was non-empty, the server will look in its session cache for a match. If a match is found and the server is willing to establish the new connection using the specified session state, the server will respond with the same value as was supplied by the client. This indicates a resumed session and dictates that the parties must proceed directly to the Finished messages. Otherwise, this field will contain a different value identifying the new session. The server may return an empty session_id to indicate that the session will not be cached and therefore cannot be resumed. If a session is resumed, it must be resumed using the same cipher suite it was originally negotiated with. Note that there is no requirement that the server resume any session even if it had formerly provided a session_id. Clients MUST be prepared to do a full negotiation -- including negotiating new cipher suites -- during any handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SESSION_IDこれは、この接続に対応するセッションのアイデンティティがあります。 ClientHello.session_idが空だった場合、サーバーは、一致のためにそのセッションキャッシュになります。一致するものが見つかったと、サーバーは、指定されたセッション状態を使用して新しい接続を確立するために喜んでいる場合は、サーバはクライアントによって供給されたのと同じ値で応答します。これは再開しているセッションを示し、当事者が完成メッセージへ進まなければなりません。それ以外の場合、このフィールドには、新しいセッションを特定する別の値が含まれます。サーバーは、セッションがキャッシュされませんので、再開できないことを示すために、空のsession_idを返す場合があります。セッションが再開された場合、それは元々と交渉したのと同じ暗号スイートを使用して再開する必要があります。サーバは、それがかつてのsession_idを提供した場合でも、すべてのセッションを再開する必要はないことに注意してください。任意のハンドシェイク中に - 新しい暗号スイートを交渉含む - クライアントは、完全な交渉を行うために準備しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suite The single cipher suite selected by the server from the list in ClientHello.cipher_suites. For resumed sessions, this field is the value from the state of the session being resumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
でClientHello.cipher_内のリストからサーバーによって選ばれた単一の暗号スイートを暗号_スイート。セッションを再開し、このフィールドは再開されたセッションの状態からの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression_method The single compression algorithm selected by the server from the list in ClientHello.compression_methods. For resumed sessions, this field is the value from the resumed session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ClientHello.compression_メソッドのリストから、サーバによって選択された単一の圧縮アルゴリズムを圧縮_。再開したセッションの場合、このフィールドは再開セッション状態からの値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extensions A list of extensions. Note that only extensions offered by the client can appear in the server&#39;s list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張子のリストを拡張モジュールを。クライアントが提供する唯一の拡張機能は、サーバーのリストに表示されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.4. Hello Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.4。こんにちは拡張機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The extension format is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ExtensionType extension_type;
          opaque extension_data&lt;0..2^16-1&gt;;
      } Extension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          signature_algorithms(13), (65535)
      } ExtensionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ここに：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- &#34;extension_type&#34; identifies the particular extension type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 「EXTENSION_TYPE」は、特定の拡張子の型を識別する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- &#34;extension_data&#34; contains information specific to the particular extension type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 「拡大」は、特定の拡張子の種類に固有の情報が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial set of extensions is defined in a companion document [TLSEXT]. The list of extension types is maintained by IANA as described in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拡張子の最初のセットは仲間ドキュメント[TLSEXT]で定義されています。項12に記載のように拡張タイプのリストはIANAによって維持されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension type MUST NOT appear in the ServerHello unless the same extension type appeared in the corresponding ClientHello. If a client receives an extension type in ServerHello that it did not request in the associated ClientHello, it MUST abort the handshake with an unsupported_extension fatal alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じ拡張型が対応するのClientHelloに登場しない限り、拡張型はServerHelloメッセージに現れてはいけません。クライアントは、それが関連付けられているのClientHelloには要求しなかったというのServerHelloで拡張タイプを受信した場合、それはunsupported_extension致命的な警告と握手を中止しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nonetheless, &#34;server-oriented&#34; extensions may be provided in the future within this framework. Such an extension (say, of type x) would require the client to first send an extension of type x in a ClientHello with empty extension_data to indicate that it supports the extension type. In this case, the client is offering the capability to understand the extension type, and the server is taking the client up on its offer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それにもかかわらず、「サーバー志向」の拡張機能は、この枠組みの中で、将来的に提供することができます。 （タイプxの言う、）このような拡張は最初、それは拡張タイプをサポートすることを示すために、空の拡大とのClientHelloにタイプXの拡張を送信するためにクライアントが必要となります。この場合、クライアントは、拡張タイプを理解するための機能を提供して、サーバはその申し出にクライアントを取っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When multiple extensions of different types are present in the ClientHello or ServerHello messages, the extensions MAY appear in any order. There MUST NOT be more than one extension of the same type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
異なる種類の複数の拡張子はのClientHelloかのServerHelloメッセージ内に存在する場合、拡張子は任意の順序で表示されることがあります。同じタイプの複数の拡張機能があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, note that extensions can be sent both when starting a new session and when requesting session resumption. Indeed, a client that requests session resumption does not in general know whether the server will accept this request, and therefore it SHOULD send the same extensions as it would send if it were not attempting resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、新しいセッションを開始するときに、セッション再開を要求するときに拡張子を両方送ることができることに注意してください。実際、セッションの再開を要求するクライアントは、一般的には、サーバがこの要求を受け入れるかどうかわからないので、それが再開を試みていなかったならば、それは送るのと同じ拡張子を送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, the specification of each extension type needs to describe the effect of the extension both during full handshake and session resumption. Most current TLS extensions are relevant only when a session is initiated: when an older session is resumed, the server does not process these extensions in Client Hello, and does not include them in Server Hello. However, some extensions may specify different behavior during session resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的に、各拡張型の仕様は、完全ハンドシェイク、セッション再開時の両方拡張の効果を説明する必要があります。古いセッションが再開されたとき、サーバは、こんにちはClientでこれらの拡張機能を処理しないと、サーバーのHelloでそれらが含まれていません：ほとんどの現在のTLS拡張は、セッションが開始されている場合にのみ関連しています。しかし、いくつかの拡張機能は、セッション再開時に異なる動作を指定することもできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are subtle (and not so subtle) interactions that may occur in this protocol between new features and existing features which may result in a significant reduction in overall security. The following considerations should be taken into account when designing new extensions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新機能と全体的なセキュリティの大幅な削減をもたらすことができる既存の機能の間でこのプロトコルで発生する可能性があり、微妙な（そしてそれほど微妙ではない）の相互作用があります。新しい拡張機能を設計する際に、以下の考慮事項を考慮に入れるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Some cases where a server does not agree to an extension are error conditions, and some are simply refusals to support particular features. In general, error alerts should be used for the former, and a field in the server extension response for the latter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - サーバが延長に同意しないいくつかの例は、エラー条件であり、いくつかは、特定の機能をサポートするために、単純に拒否されています。一般的に、エラー警告は、後者のためにサーバ拡張応答の元、およびフィールドのために使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Extensions should, as far as possible, be designed to prevent any attack that forces use (or non-use) of a particular feature by manipulation of handshake messages. This principle should be followed regardless of whether the feature is believed to cause a security problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 拡張機能は、可能な限り、握手メッセージの操作によって特定の機能の使用（または非使用）を強制的に任意の攻撃を防ぐように設計されなければなりません。この原則は関係なく、機能はセキュリティ上の問題を引き起こすと考えられているかどうかの従うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase. Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
多くの場合、拡張フィールドがFinishedメッセージハッシュへの入力に含まれているという事実は十分であろうが、拡張子がハンドシェイクフェーズで送信されたメッセージの意味を変更したときに細心の注意が必要です。設計者と実装者は、ハンドシェイクが認証されるまで、アクティブな攻撃者がメッセージを変更し、挿入、削除、または拡張を置き換えることができるという事実に注意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- It would be technically possible to use extensions to change major aspects of the design of TLS; for example the design of cipher suite negotiation. This is not recommended; it would be more appropriate to define a new version of TLS -- particularly since the TLS handshake algorithms have specific protection against version rollback attacks based on the version number, and the possibility of version rollback should be a significant consideration in any major design change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLSの設計の主要な側面を変更する拡張機能を使用することは技術的には可能だろう。例えば暗号スイートのネゴシエーションのデザイン。これはお勧めしません。 TLSの新しいバージョンを定義するのがより適切であろう -  TLSハンドシェイクアルゴリズムは、バージョン番号に基づくバージョンロールバック攻撃に対する特定の保護を持っている、特に以来、バージョンロールバックの可能性は、すべての主要な設計変更で重要な考慮事項でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.4.1. Signature Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.4.1。署名アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client uses the &#34;signature_algorithms&#34; extension to indicate to the server which signature/hash algorithm pairs may be used in digital signatures. The &#34;extension_data&#34; field of this extension contains a &#34;supported_signature_algorithms&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、署名/ハッシュアルゴリズム対がデジタル署名に使用することができるサーバに示すために、「signature_algorithms」拡張子を使用します。この拡張機能の「拡大」フィールドが「supported_signature_algorithms」の値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
          sha512(6), (255)
      } HashAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
        SignatureAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
            HashAlgorithm hash;
            SignatureAlgorithm signature;
      } SignatureAndHashAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SignatureAndHashAlgorithm supported_signature_algorithms&lt;2..2^16-2&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SignatureAndHashAlgorithmのsupported_signature_algorithms &lt;2..2 ^ 16-2&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each SignatureAndHashAlgorithm value lists a single hash/signature pair that the client is willing to verify. The values are indicated in descending order of preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各SignatureAndHashAlgorithm値は、クライアントが確認する意思があることを単一のハッシュ/署名のペアを示しています。値は優先の降順で示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Because not all signature algorithms and hash algorithms may be accepted by an implementation (e.g., DSA with SHA-1, but not SHA-256), algorithms here are listed in pairs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：いないすべての署名アルゴリズムとハッシュアルゴリズムが実装（SHA-1、例えば、DSAはなく、SHA-256）によって受け入れられる可能性があるため、ここでのアルゴリズムは、ペアに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash This field indicates the hash algorithm which may be used. The values indicate support for unhashed data, MD5 [MD5], SHA-1, SHA-224, SHA-256, SHA-384, and SHA-512 [SHS], respectively. The &#34;none&#34; value is provided for future extensibility, in case of a signature algorithm which does not require hashing before signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハッシュこのフィールドを使用することができるハッシュアルゴリズムを示します。値はそれぞれ未ハッシュのデータのためのサポート、MD5 [MD5]、SHA-1、SHA-224、SHA-256、SHA-384およびSHA-512 [SHS]を、示しています。 「なし」の値を署名する前にハッシュを必要としない署名アルゴリズムの場合には、将来の拡張のために提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature This field indicates the signature algorithm that may be used. The values indicate anonymous signatures, RSASSA-PKCS1-v1_5 [PKCS1] and DSA [DSS], and ECDSA [ECDSA], respectively. The &#34;anonymous&#34; value is meaningless in this context but used in Section 7.4.3. It MUST NOT appear in this extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名このフィールドは使用されてもよい署名アルゴリズムを示しています。値は、それぞれ、RSASSA-PKCS1-v1_5の[PKCS1]、匿名署名を示し、DSA [DSS]、及びECDSA [ECDSA]。 「匿名」の値は、この文脈では無意味が、7.4.3で使用しています。それは、この拡張に現れてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The semantics of this extension are somewhat complicated because the cipher suite indicates permissible signature algorithms but not hash algorithms. Sections 7.4.2 and 7.4.3 describe the appropriate rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この拡張機能のセマンティクスは暗号スイートが許容署名アルゴリズムを示しているため、やや複雑であるが、アルゴリズムをハッシュません。セクション7.4.2と7.4.3は、適切なルールを記述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client supports only the default hash and signature algorithms (listed in this section), it MAY omit the signature_algorithms extension. If the client does not support the default algorithms, or supports other hash and signature algorithms (and it is willing to use them for verifying messages sent by the server, i.e., server certificates and server key exchange), it MUST send the signature_algorithms extension, listing the algorithms it is willing to accept.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが（このセクションに記載されている）のみデフォルトのハッシュと署名アルゴリズムをサポートしている場合、それはsignature_algorithms拡張子を省略することができます。クライアントは、デフォルトのアルゴリズムをサポートする、または他のハッシュと署名アルゴリズムをサポートしています（そしてサーバ、すなわち、サーバ証明書とサーバキー交換により送信されたメッセージを確認するためにそれらを使用する意思がある）、しない場合には、signature_algorithms拡張子を送らなければなりませんアルゴリズムをリスト受け入れていく所存です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client does not send the signature_algorithms extension, the server MUST do the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがsignature_algorithmsの拡張子を送信しない場合、サーバーは、以下を行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- If the negotiated key exchange algorithm is one of (RSA, DHE_RSA, DH_RSA, RSA_PSK, ECDH_RSA, ECDHE_RSA), behave as if client had sent the value {sha1,rsa}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - ネゴシエートされた鍵交換アルゴリズムは、（RSA、DHE_RSA、DH_RSA、RSA_PSK、ECDH_RSA、ECDHE_RSA）のいずれかである場合、クライアントは値{SHA1、RSA}を送信したかのように振る舞います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- If the negotiated key exchange algorithm is one of (DHE_DSS, DH_DSS), behave as if the client had sent the value {sha1,dsa}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - ネゴシエートされた鍵交換アルゴリズムは、（DHE_DSS、DH_DSS）のいずれかである場合、クライアントは値{SHA1、DSA}を送信したかのように振る舞います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- If the negotiated key exchange algorithm is one of (ECDH_ECDSA, ECDHE_ECDSA), behave as if the client had sent value {sha1,ecdsa}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - ネゴシエートされた鍵交換アルゴリズムは、（ECDH_ECDSA、ECDHE_ECDSA）のいずれかである場合、クライアントは値{SHA1、ECDSA}を送信したかのように振る舞います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: this is a change from TLS 1.1 where there are no explicit rules, but as a practical matter one can assume that the peer supports MD5 and SHA-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：これは明示的なルールが存在しないTLS 1.1からの変更ですが、実際問題として1がピアがMD5とSHA-1をサポートしていることを前提とすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: this extension is not meaningful for TLS versions prior to 1.2. Clients MUST NOT offer it if they are offering prior versions. However, even if clients do offer it, the rules specified in [TLSEXT] require servers to ignore extensions they do not understand.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：この拡張機能は、1.2より前TLSのバージョンにはあまり意味がありません。彼らは以前のバージョンを提供している場合、クライアントはそれを提供してはいけません。しかし、クライアントはそれを提供ない場合でも、[TLSEXT]で指定されたルールは、彼らが理解していない拡張子を無視するようにサーバーを必要としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Servers MUST NOT send this extension. TLS servers MUST support receiving this extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバはこの拡張機能を送ってはいけません。 TLSサーバは、この拡張を受けるサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When performing session resumption, this extension is not included in Server Hello, and the server ignores the extension in Client Hello (if present).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの再開を行う場合には、この拡張機能は、こんにちはサーバに含まれており、サーバはクライアントのHello（存在する場合）に延長を無視されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. Server Certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. サーバー証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except DH_anon). This message will always immediately follow the ServerHello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
合意された鍵交換方式は、認証に証明書を使用するたびサーバーが（これはDH_anon除いて、この文書で定義されたすべての鍵交換方法を含みます）Certificateメッセージを送らなければなりません。このメッセージは、常にすぐにServerHelloメッセージに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This message conveys the server&#39;s certificate chain to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このメッセージは、クライアントにサーバーの証明書チェーンを伝えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The certificate MUST be appropriate for the negotiated cipher suite&#39;s key exchange algorithm and any negotiated extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
証明書は、交渉された暗号スイートの鍵交換アルゴリズムとどんな交渉さの拡張のために適切でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
opaque ASN.1Cert&lt;1..2^24-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
不透明ASN.1Cert &lt;1..2 ^ 24-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
      } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_list This is a sequence (chain) of certificates. The sender&#39;s certificate MUST come first in the list. Each following certificate MUST directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority MAY be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_listこれは、証明書のシーケンス（連鎖）です。送信者の証明書は、リストの最初に来なければなりません。それぞれの次の証明書は直接それに先行するものを証明する必要があります。証明書の検証がルートキーが独立して分散されている必要があるため、ルート証明機関を指定し、自己署名証明書は、リモートエンドがすでにどのような場合に、それを検証するために、それを持っていなければならないという仮定の下で、チェーンから省略されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same message type and structure will be used for the client&#39;s response to a certificate request message. Note that a client MAY send no certificates if it does not have an appropriate certificate to send in response to the server&#39;s authentication request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じメッセージタイプと構造は、証明書要求メッセージに対するクライアントの応答のために使用されます。それは、サーバーの認証要求に応答して送信するための適切な証明書を持っていない場合、クライアントは何の証明書を送信しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: PKCS #7 [PKCS7] is not used as the format for the certificate vector because PKCS #6 [PKCS6] extended certificates are not used. Also, PKCS #7 defines a SET rather than a SEQUENCE, making the task of parsing the list more difficult.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：PKCS＃6 [PKCS6】拡張証明書が使用されないので、PKCS＃7 [PKCS7]は、証明書ベクトルの形式として使用されていません。また、PKCS＃7は、リストを解析する作業がより困難に、SETはなくSEQUENCEを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules apply to the certificates sent by the server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の規則は、サーバから送信された証明書に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The certificate type MUST be X.509v3, unless explicitly negotiated otherwise (e.g., [TLSPGP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 明示的に（例えば、[TLSPGP]）ネゴシエートしない限り、証明書の種類は、のX.509v3なければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The end entity certificate&#39;s public key (and associated restrictions) MUST be compatible with the selected key exchange algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - エンドエンティティ証明書の公開鍵（および関連する制限は）選択されたキー交換アルゴリズムと互換性がなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Key Exchange Alg. Certificate Key Type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
鍵交換ALG。証明書キーの種類
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RSA RSA public key; the certificate MUST allow the RSA_PSK key to be used for encryption (the keyEncipherment bit MUST be set if the key usage extension is present). Note: RSA_PSK is defined in [TLSPSK].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RSA RSA公開鍵。証明書は、（鍵用途拡張が存在する場合keyEnciphermentビットが設定されなければならない）RSA_PSKキーが暗号化に使用されることを可能にしなければなりません。注：RSA_PSKは[TLSPSK]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DHE_RSA RSA public key; the certificate MUST allow the ECDHE_RSA key to be used for signing (the digitalSignature bit MUST be set if the key usage extension is present) with the signature scheme and hash algorithm that will be employed in the server key exchange message. Note: ECDHE_RSA is defined in [TLSECC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DHE_RSA RSA公開鍵。証明書は、サーバ鍵交換メッセージにおいて使用される署名方式やハッシュアルゴリズムを用いて（鍵使用拡張が存在する場合にデジタル署名ビットを設定しなければなりません）ECDHE_RSAキーが署名に使用されることを可能にしなければなりません。注：ECDHE_RSAは[TLSECC]で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DHE_DSS DSA public key; the certificate MUST allow the key to be used for signing with the hash algorithm that will be employed in the server key exchange message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DHE_DSS DSA公開鍵。証明書は、鍵がサーバ鍵交換メッセージに使用されるであろうハッシュアルゴリズムと契約するために使用されることを許容しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DH_DSS Diffie-Hellman public key; the keyAgreement bit DH_RSA MUST be set if the key usage extension is present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DH_DSSのDiffie-Hellman公開鍵。するKeyAgreementは、鍵用途拡張が存在する場合DH_RSAを設定しなければならないビット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ECDH_ECDSA ECDH-capable public key; the public key MUST ECDH_RSA use a curve and point format supported by the client, as described in [TLSECC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ECDH_ECDSA ECDH対応する公開鍵。 【TLSECC]に記載されているように公開鍵ECDH_RSAは、クライアントによってサポートされた曲線と点フォーマットを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ECDHE_ECDSA ECDSA-capable public key; the certificate MUST allow the key to be used for signing with the hash algorithm that will be employed in the server key exchange message. The public key MUST use a curve and point format supported by the client, as described in [TLSECC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ECDHE_ECDSA ECDSA対応する公開鍵。証明書は、鍵がサーバ鍵交換メッセージに使用されるであろうハッシュアルゴリズムと契約するために使用されることを許容しなければなりません。 【TLSECC]に記載されているように公開鍵は、クライアントによってサポートされた曲線と点フォーマットを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The &#34;server_name&#34; and &#34;trusted_ca_keys&#34; extensions [TLSEXT] are used to guide certificate selection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 「サーバ名」と「trusted_ca_keys」拡張子[TLSEXT]は、証明書の選択を導くために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client provided a &#34;signature_algorithms&#34; extension, then all certificates provided by the server MUST be signed by a hash/signature algorithm pair that appears in that extension. Note that this implies that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with a DSA key). This is a departure from TLS 1.1, which required that the algorithms be the same. Note that this also implies that the DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA key exchange algorithms do not restrict the algorithm used to sign the certificate. Fixed DH certificates MAY be signed with any hash/signature algorithm pair appearing in the extension. The names DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA are historical.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが「signature_algorithms」の拡張子を提供する場合、サーバが提供するすべての証明書は、その拡張子に表示されたハッシュ/署名アルゴリズムペアによって署名されなければなりません。これは1つの署名アルゴリズムのための鍵を含む証明書は、（例えば、DSA鍵で署名されたRSA鍵）異なる署名アルゴリズムを使用して署名されてもよいことを意味することに注意してください。これは、アルゴリズムは同じである必要はTLS 1.1からの逸脱です。これはまたDH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSA鍵交換アルゴリズムが証明書に署名するために使用されるアルゴリズムを制限しないことを意味することに注意してください。固定DH証明書は、拡張中に現れる任意のハッシュ/署名アルゴリズムペアで署名されるかもしれません。名前DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSAは歴史があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server has multiple certificates, it chooses one of them based on the above-mentioned criteria (in addition to other criteria, such as transport layer endpoint, local configuration and preferences, etc.). If the server has a single certificate, it SHOULD attempt to validate that it meets these criteria.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバが複数の証明書を持っている場合、それは（例えば、トランスポート層エンドポイント、ローカル設定と好み、等のような他の基準に加えて）上記の基準に基づいて、それらの一つが選択します。サーバが単一の証明書を持っている場合、それはこれらの基準を満たしているかどうかを検証しようとすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there are certificates that use algorithms and/or algorithm combinations that cannot be currently used with TLS. For example, a certificate with RSASSA-PSS signature key (id-RSASSA-PSS OID in SubjectPublicKeyInfo) cannot be used because TLS defines no corresponding signature algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在TLSで使用することはできませんアルゴリズムおよび/またはアルゴリズムの組み合わせを使用する証明書があることに注意してください。 TLSは、該当する署名アルゴリズムを定義していないので、例えば、RSASSA-PSS署名キー（SubjectPublicKeyInfoでのid-RSASSA-PSS OID）を持つ証明書を使用することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As cipher suites that specify new key exchange methods are specified for the TLS protocol, they will imply the certificate format and the required encoded keying information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい鍵交換方法を指定する暗号スイートは、TLSプロトコルに指定されているとして、彼らは、証明書の形式と必要なエンコードされたキーイング情報を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. Server Key Exchange Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. サーバー鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This message will be sent immediately after the server Certificate message (or the ServerHello message, if this is an anonymous negotiation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
（これが匿名の交渉である場合、またはServerHelloメッセージ）このメッセージは、サーバ証明書のメッセージの直後に送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The ServerKeyExchange message is sent by the server only when the server Certificate message (if sent) does not contain enough data to allow the client to exchange a premaster secret. This is true for the following key exchange methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ServerKeyExchangeメッセージは、サーバ証明書のメッセージ（送信された場合は）クライアントが前マスター秘密を交換することを可能にするための十分なデータが含まれていない場合にのみ、サーバーによって送信されます。これは、次の鍵交換方法についても同様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
DHE_DSS DHE_RSA DH_anon
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
DHE_DSS DHE_RSA DH_anon
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
It is not legal to send the ServerKeyExchange message for the following key exchange methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
次の鍵交換方式のためServerKeyExchangeメッセージを送信するために法的ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
RSA DH_DSS DH_RSA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
RSA DH_DSS DH_RSA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Other key exchange algorithms, such as those defined in [TLSECC], MUST specify whether the ServerKeyExchange message is sent or not; and if the message is sent, its contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このような【TLSECC]で定義されたものなどの他の鍵交換アルゴリズムは、ServerKeyExchangeメッセージが送信されているか否かを指定する必要があります。メッセージは、その内容を送信している場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This message conveys cryptographic information to allow the client to communicate the premaster secret: a Diffie-Hellman public key with which the client can complete a key exchange (with the result being the premaster secret) or a public key for some other algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントは、またはいくつかの他のアルゴリズムの公開鍵（このpremaster_secretされた結果との）鍵交換を完了することができたを使ってDiffie-Hellman公開鍵：このメッセージは、クライアントはプリマスターシークレットを通信できるようにする暗号情報を伝えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
            /* may be extended, e.g., for ECDH -- see [TLSECC] */
           } KeyExchangeAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque dh_p&lt;1..2^16-1&gt;;
          opaque dh_g&lt;1..2^16-1&gt;;
          opaque dh_Ys&lt;1..2^16-1&gt;;
      } ServerDHParams;     /* Ephemeral DH parameters */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
dh_p The prime modulus used for the Diffie-Hellman operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Diffie-Hellman演算に使用されるプライムモジュラスをdh_p。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
dh_g The generator used for the Diffie-Hellman operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Diffie-Hellman演算に使用される発電機をdh_g。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
dh_Ys The server&#39;s Diffie-Hellman public value (g^X mod p).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーののDiffie-Hellman公開値（g ^ Xモッズp）dh_Ys。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (KeyExchangeAlgorithm) {
              case dh_anon:
                  ServerDHParams params;
              case dhe_dss:
              case dhe_rsa:
                  ServerDHParams params;
                  digitally-signed struct {
                      opaque client_random[32];
                      opaque server_random[32];
                      ServerDHParams params;
                  } signed_params;
              case rsa:
              case dh_dss:
              case dh_rsa:
                  struct {} ;
                 /* message is omitted for rsa, dh_dss, and dh_rsa */
              /* may be extended, e.g., for ECDH -- see [TLSECC] */
          };
      } ServerKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
params The server&#39;s key exchange parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバの鍵交換パラメータをparamsは。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
signed_params For non-anonymous key exchanges, a signature over the server&#39;s key exchange parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
非匿名鍵交換のためにsigned_pa​​rams、サーバの鍵交換パラメータを超える署名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has offered the &#34;signature_algorithms&#34; extension, the signature algorithm and hash algorithm MUST be a pair listed in that extension. Note that there is a possibility for inconsistencies here. For instance, the client might offer DHE_DSS key exchange but omit any DSA pairs from its &#34;signature_algorithms&#34; extension. In order to negotiate correctly, the server MUST check any candidate cipher suites against the &#34;signature_algorithms&#34; extension before selecting them. This is somewhat inelegant but is a compromise designed to minimize changes to the original cipher suite design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが「signature_algorithms」の拡張子を提供している場合は、署名アルゴリズムとハッシュアルゴリズムは、その拡張子に記載されているペアでなければなりません。ここでの矛盾の可能性があることに注意してください。例えば、クライアントはDHE_DSS鍵交換を提供するかもしれないが、その「signature_algorithms」拡張子から任意のDSAのペアを省略します。正しく交渉するためには、サーバーは、それらを選択する前に「signature_algorithms」拡張子に対してどの候補暗号スイートをチェックしなければなりません。これはやや無粋ですが、元の暗号スイートデザインへの変更を最小限に抑えるように設計された妥協案です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the hash and signature algorithms MUST be compatible with the key in the server&#39;s end-entity certificate. RSA keys MAY be used with any permitted hash algorithm, subject to restrictions in the certificate, if any.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、ハッシュおよび署名アルゴリズムはサーバのエンドエンティティ証明書内のキーと適合性でなければなりません。 RSAキーが存在する場合、証明書内の制約を受け、任意の許可されたハッシュアルゴリズムで使用されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because DSA signatures do not contain any secure indication of hash algorithm, there is a risk of hash substitution if multiple hashes may be used with any key. Currently, DSA [DSS] may only be used with SHA-1. Future revisions of DSS [DSS-3] are expected to allow the use of other digest algorithms with DSA, as well as guidance as to which digest algorithms should be used with each key size. In addition, future revisions of [PKIX] may specify mechanisms for certificates to indicate which digest algorithms are to be used with DSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DSA署名は、ハッシュアルゴリズムのいずれかの安全な表示を含んでいないので、複数のハッシュは、任意のキーと一緒に使用することができる場合は、ハッシュ置換の危険性があります。現在、DSA [DSS]はSHA-1でのみ使用されてもよいです。 DSS [DSS-3]の将来の改訂は、ダイジェストアルゴリズムは、各キーサイズで使用されるべきであるようにDSAを有する他のダイジェストアルゴリズムの使用、ならびにガイダンスを可能にすることが期待されます。また、[PKIX]の今後の改正は、ダイジェストアルゴリズムがDSAと共に使用されるかを示すために証明書のメカニズムを指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As additional cipher suites are defined for TLS that include new key exchange algorithms, the server key exchange message will be sent if and only if the certificate type associated with the key exchange algorithm does not provide enough information for the client to exchange a premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加の暗号スイートは、新しい鍵交換アルゴリズムを含むTLSのために定義されているように、サーバ鍵交換メッセージが送信されます場合は、キー交換アルゴリズムに関連付けられた証明書の種類がプレマスターの秘密を交換するためのクライアントのための十分な情報を提供しない場合にのみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. Certificate Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. 証明書要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       A non-anonymous server can optionally request a certificate from
       the client, if appropriate for the selected cipher suite.  This
       message, if sent, will immediately follow the ServerKeyExchange
       message (if it is sent; otherwise, this message follows the
       server&#39;s Certificate message).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
          rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
          fortezza_dms_RESERVED(20), (255)
      } ClientCertificateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
opaque DistinguishedName&lt;1..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
不透明な識別名&lt;1..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
          SignatureAndHashAlgorithm
            supported_signature_algorithms&lt;2^16-1&gt;;
          DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
      } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_types A list of the types of certificate types that the client may offer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが提供する証明書の種類のタイプのリストを証明書_。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         rsa_sign        a certificate containing an RSA key
         dss_sign        a certificate containing a DSA key
         rsa_fixed_dh    a certificate containing a static DH key.
         dss_fixed_dh    a certificate containing a static DH key
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
supported_signature_algorithms A list of the hash/signature algorithm pairs that the server is able to verify, listed in descending order of preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは優先の降順でリストされ、確認することができるハッシュ/署名アルゴリズムペアのリストをsupported_signature_algorithms。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_authorities A list of the distinguished names [X501] of acceptable certificate_authorities, represented in DER-encoded format. These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used to describe known roots as well as a desired authorization space. If the certificate_authorities list is empty, then the client MAY send any certificate of the appropriate ClientCertificateType, unless there is some external arrangement to the contrary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DER符号化された形式で表さ許容される証明して、の識別名[X501]のリストを証明してください。これらの識別名は、ルートCAまたは下位CAのために必要な識別名を指定することもできます。したがって、このメッセージは、既知の根ならびに所望の許可スペースを記述するために使用することができます。証明してリストが空の場合は逆に、いくつかの外部の配列が存在しない限り、クライアントは、適切なClientCertificateTypeのいずれかの証明書を送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The interaction of the certificate_types and supported_signature_algorithms fields is somewhat complicated. certificate_types has been present in TLS since SSLv3, but was somewhat underspecified. Much of its functionality is superseded by supported_signature_algorithms. The following rules apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書_とsupported_signature_algorithms分野の相互作用はやや複雑です。証明書_はのSSLv3以来TLSに存在しているが、ややunderspecifiedされました。その機能の多くはsupported_signature_algorithmsに取って代わられます。次の規則が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Any certificates provided by the client MUST be signed using a hash/signature algorithm pair found in supported_signature_algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - クライアントによって提供された証明書はsupported_signature_algorithmsに見出されるハッシュ/署名アルゴリズムペアを使用して署名されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The end-entity certificate provided by the client MUST contain a key that is compatible with certificate_types. If the key is a signature key, it MUST be usable with some hash/signature algorithm pair in supported_signature_algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - クライアントが提供するエンドエンティティ証明書は、証明書_と互換性のあるキーを含まなければなりません。キーは、署名鍵である場合、それはsupported_signature_algorithmsの一部のハッシュ/署名アルゴリズムペアで使用可能でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- For historical reasons, the names of some client certificate types include the algorithm used to sign the certificate. For example, in earlier versions of TLS, rsa_fixed_dh meant a certificate signed with RSA and containing a static DH key. In TLS 1.2, this functionality has been obsoleted by the supported_signature_algorithms, and the certificate type no longer restricts the algorithm used to sign the certificate. For example, if the server sends dss_fixed_dh certificate type and {{sha1, dsa}, {sha1, rsa}} signature types, the client MAY reply with a certificate containing a static DH key, signed with RSA-SHA1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 歴史的な理由のために、いくつかのクライアント証明書の種類の名前は、証明書に署名するために使用されるアルゴリズムが含まれます。例えば、TLSの以前のバージョンでは、rsa_fixed_dhはRSAで署名された証明書および静的DHキーを含むを意味します。 TLS 1.2では、この機能はsupported_signature_algorithmsによって廃止されていない、と証明書の種類は、もはや証明書の署名に使用するアルゴリズムを制限します。サーバは、証明書の種類とdss_fixed_dh送信たとえば、{{SHA1、DSAを}、{SHA1、RSA}}署名タイプを、クライアントはRSA-SHA1で署名された静的DHキーを含む証明書で応答することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New ClientCertificateType values are assigned by IANA as described in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第12節で説明したように、新たなClientCertificateType値はIANAによって割り当てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Values listed as RESERVED may not be used. They were used in SSLv3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：RESERVEDとして記載されている値が使用されない場合があります。彼らは、SSLv3の中で使用されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: It is a fatal handshake_failure alert for an anonymous server to request client authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：これは、クライアント認証を要求する匿名サーバーのための致命的なhandshake_failureアラートとなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. Server Hello Done
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5.  Serverは、こんにちは完了します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The ServerHelloDone message is sent by the server to indicate the end of the ServerHello and associated messages. After sending this message, the server will wait for a client response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ServerHelloDoneメッセージはのServerHelloと関連メッセージの終わりを示すために、サーバによって送信されます。このメッセージを送信した後、サーバーは、クライアントの応答を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This message means that the server is done sending messages to support the key exchange, and the client can proceed with its phase of the key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このメッセージは、サーバが鍵交換をサポートするために、メッセージを送信して行われていることを意味し、クライアントは、鍵交換のその段階に進むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Upon receipt of the ServerHelloDone message, the client SHOULD verify that the server provided a valid certificate, if required, and check that the server hello parameters are acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ServerHelloDoneメッセージを受信すると、クライアントは必要に応じて、サーバーが有効な証明書を提供していることを確認し、サーバーハローパラメータが許容可能であることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct { } ServerHelloDone;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.6. Client Certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.6. クライアント証明書
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This is the first message the client can send after receiving a ServerHelloDone message. This message is only sent if the server requests a certificate. If no suitable certificate is available, the client MUST send a certificate message containing no certificates. That is, the certificate_list structure has a length of zero. If the client does not send any certificates, the server MAY at its discretion either continue the handshake without client authentication, or respond with a fatal handshake_failure alert. Also, if some aspect of the certificate chain was unacceptable (e.g., it was not signed by a known, trusted CA), the server MAY at its discretion either continue the handshake (considering the client unauthenticated) or send a fatal alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
これは、クライアントがServerHelloDoneメッセージを受信した後に送ることができる最初のメッセージです。サーバーが証明書を要求した場合、このメッセージにのみ送信されます。もし適切な証明書が利用できない場合、クライアントは証明書を全く含まない証明書メッセージを送らなければなりません。つまり、certificate_list構造は、ゼロの長さを有します。クライアントが証明書を送信しない場合、サーバーは、その裁量で、クライアント認証なしで握手を続けるか、致命的な握手_アラートに応答することができます。証明書チェーンの一部の側面が受け入れられなかった場合にも、その裁量で握手を続けるかもしれないいずれかのサーバが（認証されていないクライアントを考慮して）、（例えば、それは知らによって署名されていなかった、CAの信頼できる）、または致命的なアラートを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Client certificates are sent using the Certificate structure defined in Section 7.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアント証明書は、セクション7.4.2で定義された証明書の構造を使用して送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This message conveys the client&#39;s certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie-Hellman). The certificate MUST be appropriate for the negotiated cipher suite&#39;s key exchange algorithm, and any negotiated extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このメッセージは、サーバーへのクライアントの証明書チェーンを伝えます。 （クライアント認証が署名に基づいています）CertificateVerifyメッセージを確認するか（非はかないディフィー・ヘルマン用）プリマスターシークレットを計算するときに、サーバーはそれを使用します。証明書は、交渉された暗号スイートの鍵交換アルゴリズム、およびどんな交渉さの拡張のために適切でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The certificate type MUST be X.509v3, unless explicitly negotiated otherwise (e.g., [TLSPGP]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 明示的に（例えば、[TLSPGP]）ネゴシエートしない限り、証明書の種類は、のX.509v3なければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The end-entity certificate&#39;s public key (and associated restrictions) has to be compatible with the certificate types listed in CertificateRequest:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - エンドエンティティ証明書の公開鍵（および関連する制限）証明書要求に記載されている証明書の種類と互換性がなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Client Cert. Type Certificate Key Type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアント証明書。証明書キーの種類を入力
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rsa_sign RSA public key; the certificate MUST allow the key to be used for signing with the signature scheme and hash algorithm that will be employed in the certificate verify message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RSA公開鍵をrsa_sign。証明書は、鍵が証明書検証メッセージに使用される署名方式やハッシュアルゴリズムを用いて署名するために使用されることを可能にしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
dss_sign DSA public key; the certificate MUST allow the key to be used for signing with the hash algorithm that will be employed in the certificate verify message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
dss_sign DSA公開鍵。証明書は、鍵が証明書検証メッセージで使用されるハッシュアルゴリズムを用いて署名するために使用されることを可能にしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ecdsa_sign ECDSA-capable public key; the certificate MUST allow the key to be used for signing with the hash algorithm that will be employed in the certificate verify message; the public key MUST use a curve and point format supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ecdsa_sign ECDSA対応する公開鍵。証明書は、鍵が証明書検証メッセージで使用されるハッシュアルゴリズムを用いて署名するために使用されることを可能にしなければなりません。公開鍵は、サーバーでサポートされている曲線とポイント形式を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rsa_fixed_dh Diffie-Hellman public key; MUST use the same dss_fixed_dh parameters as server&#39;s key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rsa_fixed_dhのDiffie-Hellman公開鍵。サーバーの鍵と同じdss_fixed_dhパラメータを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rsa_fixed_ecdh ECDH-capable public key; MUST use the ecdsa_fixed_ecdh same curve as the server&#39;s key, and MUST use a point format supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
rsa_fixed_ecdh ECDH対応する公開鍵。サーバーの鍵とecdsa_fixed_ecdh同じカーブを使用しなければならないし、サーバーでサポートされている小数点形式を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- If the certificate_authorities list in the certificate request message was non-empty, one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - 証明書要求メッセージに証明してリストが空だった場合、証明書チェーン内の証明書のいずれかが記載されているCAのいずれかによって発行されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The certificates MUST be signed using an acceptable hash/ signature algorithm pair, as described in Section 7.4.4. Note that this relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - セクション7.4.4で説明したように、証明書は、許容されるハッシュ/署名アルゴリズムペアを使用して署名されなければなりません。これは、TLSの以前のバージョンで見つかった証明書署名アルゴリズムの制約を緩和することに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that, as with the server certificate, there are certificates that use algorithms/algorithm combinations that cannot be currently used with TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー証明書と同じように、現在TLSで使用することはできませんアルゴリズム/アルゴリズムの組み合わせを使用する証明書がある、ということに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7. Client Key Exchange Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7. クライアント鍵交換メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This message is always sent by the client. It MUST immediately follow the client certificate message, if it is sent. Otherwise, it MUST be the first message sent by the client after it receives the ServerHelloDone message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このメッセージは、常にクライアントによって送信されます。それが送信された場合は、直ちに、クライアント証明書メッセージに従わなければなりません。そうでなければ、それはServerHelloDoneメッセージを受信した後、クライアントから送信された最初のメッセージでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
With this message, the premaster secret is set, either by direct transmission of the RSA-encrypted secret or by the transmission of Diffie-Hellman parameters that will allow each side to agree upon the same premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このメッセージでは、このpremaster_secretは、RSA暗号化秘密の直接伝送するか、それぞれの側が同じプレマスター秘密に同意することを可能にするのDiffie-Hellmanパラメータを送信することにより、いずれか、設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When the client is using an ephemeral Diffie-Hellman exponent, then this message contains the client&#39;s Diffie-Hellman public value. If the client is sending a certificate containing a static DH exponent (i.e., it is doing fixed_dh client authentication), then this message MUST be sent but MUST be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントがはかないのDiffie-Hellman指数を使用している場合は、このメッセージは、クライアントのディフィー-Hellman公開値が含まれています。クライアントが（すなわち、それはfixed_dhクライアント認証を行っている）静的DH指数を含む証明書を送信している場合、このメッセージが送られなければならないが、空でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The choice of messages depends on which key exchange method has been selected. See Section 7.4.3 for the KeyExchangeAlgorithm definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
メッセージの選択が鍵交換方式が選択されているに依存します。 KeyExchangeAlgorithm定義に関してセクション7.4.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (KeyExchangeAlgorithm) {
              case rsa:
                  EncryptedPreMasterSecret;
              case dhe_dss:
              case dhe_rsa:
              case dh_dss:
              case dh_rsa:
              case dh_anon:
                  ClientDiffieHellmanPublic;
          } exchange_keys;
      } ClientKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.1. RSA-Encrypted Premaster Secret Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.1。 RSA-暗号化されたプレマスターシークレットメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If RSA is being used for key agreement and authentication, the client generates a 48-byte premaster secret, encrypts it using the public key from the server&#39;s certificate, and sends the result in an encrypted premaster secret message. This structure is a variant of the ClientKeyExchange message and is not a message in itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RSAが主要な協定と認証に使用されている場合、クライアントは、48バイトのpremaster_secretを生成し、それはサーバの証明書から公開鍵を使って暗号化し、暗号化されたプリマスター秘密のメッセージに結果を送信します。この構造は、ClientKeyExchangeメッセージの変異体であり、それ自体がメッセージではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          ProtocolVersion client_version;
          opaque random[46];
      } PreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
client_version The latest (newest) version supported by the client. This is used to detect version rollback attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントがサポートする最新バージョンをクライアント_。これは、バージョンロールバック攻撃を検出するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
random 46 securely-generated random bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ランダム46確実に、生成されたランダムバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          public-key-encrypted PreMasterSecret pre_master_secret;
      } EncryptedPreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
pre_master_secret This random value is generated by the client and is used to generate the master secret, as specified in Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
pre_master_secretはこの乱数値はクライアントによって生成され、セクション8.1で指定されるように、マスターシークレットを生成するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The version number in the PreMasterSecret is the version offered by the client in the ClientHello.client_version, not the version negotiated for the connection. This feature is designed to prevent rollback attacks. Unfortunately, some old implementations use the negotiated version instead, and therefore checking the version number may lead to failure to interoperate with such incorrect client implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：たPreMasterSecretにバージョン番号はClientHello.client_version、ない接続のために交渉のバージョンでは、クライアントが提供するバージョンです。この機能は、ロールバック攻撃を防ぐように設計されています。残念ながら、いくつかの古い実装が代わりに交渉されたバージョンを使用するので、バージョン番号をチェックすることは、そのような不正なクライアント実装と相互運用の失敗につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client implementations MUST always send the correct version number in PreMasterSecret. If ClientHello.client_version is TLS 1.1 or higher, server implementations MUST check the version number as described in the note below. If the version number is TLS 1.0 or earlier, server implementations SHOULD check the version number, but MAY have a configuration option to disable the check. Note that if the check fails, the PreMasterSecret SHOULD be randomized as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの実装は常にたPreMasterSecretに正しいバージョン番号を送らなければなりません。 ClientHello.client_versionがTLS 1.1以上である場合は、以下の注記に記載されているように、サーバの実装は、バージョン番号をチェックしなければなりません。バージョン番号がTLS 1.0またはそれ以前である場合は、サーバーの実装は、バージョン番号を確認する必要がありますが、チェックを無効にする設定オプションがあるかもしれません。チェックが失敗した場合、以下に説明するように、たPreMasterSecretがランダム化されるべきであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Attacks discovered by Bleichenbacher [BLEI] and Klima et al. [KPR03] can be used to attack a TLS server that reveals whether a particular message, when decrypted, is properly PKCS#1 formatted, contains a valid PreMasterSecret structure, or has the correct version number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：Bleichenbacherの[BLEI]とクリマらによって発見された攻撃。 【KPR03]特定のメッセージ、復号化され、適切にフォーマット＃1をPKCSされているかどうかを明らかにするTLSサーバを攻撃するために使用することができ、有効たPreMasterSecret構造が含まれているか、または正しいバージョン番号を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described by Klima [KPR03], these vulnerabilities can be avoided by treating incorrectly formatted message blocks and/or mismatched version numbers in a manner indistinguishable from correctly formatted RSA blocks. In other words:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クリマ[KPR03]により記載されたように、これらの脆弱性は、正しくフォーマットされたRSAブロックから区別できないように正しくフォーマットメッセージブロックおよび/またはミスマッチバージョン番号を処理することによって回避することができます。言い換えると：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Generate a string R of 46 random bytes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 46ランダムバイトの文字列Rを生成します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Decrypt the message to recover the plaintext M
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.平文Mを回復するためのメッセージを復号化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. If the PKCS#1 padding is not correct, or the length of message M is not exactly 48 bytes: pre_master_secret = ClientHello.client_version || R else If ClientHello.client_version &lt;= TLS 1.0, and version number check is explicitly disabled: pre_master_secret = M else: pre_master_secret = ClientHello.client_version || M[2..47]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. PKCS＃1パディングが正しくない、またはメッセージMの長さが正確に48バイトでない場合：前_のマスター_秘密= ClientHello.client_version ||他のR ClientHello.client_version &lt;= TLS 1.0、およびバージョン番号の確認が明示的に無効になっている場合：他のpre_master_secret = M：前_のマスター_秘密= ClientHello.client_version || M [2..47]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that explicitly constructing the pre_master_secret with the ClientHello.client_version produces an invalid master_secret if the client has sent the wrong version in the original pre_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、元の前_のマスター_秘密に間違ったバージョンを送信した場合、明示的にClientHello.client_versionで前_のマスター_秘密を構築注意が無効でマスター_を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative approach is to treat a version number mismatch as a PKCS-1 formatting error and randomize the premaster secret completely:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のアプローチは、PKCS-1フォーマットエラーとして、バージョン番号の不一致を治療し、完全にプリマスターシークレットをランダム化することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Generate a string R of 48 random bytes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 48ランダムバイトの文字列Rを生成します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Decrypt the message to recover the plaintext M
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.平文Mを回復するためのメッセージを復号化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. If the PKCS#1 padding is not correct, or the length of message M is not exactly 48 bytes: pre_master_secret = R else If ClientHello.client_version &lt;= TLS 1.0, and version number check is explicitly disabled: premaster secret = M else If M[0..1] != ClientHello.client_version: premaster secret = R else: premaster secret = M
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. PKCS＃1パディングが正しくない、またはメッセージMの長さが正確に48バイトではない場合：他のpre_master_secret = R ClientHello.client_versionは、&lt;= TLS 1.0の場合、バージョン番号の確認が明示的に無効になっている：他にM =プリマスター秘密！他のプレマスター秘密= R：プリマスタ秘密= M Mは[0..1] = ClientHello.client_versionの場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although no practical attacks against this construction are known, Klima et al. [KPR03] describe some theoretical attacks, and therefore the first construction described is RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構成に対しては実用的な攻撃は、クリマらに知られていませんが。 【KPR03いくつかの理論的な攻撃を記述し、したがって説明した第一構成が推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any case, a TLS server MUST NOT generate an alert if processing an RSA-encrypted premaster secret message fails, or the version number is not as expected. Instead, it MUST continue the handshake with a randomly generated premaster secret. It may be useful to log the real cause of failure for troubleshooting purposes; however, care must be taken to avoid leaking the information to an attacker (through, e.g., timing, log files, or other channels.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
秘密のメッセージが失敗したRSA暗号化プリマスターを処理した場合、またはバージョン番号が期待されていないとして、どのような場合には、TLSサーバは、アラートを生成してはなりません。その代わりに、ランダムに生成されたプリマスターの秘密と握手を継続する必要があります。トラブルシューティングの目的のために失敗の本当の原因をログに記録することが有用であり得ます。ただし、注意が攻撃者に情報を漏洩しないように注意しなければならない（例えば、タイミング、ファイル、または他のチャンネルを記録し、経由。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RSAES-OAEP encryption scheme defined in [PKCS1] is more secure against the Bleichenbacher attack. However, for maximal compatibility with earlier versions of TLS, this specification uses the RSAES-PKCS1-v1_5 scheme. No variants of the Bleichenbacher attack are known to exist provided that the above recommendations are followed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS1]で定義されたRSAES-OAEPの暗号化方式は、Bleichenbacherの攻撃に対してより安全です。しかし、TLSの以前のバージョンとの最大の互換性のために、この仕様はRSAES-PKCS1-v1_5のスキームを使用しています。 Bleichenbacherの攻撃のいかなる変異体は、上記の勧告に従っていることを提供存在することが知られていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note: Public-key-encrypted data is represented as an opaque vector &lt;0..2^16-1&gt; (see Section 4.7). Thus, the RSA-encrypted PreMasterSecret in a ClientKeyExchange is preceded by two length bytes. These bytes are redundant in the case of RSA because the EncryptedPreMasterSecret is the only data in the ClientKeyExchange and its length can therefore be unambiguously determined. The SSLv3 specification was not clear about the encoding of public-key-encrypted data, and therefore many SSLv3 implementations do not include the length bytes -- they encode the RSA-encrypted data directly in the ClientKeyExchange message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：公開鍵で暗号化されたデータは不透明なベクトルとして表され、&lt;0..2 ^ 16-1&gt;（4.7節を参照してください）。したがって、ClientKeyExchangeでRSA暗号化されたPreMasterSecretは、二つの長さバイトが先行します。 EncryptedPreMasterSecretはClientKeyExchangeその長さのデータのみが、従って明確に決定することが可能であるため、これらのバイトは、RSAの場合には冗長です。 SSLv3仕様は公開鍵暗号化データの符号化について明確ではなかったので、多くのSSLv3実装は長さバイトを含まない - それらは、ClientKeyExchangeメッセージに直接RSA暗号化データを符号化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification requires correct encoding of the EncryptedPreMasterSecret complete with length bytes. The resulting PDU is incompatible with many SSLv3 implementations. Implementors upgrading from SSLv3 MUST modify their implementations to generate and accept the correct encoding. Implementors who wish to be compatible with both SSLv3 and TLS should make their implementation&#39;s behavior dependent on the protocol version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、長さバイトと完全EncryptedPreMasterSecretの正しい符号化を必要とします。得られたPDUは多くのSSLv3実装と互換性がありません。 SSLv3からアップグレード実装者は正しいエンコーディングを生成して受け入れるようにその実装を変更する必要があります。 SSLv3およびTLSの両方と互換性があることを望む実装者は、プロトコルバージョンにその実装の動作に依存すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note: It is now known that remote timing-based attacks on TLS are possible, at least when the client and server are on the same LAN. Accordingly, implementations that use static RSA keys MUST use RSA blinding or some other anti-timing technique, as described in [TIMING].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：これは、今、TLS上のリモートタイミングベースの攻撃は、クライアントとサーバが同じLAN上にある少​​なくともとき、可能であることが知られています。 [タイミング]で説明されるようしたがって、静的RSAキーを使用する実装は、RSAの盲目またはいくつかの他の抗タイミング手法を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.2. Client Diffie-Hellman Public Value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.2。クライアントのDiffie-Hellman公開値
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This structure conveys the client&#39;s Diffie-Hellman public value (Yc) if it was not already included in the client&#39;s certificate. The encoding used for Yc is determined by the enumerated PublicValueEncoding. This structure is a variant of the client key exchange message, and not a message in itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
それはすでにクライアントの証明書に含まれていなかった場合は、この構造はクライアントのディフィー-Hellman公開値（YC）を伝えます。 Ycのために使用される符号化は、列挙型のPublicValueEncodingによって決定されます。この構造は、クライアント鍵交換メッセージのバリアントではなく、それ自体がメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
implicit If the client has sent a certificate which contains a suitable Diffie-Hellman key (for fixed_dh client authentication), then Yc is implicit and does not need to be sent again. In this case, the client key exchange message will be sent, but it MUST be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントが（fixed_dhクライアント認証用）に適しのDiffie-Hellman鍵を含む証明書を送信した場合、暗黙的な、そしてYcのは暗黙的で、再び送られる必要はありません。この場合、クライアント鍵交換メッセージが送信されますが、それは空である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
explicit Yc needs to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
明示的なYcを送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          select (PublicValueEncoding) {
              case implicit: struct { };
              case explicit: opaque dh_Yc&lt;1..2^16-1&gt;;
          } dh_public;
      } ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
dh_Yc The client&#39;s Diffie-Hellman public value (Yc).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントのディフィー-Hellman公開値（YC）dh_Yc。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.8. Certificate Verify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.8. 証明書は、確認してください
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This message is used to provide explicit verification of a client certificate. This message is only sent following a client certificate that has signing capability (i.e., all certificates except those containing fixed Diffie-Hellman parameters). When sent, it MUST immediately follow the client key exchange message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
このメッセージは、クライアント証明書の明示的な検証を提供するために使用されます。このメッセージは、機能のみを署名したクライアント証明書下記送信される（すなわち、それらを含有する固定のDiffie-Hellmanパラメータを除くすべての証明書）。送信された場合は、すぐにクライアント鍵交換メッセージに従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
           digitally-signed struct {
               opaque handshake_messages[handshake_messages_length];
           }
      } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Here handshake_messages refers to all handshake messages sent or received, starting at client hello and up to, but not including, this message, including the type and length fields of the handshake messages. This is the concatenation of all the Handshake structures (as defined in Section 7.4) exchanged thus far. Note that this requires both sides to either buffer the messages or compute running hashes for all potential hash algorithms up to the time of the CertificateVerify computation. Servers can minimize this computation cost by offering a restricted set of digest algorithms in the CertificateRequest message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ここでは握手はハロークライアントから始まり、送信または受信したすべてのハンドシェイクメッセージを参照し、最大ではなく、ハンドシェイクメッセージのタイプと長さフィールドを含む、このメッセージを、含みません。これは、すべてのハンドシェイク構造の連結は（セクション7.4で定義されるように）これまでに交換されます。これはメッセージをバッファまたはCertificateVerify計算の時間までのすべての潜在的なハッシュアルゴリズムのためのハッシュを実行する計算のいずれかに両面が必要であることに注意してください。サーバは、CertificateRequestメッセージにダイジェストアルゴリズムの制限されたセットを提供することによって、この計算コストを最小限に抑えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The hash and signature algorithms used in the signature MUST be one of those present in the supported_signature_algorithms field of the CertificateRequest message. In addition, the hash and signature algorithms MUST be compatible with the key in the client&#39;s end-entity certificate. RSA keys MAY be used with any permitted hash algorithm, subject to restrictions in the certificate, if any.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
署名に使用されるハッシュと署名アルゴリズムは、CertificateRequestメッセージのsupported_signature_algorithmsフィールドに存在するもののいずれかでなければなりません。また、ハッシュおよび署名アルゴリズムは、クライアントのエンドエンティティ証明書内のキーと適合性でなければなりません。 RSAキーが存在する場合、証明書内の制約を受け、任意の許可されたハッシュアルゴリズムで使用されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Because DSA signatures do not contain any secure indication of hash algorithm, there is a risk of hash substitution if multiple hashes may be used with any key. Currently, DSA [DSS] may only be used with SHA-1. Future revisions of DSS [DSS-3] are expected to allow the use of other digest algorithms with DSA, as well as guidance as to which digest algorithms should be used with each key size. In addition, future revisions of [PKIX] may specify mechanisms for certificates to indicate which digest algorithms are to be used with DSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DSA署名は、ハッシュアルゴリズムのいずれかの安全な表示を含んでいないので、複数のハッシュは、任意のキーと一緒に使用することができる場合は、ハッシュ置換の危険性があります。現在、DSA [DSS]はSHA-1でのみ使用されてもよいです。 DSS [DSS-3]の将来の改訂は、ダイジェストアルゴリズムは、各キーサイズで使用されるべきであるようにDSAを有する他のダイジェストアルゴリズムの使用、ならびにガイダンスを可能にすることが期待されます。また、[PKIX]の今後の改正は、ダイジェストアルゴリズムがDSAと共に使用されるかを示すために証明書のメカニズムを指定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.9. Finished
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.9. 完成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージが送信されるとき：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A Finished message is always sent immediately after a change cipher spec message to verify that the key exchange and authentication processes were successful. It is essential that a change cipher spec message be received between the other handshake messages and the Finished message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Finishedメッセージは、常に鍵交換と認証プロセスが成功したことを確認するために、変更暗号仕様メッセージの直後に送信されます。 ChangeCipherSpecメッセージは、他のハンドシェイクメッセージとFinishedメッセージの間で送受信されることが不可欠です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの意味：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The Finished message is the first one protected with the just negotiated algorithms, keys, and secrets. Recipients of Finished messages MUST verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Finishedメッセージはただ交渉されたアルゴリズム、鍵、および秘密で保護された最初のものです。 Finishedメッセージの受信者は、内容が正しいことを確かめなければなりません。側面がFinishedメッセージを送受信し、そのピアからのFinishedメッセージを検証した後、それが接続を介してアプリケーションデータを送受信するために開始することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメッセージの構造：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      struct {
          opaque verify_data[verify_data_length];
      } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
verify_data PRF(master_secret, finished_label, Hash(handshake_messages)) [0..verify_data_length-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
PRF（マスター_、finished_label、ハッシュ（握手））0..verify_data_length-1] verify_data。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
finished_label For Finished messages sent by the client, the string &#34;client finished&#34;. For Finished messages sent by the server, the string &#34;server finished&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
クライアントから送信されたFinishedメッセージについてはfinished_label、文字列「クライアントが終了しました」。サーバによって送信されるFinishedメッセージについては、文字列「サーバが終わっ」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Hash denotes a Hash of the handshake messages. For the PRF defined in Section 5, the Hash MUST be the Hash used as the basis for the PRF. Any cipher suite which defines a different PRF MUST also define the Hash to use in the Finished computation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ハッシュは、ハンドシェイクメッセージのハッシュを示しています。 PRFは、セクション5で定義されたため、ハッシュは、PRFのための基礎として使用されるハッシュでなければなりません。異なるPRFを定義する任意の暗号スイートはまた、仕上がりの計算に使用するハッシュを定義しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In previous versions of TLS, the verify_data was always 12 octets long. In the current version of TLS, it depends on the cipher suite. Any cipher suite which does not explicitly specify verify_data_length has a verify_data_length equal to 12. This includes all existing cipher suites. Note that this representation has the same encoding as with previous versions. Future cipher suites MAY specify other lengths but such length MUST be at least 12 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
TLSの以前のバージョンでは、verify_dataは常に12オクテットの長さでした。 TLSの現在のバージョンでは、暗号スイートに依存します。明示的verify_data_length指定していない任意の暗号スイートは、これは、既存のすべての暗号スイートが含まれて12に等しいverify_data_lengthを持っています。この表現は、以前のバージョンと同じ符号を有することに留意されたいです。将来の暗号スイートは、他の長さを指定することができるが、そのような長さは少なくとも12バイトでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
handshake_messages All of the data from all messages in this handshake (not including any HelloRequest messages) up to, but not including, this message. This is only data visible at the handshake layer and does not include record layer headers. This is the concatenation of all the Handshake structures as defined in Section 7.4, exchanged thus far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
握手まで（任意のHelloRequestメッセージを含まない）、このハンドシェイクのすべてのメッセージからのデータのすべてが、このメッセージを含んでいません。これは、ハンドシェイク層における可視データのみであり、記録層ヘッダを含んでいません。これは、セクション7.4で定義されるように、すべてのHandshake構造の連結です、これまでに交換しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is a fatal error if a Finished message is not preceded by a ChangeCipherSpec message at the appropriate point in the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finishedメッセージは、ハンドシェーク中の適切な時点でChangeCipherSpecをメッセージに先行されていない場合には、致命的なエラーです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value handshake_messages includes all handshake messages starting at ClientHello up to, but not including, this Finished message. This may be different from handshake_messages in Section 7.4.8 because it would include the CertificateVerify message (if sent). Also, the handshake_messages for the Finished message sent by the client will be different from that for the Finished message sent by the server, because the one that is sent second will include the prior one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値の握手は、すべてのハンドシェイクメッセージまでのClientHelloで始まる、しかし、このFinishedメッセージを含んでいないが含まれています。 （送信された場合）、それはCertificateVerifyメッセージを含むことになるので、これは、セクション7.4.8に握手異なっていてもよいです。第二送信されたもの前いずれかを含むことになるので、また、クライアントによって送信されるFinishedメッセージのための握手は、サーバによって送信されるFinishedメッセージとは異なるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: ChangeCipherSpec messages, alerts, and any other record types are not handshake messages and are not included in the hash computations. Also, HelloRequest messages are omitted from handshake hashes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：ChangeCipherSpecをメッセージ、警告、およびその他のレコードタイプは、メッセージをハンドシェイクしていないと、ハッシュ計算に含まれていません。また、HelloRequestメッセージは握手ハッシュから省略されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Cryptographic Computations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.暗号計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, encryption, and MAC algorithms are determined by the cipher_suite selected by the server and revealed in the ServerHello message. The compression algorithm is negotiated in the hello messages, and the random values are exchanged in the hello messages. All that remains is to calculate the master secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続保護を開始するためには、TLSレコードプロトコルは、アルゴリズムのスイート、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります。認証、暗号化、およびMACアルゴリズムは暗号_スイートサーバによって選択され、ServerHelloメッセージで明らかにすることによって決定されます。圧縮アルゴリズムは、helloメッセージに交渉され、ランダムな値がhelloメッセージで交換されています。残っているのは、マスターシークレットを計算することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Computing the Master Secret
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. マスターシークレットの計算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all key exchange methods, the same algorithm is used to convert the pre_master_secret into the master_secret. The pre_master_secret should be deleted from memory once the master_secret has been computed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての鍵交換方法については、同じアルゴリズムがpre_master_secretをmaster_secretに変換するために使用されます。 master_secretが計算されると、pre_master_secretはメモリから削除されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
master_secret = PRF(pre_master_secret, &#34;master secret&#34;, ClientHello.random + ServerHello.random) [0..47];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
マスター_ = PRF（前_のマスター_秘密、 &#34;マスタシークレット&#34;、ClientHello.randomと+ ServerHello.random）[0..47]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master secret is always exactly 48 bytes in length. The length of the premaster secret will vary depending on key exchange method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マスターシークレットの長さは常に正確に48バイトです。このpremaster_secretの長さは、鍵交換方式によって異なります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. RSA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1.  RSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RSA is used for server authentication and key exchange, a 48- byte pre_master_secret is generated by the client, encrypted under the server&#39;s public key, and sent to the server. The server uses its private key to decrypt the pre_master_secret. Both parties then convert the pre_master_secret into the master_secret, as specified above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAは、サーバー認証と鍵交換のために使用されている場合は、48-バイトのpre_master_secretは、クライアントによって生成されたサーバの公開鍵で暗号化し、サーバーに送信されます。サーバーは、前_のマスター_秘密を解読するためにその秘密鍵を使用しています。両当事者は、その後、上記のような方法でmaster_secretに前_のマスター_秘密に変換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. Diffie-Hellman
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. ディフィー・ヘルマン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is used as the pre_master_secret, and is converted into the master_secret, as specified above. Leading bytes of Z that contain all zero bits are stripped before it is used as the pre_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従来のDiffie-Hellman計算が行われます。ネゴシエートされたキー（Z）は、前_のマスター_秘密として使用され、上記指定されるように、マスター_に変換されます。それは前_のマスター_秘密として使用される前に、すべてのゼロのビットを含むZの先頭バイトが取り除かれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Diffie-Hellman parameters are specified by the server and may be either ephemeral or contained within the server&#39;s certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：のDiffie-Hellmanパラメータは、サーバによって指定され、一時的またはサーバの証明書内に含まれるのいずれであってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Mandatory Cipher Suites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.必須の暗号スイート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA (see Appendix A.5 for the definition).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そうでなければ特定のアプリケーションプロファイル規格の非存在下で、TLS準拠アプリケーションは、暗号スイートTLS_RSA_WITH_AES_128_CBC_SHAを（定義については、付録A.5を参照）を実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Application Data Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.アプリケーションデータプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application data messages are carried by the record layer and are fragmented, compressed, and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションデータメッセージが記録層によって運ばれ、断片化され、圧縮され、現在の接続状態に基づいて暗号化されています。メッセージは、記録層への透過的なデータとして扱われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.セキュリティについての考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security issues are discussed throughout this memo, especially in Appendices D, E, and F.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティの問題は、特に付録D、E、およびFに、このメモ中で議論されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses several registries that were originally created in [TLS1.1]. IANA has updated these to reference this document. The registries and their allocation policies (unchanged from [TLS1.1]) are listed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、もともと[TLS1.1]で作成されたいくつかのレジストリを使用しています。 IANAはこのドキュメントを参照するためにこれらを更新しました。レジストリとその割り当てポリシー（[TLS1.1]から変更）を以下に列挙する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS ClientCertificateType Identifiers Registry: Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action [RFC2434]. Values in the range 64-223 (decimal) inclusive are assigned via Specification Required [RFC2434]. Values from 224-255 (decimal) inclusive are reserved for Private Use [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS ClientCertificateType識別子レジストリは：包括範囲0-63（10進数）の将来の値は標準化行動[RFC2434]を介して割り当てられます。範囲64から223（10進数）包括的に値を仕様が必要[RFC2434]を介して割り当てられます。包括的な224から255（10進数）の値が私用[RFC2434]のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS Cipher Suite Registry: Future values with the first byte in the range 0-191 (decimal) inclusive are assigned via Standards Action [RFC2434]. Values with the first byte in the range 192-254 (decimal) are assigned via Specification Required [RFC2434]. Values with the first byte 255 (decimal) are reserved for Private Use [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS暗号スイートレジストリ：範囲内の最初のバイト0から191（10進数）包括的で将来の値は標準化アクション[RFC2434]を経由して割り当てられます。範囲192から254（10進数）の最初のバイトとの値は仕様が必要[RFC2434]を介して割り当てられます。最初のバイト255（10進数）との値は私用[RFC2434]のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- This document defines several new HMAC-SHA256-based cipher suites, whose values (in Appendix A.5) have been allocated from the TLS Cipher Suite registry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - この文書は、その値（付録A.5中）TLS暗号スイートレジストリから割り当てられているいくつかの新しいHMAC-SHA256ベースの暗号スイートを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS ContentType Registry: Future values are allocated via Standards Action [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS ContentTypeをレジストリ：未来の値は標準アクション[RFC2434]を経由して割り当てられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS Alert Registry: Future values are allocated via Standards Action [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS警告レジストリ：未来の値は標準アクション[RFC2434]を経由して割り当てられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS HandshakeType Registry: Future values are allocated via Standards Action [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS HandshakeTypeレジストリ：未来の値は標準アクション[RFC2434]を経由して割り当てられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document also uses a registry originally created in [RFC4366]. IANA has updated it to reference this document. The registry and its allocation policy (unchanged from [RFC4366]) is listed below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書はまた、元々[RFC4366]で作成したレジストリを使用しています。 IANAはこのドキュメントを参照するためにそれを更新しました。レジストリと（[RFC4366]から変化しない）、その割り当てポリシーを以下に示します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS ExtensionType Registry: Future values are allocated via IETF Consensus [RFC2434]. IANA has updated this registry to include the signature_algorithms extension and its corresponding value (see Section 7.4.1.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS ExtensionTypeレジストリ：将来の値はIETFコンセンサス[RFC2434]を介して割り当てられています。 IANA（セクション7.4.1.4を参照）signature_algorithms拡張子とそれに対応する値を含めるには、このレジストリを更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, this document defines two new registries to be maintained by IANA:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、この文書はIANAによって維持される2つの新しいレジストリを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS SignatureAlgorithm Registry: The registry has been initially populated with the values described in Section 7.4.1.4.1. Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action [RFC2434]. Values in the range 64-223 (decimal) inclusive are assigned via Specification Required [RFC2434]. Values from 224-255 (decimal) inclusive are reserved for Private Use [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLSのsignatureAlgorithmレジストリ：レジストリは、最初のセクション7.4.1.4.1に記載された値が移入されています。範囲0-63（10進数）包括的に将来の値は標準化行動[RFC2434]を介して割り当てられます。範囲64から223（10進数）包括的に値を仕様が必要[RFC2434]を介して割り当てられます。包括的な224から255（10進数）の値が私用[RFC2434]のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- TLS HashAlgorithm Registry: The registry has been initially populated with the values described in Section 7.4.1.4.1. Future values in the range 0-63 (decimal) inclusive are assigned via Standards Action [RFC2434]. Values in the range 64-223 (decimal) inclusive are assigned via Specification Required [RFC2434]. Values from 224-255 (decimal) inclusive are reserved for Private Use [RFC2434].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  TLS HashAlgorithmレジストリ：レジストリは、最初のセクション7.4.1.4.1に記載された値が移入されています。範囲0-63（10進数）包括的に将来の値は標準化行動[RFC2434]を介して割り当てられます。範囲64から223（10進数）包括的に値を仕様が必要[RFC2434]を介して割り当てられます。包括的な224から255（10進数）の値が私用[RFC2434]のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This document also uses the TLS Compression Method Identifiers Registry, defined in [RFC3749]. IANA has allocated value 0 for the &#34;null&#34; compression method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
この文書はまた、[RFC3749]で定義されたTLS圧縮方法識別子レジストリを使用しています。 IANAは、「NULL」圧縮方法に値0を割り当てました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Protocol Data Structures and Constant Values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A.プロトコルデータ構造と定数値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes protocol types and constants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、プロトコルの種類と定数について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1. Record Layer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1。レコード層
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       uint8 major;
       uint8 minor;
   } ProtocolVersion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   ProtocolVersion version = { 3, 3 };     /* TLS v1.2*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum {
       change_cipher_spec(20), alert(21), handshake(22),
       application_data(23), (255)
   } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSPlaintext.length];
   } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       opaque fragment[TLSCompressed.length];
   } TLSCompressed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ContentType type;
       ProtocolVersion version;
       uint16 length;
       select (SecurityParameters.cipher_type) {
           case stream: GenericStreamCipher;
           case block:  GenericBlockCipher;
           case aead:   GenericAEADCipher;
       } fragment;
   } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   stream-ciphered struct {
       opaque content[TLSCompressed.length];
       opaque MAC[SecurityParameters.mac_length];
   } GenericStreamCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       opaque IV[SecurityParameters.record_iv_length];
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[SecurityParameters.mac_length];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       };
   } GenericBlockCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
      opaque nonce_explicit[SecurityParameters.record_iv_length];
      aead-ciphered struct {
          opaque content[TLSCompressed.length];
      };
   } GenericAEADCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2. Change Cipher Specs Message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2。変更暗号仕様メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       enum { change_cipher_spec(1), (255) } type;
   } ChangeCipherSpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3. Alert Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.3。警告メッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum {
       close_notify(0),
       unexpected_message(10),
       bad_record_mac(20),
       decryption_failed_RESERVED(21),
       record_overflow(22),
       decompression_failure(30),
       handshake_failure(40),
       no_certificate_RESERVED(41),
       bad_certificate(42),
       unsupported_certificate(43),
       certificate_revoked(44),
       certificate_expired(45),
       certificate_unknown(46),
       illegal_parameter(47),
       unknown_ca(48),
       access_denied(49),
       decode_error(50),
       decrypt_error(51),
       export_restriction_RESERVED(60),
       protocol_version(70), insufficient_security(71),
       internal_error(80),
       user_canceled(90),
       no_renegotiation(100),
       unsupported_extension(110),           /* new */
       (255)
   } AlertDescription;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       AlertLevel level;
       AlertDescription description;
   } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4. Handshake Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4。ハンドシェイクプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum {
       hello_request(0), client_hello(1), server_hello(2),
       certificate(11), server_key_exchange (12),
       certificate_request(13), server_hello_done(14),
       certificate_verify(15), client_key_exchange(16),
       finished(20)
       (255)
   } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       HandshakeType msg_type;
       uint24 length;
       select (HandshakeType) {
           case hello_request:       HelloRequest;
           case client_hello:        ClientHello;
           case server_hello:        ServerHello;
           case certificate:         Certificate;
           case server_key_exchange: ServerKeyExchange;
           case certificate_request: CertificateRequest;
           case server_hello_done:   ServerHelloDone;
           case certificate_verify:  CertificateVerify;
           case client_key_exchange: ClientKeyExchange;
           case finished:            Finished;
       } body;
   } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.1. Hello Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.1。 helloメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct { } HelloRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       uint32 gmt_unix_time;
       opaque random_bytes[28];
   } Random;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
opaque SessionID&lt;0..32&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明なセッションID &lt;0 32&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8 CipherSuite[2];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UINT8のCipherSuite [2]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ProtocolVersion client_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suites&lt;2..2^16-2&gt;;
       CompressionMethod compression_methods&lt;1..2^8-1&gt;;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions&lt;0..2^16-1&gt;;
       };
   } ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ProtocolVersion server_version;
       Random random;
       SessionID session_id;
       CipherSuite cipher_suite;
       CompressionMethod compression_method;
       select (extensions_present) {
           case false:
               struct {};
           case true:
               Extension extensions&lt;0..2^16-1&gt;;
       };
   } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ExtensionType extension_type;
       opaque extension_data&lt;0..2^16-1&gt;;
   } Extension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum {
       signature_algorithms(13), (65535)
   } ExtensionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum{
       none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
       sha512(6), (255)
   } HashAlgorithm;
   enum {
      anonymous(0), rsa(1), dsa(2), ecdsa(3), (255)
   } SignatureAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
         HashAlgorithm hash;
         SignatureAlgorithm signature;
   } SignatureAndHashAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SignatureAndHashAlgorithm supported_signature_algorithms&lt;2..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SignatureAndHashAlgorithmのsupported_signature_algorithms &lt;2..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.2. Server Authentication and Key Exchange Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.2。サーバー認証と鍵交換のメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
opaque ASN.1Cert&lt;2^24-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明ASN.1Cert &lt;2 ^ 24-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
   } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { dhe_dss, dhe_rsa, dh_anon, rsa,dh_dss, dh_rsa
          /* may be extended, e.g., for ECDH -- see [TLSECC] */
        } KeyExchangeAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       opaque dh_p&lt;1..2^16-1&gt;;
       opaque dh_g&lt;1..2^16-1&gt;;
       opaque dh_Ys&lt;1..2^16-1&gt;;
   } ServerDHParams;     /* Ephemeral DH parameters */ struct {
       select (KeyExchangeAlgorithm) {
           case dh_anon:
               ServerDHParams params;
           case dhe_dss:
           case dhe_rsa:
               ServerDHParams params;
               digitally-signed struct {
                   opaque client_random[32];
                   opaque server_random[32];
                   ServerDHParams params;
               } signed_params;
           case rsa:
           case dh_dss:
           case dh_rsa:
               struct {} ;
              /* message is omitted for rsa, dh_dss, and dh_rsa */
           /* may be extended, e.g., for ECDH -- see [TLSECC] */
   } ServerKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum {
       rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
       rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
       fortezza_dms_RESERVED(20),
       (255)
   } ClientCertificateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
opaque DistinguishedName&lt;1..2^16-1&gt;;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明な識別名&lt;1..2 ^ 16-1&gt;;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
       DistinguishedName certificate_authorities&lt;0..2^16-1&gt;;
   } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct { } ServerHelloDone;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.3. Client Authentication and Key Exchange Messages
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.3。クライアント認証と鍵交換のメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       select (KeyExchangeAlgorithm) {
           case rsa:
               EncryptedPreMasterSecret;
           case dhe_dss:
           case dhe_rsa:
           case dh_dss:
           case dh_rsa:
           case dh_anon:
               ClientDiffieHellmanPublic;
       } exchange_keys;
   } ClientKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ProtocolVersion client_version;
       opaque random[46];
   } PreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       public-key-encrypted PreMasterSecret pre_master_secret;
   } EncryptedPreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       select (PublicValueEncoding) {
           case implicit: struct {};
           case explicit: opaque DH_Yc&lt;1..2^16-1&gt;;
       } dh_public;
   } ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
        digitally-signed struct {
            opaque handshake_messages[handshake_messages_length];
        }
   } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.4. Handshake Finalization Message
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.4.4。握手ファイナライズのメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       opaque verify_data[verify_data_length];
   } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.5. The Cipher Suite
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.5。暗号スイート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following values define the cipher suite codes used in the ClientHello and ServerHello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下の値がのClientHelloとのServerHelloメッセージで使用される暗号スイート・コードを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A cipher suite defines a cipher specification supported in TLS Version 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号スイートは、TLSバージョン1.2でサポートされる暗号仕様を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a TLS connection during the first handshake on that channel, but MUST NOT be negotiated, as it provides no more protection than an unsecured connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_NULL_WITH_NULL_NULLが指定され、そのチャネル上の最初のハンドシェイク中に、TLS接続の初期状態であるが、それは無担保接続よりも多くの保護を提供しないよう、交渉してはなりませんさ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CipherSuite TLS_NULL_WITH_NULL_NULL = { 0x00,0x00 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
CipherSuite TLS_NULL_WITH_NULL_NULL = {0x00,0x00}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following CipherSuite definitions require that the server provide an RSA certificate that can be used for key exchange. The server may request any signature-capable certificate in the certificate request message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のCipherSuite定義は、サーバーが鍵交換のために使用することができるRSA証明書を提供する必要があります。サーバは、証明書要求メッセージ内の任意の署名可能な証明書を要求することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      CipherSuite TLS_RSA_WITH_NULL_MD5                 = { 0x00,0x01 };
      CipherSuite TLS_RSA_WITH_NULL_SHA                 = { 0x00,0x02 };
      CipherSuite TLS_RSA_WITH_NULL_SHA256              = { 0x00,0x3B };
      CipherSuite TLS_RSA_WITH_RC4_128_MD5              = { 0x00,0x04 };
      CipherSuite TLS_RSA_WITH_RC4_128_SHA              = { 0x00,0x05 };
      CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA         = { 0x00,0x0A };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA          = { 0x00,0x2F };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA          = { 0x00,0x35 };
      CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256       = { 0x00,0x3C };
      CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256       = { 0x00,0x3D };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following cipher suite definitions are used for server-authenticated (and optionally client-authenticated) Diffie-Hellman. DH denotes cipher suites in which the server&#39;s certificate contains the Diffie-Hellman parameters signed by the certificate authority (CA). DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a signature-capable certificate, which has been signed by the CA. The signing algorithm used by the server is specified after the DHE component of the CipherSuite name. The server can request any signature-capable certificate from the client for client authentication, or it may request a Diffie-Hellman certificate. Any Diffie-Hellman certificate provided by the client must use the parameters (group and generator) described by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の暗号スイートの定義は、サーバ認証（および必要に応じてクライアント認証）のDiffie-Hellmanのために使用されます。 DHは、サーバーの証明書は、認証局（CA）によって署名のDiffie-Hellmanパラメータが含まれている暗号スイートを示しています。 DHEはのDiffie-Hellmanパラメータは、CAによって署名された署名できる証明書によって署名され短命ディフィー - ヘルマンを示しサーバによって使用される署名アルゴリズムのCipherSuite名のDHE成分の後に指定されています。サーバは、クライアント認証のためにクライアントからの署名可能な証明書を要求することができ、またはそれはのDiffie-Hellman証明書を要求することができます。クライアントによって提供される任意のDiffie-Hellman証明書がサーバによって記述パラメータ（群と発電機）を使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x0D };
      CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x10 };
      CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x13 };
      CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x16 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA       = { 0x00,0x30 };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA       = { 0x00,0x31 };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA      = { 0x00,0x32 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA      = { 0x00,0x33 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA       = { 0x00,0x36 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA       = { 0x00,0x37 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA      = { 0x00,0x38 };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA      = { 0x00,0x39 };
      CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256    = { 0x00,0x3E };
      CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256    = { 0x00,0x3F };
      CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256   = { 0x00,0x40 };
      CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256   = { 0x00,0x67 };
      CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256    = { 0x00,0x68 };
      CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256    = { 0x00,0x69 };
      CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256   = { 0x00,0x6A };
      CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256   = { 0x00,0x6B };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following cipher suites are used for completely anonymous Diffie-Hellman communications in which neither party is authenticated. Note that this mode is vulnerable to man-in-the-middle attacks. Using this mode therefore is of limited use: These cipher suites MUST NOT be used by TLS 1.2 implementations unless the application layer has specifically requested to allow anonymous key exchange. (Anonymous key exchange may sometimes be acceptable, for example, to support opportunistic encryption when no set-up for authentication is in place, or when TLS is used as part of more complex security protocols that have other means to ensure authentication.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の暗号スイートは、いずれの当事者が認証されている完全に匿名のDiffie-Hellman通信に使用されています。このモードでは、man-in-the-middle攻撃に対して脆弱であることに注意してください。したがって、このモードを使用すると、限られた用途は次のとおりです。アプリケーション層は、具体的に匿名鍵交換を許可するように要求していない限り、これらの暗号スイートは、TLS 1.2実装で使用してはいけません。 （匿名キー交換は、時々、認証のためのセットアップが所定の位置にない場合、またはTLSが認証を確実にする他の手段を有する、より複雑なセキュリティプロトコルの一部として使用する場合日和見暗号化をサポートするために、例えば、許容されるかもしれません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      CipherSuite TLS_DH_anon_WITH_RC4_128_MD5          = { 0x00,0x18 };
      CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA     = { 0x00,0x1B };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA      = { 0x00,0x34 };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA      = { 0x00,0x3A };
      CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256   = { 0x00,0x6C };
      CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256   = { 0x00,0x6D };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that using non-anonymous key exchange without actually verifying the key exchange is essentially equivalent to anonymous key exchange, and the same precautions apply. While non-anonymous key exchange will generally involve a higher computational and communicational cost than anonymous key exchange, it may be in the interest of interoperability not to disable non-anonymous key exchange when the application layer is allowing anonymous key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実際に鍵交換を検証せずに非匿名鍵交換を使用すると、匿名の鍵交換と本質的に同等であり、同一の注意事項が適用されることに注意してください。非匿名の鍵交換は、一般的に匿名の鍵交換よりも高い計算とコミュニケーション的コストを伴うだろうが、それはアプリケーション層は、匿名の鍵交換を可能にされた非匿名の鍵交換を無効にすることはない相互運用性の関心であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New cipher suite values have been assigned by IANA as described in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第12節で説明したように、新たな暗号スイート値はIANAによって割り当てられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid collision with Fortezza-based cipher suites in SSL 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：暗号スイート値{0x00で、0x1cに}及び{0x00の、0x1Dの}は、SSL 3にフォルテッツァベースの暗号スイートとの衝突を回避するために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.6. The Security Parameters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.6。セキュリティパラメータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These security parameters are determined by the TLS Handshake Protocol and provided as parameters to the TLS record layer in order to initialize a connection state. SecurityParameters includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのセキュリティパラメータは、TLSハンドシェイクプロトコルによって決定され、接続状態を初期化するためにTLS記録層へのパラメータとして提供されます。 SecurityParametersが含まれています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { server, client } ConnectionEnd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { tls_prf_sha256 } PRFAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { null, rc4, 3des, aes } BulkCipherAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { stream, block, aead } CipherType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   enum { null, hmac_md5, hmac_sha1, hmac_sha256, hmac_sha384,
     hmac_sha512} MACAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /* Other values may be added to the algorithms specified in
   CompressionMethod, PRFAlgorithm, BulkCipherAlgorithm, and
   MACAlgorithm. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct {
       ConnectionEnd          entity;
       PRFAlgorithm           prf_algorithm;
       BulkCipherAlgorithm    bulk_cipher_algorithm;
       CipherType             cipher_type;
       uint8                  enc_key_length;
       uint8                  block_length;
       uint8                  fixed_iv_length;
       uint8                  record_iv_length;
       MACAlgorithm           mac_algorithm;
       uint8                  mac_length;
       uint8                  mac_key_length;
       CompressionMethod      compression_algorithm;
       opaque                 master_secret[48];
       opaque                 client_random[32];
       opaque                 server_random[32];
   } SecurityParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
A.7. Changes to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
A.7。への変更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 4492 [TLSECC] adds Elliptic Curve cipher suites to TLS. This document changes some of the structures used in that document. This section details the required changes for implementors of both RFC 4492 and TLS 1.2. Implementors of TLS 1.2 who are not implementing RFC 4492 do not need to read this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 4492 [TLSECC]は、TLSに楕円曲線暗号スイートを追加します。この文書は、その文書で使用される構造物の一部を変更します。このセクションでは、両方のRFC 4492およびTLS 1.2の実装のために必要な変更の詳細について説明します。 RFC 4492を実装していないTLS 1.2の実装者は、このセクションを読む必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document adds a &#34;signature_algorithm&#34; field to the digitally-signed element in order to identify the signature and digest algorithms used to create a signature. This change applies to digital signatures formed using ECDSA as well, thus allowing ECDSA signatures to be used with digest algorithms other than SHA-1, provided such use is compatible with the certificate and any restrictions imposed by future revisions of [PKIX].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、署名を識別し、署名を作成するために使用されるアルゴリズムを消化するために、デジタル署名された要素に「signature_algorithm」フィールドを追加します。この変化は、そのような使用を提供、したがってECDSA署名は、SHA-1以外のダイジェストアルゴリズムで使用することを可能にする、並びにECDSAを用いて形成された電子署名に適用された証明書と[PKIX]の今後の改正によって課される任意の制約と互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Sections 7.4.2 and 7.4.6, the restrictions on the signature algorithms used to sign certificates are no longer tied to the cipher suite (when used by the server) or the ClientCertificateType (when used by the client). Thus, the restrictions on the algorithm used to sign certificates specified in Sections 2 and 3 of RFC 4492 are also relaxed. As in this document, the restrictions on the keys in the end-entity certificate remain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション7.4.2と7.4.6で説明したように、証明書に署名するために使用される署名アルゴリズムの制限はもはや暗号スイート（サーバーで使用する場合）または（クライアントによって使用される）ClientCertificateTypeに縛られていません。このように、RFC 4492のセクション2と3で指定された証明書に署名するために使用されるアルゴリズムの制限も緩和されます。この文書に記載されているように、エンドエンティティ証明書のキーに制限が残っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix B. Glossary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録B.用語集
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Advanced Encryption Standard (AES) AES [AES] is a widely used symmetric encryption algorithm. AES is a block cipher with a 128-, 192-, or 256-bit keys and a 16-byte block size. TLS currently only supports the 128- and 256-bit key sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高度暗号化標準（AES）AES [AES]が広く使用される対称暗号化アルゴリズムです。 AESは、128、192、または256ビットの鍵と16バイトのブロックサイズを有するブロック暗号です。 TLSは現在、128および256ビットのキーサイズをサポートしています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
application protocol An application protocol is a protocol that normally layers directly on top of the transport layer (e.g., TCP/IP). Examples include HTTP, TELNET, FTP, and SMTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションプロトコルアプリケーションプロトコルは、（例えば、TCP / IP）、トランスポート層の上に直接、通常、層のプロトコルです。例としては、HTTP、TELNET、FTP、およびSMTPが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
asymmetric cipher See public key cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非対称暗号は、公開鍵暗号方式を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
authenticated encryption with additional data (AEAD) A symmetric encryption algorithm that simultaneously provides confidentiality and message integrity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加データ（AEAD）同時に機密性及びメッセージ完全性を提供する対称暗号化アルゴリズムで暗号化認証。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
authentication Authentication is the ability of one entity to determine the identity of another entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
認証認証とは別のエンティティの同一性を決定する一つのエンティティの能力です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
block cipher A block cipher is an algorithm that operates on plaintext in groups of bits, called blocks. 64 bits was, and 128 bits is, a common block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック暗号暗号ブロックは、ブロックと呼ばれる、ビットのグループに平文で動作するアルゴリズムです。 64ビットであり、128ビットは、共通のブロックサイズです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bulk cipher A symmetric encryption algorithm used to encrypt large quantities of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バルク暗号大量のデータを暗号化するために使用される対称暗号化アルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher block chaining (CBC) CBC is a mode in which every plaintext block encrypted with a block cipher is first exclusive-ORed with the previous ciphertext block (or, in the case of the first block, with the initialization vector). For decryption, every block is first decrypted, then exclusive-ORed with the previous ciphertext block (or IV).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号ブロック連鎖（CBC）CBCは、（初期化ベクトルを用いて、または、最初のブロックの場合）ブロック暗号で暗号化されたすべての平文ブロックは、前の暗号文ブロックと第一の排他的論理和するモードです。復号化のために、すべてのブロックが最初に排他的論理和は、前の暗号文ブロック（またはIV）を用いて、復号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate As part of the X.509 protocol (a.k.a. ISO Authentication framework), certificates are assigned by a trusted Certificate Authority and provide a strong binding between a party&#39;s identity or some other attributes and its public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
X.509プロトコル（別称、ISO認証フレームワーク）の一環として、証明書、証明書は信頼できる認証局によって割り当てられ、党のアイデンティティまたはその他の属性と公開鍵の間に強い結合を提供しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client The application entity that initiates a TLS connection to a server. This may or may not imply that the client initiated the underlying transport connection. The primary operational difference between the server and client is that the server is generally authenticated, while the client is only optionally authenticated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントサーバーへのTLS接続を開始アプリケーションエンティティ。これは、クライアントが、ベースとなるトランスポート接続を開始したことを意味しない場合があります。サーバとクライアントとの間の主な操作上の違いは、クライアントが唯一のオプションとして認証されている間、サーバーは、一般的に、認証されていることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client write key The key used to encrypt data written by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、クライアントによって書き込まれたデータを暗号化するために使用されるキーのキーを書きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client write MAC key The secret data used to authenticate data written by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、MACキークライアントによって書き込まれたデータを認証するために使用される秘密データを書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
connection A connection is a transport (in the OSI layering model definition) that provides a suitable type of service. For TLS, such connections are peer-to-peer relationships. The connections are transient. Every connection is associated with one session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続接続は、サービスの適切なタイプを提供する（OSI階層化モデルの定義で）輸送です。 TLSのために、そのような接続は、ピア・ツー・ピア関係です。接続が一時的なものです。すべての接続は、1つのセッションに関連付けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Encryption Standard DES [DES] still is a very widely used symmetric encryption algorithm although it is considered as rather weak now. DES is a block cipher with a 56-bit key and an 8-byte block size. Note that in TLS, for key generation purposes, DES is treated as having an 8-byte key length (64 bits), but it still only provides 56 bits of protection. (The low bit of each key byte is presumed to be set to produce odd parity in that key byte.) DES can also be operated in a mode [3DES] where three independent keys and three encryptions are used for each block of data; this uses 168 bits of key (24 bytes in the TLS key generation method) and provides the equivalent of 112 bits of security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ暗号化規格DES [DES]はまだそれが今のようにかなり弱いと考えられているが、非常に広く使用される対称暗号化アルゴリズムです。 DESは56ビットキーと8バイトのブロックサイズを有するブロック暗号です。 TLSでなお、鍵生成のために、DESは8バイトの鍵長（64ビット）を有するように処理され、それはまだのみ保護の56ビットを提供します。 （各キーのバイトの下位ビットは、そのキーのバイトに奇数パリティを生成するように設定されると推定される）DESはまた、三つの独立したキー三個の暗号化は、データの各ブロックのために使用されるモード[3DES]で動作させることができます。これは、キーの168ビット（TLS鍵生成方法における24バイト）を使用し、セキュリティの112ビットの同等物を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Digital Signature Standard (DSS) A standard for digital signing, including the Digital Signing Algorithm, approved by the National Institute of Standards and Technology, defined in NIST FIPS PUB 186-2, &#34;Digital Signature Standard&#34;, published January 2000 by the U.S. Department of Commerce [DSS]. A significant update [DSS-3] has been drafted and was published in March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
米国務省による2000年1月に公開デジタル署名標準（DSS）NIST FIPS PUB 186-2の中で定義されたアメリカ国立標準技術研究所、「デジタル署名標準」で承認されたデジタル署名アルゴリズムを含むデジタル署名、のための標準的な、コマースの[DSS]。重要な更新[DSS-3]は起草され、2006年3月に発表されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
digital signatures Digital signatures utilize public key cryptography and one-way hash functions to produce a signature of the data that can be authenticated, and is difficult to forge or repudiate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デジタル署名デジタル署名を認証することができるデータの署名を生成するために公開鍵暗号と一方向ハッシュ関数を利用して、偽造又は否認することは困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
handshake An initial negotiation between client and server that establishes the parameters of their transactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その取引のパラメータを確立するために、クライアントとサーバ間の最初のネゴシエーションをハンドシェイク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialization Vector (IV) When a block cipher is used in CBC mode, the initialization vector is exclusive-ORed with the first plaintext block prior to encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロック暗号がCBCモードで使用される初期化ベクトル（IV）は、初期化ベクトルは、暗号化の前に最初の平文ブロックとの排他的論理和です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message Authentication Code (MAC) A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ認証コード（MAC）メッセージ認証コードは、メッセージおよび何らかの秘密データから計算された一方向ハッシュです。秘密データを知らずに偽造することは困難です。その目的は、メッセージが変更されたかどうかを検出することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret Secure secret data used for generating encryption keys, MAC secrets, and IVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化キー、MACシークレット、IVを生成するために使用される秘密セキュアな秘密データを習得。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5 MD5 [MD5] is a hashing function that converts an arbitrarily long data stream into a hash of fixed size (16 bytes). Due to significant progress in cryptanalysis, at the time of publication of this document, MD5 no longer can be considered a &#39;secure&#39; hashing function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5 MD5 [MD5]は固定サイズ（16バイト）のハッシュに任意の長さのデータストリームに変換するハッシュ関数です。暗号解読の大幅な進歩に、このドキュメントの発行時点で、MD5はもはや「安全な」ハッシング機能と考えることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
public key cryptography A class of cryptographic techniques employing two-key ciphers. Messages encrypted with the public key can only be decrypted with the associated private key. Conversely, messages signed with the private key can be verified with the public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2個の鍵を使用する暗号技術の公開鍵暗号Aクラス。公開鍵で暗号化されたメッセージにのみ関連する秘密鍵で復号化することができます。逆に、秘密鍵で署名されたメッセージは、公開鍵で検証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
one-way hash function A one-way transformation that converts an arbitrary amount of data into a fixed-length hash. It is computationally hard to reverse the transformation or to find collisions. MD5 and SHA are examples of one-way hash functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方向ハッシュ関数固定長のハッシュへのデータの任意の量を変換する一方向変換。変換を逆にするか、衝突を発見するのは困難です。 MD5とSHAは、一方向ハッシュ関数の例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC4 A stream cipher invented by Ron Rivest. A compatible cipher is described in [SCH].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロナルド・リベストによって発明されたRC4ストリーム暗号。互換性のある暗号は[SCH]に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA A very widely used public key algorithm that can be used for either encryption or digital signing. [RSA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA Aは非常に広く、暗号化、デジタル署名のどちらにも使用することができ、公開鍵アルゴリズムを使用していました。 [RSA]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server The server is the application entity that responds to requests for connections from clients. See also &#34;client&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーサーバーは、クライアントからの接続のための要求に応答するアプリケーションエンティティです。 「クライアント」も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session A TLS session is an association between a client and a server. Sessions are created by the handshake protocol. Sessions define a set of cryptographic security parameters that can be shared among multiple connections. Sessions are used to avoid the expensive negotiation of new security parameters for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションTLSセッションは、クライアントとサーバの間の関連付けです。セッションはハンドシェイクプロトコルによって作成されます。セッションは複数の接続間で共有できる暗号化セキュリティパラメータのセットを定義します。セッションは、接続ごとに新しいセキュリティパラメータの高価な交渉を回避するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session identifier A session identifier is a value generated by a server that identifies a particular session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション識別子は、セッション識別子は、特定のセッションを識別するサーバによって生成された値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server write key The key used to encrypt data written by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、サーバーによって書き込まれたデータを暗号化するために使用されるキーをキー書きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server write MAC key The secret data used to authenticate data written by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバー書き込みMACサーバーによって書き込まれたデータを認証するために使用される秘密のデータをキーを押します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA The Secure Hash Algorithm [SHS] is defined in FIPS PUB 180-2. It produces a 20-byte output. Note that all references to SHA (without a numerical suffix) actually use the modified SHA-1 algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHAは、セキュアハッシュアルゴリズム[SHS]はFIPS PUB 180-2の中に定義されています。これは、20バイトの出力を生成します。 SHA（数値サフィックスなし）へのすべての参照は、実際に変更SHA-1アルゴリズムを使用することに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA-256 The 256-bit Secure Hash Algorithm is defined in FIPS PUB 180-2. It produces a 32-byte output.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA-256の256ビットセキュアハッシュアルゴリズムは、FIPS PUB 180-2の中に定義されています。これは、32バイトの出力を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSL Netscape&#39;s Secure Socket Layer protocol [SSL3]. TLS is based on SSL Version 3.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSL Netscapeのセキュアソケットレイヤプロトコル[SSL3]。 TLSは、SSLバージョン3.0に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stream cipher An encryption algorithm that converts a key into a cryptographically strong keystream, which is then exclusive-ORed with the plaintext.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その後、平文との排他的論理和である、暗号強度の高いキーストリーム、にキーを変換する暗号化アルゴリズムの暗号ストリーム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
symmetric cipher See bulk cipher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
対称暗号は、バルク暗号を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport Layer Security (TLS) This protocol; also, the Transport Layer Security working group of the Internet Engineering Task Force (IETF). See &#34;Working Group Information&#34; at the end of this document (see page 99).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランスポート層セキュリティ（TLS）このプロトコル。インターネットエンジニアリングタスクフォース（IETF）のも、トランスポート・レイヤ・セキュリティワーキンググループ。このドキュメントの最後に「ワーキング・グループ情報」を参照してください（99ページを参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix C. Cipher Suite Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録C.暗号スイートの定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Cipher Suite Key Cipher Mac Exchange
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
暗号スイート鍵暗号マック交換
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
TLS_NULL_WITH_NULL_NULL NULL NULL NULL TLS_RSA_WITH_NULL_MD5 RSA NULL MD5 TLS_RSA_WITH_NULL_SHA RSA NULL SHA TLS_RSA_WITH_NULL_SHA256 RSA NULL SHA256 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA RSA AES_128_CBC SHA TLS_RSA_WITH_AES_256_CBC_SHA RSA AES_256_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA256 RSA AES_128_CBC SHA256 TLS_RSA_WITH_AES_256_CBC_SHA256 RSA AES_256_CBC SHA256 TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA DH_DSS AES_128_CBC SHA TLS_DH_RSA_WITH_AES_128_CBC_SHA DH_RSA AES_128_CBC SHA TLS_DHE_DSS_WITH_AES_128_CBC_SHA DHE_DSS AES_128_CBC SHA TLS_DHE_RSA_WITH_AES_128_CBC_SHA DHE_RSA AES_128_CBC SHA TLS_DH_anon_WITH_AES_128_CBC_SHA DH_anon AES_128_CBC SHA TLS_DH_DSS_WITH_AES_256_CBC_SHA DH_DSS AES_256_CBC SHA TLS_DH_RSA_WITH_AES_256_CBC_SHA DH_RSA AES_256_CBC SHA TLS_DHE_DSS_WITH_AES_256_CBC_SHA DHE_DSS AES_256_CBC SHA TLS_DHE_RSA_WITH_AES_256_CBC_SHA DHE_RSA AES_256_CBC SHA TLS_DH_anon_WITH_AES_256_CBC_SHA DH_anon AES_256_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA256 DH_DSS AES_128_CBC SHA256 TLS_DH_RSA_WITH_AES_128_CBC_SHA256 DH_RSA AES_128_CBC SHA256 TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 DHE_DSS AES_128_CBC SHA256 TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 DHE_RSA AES_128_CBC SHA256 TLS_DH_anon_WITH_AES_128_CBC_SHA256 DH_anon AES_128_CBC SHA256 TLS_DH_DSS_WITH_AES_256_CBC_SHA256 DH_DSS AES_256_CBC SHA256 TLS_DH_RSA_WITH_AES_256_CBC_SHA256 DH_RSA AES_256_CBC SHA256 TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 DHE_DSS AES_256_CBC SHA256 TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 DHE_RSA AES_256_CBC SHA256 TLS_DH_anon_WITH_AES_256_CBC_SHA256 DH_anon AES_256_CBC SHA256
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
SHA256 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128沙TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC沙TLS_RSA_WITH_AES_128_CBC_SHA RSA AES_128_CBC沙TLS_RSA_WITH_AES_256_CBC_SHA RSA AES_256_CBC沙TLS_RSA_WITH_AES_128_CBC_SHA256 RSA AES_128_CBC SHA256 TLS_RSA_WITH_AES_256_CBC_SHA256 RSA AES_256_CBC SHA256 TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC沙TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSAオーバー沙TLS_RSA_WITH_NULL_SHA256 RSAオーバーMD5 TLS_RSA_WITH_NULL_SHA RSAオーバーTLS_NULL_WITH_NULL_NULLヌルヌルヌルTLS_RSA_WITH_NULL_MD5 RSA 3DES_EDE_CBC沙沙TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC沙TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC沙沙TLS_DH_DSS_WITH_AES_128_CBC_SHA DH_DSS AES_128_CBC TLS_DH_RSA_WITH_AES_128_CBC_SHA DH_RSA AES_128_CBC沙沙TLS_DHE_DSS_WITH_AES_128_CBC_SHA DHE_DSS AES_128_CBC TL S_DHE_RSA_WITH_AES_128_CBC_SHA DHE_RSA AES_128_CBC沙TLS_DH_anon_WITH_AES_128_CBC_SHA DH_anon AES_128_CBC沙TLS_DH_DSS_WITH_AES_256_CBC_SHA DH_DSS AES_256_CBC沙TLS_DH_RSA_WITH_AES_256_CBC_SHA DH_RSA AES_256_CBC沙TLS_DHE_DSS_WITH_AES_256_CBC_SHA DHE_DSS AES_256_CBC沙TLS_DHE_RSA_WITH_AES_256_CBC_SHA DHE_RSA AES_256_CBC沙TLS_DH_anon_WITH_AES_256_CBC_SHA DH_anon AES_256_CBC沙TLS_DH_DSS_WITH_AES_128_CBC_SHA256 DH_DSS AES_128_CBC SHA256 TLS_DH_RSA_WITH_AES_128_CBC_SHA256 DH_RSA AES_128_CBC SHA256 TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 DHE_DSS AES_128_CBC SHA256 TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 DHE_RSA AES_128_CBC SHA256 TLS_DH_anon_WITH_AES_128_CBC_SHA256 DH_anon AES_128_CBC SHA256 TLS_DH_DSS_WITH_AES_256_CBC_SHA256 DH_DSS AES_256_CBC TLS_DH_RSA_WITH_AES_256_CBC_SHA256 DH_RSA AES_256_CBC SHA256 SHA256 SHA256 TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 DHE_DSS AES_256_CBC TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 DHE_RSA AES_256_CBC SHA256 TLS_DH_anon_WITH_AES_256_CBC_SHA256 DH_anon AES_ 256_CBC SHA256
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        Key      IV   Block
Cipher        Type    Material  Size  Size
------------  ------  --------  ----  -----
NULL          Stream      0       0    N/A
RC4_128       Stream     16       0    N/A
3DES_EDE_CBC  Block      24       8      8
AES_128_CBC   Block      16      16     16
AES_256_CBC   Block      32      16     16
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
MAC       Algorithm    mac_length  mac_key_length
--------  -----------  ----------  --------------
NULL      N/A              0             0
MD5       HMAC-MD5        16            16
SHA       HMAC-SHA1       20            20
SHA256    HMAC-SHA256     32            32
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Indicates whether this is a stream cipher or a block cipher running in CBC mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプは、これはストリーム暗号やCBCモードで実行されているブロック暗号であるかどうかを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key Material The number of bytes from the key_block that are used for generating the write keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化キーの書き込みキーを生成するために使用されているなkey_blockからのバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV Size The amount of data needed to be generated for the initialization vector. Zero for stream ciphers; equal to the block size for block ciphers (this is equal to SecurityParameters.record_iv_length).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IVサイズ初期化ベクトルのために生成されるために必要なデータの量。ストリーム暗号のためのゼロ。ブロック暗号のブロックサイズに等しい（これはSecurityParameters.record_iv_lengthに等しいです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Block Size The amount of data a block cipher enciphers in one chunk; a block cipher running in CBC mode can only encrypt an even multiple of its block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ブロックサイズデータの量が1つのチャンク内のブロック暗号暗号化し、 CBCモードで実行されているブロック暗号はそのブロックサイズの倍数を暗号化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix D. Implementation Notes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録D.実装ノート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSプロトコルは、多くの一般的なセキュリティ上のミスを防ぐことはできません。このセクションでは、実装を支援するために、いくつかの提言を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.1. Random Number Generation and Seeding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.1。乱数生成と播種
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS requires a cryptographically secure pseudorandom number generator (PRNG). Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably SHA-1, are acceptable, but cannot provide more security than the size of the random number generator state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは、暗号論的擬似乱数生成器（PRNG）が必要です。ケアのPRNGの設計と播種に注意する必要があります。セキュアハッシュ操作に基づいのPRNG、最も顕著にはSHA-1は、許容可能であるが、乱数発生器の状態のサイズよりも多くのセキュリティを提供することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible&#39;s 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more. Seeding a 128-bit PRNG would thus require approximately 100 such timer values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生産されたシード材料の量を推定するために、各シードバイトの予測不可能な情報のビット数を追加します。例えば、のPC互換18.2 Hzのタイマーから採取したキーストロークタイミング値は、カウンタ値の合計サイズが16ビット以上であっても、1つの又は2の安全なビットそれぞれを提供します。 128ビットのPRNGを播種することは、したがって、約100そのようなタイマ値を必要とするであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RANDOM] provides guidance on the generation of random values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ランダム]はランダム値の生成に関するガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.2. Certificates and Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.2。証明書と認証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully. Users should be able to view information about the certificate and root CA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、証明書の有効性について検証する責任があり、一般的に証明書失効メッセージをサポートする必要があります。証明書は常に信頼できる認証局（CA）によって適切な署名を確認するために検証する必要があります。信頼できるCAの選択や追加は非常に慎重に行われるべきです。ユーザーは、証明書とルートCAの情報を閲覧することができるはずです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.3. Cipher Suites
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.3。暗号スイート
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS supports a range of key sizes and security levels, including some that provide no or minimal security. A proper implementation will probably not support many cipher suites. For instance, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man-in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512- bit RSA keys or signatures are not appropriate for high-security applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSはないか、最小限のセキュリティを提供することも含め、キーのサイズとセキュリティレベルの範囲を、サポートしています。適切な実装は、おそらく多くの暗号スイートをサポートしていません。それはman-in-the-middle攻撃を防ぐことができないので、例えば、匿名のDiffie-Hellmanは強くお勧めします。また、アプリケーションは、最小と最大のキーサイズを強制する必要があります。例えば、512-ビットRSAキーまたは署名を含む証明書チェーンは、高セキュリティアプリケーションに適していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.4. Implementation Pitfalls
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.4。実装の落とし穴
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation experience has shown that certain parts of earlier TLS specifications are not easy to understand, and have been a source of interoperability and security problems. Many of these areas have been clarified in this document, but this appendix contains a short list of the most important things that require special attention from implementors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装経験は、以前のTLS仕様の特定の部分を理解することは容易ではないことが示されている、および相互運用性とセキュリティ問題の原因となっています。これらの地域の多くは、この文書で明らかにされているが、この付録では、実装者からの特別な注意が必要で最も重要なものの短いリストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS protocol issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSプロトコルの問題：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Do you correctly handle handshake messages that are fragmented to multiple TLS records (see Section 6.2.1)? Including corner cases like a ClientHello that is split to several small fragments? Do you fragment handshake messages that exceed the maximum fragment size? In particular, the certificate and certificate request handshake messages can be large enough to require fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - あなたは正しく（6.2.1項を参照）、複数のTLSレコードに断片化されている握手メッセージを処理するのですか？いくつかの小さな断片に分割されたClientHelloのようなコーナーケースを含みますか？あなたは最大フラグメントサイズを超えたハンドシェイクメッセージを断片化していますか？具体的には、証明書と証明書要求ハンドシェイクメッセージは断片化を必要とするほど大きくなることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Do you ignore the TLS record layer version number in all TLS records before ServerHello (see Appendix E.1)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - あなたはのServerHello前にすべてのTLSレコードでTLSレコード層のバージョン番号を無視してください（付録E.1を参照してください）？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Do you handle TLS extensions in ClientHello correctly, including omitting the extensions field completely?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - あなたは完全に拡張フィールドを省略することを含め、正しくのClientHelloでTLS拡張を扱うのですか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Do you support renegotiation, both client and server initiated? While renegotiation is an optional feature, supporting it is highly recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - あなたは、クライアントとサーバーの両方が開始され、再交渉をサポートしていますか？再交渉はオプション機能ですが、それを支援することを強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- When the server has requested a client certificate, but no suitable certificate is available, do you correctly send an empty Certificate message, instead of omitting the whole message (see Section 7.4.6)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - サーバーがクライアント証明書を要求しましたが、もし適切な証明書が利用できない場合、あなたは正しく代わりにメッセージ全体を省略することで、空の証明書メッセージを送信します（セクション7.4.6を参照してください）？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cryptographic details:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化の詳細：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- In the RSA-encrypted Premaster Secret, do you correctly send and verify the version number? When an error is encountered, do you continue the handshake to avoid the Bleichenbacher attack (see Section 7.4.7.1)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  RSA暗号化プレマスターシークレットでは、あなたは正しく送信し、バージョン番号を確認するのですか？エラーが発生したときは、（セクション7.4.7.1を参照）Bleichenbacherの攻撃を避けるためにハンドシェイクを続けるのですか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- What countermeasures do you use to prevent timing attacks against RSA decryption and signing operations (see Section 7.4.7.1)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - どのような対策をします（セクション7.4.7.1を参照）のRSA復号化と署名に対するタイミング攻撃を防ぐために使用しますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- When verifying RSA signatures, do you accept both NULL and missing parameters (see Section 4.7)? Do you verify that the RSA padding doesn&#39;t have additional data after the hash value? [FI06]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 -  RSA署名を検証するときは、NULLと行方不明のパラメータ（4.7節を参照）の両方を受け入れるのですか？あなたは、RSAのパディングがハッシュ値の後に追加のデータを持っていないことを確認しますか？ [FI06]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- When using Diffie-Hellman key exchange, do you correctly strip leading zero bytes from the negotiated key (see Section 8.1.2)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - のDiffie-Hellman鍵交換を使用している場合、あなたは正確に交渉し、キー（8.1.2項を参照）から、ゼロバイトを先行ストリップのですか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Does your TLS client check that the Diffie-Hellman parameters sent by the server are acceptable (see Section F.1.1.3)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - サーバーから送信されたのDiffie-Hellmanパラメータが許容可能であることをごTLSクライアントのチェックが（セクションF.1.1.3を参照）していますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- How do you generate unpredictable IVs for CBC mode ciphers (see Section 6.2.3.2)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - どのようにCBCモード暗号（セクション6.2.3.2を参照）ため、予測不可能なIVを生成するのですか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Do you accept long CBC mode padding (up to 255 bytes; see Section 6.2.3.2)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - あなたは（255のバイトまで、セクション6.2.3.2を参照）長いCBCモードのパディングを受け入れますか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- How do you address CBC mode timing attacks (Section 6.2.3.2)?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - あなたはCBCモードのタイミング攻撃（セクション6.2.3.2）をどのように対処するのですか？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Do you use a strong and, most importantly, properly seeded random number generator (see Appendix D.1) for generating the premaster secret (for RSA key exchange), Diffie-Hellman private values, the DSA &#34;k&#34; parameter, and other security-critical values?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 - あなたが使用していますか強いと、最も重要なのは、適切に、（RSA鍵交換のための）プレマスターの秘密、のDiffie-Hellman非公開値、DSA「K」パラメータを生成するための乱数ジェネレータを（付録D.1を参照）を播種し、他のセキュリティが重要な値？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix E. Backward Compatibility
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録E.旧バージョンとの互換性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E.1. Compatibility with TLS 1.0/1.1 and SSL 3.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E.1。 TLS 1.0 / 1.1およびSSL 3.0との互換性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since there are various versions of TLS (1.0, 1.1, 1.2, and any future versions) and SSL (2.0 and 3.0), means are needed to negotiate the specific protocol version to use. The TLS protocol provides a built-in mechanism for version negotiation so as not to bother other protocol components with the complexities of version selection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSのさまざまなバージョン（1.0、1.1、1.2、および将来のバージョン）やSSL（2.0および3.0）があるので、手段は、使用する特定のプロトコルバージョンを交渉するために必要とされます。バージョン選択の複雑さを有する他のプロトコルコンポーネントを邪魔しないように、TLSプロトコルバージョンネゴシエーションのための組み込み機構を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS versions 1.0, 1.1, and 1.2, and SSL 3.0 are very similar, and use compatible ClientHello messages; thus, supporting all of them is relatively easy. Similarly, servers can easily handle clients trying to use future versions of TLS as long as the ClientHello format remains compatible, and the client supports the highest protocol version available in the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSバージョン1.0、1.1、および1.2、およびSSL 3.0は非常に似ており、互換性のClientHelloメッセージを使用します。したがって、それらのすべてをサポートすることは比較的容易です。同様に、サーバは、簡単のClientHelloフォーマットは互換性を維持し、クライアントがサーバで利用可能な最上位のプロトコルバージョンをサポートしている限り、TLSの将来のバージョンを使用しようとしているクライアントを処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TLS 1.2 client who wishes to negotiate with such older servers will send a normal TLS 1.2 ClientHello, containing { 3, 3 } (TLS 1.2) in ClientHello.client_version. If the server does not support this version, it will respond with a ServerHello containing an older version number. If the client agrees to use this version, the negotiation will proceed as appropriate for the negotiated protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このような古いサーバと交渉することを望むTLS 1.2クライアントはClientHello.client_versionに{3,3}（TLS 1.2）を含む、通常のTLS 1.2のClientHelloを送信します。サーバはこのバージョンをサポートしていない場合、それは古いバージョン番号を含むServerHelloメッセージで応答します。クライアントは、このバージョンを使用することに同意した場合、交渉は交渉されたプロトコルに応じて進行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the version chosen by the server is not supported by the client (or not acceptable), the client MUST send a &#34;protocol_version&#34; alert message and close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーによって選ばれたバージョンがクライアント（または許容できない）でサポートされていない場合、クライアントは「PROTOCOL_VERSION」の警告メッセージを送信し、接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a TLS server receives a ClientHello containing a version number greater than the highest version supported by the server, it MUST reply according to the highest version supported by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSサーバはサーバによってサポートされる最も高いバージョンよりも大きいバージョン番号を含むのClientHelloを受信した場合、それはサーバによってサポートされる最も高いバージョンに応じて応答しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TLS server can also receive a ClientHello containing a version number smaller than the highest supported version. If the server wishes to negotiate with old clients, it will proceed as appropriate for the highest version supported by the server that is not greater than ClientHello.client_version. For example, if the server supports TLS 1.0, 1.1, and 1.2, and client_version is TLS 1.0, the server will proceed with a TLS 1.0 ServerHello. If server supports (or is willing to use) only versions greater than client_version, it MUST send a &#34;protocol_version&#34; alert message and close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSサーバは、最高のサポートされているバージョンよりも小さいバージョン番号を含むのClientHelloを受けることができます。サーバが古いクライアントと交渉することを希望する場合、それはClientHello.client_versionより大きくないサーバーでサポートされる最高のバージョンに応じて進行します。サーバはTLS 1.0、1.1、および1.2をサポートし、クライアント_がTLS 1.0であれば、例えば、サーバはTLS 1.0のServerHelloを進めてまいります。クライアント_よりも唯一のバージョン大きいサーバーがサポートする（または使用する意志がある）場合、それは「PROTOCOL_VERSION」の警告メッセージを送信し、接続を閉じる必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a client already knows the highest protocol version known to a server (for example, when resuming a session), it SHOULD initiate the connection in that native protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（セッションを再開する際に、例えば）クライアントがすでにサーバーに知られている最上位のプロトコルバージョンを知っているときはいつでも、それは、そのネイティブプロトコルで接続を開始すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: some server implementations are known to implement version negotiation incorrectly. For example, there are buggy TLS 1.0 servers that simply close the connection when the client offers a version newer than TLS 1.0. Also, it is known that some servers will refuse the connection if any TLS extensions are included in ClientHello. Interoperability with such buggy servers is a complex topic beyond the scope of this document, and may require multiple connection attempts by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：一部のサーバーの実装が誤ってバージョン交渉を実装することが知られています。たとえば、クライアントがTLS 1.0よりも新しいバージョンを提供するとき、単に接続を閉じるバギーTLS 1.0のサーバーがあります。また、どのTLS拡張はのClientHelloに含まれている場合、一部のサーバが接続を拒否することが知られています。そのようなバグのあるサーバとの相互運用性は、このドキュメントの範囲を超えた複雑な話題であり、クライアントによる複数の接続試行が必要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Earlier versions of the TLS specification were not fully clear on what the record layer version number (TLSPlaintext.version) should contain when sending ClientHello (i.e., before it is known which version of the protocol will be employed). Thus, TLS servers compliant with this specification MUST accept any value {03,XX} as the record layer version number for ClientHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS仕様の以前のバージョンのClientHelloを送信するとき（すなわち、プロトコルのバージョンを使用するものが知られている前に）記録層のバージョン番号（TLSPlaintext.version）が含まれているべきで完全に明らかではなかったです。したがって、この仕様に準拠TLSサーバはのClientHelloの記録層のバージョン番号として任意の値{03、XX}を受け入れなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS clients that wish to negotiate with older servers MAY send any value {03,XX} as the record layer version number. Typical values would be {03,00}, the lowest version number supported by the client, and the value of ClientHello.client_version. No single value will guarantee interoperability with all old servers, but this is a complex topic beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
古いサーバと交渉したいTLSクライアントは記録層のバージョン番号として任意の値{03、XX}を送るかもしれません。典型的な値は、{03,00}クライアントでサポートされている最も低いバージョン番号、及びClientHello.client_versionの値であろう。いかなる単一の値は、すべての古いサーバとの相互運用性を保証しませんが、これは、このドキュメントの範囲を超えた複雑な話題です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E.2. Compatibility with SSL 2.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E.2。 SSL 2.0との互換性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.2 clients that wish to support SSL 2.0 servers MUST send version 2.0 CLIENT-HELLO messages defined in [SSL2]. The message MUST contain the same version number as would be used for ordinary ClientHello, and MUST encode the supported TLS cipher suites in the CIPHER-SPECS-DATA field as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSL 2.0サーバーをサポートしたいTLS 1.2のクライアントは、バージョン[SSL2]で定義された2.0 CLIENT-HELLOメッセージを送らなければなりません。メッセージは、通常のClientHelloのために使用されるのと同じバージョン番号を含まなければなりません、そして以下に記載するようにCIPHER-SPECS-DATAフィールドにサポートされているTLS暗号スイートをコードしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Warning: The ability to send version 2.0 CLIENT-HELLO messages will be phased out with all due haste, since the newer ClientHello format provides better mechanisms for moving to newer versions and negotiating extensions. TLS 1.2 clients SHOULD NOT support SSL 2.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
警告：新しいのClientHelloフォーマットは新しいバージョンと交渉拡張に移動するためのより良いメカニズムを提供するので、バージョン2.0クライアントハローメッセージを送信する能力は、全てにより急いで段階的に廃止されます。 TLS 1.2クライアントは、SSL 2.0をサポートしていない（SHOULD NOT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, even TLS servers that do not support SSL 2.0 MAY accept version 2.0 CLIENT-HELLO messages. The message is presented below in sufficient detail for TLS server implementors; the true definition is still assumed to be [SSL2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、SSL 2.0をサポートしていません。でも、TLSサーバは、バージョン2.0 CLIENT-HELLOメッセージを受け入れることができます。メッセージは、TLSサーバーの実装のために十分詳細に以下に提示されます。真の定義はまだ[SSL2]であると仮定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For negotiation purposes, 2.0 CLIENT-HELLO is interpreted the same way as a ClientHello with a &#34;null&#34; compression method and no extensions. Note that this message MUST be sent directly on the wire, not wrapped as a TLS record. For the purposes of calculating Finished and CertificateVerify, the msg_length field is not considered to be a part of the handshake message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネゴシエーションの目的のために、2.0クライアントハローは「ヌル」圧縮方式なし拡張子のClientHelloと同じように解釈されます。このメッセージは、TLSレコードとしてラップではない、ワイヤーに直接送らなければならないことに注意してください。終了しCertificateVerify計算の目的のために、msg_lengthフィールドは、ハンドシェイクメッセージの一部であるとは考えられません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      uint8 V2CipherSpec[3];
      struct {
          uint16 msg_length;
          uint8 msg_type;
          Version version;
          uint16 cipher_spec_length;
          uint16 session_id_length;
          uint16 challenge_length;
          V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
          opaque session_id[V2ClientHello.session_id_length];
          opaque challenge[V2ClientHello.challenge_length;
      } V2ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
msg_length The highest bit MUST be 1; the remaining bits contain the length of the following data in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最上位ビットが1でなければなりませんmsg_length。残りのビットは、バイト単位で、次のデータの長さを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
msg_type This field, in conjunction with the version field, identifies a version 2 ClientHello message. The value MUST be 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このフィールドMSG_TYPE、バージョンフィールドと関連して、バージョン2のClientHelloメッセージを識別する。値は1でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version Equal to ClientHello.client_version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ClientHello.client_versionに等しいバージョン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_spec_length This field is the total length of the field cipher_specs. It cannot be zero and MUST be a multiple of the V2CipherSpec length (3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_spec長さこのフィールドは、フィールドcipher_specsの長さの合計です。それはゼロにすることはできず、V2暗号スペック長さ（3）の倍数でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id_length This field MUST have a value of zero for a client that claims to support TLS 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id_lengthこのフィールドは、TLS 1.2をサポートするために主張し、クライアントのためにゼロの値を持つ必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge_length The length in bytes of the client&#39;s challenge to the server to authenticate itself. Historically, permissible values are between 16 and 32 bytes inclusive. When using the SSLv2 backward-compatible handshake the client SHOULD use a 32-byte challenge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
自身を認証するために、サーバーへのクライアントの挑戦の長さをバイト単位でchallenge_length。歴史的には、許容値が16と32バイトとの間に含まれています。 SSLv2の後方互換性のハンドシェイクを使用している場合、クライアントは、32バイトのチャレンジを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_specs This is a list of all CipherSpecs the client is willing and able to use. In addition to the 2.0 cipher specs defined in [SSL2], this includes the TLS cipher suites normally sent in ClientHello.cipher_suites, with each cipher suite prefixed by a zero byte. For example, the TLS cipher suite {0x00,0x0A} would be sent as {0x00,0x00,0x0A}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_specsこれは、クライアントが喜んでと使用することができ、すべてのCipherSpecのリストです。 [SSL2]で定義された2.0暗号仕様に加えて、これは通常ゼロバイトで始まる各暗号スイートと、でClientHello.cipher_で送信TLS暗号スイートを含みます。例えば、TLS暗号スイート{0x00,0x0Aは} {0x00,0x00,0x0A}として送信されることになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id This field MUST be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SESSION_IDこのフィールドは空である必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge Corresponds to ClientHello.random. If the challenge length is less than 32, the TLS server will pad the data with leading (note: not trailing) zero bytes to make it 32 bytes long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
課題は、ClientHello.randomとに対応します。チャレンジの長さが32未満の場合、TLSサーバー意志パッドリーディング（注：末尾ではない）とのデータのゼロバイトは、32バイト長作ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Requests to resume a TLS session MUST use a TLS client hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：TLSセッションを再開する要求はTLSクライアントのhelloを使用しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E.3. Avoiding Man-in-the-Middle Version Rollback
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E.3。マン・イン・ザ・ミドル・バージョンのロールバックを回避
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When TLS clients fall back to Version 2.0 compatibility mode, they MUST use special PKCS#1 block formatting. This is done so that TLS servers will reject Version 2.0 sessions with TLS-capable clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSクライアントがバックバージョン2.0互換モードにフォールすると、彼らは特別なPKCS＃1ブロックフォーマットを使用しなければなりません。 TLSサーバがTLS対応のクライアントとのバージョン2.0セッションを拒絶するように行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client negotiates SSL 2.0 but also supports TLS, it MUST set the right-hand (least-significant) 8 random bytes of the PKCS padding (not including the terminal null of the padding) for the RSA encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY to 0x03 (the other padding bytes are random).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、SSL 2.0を交渉するだけでなく、TLSをサポートしている場合、それは、暗号化さ-KEY-のRSA暗号化のために右手（パディングの端子ヌルは含みません）PKCSパディングの（最下位）8つのランダムバイトを設定しなければなりません0×03にCLIENT-MASTER-KEYのDATAフィールド（他のパディングバイトがランダムです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a TLS-capable server negotiates SSL 2.0 it SHOULD, after decrypting the ENCRYPTED-KEY-DATA field, check that these 8 padding bytes are 0x03. If they are not, the server SHOULD generate a random value for SECRET-KEY-DATA, and continue the handshake (which will eventually fail since the keys will not match). Note that reporting the error situation to the client could make the server vulnerable to attacks described in [BLEI].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS対応のサーバーがSSL 2.0を交渉するときには、ENCRYPTED-KEY-DATAフィールドを復号化した後、これらの8詰め物バイトが0x03であることを確認する必要があります。そうでない場合は、サーバーはSECRET-KEY-DATAのためのランダムな値を生成し、（キーが一致しませんので、最終的に失敗するでしょう）握手を続けるべきです。クライアントにエラー状況を報告すると、[BLEI]で説明された攻撃にサーバが脆弱に作ることができることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix F. Security Analysis
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録F.セキュリティ分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSプロトコルは、クライアントと安全でないチャネルを介して通信サーバ間の安全な接続を確立するために設計されています。この文書では、攻撃者が実質的な計算リソースを持っており、プロトコル外部ソースから秘密情報を得ることができないことを含め、いくつかの伝統的な仮定を行います。攻撃者は、キャプチャ、変更、削除、再生、およびそれ以外の通信チャネルを介して送信されたメッセージを改ざんする能力を持っていると想定されています。この付録では、TLSがさまざまな攻撃に耐えるように設計されている方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1. Handshake Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1。ハンドシェイクプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake protocol is responsible for selecting a cipher spec and generating a master secret, which together comprise the primary cryptographic parameters associated with a secure session. The handshake protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ハンドシェイクプロトコルは、暗号化仕様を選択し、一緒に安全なセッションに関連付けられたプライマリ暗号パラメータを含むマスターシークレットを生成する責任があります。ハンドシェイクプロトコルはまた、必要に応じて、信頼できる認証局によって署名された証明書を持って、当事者を認証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.1. Authentication and Key Exchange
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.1。認証と鍵交換
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other&#39;s certificate is valid and has not expired or been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両当事者の認証、認証されていないクライアントとサーバー認証、および総匿名：TLSは、3つの認証モードをサポートしています。サーバーが認証されるたびに、チャネルは、man-in-the-middle攻撃に対して安全であるが、完全に匿名のセッションはそのような攻撃にさらされやすいです。匿名のサーバはクライアントを認証することはできません。サーバーが認証されている場合は、その証明書のメッセージは許容できる認証局につながる有効な証明書チェーンを提供する必要があります。同様に、認証されたクライアントは、サーバーへの許容可能な証明書を提供する必要があります。各当事者は、他の証明書が有効で、期限が切れていないか、取り消されていることを検証する責任があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general goal of the key exchange process is to create a pre_master_secret known to the communicating parties and not to attackers. The pre_master_secret will be used to generate the master_secret (see Section 8.1). The master_secret is required to generate the Finished messages, encryption keys, and MAC keys (see Sections 7.4.9 and 6.3). By sending a correct Finished message, parties thus prove that they know the correct pre_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鍵交換プロセスの一般的な目標は、通信相手にしていない攻撃者に知られている前_のマスター_秘密を作成することです。前_のマスター_秘密をmaster_secretを生成するのに使用されます（8.1節を参照してください）。でマスター_はFinishedメッセージ、暗号化キー、およびMACキーを（セクション7.4.9と6.3を参照）を生成するために必要とされます。正しいFinishedメッセージを送信することにより、関係者は、このように、彼らは正しい前_のマスター_秘密を知っていることを証明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.1.1. Anonymous Key Exchange
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.1.1。匿名の鍵交換
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Completely anonymous sessions can be established using Diffie-Hellman for key exchange. The server&#39;s public parameters are contained in the server key exchange message, and the client&#39;s are sent in the client key exchange message. Eavesdroppers who do not know the private values should not be able to find the Diffie-Hellman result (i.e., the pre_master_secret).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全に匿名のセッションは、鍵交換にDiffie-Hellmanのを使用して確立することができます。サーバーの公開パラメータは、サーバ鍵交換メッセージに含まれており、クライアントのは、クライアント鍵交換メッセージで送信されます。民間の値を知らない盗聴者は、Diffie-Hellman結果（すなわち、前_のマスター_秘密を）見つけることができないようにする必要があり。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Warning: Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the Finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
警告：完全に匿名接続のみ受動的盗聴に対する保護を提供します。独立した改ざん防止チャンネルがFinishedメッセージが攻撃者に取り替えられなかったことを確認するために使用されていない限り、サーバー認証がアクティブman-in-the-middle攻撃が懸念されている環境で必要とされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.1.2. RSA Key Exchange and Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.1.2。 RSA鍵交換と認証
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With RSA, key exchange and server authentication are combined. The public key is contained in the server&#39;s certificate. Note that compromise of the server&#39;s static RSA key results in a loss of confidentiality for all sessions protected under that static key. TLS users desiring Perfect Forward Secrecy should use DHE cipher suites. The damage done by exposure of a private key can be limited by changing one&#39;s private key (and certificate) frequently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAでは、鍵交換およびサーバー認証が組み合わされています。公開鍵は、サーバーの証明書に含まれています。その静的なキーの下に保護されたすべてのセッションの機密性の損失におけるサーバの静的なRSAキーの結果の妥協点に注意してください。完全転送秘密を希望TLSユーザはDHE暗号スイートを使用する必要があります。秘密鍵の暴露によるダメージは、頻繁に自分の秘密鍵（および証明書）を変更することによって制限することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After verifying the server&#39;s certificate, the client encrypts a pre_master_secret with the server&#39;s public key. By successfully decoding the pre_master_secret and producing a correct Finished message, the server demonstrates that it knows the private key corresponding to the server certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーの証明書を検証した後、クライアントは、サーバの公開鍵で前_のマスター_秘密を暗号化します。首尾よく前_のマスター_秘密を解読し、正しいFinishedメッセージを出すことによって、サーバは、サーバ証明書に対応する秘密鍵を知っていることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RSA is used for key exchange, clients are authenticated using the certificate verify message (see Section 7.4.8). The client signs a value derived from all preceding handshake messages. These handshake messages include the server certificate, which binds the signature to the server, and ServerHello.random, which binds the signature to the current handshake process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSAは、鍵交換に使用されている場合、クライアントは証明書（セクション7.4.8を参照）のメッセージを確認するを使用して認証されます。クライアントは、先行するすべてのハンドシェイクメッセージから得られた値に署名します。これらのハンドシェイクメッセージは、現在のハンドシェイクプロセスへの署名をバインドするサーバーサーバーへの署名を結合した証明書、およびServerHello.randomが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.1.3. Diffie-Hellman Key Exchange with Authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.1.3。認証を使ってDiffie-Hellman鍵交換
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When Diffie-Hellman key exchange is used, the server can either supply a certificate containing fixed Diffie-Hellman parameters or use the server key exchange message to send a set of temporary Diffie-Hellman parameters signed with a DSA or RSA certificate. Temporary parameters are hashed with the hello.random values before signing to ensure that attackers do not replay old parameters. In either case, the client can verify the certificate or signature to ensure that the parameters belong to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Diffie-Hellman鍵交換を使用した場合、サーバは、固定のDiffie-Hellmanパラメータを含む証明書を提供またはDSAまたはRSA証明書で署名された一時的のDiffie-Hellmanパラメータのセットを送信するためにサーバ鍵交換メッセージを使用しますか。一時的なパラメータは、攻撃者が古いパラメータを再生していないことを保証するために署名する前のhello.random値でハッシュ化されています。いずれの場合も、クライアントは、パラメータがサーバーに属していることを確認するために証明書または署名を検証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has a certificate containing fixed Diffie-Hellman parameters, its certificate contains the information required to complete the key exchange. Note that in this case the client and server will generate the same Diffie-Hellman result (i.e., pre_master_secret) every time they communicate. To prevent the pre_master_secret from staying in memory any longer than necessary, it should be converted into the master_secret as soon as possible. Client Diffie-Hellman parameters must be compatible with those supplied by the server for the key exchange to work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが固定Diffie-Hellmanパラメータを含む証明書を持っている場合は、その証明書は、鍵交換を完了するために必要な情報が含まれています。この場合、クライアントとサーバが同一のDiffie-Hellman結果（すなわち、前_のマスター_秘密）は、それらが通信するたびに発生することに注意してください。もはや必要以上にメモリに滞在から前_のマスター_秘密を防止するためには、できるだけ早くmaster_secretへ変換する必要があります。クライアントのDiffie-Hellmanパラメータは、鍵交換を行うために、サーバによって提供されたものと互換性がなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has a standard DSA or RSA certificate or is unauthenticated, it sends a set of temporary parameters to the server in the client key exchange message, then optionally uses a certificate verify message to authenticate itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、標準のDSAまたはRSA証明書を持っているか、認証されていない場合には、それはクライアント鍵交換メッセージでサーバーに一時的なパラメータのセットを送信し、その後、必要に応じて自分自身を認証するためのメッセージを確認し、証明書を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the same DH keypair is to be used for multiple handshakes, either because the client or server has a certificate containing a fixed DH keypair or because the server is reusing DH keys, care must be taken to prevent small subgroup attacks. Implementations SHOULD follow the guidelines found in [SUBGROUP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じDH鍵ペアは、複数の握手のために使用される、クライアントまたはサーバが固定DH鍵ペアを含む証明書を持っているか、サーバがDHキーを再利用しているため、介護が小さいサブグループ攻撃を防ぐために取らなければならないので、場合。実装は[SUBGROUP]で見つかったガイドラインに従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Small subgroup attacks are most easily avoided by using one of the DHE cipher suites and generating a fresh DH private key (X) for each handshake. If a suitable base (such as 2) is chosen, g^X mod p can be computed very quickly; therefore, the performance cost is minimized. Additionally, using a fresh key for each handshake provides Perfect Forward Secrecy. Implementations SHOULD generate a new X for each handshake when using DHE cipher suites.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
小さなサブグループ攻撃は、最も簡単にDHE暗号スイートのいずれかを使用し、各握手のために新鮮なDH秘密鍵（X）を生成することによって回避されています。 （例えば2など）の適切な塩基を選択した場合、G ^ X MOD pが非常に迅速に計算することができます。そのため、パフォーマンスコストが最小化されます。また、各握手のために新鮮なキーを使用すると、完全転送秘密を提供します。 DHE暗号スイートを使用した場合、実装は各握手のための新しいXを生成する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because TLS allows the server to provide arbitrary DH groups, the client should verify that the DH group is of suitable size as defined by local policy. The client SHOULD also verify that the DH public exponent appears to be of adequate size. [KEYSIZ] provides a useful guide to the strength of various group sizes. The server MAY choose to assist the client by providing a known group, such as those defined in [IKEALG] or [MODP]. These can be verified by simple comparison.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSサーバは、任意のDHグループを提供することを可能にするため、クライアントは、ローカルポリシーによって定義されたDH群は適切なサイズのものであることを確認すべきです。また、クライアントは、DH公開指数が適切なサイズのように見えることを確認する必要があります。 【KEYSIZ様々なグループサイズの強度に有用な指針を提供します。サーバーは、[IKEALG]または[MODP]定義されたものとして、知られているグループを提供することにより、クライアントを支援するために選ぶかもしれません。これらは、単純な比較によって検証することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.2. Version Rollback Attacks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.2。バージョンロールバック攻撃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS-capable parties use an SSL 2.0 handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは、SSLバージョン2.0からのかなりの改良が含まれているため、攻撃者は、TLS対応のクライアントとサーバがバージョン2.0に戻すようにさせるかもしれません。 （および場合のみ）2 TLS対応の当事者はSSL 2.0ハンドシェイクを使用する場合は、この攻撃が発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute-force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application-specified wait threshold has expired. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非ランダムPKCS＃1ブロック型2メッセージパディングを使用したソリューションは無粋ですが、それはバージョン3.0のサーバーが攻撃を検出するための合理的に安全な方法を提供します。このソリューションは、ブルートフォースキーを、アプリケーションが指定した待機しきい値が経過する前に同じキーを（ただし、通常のパディングを持つ）を含む新しいENCRYPTED-KEY-DATAメッセージを置き換えることができ、攻撃者に対して安全ではありません。これは8バイトの入力ブロックサイズを大きくすると本質的に同等であるので、PKCSパディングの最下位8バイトのパディングを変更すると、署名されたハッシュとプロトコルで使用されるRSA鍵の長さのサイズのセキュリティに影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.3. Detecting Attacks Against the Handshake Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.3。ハンドシェイクプロトコルに対する攻撃を検出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally choose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者は、当事者が、彼らは通常、選ぶだろうとは異なる暗号化アルゴリズムを選択するためにハンドシェイク交換に影響を与えることを試みるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others&#39; Finished messages. Without the master_secret, the attacker cannot repair the Finished messages, so the attack will be discovered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この攻撃では、攻撃者が積極的に一つ以上のハンドシェイクメッセージを変更する必要があります。この問題が発生した場合、クライアントとサーバーはハンドシェイクメッセージのハッシュに異なる値を計算します。その結果、当事者はお互いのFinishedメッセージを受け付けません。攻撃が検出されますので、マスター_がなければ、攻撃者は、Finishedメッセージを修復することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.4. Resuming Sessions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.1.4。セッションを再開
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a connection is established by resuming a session, new ClientHello.random and ServerHello.random values are hashed with the session&#39;s master_secret. Provided that the master_secret has not been compromised and that the secure hash operations used to produce the encryption keys and MAC keys are secure, the connection should be secure and effectively independent from previous connections. Attackers cannot use known encryption keys or MAC secrets to compromise the master_secret without breaking the secure hash operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接続がセッションを再開することによって確立されたとき、新しいClientHello.randomととServerHello.random値はセッションのマスター_秘密で論じ尽くされます。マスター_が損なわれていないことと、暗号化鍵とMAC鍵を生成するために使用されるセキュアハッシュ操作が安全であることを条件とする、接続は、以前の接続から安全かつ効果的に独立であるべきです。攻撃者は、安全なハッシュ操作を壊すことなくでマスター_を損なうことが知られている暗号化キーまたはMAC秘密を使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sessions cannot be resumed unless both the client and server agree. If either party suspects that the session may have been compromised, or that certificates may have expired or been revoked, it should force a full handshake. An upper limit of 24 hours is suggested for session ID lifetimes, since an attacker who obtains a master_secret may be able to impersonate the compromised party until the corresponding session ID is retired. Applications that may be run in relatively insecure environments should not write session IDs to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバの両方が同意しない限り、セッションは再開できません。いずれかの当事者が、セッションが侵害された可能性があること、または証明書の期限が切れたか、取り消されていることを疑った場合、それは完全なハンドシェイクを強制する必要があります。対応するセッションIDがリタイアするまでmaster_secretを入手した攻撃者は妥協がパーティを偽装することができる可能性があるため、24時間の上限は、セッションIDの寿命のために提案されます。比較的安全でない環境で実行されるアプリケーションは、安定したストレージにセッションIDを書くべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.2. Protecting Application Data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.2。アプリケーションデータの保護
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master_secret is hashed with the ClientHello.random and ServerHello.random to produce unique data encryption keys and MAC secrets for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
でマスター_は、接続ごとに固有のデータ暗号化鍵とMACシークレットを生成するためのClientHello.randomとServerHello.randomでハッシュされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outgoing data is protected with a MAC before transmission. To prevent message replay or modification attacks, the MAC is computed from the MAC key, the sequence number, the message length, the message contents, and two fixed character strings. The message type field is necessary to ensure that messages intended for one TLS record layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64 bits long, they should never overflow. Messages from one party cannot be inserted into the other&#39;s output, since they use independent MAC keys. Similarly, the server write and client write keys are independent, so stream cipher keys are used only once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信データが送信される前にMACで保護されています。メッセージの再生や修正の攻撃を防ぐために、MACはMACキー、シーケンス番号、メッセージ長、メッセージの内容、および2つの固定文字列から計算されます。メッセージタイプフィールドは1つのTLSレコード層クライアント向けのメッセージを別のにリダイレクトされていないことを確認する必要があります。シーケンス番号は、メッセージを削除したり、並べ替えしようとする試みが検出されることを保証します。シーケンス番号は64ビット長であるので、彼らがオーバーフローありません。彼らは独立したMACキーを使用するので、1回のパーティーからのメッセージは、相手の出力に挿入することはできません。同様に、サーバーの書き込みとクライアントの書き込みキーが独立しているので、暗号キーは一度だけ使用されているストリーム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an attacker does break an encryption key, all messages encrypted with it can be read. Similarly, compromise of a MAC key can make message-modification attacks possible. Because MACs are also encrypted, message-alteration attacks generally require breaking the encryption algorithm as well as the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻撃者が暗号化キーを破るない場合、それを用いて暗号化されたすべてのメッセージを読み取ることができます。同様に、MACキーの妥協点は、メッセージ変更攻撃を可能にすることができます。 MACのも暗号化されているので、メッセージ改ざん攻撃は、一般的に、暗号化アルゴリズムと同様にMACを破る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: MAC keys may be larger than encryption keys, so messages can remain tamper resistant even if encryption keys are broken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：メッセージは暗号化キーが壊れている場合でも、耐タンパ残ることができるようにMACキーは、暗号化キーより大きいかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.3. Explicit IVs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.3。明示的なIV
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBCATT] describes a chosen plaintext attack on TLS that depends on knowing the IV for a record. Previous versions of TLS [TLS1.0] used the CBC residue of the previous record as the IV and therefore enabled this attack. This version uses an explicit IV in order to protect against this attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBCATT]はレコードのIVを知ることに依存TLS上の選択平文攻撃を説明しています。 TLSの以前のバージョンでは、[TLS1.0] IVとして前のレコードのCBC残基を使用し、したがって、この攻撃を可能にしました。このバージョンでは、この攻撃から保護するために、明示的なIVを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.4. Security of Composite Cipher Modes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.4。コンポジット暗号モードのセキュリティ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS secures transmitted application data via the use of symmetric encryption and authentication functions defined in the negotiated cipher suite. The objective is to protect both the integrity and confidentiality of the transmitted data from malicious actions by active attackers in the network. It turns out that the order in which encryption and authentication functions are applied to the data plays an important role for achieving this goal [ENCAUTH].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは、ネゴシエートされた暗号スイートに定義され、対称暗号化と認証機能の使用を介して送信されたアプリケーションデータを保護します。目的は、ネットワーク内のアクティブな攻撃者によって悪質な行為から送信されたデータの整合性と機密性の両方を保護することです。これは、暗号化と認証機能をデータに適用される順序は、この目標[ENCAUTH]を達成するための重要な役割を果たしていることが判明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most robust method, called encrypt-then-authenticate, first applies encryption to the data and then applies a MAC to the ciphertext. This method ensures that the integrity and confidentiality goals are obtained with ANY pair of encryption and MAC functions, provided that the former is secure against chosen plaintext attacks and that the MAC is secure against chosen-message attacks. TLS uses another method, called authenticate-then-encrypt, in which first a MAC is computed on the plaintext and then the concatenation of plaintext and MAC is encrypted. This method has been proven secure for CERTAIN combinations of encryption functions and MAC functions, but it is not guaranteed to be secure in general.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化は、当時の認証と呼ばれる最も堅牢な方法は、第1のデータに暗号化を適用して、暗号文にMACを適用します。この方法は、完全性と機密性の目標は、暗号化とMAC機能の任意のペアを用いて得られることを保証し、前者は選択平文攻撃に対するおよびMACは、選択したメッセージ攻撃に対して安全である安全であることを条件とします。 TLSは、最初のMACが平文で計算され、その後、平文とMACの連結が暗号化された認証、次いで暗号化と呼ばれる別の方法を使用します。この方法では、暗号化機能とMAC機能の特定の組み合わせのために安全な証明されているが、一般的に安全であると保証するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In particular, it has been shown that there exist perfectly secure encryption functions (secure even in the information-theoretic sense) that combined with any secure MAC function, fail to provide the confidentiality goal against an active attack. Therefore, new cipher suites and operation modes adopted into TLS need to be analyzed under the authenticate-then-encrypt method to verify that they achieve the stated integrity and confidentiality goals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に、任意の安全なMAC機能と組み合わせる完全に安全な暗号化機能が（たとえ情報理論的な意味で固定）、アクティブ攻撃に対する機密性の目標を提供することができないが存在することが示されています。したがって、TLSに採用した新しい暗号スイートおよび動作モードは、彼らが述べ完全性と機密性の目標を達成することを確認するために、認証、そして暗号化方式で分析する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Currently, the security of the authenticate-then-encrypt method has been proven for some important cases. One is the case of stream ciphers in which a computationally unpredictable pad of the length of the message, plus the length of the MAC tag, is produced using a pseudorandom generator and this pad is exclusive-ORed with the concatenation of plaintext and MAC tag. The other is the case of CBC mode using a secure block cipher. In this case, security can be shown if one applies one CBC encryption pass to the concatenation of plaintext and MAC and uses a new, independent, and unpredictable IV for each new pair of plaintext and MAC. In versions of TLS prior to 1.1, CBC mode was used properly EXCEPT that it used a predictable IV in the form of the last block of the previous ciphertext. This made TLS open to chosen plaintext attacks. This version of the protocol is immune to those attacks. For exact details in the encryption modes proven secure, see [ENCAUTH].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在、認証、そして暗号化方式のセキュリティは、いくつかの重要な例のために証明されています。一つは、メッセージの長さの計算予測不可能なパッド、プラスMACタグの長さは、擬似乱数生成器を用いて製造されたストリーム暗号の場合であり、このパッドは、平文とMACタグの連結と排他的論理和です。他のセキュアなブロック暗号を使用して、CBCモードの場合です。一つは平文とMACの連結に1つのCBC暗号化パスを適用して平文とMACの新しい各対について、新たな独立した予測不可能なIVを使用している場合この場合、セキュリティを示すことができます。 1.1前TLSのバージョンでは、CBCモードは、前の暗号文の最後のブロックの形で予測可能なIVを使用することを除いて適切に使用されました。これは、TLSは平文攻撃を選択するために開きました。プロトコルのこのバージョンは、これらの攻撃に免疫があります。安全な実績のある暗号化モードでの正確な詳細については、[ENCAUTH]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.5. Denial of Service
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.5。サービス拒否
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS is susceptible to a number of denial-of-service (DoS) attacks. In particular, an attacker who initiates a large number of TCP connections can cause a server to consume large amounts of CPU for doing RSA decryption. However, because TLS is generally used over TCP, it is difficult for the attacker to hide his point of origin if proper TCP SYN randomization is used [SEQNUM] by the TCP stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSは、サービス拒否（DoS）攻撃の数の影響を受けやすいです。具体的には、TCPコネクションの多数を開始し、攻撃者は、サーバーがRSAの復号化を行うためのCPUを大量に消費する可能性があります。 TLSは、一般的にTCP上で使用されているため、適切なTCPのSYNのランダム化は、TCPスタックによって[SEQNUM]使用されている場合、攻撃者が起源の彼のポイントを非表示にするためしかし、それは困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because TLS runs over TCP, it is also susceptible to a number of DoS attacks on individual connections. In particular, attackers can forge RSTs, thereby terminating connections, or forge partial TLS records, thereby causing the connection to stall. These attacks cannot in general be defended against by a TCP-using protocol. Implementors or users who are concerned with this class of attack should use IPsec AH [AH] or ESP [ESP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSはTCP上で実行されるため、それはまた、個々の接続にDoS攻撃の数の影響を受けやすいです。具体的には、攻撃者は、偽造のRSTをこれによって接続を終了する、または部分的なTLSレコードを偽造することにより停止する接続を生じさせることができます。これらの攻撃は、一般的にTCP-使用してプロトコルによりに対して擁護することはできません。攻撃のこのクラスに関係している実装者またはユーザーは、IPsec AH [AH]またはESP [ESP]を使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.6. Final Notes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.6。最終的な注意事項
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLSが安全な接続を提供することができるようにするには、クライアントとサーバシステム、キー、およびアプリケーションの両方が安全でなければなりません。また、実装は、セキュリティエラーがあってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
システムは、最も弱いキー交換および認証アルゴリズムがサポートされる唯一のような強く、唯一信頼できる暗号化機能を使用すべきです。短い公開鍵と匿名のサーバは十分に注意して使用する必要があります。証明書と認証局が許容されるかを決めるとき、実装し、ユーザーが注意しなければなりません。不正認証局は多大なダメージを与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Normative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
引用規格
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AES] National Institute of Standards and Technology, &#34;Specification for the Advanced Encryption Standard (AES)&#34; FIPS 197. November 26, 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準技術[AES]国立研究所、FIPS 197 2001年11月26日 &#34;のAdvanced Encryption Standard（AES）のための仕様&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3DES] National Institute of Standards and Technology, &#34;Recommendation for the Triple Data Encryption Algorithm (TDEA) Block Cipher&#34;, NIST Special Publication 800-67, May 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3DES]、は、NIST Special Publication 800から67、2004年5月米国国立標準技術研究所、「トリプル・データ暗号化アルゴリズム（TDEA）ブロック暗号のための勧告」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS] NIST FIPS PUB 186-2, &#34;Digital Signature Standard&#34;, National Institute of Standards and Technology, U.S. Department of Commerce, 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS] NIST FIPS PUB 186-2、「デジタル署名標準」、アメリカ国立標準技術研究所、米国商務省が2000年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HMAC] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 &#34;HMAC：メッセージ認証のための鍵付きハッシュ化&#34;、RFC 2104、1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest, R., &#34;The MD5 Message-Digest Algorithm&#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest氏、R.、 &#34;MD5メッセージダイジェストアルゴリズム&#34;、RFC 1321、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS1] Jonsson, J. and B. Kaliski, &#34;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1&#34;, RFC 3447, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS1]ジョンソン、J.とB. Kaliski、 &#34;公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1&#34;、RFC 3447、2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKIX] Housley, R., Polk, W., Ford, W., and D. Solo, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 3280, April 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKIX] Housley氏、R.、ポーク、W.、フォード、W.、およびD.ソロ、 &#34;インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィール&#34;、RFC 3280、2002年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCH] B. Schneier. &#34;Applied Cryptography: Protocols, Algorithms, and Source Code in C, 2nd ed.&#34;, Published by John Wiley &amp; Sons, Inc. 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCH] B.シュナイアー。 &#34;応用暗号：プロトコル、アルゴリズム、およびCでのソースコード、第2版&#34;、John Wiley＆Sons社1996年発行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHS] NIST FIPS PUB 180-2, &#34;Secure Hash Standard&#34;, National Institute of Standards and Technology, U.S. Department of Commerce, August 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHS] NISTのFIPS PUB 180-2、国立標準技術研究所、商業、2002年8月の米国部門「ハッシュ標準セキュア」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REQ] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REQ]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2434] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 2434, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2434] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 2434、1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X680] ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002, Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X680] ITU-T勧告X.680（2002）| ISO / IEC 8824から1：2002、情報技術 - 抽象構文記法1（ASN.1）：基本的な記法の仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X690] ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002, Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X690] ITU-T勧告X.690（2002）| ISO / IEC 8825から1：2002、情報技術 -  ASN.1エンコーディングルール：基本符号化規則（BER）の仕様、Canonicalの符号化規則（CER）、および顕著な符号化規則（DER）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Informative References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
参考文献
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AEAD] McGrew, D., &#34;An Interface and Algorithms for Authenticated Encryption&#34;, RFC 5116, January 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AEAD]マグリュー、D.、 &#34;認証暗号化のためのインタフェースとアルゴリズム&#34;、RFC 5116、2008年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AH] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[AH]ケント、S.、 &#34;IP認証ヘッダー&#34;、RFC 4302、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BLEI] Bleichenbacher D., &#34;Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1&#34; in Advances in Cryptology -- CRYPTO&#39;98, LNCS vol. 1462, pages: 1-12, 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【BLEI] BleichenbacherのD.、暗号理論における進歩で「RSA暗号化標準PKCS＃1に基づくプロトコルに対して選択暗号文攻撃」 -  CRYPTO&#39;98、LNCS体積。 1462年、頁：1-12、1998。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBCATT] Moeller, B., &#34;Security of CBC Ciphersuites in SSL/TLS: Problems and Countermeasures&#34;, http://www.openssl.org/~bodo/tls-cbc.txt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBCATT]メラー、B.、 &#34;SSL / TLSでのCBC暗号の組み合わせのセキュリティ：問題点と対策&#34;、http://www.openssl.org/~bodo/tls-cbc.txt。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBCTIME] Canvel, B., Hiltgen, A., Vaudenay, S., and M. Vuagnoux, &#34;Password Interception in a SSL/TLS Channel&#34;, Advances in Cryptology -- CRYPTO 2003, LNCS vol. 2729, 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CRYPTO 2003、LNCS体積 -  [CBCTIME] Canvel、B.、Hiltgen、Aは、Vaudenay、S.、およびM. Vuagnoux、 &#34;SSL / TLSチャネルにおけるパスワード傍受&#34; は、暗号理論の進歩します。 2729年、2003年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCM] &#34;NIST Special Publication 800-38C: The CCM Mode for Authentication and Confidentiality&#34;, http://csrc.nist.gov/publications/nistpubs/800-38C/ SP800-38C.pdf
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CCM] &#34;は、NIST Special Publicationの800-38C：認証および機密性のためのCCMモード&#34;、http://csrc.nist.gov/publications/nistpubs/800-38C/ SP800-38C.pdf
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DES] National Institute of Standards and Technology, &#34;Data Encryption Standard (DES)&#34;, FIPS PUB 46-3, October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DES]米国国立標準技術研究所、 &#34;データ暗号化規格（DES）&#34;、FIPS PUBの46-3、1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS-3] NIST FIPS PUB 186-3 Draft, &#34;Digital Signature Standard&#34;, National Institute of Standards and Technology, U.S. Department of Commerce, 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS-3] NIST FIPS PUB 186-3ドラフト、 &#34;デジタル署名標準&#34;、アメリカ国立標準技術研究所、商業、2006年の米国部門。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECDSA] American National Standards Institute, &#34;Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)&#34;, ANS X9.62-2005, November 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ECDSA]米国規格協会、「金融サービス業界向け公開鍵暗号：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANS X9.62-2005、2005年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ENCAUTH] Krawczyk, H., &#34;The Order of Encryption and Authentication for Protecting Communications (Or: How Secure is SSL?)&#34;, Crypto 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ENCAUTH] Krawczyk、H.、 &#34;通信を保護するための暗号化および認証の順序（または：SSLどのように安全ですか？）&#34;、暗号2001。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ESP] Kent, S., &#34;IP Encapsulating Security Payload (ESP)&#34;, RFC 4303, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ESP]ケント、S.、 &#34;IPカプセル化セキュリティペイロード（ESP）&#34;、RFC 4303、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FI06] Hal Finney, &#34;Bleichenbacher&#39;s RSA signature forgery based on implementation error&#34;, ietf-openpgp@imc.org mailing list, 27 August 2006, http://www.imc.org/ietf-openpgp/ mail-archive/msg14307.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FI06]ハル・フィニー、ietf-openpgp@imc.orgメーリングリスト「実装エラーに基づくBleichenbacherののRSA署名偽造」、2006年8月27日、http://www.imc.org/ietf-openpgp/メールアーカイブ/ msg14307 .htmlを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GCM] Dworkin, M., NIST Special Publication 800-38D, &#34;Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC&#34;, November 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2007年11月：[GCM] Dworkin、M.、は、NIST Special Publication 800-38D、 &#34;ガロア/カウンタモード（GCM）とGMACの動作のブロック暗号モードのための勧告&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IKEALG] Schiller, J., &#34;Cryptographic Algorithms for Use in the Internet Key Exchange Version 2 (IKEv2)&#34;, RFC 4307, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IKEALG]シラー、J.、 &#34;インターネット鍵交換バージョン2（IKEv2の）での使用のための暗号アルゴリズム&#34;、RFC 4307、2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KEYSIZ] Orman, H. and P. Hoffman, &#34;Determining Strengths For Public Keys Used For Exchanging Symmetric Keys&#34;, BCP 86, RFC 3766, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KEYSIZ]オーマン、H.、およびP.ホフマン、BCP 86、RFC 3766、2004年4月 &#34;対称鍵を交換するために使用公開鍵の強さを測定します&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KPR03] Klima, V., Pokorny, O., Rosa, T., &#34;Attacking RSA-based Sessions in SSL/TLS&#34;, http://eprint.iacr.org/2003/052/, March 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KPR03]クリマ、V.、Pokorny、O.、ローザ、T.、 &#34;SSL / TLSでのRSAベースのセッションへの攻撃&#34;、http://eprint.iacr.org/2003/052/、2003年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MODP] Kivinen, T. and M. Kojo, &#34;More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)&#34;, RFC 3526, May 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MODP] Kivinen、T.およびM.古城、 &#34;インターネット鍵交換のためのより多くのモジュラー指数（MODP）のDiffie-Hellmanグループ（IKE）&#34;、RFC 3526、2003年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS6] RSA Laboratories, &#34;PKCS #6: RSA Extended Certificate Syntax Standard&#34;, version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS6] RSA Laboratories社、 &#34;PKCS＃6：RSA拡張証明書の構文標準&#34;、バージョン1.5、1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS7] RSA Laboratories, &#34;PKCS #7: RSA Cryptographic Message Syntax Standard&#34;, version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS7] RSA Laboratories社、 &#34;PKCS＃7：RSA暗号メッセージ構文標準&#34;、バージョン1.5、1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RANDOM] Eastlake, D., 3rd, Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ランダム]イーストレーク、D.、3、シラー、J.、およびS.クロッカー、 &#34;セキュリティのためのランダム要件&#34;、BCP 106、RFC 4086、2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3749] Hollenbeck, S., &#34;Transport Layer Security Protocol Compression Methods&#34;, RFC 3749, May 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3749]ホレンベック、S.、 &#34;トランスポート層セキュリティプロトコル圧縮方法&#34;、RFC 3749、2004年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4366] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, &#34;Transport Layer Security (TLS) Extensions&#34;, RFC 4366, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4366]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.、ミケルセン、J.、およびT.ライト、 &#34;トランスポート層セキュリティ（TLS）拡張機能&#34;、RFC 4366、2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSA] R. Rivest, A. Shamir, and L. M. Adleman, &#34;A Method for Obtaining Digital Signatures and Public-Key Cryptosystems&#34;, Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120-126.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSA] R.リベスト、A. Shamir、およびL. M.エイドルマン、 &#34;メソッドデジタル署名と公開鍵暗号を取得する&#34;、ACMの通信、V。21、N。 2、1978年2月、頁120-126。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SEQNUM] Bellovin, S., &#34;Defending Against Sequence Number Attacks&#34;, RFC 1948, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SEQNUM] Bellovin氏、S.、 &#34;シーケンス番号攻撃からの保護&#34;、RFC 1948、1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL2] Hickman, Kipp, &#34;The SSL Protocol&#34;, Netscape Communications Corp., Feb 9, 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL2]ヒックマン、キップ、 &#34;SSLプロトコル&#34;、ネットスケープ・コミュニケーションズ社、1995年2月9日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL3] A. Freier, P. Karlton, and P. Kocher, &#34;The SSL 3.0 Protocol&#34;, Netscape Communications Corp., Nov 18, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL3] A.フライアー、P. Karlton、およびP.コッヘル、 &#34;SSL 3.0プロトコル&#34;、ネットスケープ・コミュニケーションズ社、1996年11月18日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SUBGROUP] Zuccherato, R., &#34;Methods for Avoiding the &#34;Small-Subgroup&#34; Attacks on the Diffie-Hellman Key Agreement Method for S/MIME&#34;, RFC 2785, March 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SUBGROUP] Zuccherato、R.、 &#34;S / MIMEにDiffie-Hellman鍵合意方式に対する攻撃 &#34;小サブグループ&#34; の回避のための方法&#34;、RFC 2785、2000年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TIMING] Boneh, D., Brumley, D., &#34;Remote timing attacks are practical&#34;, USENIX Security Symposium 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[タイミング] Boneh、D.、Brumley、D.、 &#34;リモートタイミング攻撃が実用的である&#34;、USENIXセキュリティシンポジウム2003。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLSAES] Chown, P., &#34;Advanced Encryption Standard (AES) Ciphersuites for Transport Layer Security (TLS)&#34;, RFC 3268, June 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、RFC 3268、2002年6月[TLSAES]のchown、P.、 &#34;トランスポート層セキュリティ（TLS）用のAdvanced Encryption Standard（AES）暗号の組み合わせ&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLSECC] Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, &#34;Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)&#34;, RFC 4492, May 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【TLSECC]ブレイク・ウィルソン、S.、Bolyard、N.、グプタ、V.、ホーク、C.、​​およびB.メラー、 &#34;楕円曲線暗号（ECC）暗号スイートトランスポート層セキュリティ（TLS）のための&#34;、RFC 4492 、2006年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLSEXT] Eastlake, D., 3rd, &#34;Transport Layer Security (TLS) Extensions: Extension Definitions&#34;, Work in Progress, February 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLSEXT]イーストレイク、D.、第三、 &#34;トランスポート層セキュリティ（TLS）拡張機能：拡張定義&#34;、進歩、2008年2月に作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLSPGP] Mavrogiannopoulos, N., &#34;Using OpenPGP Keys for Transport Layer Security (TLS) Authentication&#34;, RFC 5081, November 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、RFC 5081、2007年11月 &#34;トランスポート層セキュリティ（TLS）認証のためのOpenPGPキーの使用&#34; [TLSPGP] Mavrogiannopoulos、N.、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLSPSK] Eronen, P., Ed., and H. Tschofenig, Ed., &#34;Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)&#34;, RFC 4279, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、RFC 4279、2005年12月 &#34;トランスポート層セキュリティ（TLS）のための事前共有鍵暗号の組み合わせ&#34; [TLSPSK] Eronen、P.、エド。、およびH. Tschofenig、エド。、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS1.0] Dierks, T. and C. Allen, &#34;The TLS Protocol Version 1.0&#34;, RFC 2246, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS1.0]ダークス、T.とC.アレン、 &#34;TLSプロトコルバージョン1.0&#34;、RFC 2246、1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS1.1] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.1&#34;, RFC 4346, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TLS1.1]ダークス、T.およびE.レスコラ、 &#34;トランスポート層セキュリティ（TLS）プロトコルバージョン1.1&#34;、RFC 4346、2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X501] ITU-T Recommendation X.501: Information Technology - Open Systems Interconnection - The Directory: Models, 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X501] ITU-T勧告X.501：情報技術 - 開放型システム間相互接続 - ディレクトリ：モデル、1993。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XDR] Eisler, M., Ed., &#34;XDR: External Data Representation Standard&#34;, STD 67, RFC 4506, May 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XDR]アイスラー、M.、エド、 &#34;XDR：外部データ表現標準&#34;、STD 67、RFC 4506、2006年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Working Group Information
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
ワーキンググループ情報
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The discussion list for the IETF TLS working group is located at the e-mail address &lt;tls@ietf.org&gt;. Information on the group and information on how to subscribe to the list is at &lt;https://www1.ietf.org/mailman/listinfo/tls&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF TLSワーキンググループの議論のリストは、電子メールアドレス&lt;tls@ietf.org&gt;に位置しています。リストの購読方法グループ情報に関する情報は、&lt;https://www1.ietf.org/mailman/listinfo/tls&gt;であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Archives of the list can be found at: &lt;http://www.ietf.org/mail-archive/web/tls/current/index.html&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&lt;http://www.ietf.org/mail-archive/web/tls/current/index.html&gt;：リストのアーカイブはで見つけることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
協力者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christopher Allen (co-editor of TLS 1.0) Alacrity Ventures ChristopherA@AlacrityManagement.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クリストファー・アレン（TLS 1.0の共同編集者）いそいそベンチャーズChristopherA@AlacrityManagement.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Abadi University of California, Santa Cruz abadi@cs.ucsc.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カリフォルニア州のマーティン・アバディ大学サンタクルーズ校abadi@cs.ucsc.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Steven M. Bellovin Columbia University smb@cs.columbia.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スティーブンM. Bellovin氏コロンビア大学smb@cs.columbia.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Simon Blake-Wilson BCI sblakewilson@bcisse.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サイモン・ブレイク・ウィルソンBCI sblakewilson@bcisse.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ran Canetti IBM canetti@watson.ibm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
蘭カネッティIBM canetti@watson.ibm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pete Chown Skygate Technology Ltd pc@skygate.co.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ピートのchownスカイゲートテクノロジー株式会社pc@skygate.co.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taher Elgamal taher@securify.com Securify
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タハー・エルガマルtaher@s​​ecurify.com Securify
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pasi Eronen pasi.eronen@nokia.com Nokia
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パシEronenノキアpasi.eronen@nokia.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anil Gangolli anil@busybuddha.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アニルGangoliಅನಿಲ್@ಬ್ಯುಸಿಬ್ಯುದ್ಧ.ಒರ್ಗ್
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kipp Hickman
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キップヒックマン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alfred Hoenes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルフレッドHoenes
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Hopwood Independent Consultant david.hopwood@blueyonder.co.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デビッド・ホップウッド独立コンサルタントdavid.hopwood@blueyonder.co.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phil Karlton (co-author of SSLv3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フィル・Karlton（のSSLv3の共著）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Kocher (co-author of SSLv3) Cryptography Research paul@cryptography.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポール・コッヘル（のSSLv3の共著）暗号技術paul@cryptography.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hugo Krawczyk IBM hugo@ee.technion.ac.il
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヒューゴKrawczyk IBM hugo@ee.technion.ac.il
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jan Mikkelsen Transactionware janm@transactionware.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1月ミケルセンTransactionware janm@transactionware.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Magnus Nystrom RSA Security magnus@rsasecurity.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マグナスNystrom RSAセキュリティmagnus@rsasecurity.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert Relyea Netscape Communications relyea@netscape.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ロバートRelyeaネットスケープ・コミュニケーションズrelyea@netscape.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jim Roskind Netscape Communications jar@netscape.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジム・Roskindネットスケープ・コミュニケーションズjar@netscape.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael Sabin
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイケル・セービン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dan Simon Microsoft, Inc. dansimon@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そしてサイモンマイクロソフト株式会社dansimon@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tom Weinstein
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トム・ワインスタイン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tim Wright Vodafone timothy.wright@vodafone.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ティム・ライトボーダフォンtimothy.wright@vodafone.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Editors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
エディタのアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tim Dierks Independent EMail: tim@dierks.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ティム・ダークス独立した電子メール：tim@dierks.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eric Rescorla RTFM, Inc. EMail: ekr@rtfm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エリックレスコラRTFM、Inc.のEメール：ekr@rtfm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The IETF Trust (2008).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）IETFトラスト（2008）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットSOCIETY、（もしあれば）を後援し、IETF TRUST ANDインターネットエンジニアリングタスクフォース放棄ALLに設けられています。保証は、明示または黙示、この情報の利用および特定目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証がこれらに限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
