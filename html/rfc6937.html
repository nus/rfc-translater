<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 6937 - Proportional Rate Reduction for TCP 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6937</span>
  <div style="height: 1ex;"></div>
  <div style="float: right; position: sticky; top: 0;">
    <button type="button" class="btn btn-light btn-sm">
      <a href="https://tools.ietf.org/html/rfc6937">Orig</a>
    </button>
  </div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6937 - Proportional Rate Reduction for TCP 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc6937">
              https://tools.ietf.org/html/rfc6937
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 6937 - TCPのための比例速度低下</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         M. Mathis
Request for Comments: 6937                                  N. Dukkipati
Category: Experimental                                          Y. Cheng
ISSN: 2070-1721                                             Google, Inc.
                                                                May 2013
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  Proportional Rate Reduction for TCP
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes an experimental Proportional Rate Reduction (PRR) algorithm as an alternative to the widely deployed Fast Recovery and Rate-Halving algorithms. These algorithms determine the amount of data sent by TCP during loss recovery. PRR minimizes excess window adjustments, and the actual window size at the end of recovery will be as close as possible to the ssthresh, as determined by the congestion control algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、広く普及している高速リカバリおよびレート半減アルゴリズムの代替として実験的比例する速度削減（PRR）アルゴリズムを記述しています。これらのアルゴリズムは、損失回復の間にTCPで送信されるデータの量を決定します。 PRRは、過剰なウィンドウの調整を最小限に抑え、輻輳制御アルゴリズムによって決定されるような回復の終わりに実際のウィンドウサイズは、SSTHRESHにできるだけ近くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6937.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6937で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................2
   2. Definitions .....................................................5
   3. Algorithms ......................................................6
      3.1. Examples ...................................................6
   4. Properties ......................................................9
   5. Measurements ...................................................11
   6. Conclusion and Recommendations .................................12
   7. Acknowledgements ...............................................13
   8. Security Considerations ........................................13
   9. References .....................................................13
      9.1. Normative References ......................................13
      9.2. Informative References ....................................14
   Appendix A. Strong Packet Conservation Bound ......................15
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes an experimental algorithm, PRR, to improve the accuracy of the amount of data sent by TCP during loss recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、損失回復の間にTCPで送信されるデータの量の精度を向上させるために、実験的なアルゴリズム、PRRを説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standard congestion control [RFC5681] requires that TCP (and other protocols) reduce their congestion window (cwnd) in response to losses. Fast Recovery, described in the same document, is the reference algorithm for making this adjustment. Its stated goal is to recover TCP&#39;s self clock by relying on returning ACKs during recovery to clock more data into the network. Fast Recovery typically adjusts the window by waiting for one half round-trip time (RTT) of ACKs to pass before sending any data. It is fragile because it cannot compensate for the implicit window reduction caused by the losses themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
標準的な輻輳制御[RFC5681]はTCP（および他のプロトコル）が損失に応じて、その輻輳ウィンドウ（CWND）を減らすことが必要です。同文献に記載の高速リカバリは、この調整を行うための参考アルゴリズムです。その定められた目標は、ネットワークへのクロックより多くのデータを復旧中にACKを返すに依存することにより、TCPの自己クロックを回復することです。高速リカバリは、典型的には、任意のデータを送信する前に渡すためにACKの半分のラウンドトリップ時間（RTT）を待ってウィンドウを調整します。それは損失自身によって引き起こされる暗黙のウィンドウの低下を補うことができないので、それは壊れやすいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6675 [RFC6675] makes Fast Recovery with Selective Acknowledgement (SACK) [RFC2018] more accurate by computing &#34;pipe&#34;, a sender side estimate of the number of bytes still outstanding in the network. With RFC 6675, Fast Recovery is implemented by sending data as necessary on each ACK to prevent pipe from falling below slow-start threshold (ssthresh), the window size as determined by the congestion control algorithm. This protects Fast Recovery from timeouts in many cases where there are heavy losses, although not if the entire second half of the window of data or ACKs are lost. However, a single ACK carrying a SACK option that implies a large quantity of missing data can cause a step discontinuity in the pipe estimator, which can cause Fast Retransmit to send a burst of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6675 [RFC6675]は選択的確認応答（SACK）[RFC2018]「パイプ」、ネットワークにまだ未処理のバイト数の送信側の推定値を計算することによって、より正確と高速リカバリを行います。 RFC 6675で、高速リカバリは、それぞれに必要に応じてデータを送信することによって実現される輻輳制御アルゴリズムによって決定されるように、ウィンドウサイズ、スロースタート閾値（SSTHRESH）を下回るからパイプを防止するためにACK。データまたはACKの窓の全体の後半が失われていない場合が、これは、大きな損失があり、多くの場合、タイムアウトからの高速リカバリを保護します。しかし、高速再送信は、データのバーストを送信させることができるパイプ推定のステップ不連続を引き起こす可能性が不足している大量のデータを意味SACKオプションを搬送する単一のACK。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Rate-Halving algorithm sends data on alternate ACKs during recovery, such that after 1 RTT the window has been halved. Rate-Halving is implemented in Linux after only being informally published [RHweb], including an uncompleted document [RHID]. Rate-Halving also does not adequately compensate for the implicit window reduction caused by the losses and assumes a net 50% window reduction, which was completely standard at the time it was written but not appropriate for modern congestion control algorithms, such as CUBIC [CUBIC], which reduce the window by less than 50%. As a consequence, Rate-Halving often allows the window to fall further than necessary, reducing performance and increasing the risk of timeouts if there are additional losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レート-半減アルゴリズムは1 RTT後にウィンドウが半減されたことなど、回復中に、代替のACKにデータを送信します。レート半減のみが非公式に[RHweb]、未完成の文書[RHID]を含む公表された後にLinuxに実装されています。レート-半減も十分な損失によって引き起こされる暗黙のウィンドウの減少を補償し、完全にそれが書かれた時点での標準が、のような近代的な輻輳制御アルゴリズム、には適していませんでしたネット50％ウィンドウの削減を前提としていませんCUBIC [CUBIC ]、50％未満、ウィンドウを減少させます。その結果、レート-半減は、多くの場合、パフォーマンスが低下し、追加損失がある場合、タイムアウトのリスクを増加、窓は必要以上に低下することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR avoids these excess window adjustments such that at the end of recovery the actual window size will be as close as possible to ssthresh, the window size as determined by the congestion control algorithm. It is patterned after Rate-Halving, but using the fraction that is appropriate for the target window chosen by the congestion control algorithm. During PRR, one of two additional Reduction Bound algorithms limits the total window reduction due to all mechanisms, including transient application stalls and the losses themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRRは、輻輳制御アルゴリズムによって決定されるような回復の終わりに実際のウィンドウサイズは、ウィンドウサイズSSTHRESHにできるだけ近くなるように、これらの過剰なウィンドウの調整を回避します。これは、輻輳制御アルゴリズムにより選択されたターゲットウィンドウに適切な割合を使用してレートを半減した後にパターン化されているが、。 PRRの間に、二つの追加削減バウンドアルゴリズムの一つは、一時的なアプリケーションの屋台や損失自分自身を含むすべてのメカニズムによる総ウィンドウの減少を、制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We describe two slightly different Reduction Bound algorithms: Conservative Reduction Bound (CRB), which is strictly packet conserving; and a Slow Start Reduction Bound (SSRB), which is more aggressive than CRB by, at most, 1 segment per ACK. PRR-CRB meets the Strong Packet Conservation Bound described in Appendix A; however, in real networks it does not perform as well as the algorithms described in RFC 6675, which prove to be more aggressive in a significant number of cases. SSRB offers a compromise by allowing TCP to send 1 additional segment per ACK relative to CRB in some situations. Although SSRB is less aggressive than RFC 6675
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、わずかに異なる2つの削減バウンドアルゴリズムを説明します。厳密にパケット節約です（CRB）バウンド保守的な削減、。そしてせいぜいによってCRBより攻撃的である（SSRB）結合したスロースタート削減、ACK当たり1つのセグメント。 PRR-CRBは、付録Aに記載バウンド強力パケット保全を満たしています。しかし、実際のネットワークでは、例かなりの数でより積極的であることを証明するRFC 6675で説明したアルゴリズム、と同様に実行されません。 SSRBは、TCPはいくつかの状況でCRBにACKの相対あたり1つの追加のセグメントを送信できるようにすることで、妥協を提供しています。 SSRBは、RFC 6675未満積極的ではあるが
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(transmitting fewer segments or taking more time to transmit them), it outperforms it, due to the lower probability of additional losses during recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（より少ないセグメントを送信したり、送信するためにより多くの時間を取って）、それにより、回復中に追加の損失の低い確率のために、それよりも性能が優れています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Strong Packet Conservation Bound on which PRR and both Reduction Bounds are based is patterned after Van Jacobson&#39;s packet conservation principle: segments delivered to the receiver are used as the clock to trigger sending the same number of segments back into the network. As much as possible, PRR and the Reduction Bound algorithms rely on this self clock process, and are only slightly affected by the accuracy of other estimators, such as pipe [RFC6675] and cwnd. This is what gives the algorithms their precision in the presence of events that cause uncertainty in other estimators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR両方還元境界が基づくバウンド強いパケット保全はバン・ジェイコブソンのパケット保存原理後にパターニングされる。受信機に配信セグメントはバックネットワークへのセグメントの同じ数の送信トリガするためのクロックとして使用されます。できるだけ多くのPRRと還元結合したアルゴリズムは、この自己クロックプロセスに依存し、そしてわずかにしかそのようなパイプ[RFC6675]とCWNDのような他の推定の精度に影響されます。これは、他の推定量の不確実性の原因となる事象の存在下で、アルゴリズムに彼らの精度を与えるものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The original definition of the packet conservation principle [Jacobson88] treated packets that are presumed to be lost (e.g., marked as candidates for retransmission) as having left the network. This idea is reflected in the pipe estimator defined in RFC 6675 and used here, but it is distinct from the Strong Packet Conservation Bound as described in Appendix A, which is defined solely on the basis of data arriving at the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット保存原理の元の定義[Jacobson88】失われると推定される処理されたパケット（例えば、再送のための候補としてマークされた）ネットワークを離れたとして。このアイデアは、RFC 6675で定義され、ここで使用されるパイプの推定に反映され、それが受信機に到着するデータのみに基づいて定義され、付録Aに記載されるように結合した強力なパケット保全とは区別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We evaluated these and other algorithms in a large scale measurement study presented in a companion paper [IMC11] and summarized in Section 5. This measurement study was based on RFC 3517 [RFC3517], which has since been superseded by RFC 6675. Since there are slight differences between the two specifications, and we were meticulous about our implementation of RFC 3517, we are not comfortable unconditionally asserting that our measurement results apply to RFC 6675, although we believe this to be the case. We have instead chosen to be pedantic about describing measurement results relative to RFC 3517, on which they were actually based. General discussions of algorithms and their properties have been updated to refer to RFC 6675.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、[IMC11]コンパニオン論文で提示大規模な測定調査では、これらおよび他のアルゴリズムを評価し、第5節でまとめこの測定研究はありますので以来、RFC 6675.に取って代わられているRFC 3517 [RFC3517]、に基づいていましたわずか2つの仕様との違い、そして私たちはRFC 3517の私達の実装について細心のだったが、我々は無条件に私たちはこのようなケースであると信じるが、私たちの測定結果は、RFC 6675に適用されることを主張し、快適ではありません。私たちは、代わりに彼らは実際に基づいていたどのRFC 3517、に対する測定結果を説明に関する知識をひけらかすことを選択しました。アルゴリズムとそのプロパティの一般的な議論はRFC 6675を参照するように更新されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We found that for authentic network traffic, PRR-SSRB outperforms both RFC 3517 and Linux Rate-Halving even though it is less aggressive than RFC 3517. We believe that these results apply to RFC 6675 as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、本物のネットワークトラフィックのために、PRR-SSRBが、それは私たちは、これらの結果は、同様RFC 6675に適用されることを信じているRFC 3517.未満積極的であるにもかかわらず、RFC 3517およびLinuxレート-半減両方よりも優れていることが分かりました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithms are described as modifications to RFC 5681 [RFC5681], &#34;TCP Congestion Control&#34;, using concepts drawn from the pipe algorithm [RFC6675]. They are most accurate and more easily implemented with SACK [RFC2018], but do not require SACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アルゴリズムはパイプアルゴリズム[RFC6675]から引き出された概念を使用して、RFC 5681に変更ようRFC5681]、「TCPの輻輳制御」に記載されています。彼らは、最も正確で、より簡単にSACK [RFC2018]で実装されているが、SACKを必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following terms, parameters, and state variables are used as they are defined in earlier documents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らは以前の文書で定義されている通り、以下の用語は、パラメータ、および状態変数が使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 793: snd.una (send unacknowledged)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 793：SND.UNA（未確認の送信）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681: duplicate ACK, FlightSize, Sender Maximum Segment Size (SMSS)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681：ACK、FlightSize、送信者の最大セグメントサイズ（SMSS）を複製します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6675: covered (as in &#34;covered sequence numbers&#34;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6675：カバー（以下「対象シーケンス番号」のように）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Voluntary window reductions: choosing not to send data in response to some ACKs, for the purpose of reducing the sending window size and data rate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
自主ウィンドウの削減：送信ウィンドウサイズとデータレートを低減する目的のために、いくつかのACKに応答してデータを送信しないように選択します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We define some additional variables:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々はいくつかの追加の変数を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SACKd: The total number of bytes that the scoreboard indicates have been delivered to the receiver. This can be computed by scanning the scoreboard and counting the total number of bytes covered by all SACK blocks. If SACK is not in use, SACKd is not defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SACKd：バイト数の合計スコアボードが示す受信機に配信されてきました。これは、スコアボードをスキャンし、すべてのSACKブロックにより覆われたバイトの総数をカウントすることによって計算することができます。 SACKが使用されていない場合は、SACKdが定義されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DeliveredData: The total number of bytes that the current ACK indicates have been delivered to the receiver. When not in recovery, DeliveredData is the change in snd.una. With SACK, DeliveredData can be computed precisely as the change in snd.una, plus the (signed) change in SACKd. In recovery without SACK, DeliveredData is estimated to be 1 SMSS on duplicate acknowledgements, and on a subsequent partial or full ACK, DeliveredData is estimated to be the change in snd.una, minus 1 SMSS for each preceding duplicate ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DeliveredData：バイトの総数現在のACKが示す受信機に配信されてきました。ないときは、回復中、DeliveredDataはSND.UNAの変化です。 SACKと、DeliveredDataはSND.UNAの変化、プラスSACKdで（符号付き）変化として正確に計算することができます。 SACKなしで回復、DeliveredDataは重複確認応答に1 SMSSであると推定され、そしてその後の部分的または完全なACKに、DeliveredDataはSND.UNAの変化、マイナス各先行重複ACKのために1 SMSSであると推定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that DeliveredData is robust; for TCP using SACK, DeliveredData can be precisely computed anywhere in the network just by inspecting the returning ACKs. The consequence of missing ACKs is that later ACKs will show a larger DeliveredData. Furthermore, for any TCP (with or without SACK), the sum of DeliveredData must agree with the forward progress over the same time interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DeliveredDataが堅牢であることに注意してください。 TCPは、SACKを使用するため、DeliveredDataは正確にちょうど戻ってACKを検査することによって、ネットワーク内のどこにでも計算できます。 ACKを行方不明の結果は、後にACKが大きなDeliveredDataを示すことです。さらに、（SACKの有無にかかわらず）任意のTCPのために、DeliveredDataの合計が同じ時間間隔で前進に同意する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We introduce a local variable &#34;sndcnt&#34;, which indicates exactly how many bytes should be sent in response to each ACK. Note that the decision of which data to send (e.g., retransmit missing data or send more new data) is out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、各ACKに応答して送信する必要があります正確にどのように多くのバイト数を示すローカル変数「sndcnt」を、ご紹介します。データは、（例えば、再送欠落したデータを以上の新しいデータを送信する）を送信するかの決定は、このドキュメントの範囲外であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the beginning of recovery, initialize PRR state. This assumes a modern congestion control algorithm, CongCtrlAlg(), that might set ssthresh to something other than FlightSize/2:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
回復の開始時に、PRRの状態を初期化します。これはFlightSize / 2以外にSSTHRESHを設定する可能性がある近代的な輻輳制御アルゴリズム、CongCtrlAlgを（）、前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ssthresh = CongCtrlAlg() // Target cwnd after recovery prr_delivered = 0 // Total bytes delivered during recovery prr_out = 0 // Total bytes sent during recovery RecoverFS = snd.nxt-snd.una // FlightSize at the start of recovery
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SSTHRESH = CongCtrlAlg（）//ターゲットprr_delivered回復後にcwndを= 0合計は回復prr_out中に送出バイト// = 0合計は、リカバリ時に送信されたバイト// RecoverFS = SND.NXT-SND.UNA // FlightSize回復の開始時
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On every ACK during recovery compute:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
回復計算時に、すべてのACKの場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeliveredData = change_in(snd.una) + change_in(SACKd) prr_delivered += DeliveredData pipe = (RFC 6675 pipe algorithm) if (pipe &gt; ssthresh) { // Proportional Rate Reduction sndcnt = CEIL(prr_delivered * ssthresh / RecoverFS) - prr_out } else { // Two versions of the Reduction Bound if (conservative) { // PRR-CRB limit = prr_delivered - prr_out } else { // PRR-SSRB limit = MAX(prr_delivered - prr_out, DeliveredData) + MSS } // Attempt to catch up, as permitted by limit sndcnt = MIN(ssthresh - pipe, limit) }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DeliveredData = change_in（SND.UNA）+ change_in（SACKd）prr_delivered + = DeliveredDataパイプ=（RFC 6675パイプアルゴリズム）IF（パイプ&gt; SSTHRESH）{//比例した速度低減sndcnt = CEIL（prr_delivered * SSTHRESH / RecoverFS） -  prr_out}他{//（保守的）{// PRR-CRB限界= prr_delivered場合バウンド削減2つのバージョン -  prr_out}他{// PRR-SSRB限界= MAX（prr_delivered  -  prr_out、DeliveredData）+ MSS} //試みること制限sndcntによって許可されるように、追いつく= MIN（SSTHRESH  - パイプ、リミット）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On any data transmission or retransmission:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべてのデータの送信または再送信の場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
prr_out += (data sent) // strictly less than or equal to sndcnt
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
prr_out + =（送信データ）//厳密以下sndcntに等しいです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We illustrate these algorithms by showing their different behaviors for two scenarios: TCP experiencing either a single loss or a burst of 15 consecutive losses. In all cases we assume bulk data (no application pauses), standard Additive Increase Multiplicative Decrease (AIMD) congestion control, and cwnd = FlightSize = pipe = 20 segments, so ssthresh will be set to 10 at the beginning of recovery. We also assume standard Fast Retransmit and Limited Transmit [RFC3042], so TCP will send 2 new segments followed by 1 retransmit in response to the first 3 duplicate ACKs following the losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は2つのシナリオのための彼らの異なる動作を示すことによって、これらのアルゴリズムを説明する：TCPは、単一の損失または15連敗のバーストのいずれかを経験します。我々は、バルクデータを想定し、全ての場合（NOアプリケーションが一時停止）で、標準的な添加剤は、乗算減少（AIMD）輻輳制御、およびCWND = FlightSize =パイプ= 20個のセグメントを増やすので、SSTHRESH回復の開始時に10に設定されます。また、標準の高速再送とリミテッド送信[RFC3042]を想定し、そのTCPは損失を以下の最初の3個の重複ACKに応じて、1つの再送続く2つの新しいセグメントを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the diagrams below shows the per ACK response to the first round trip for the various recovery algorithms when the zeroth segment is lost. The top line indicates the transmitted segment number triggering the ACKs, with an X for the lost segment. &#34;cwnd&#34; and &#34;pipe&#34; indicate the values of these algorithms after processing each returning ACK. &#34;Sent&#34; indicates how much &#39;N&#39;ew or &#39;R&#39;etransmitted data would be sent. Note that the algorithms for deciding which data to send are out of scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゼロ番目のセグメントが失われたときに以下の図の各々は、様々な回収アルゴリズムの最初のラウンドトリップにACKあたりの応答を示しています。一番上の行は、失われたセグメントのXと、ACKをトリガ送信されたセグメント番号を示します。 「CWND」および「パイプ」は、各戻りACKを処理した後、これらのアルゴリズムの値を示しています。 「送信済み」「N&#39;ewや」R&#39;etransmittedデータが送信されますどのくらいを示しています。送信するデータを決定するためのアルゴリズムは、この文書の範囲外であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When there is a single loss, PRR with either of the Reduction Bound algorithms has the same behavior. We show &#34;RB&#34;, a flag indicating which Reduction Bound subexpression ultimately determined the value of sndcnt. When there are minimal losses, &#34;limit&#34; (both algorithms) will always be larger than ssthresh - pipe, so the sndcnt will be ssthresh - pipe, indicated by &#34;s&#34; in the &#34;RB&#34; row.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一損失がある場合には、削減バウンドアルゴリズムのいずれかでのPRRは、同じ動作を持っています。我々は、還元結合した部分式を示すフラグは、最終的sndcntの値を決定し、「RB」を示します。最小の損失がある場合、「限界」（両方のアルゴリズム）は、常にSSTHRESHよりも大きくなる - パイプ、sndcntがSSTHRESHになるよう - パイプ、「RB」行の「S」で示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6675 ack# X 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 cwnd: 20 20 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 pipe: 19 19 18 18 17 16 15 14 13 12 11 10 10 10 10 10 10 10 10 sent: N N R N N N N N N N N
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6675にACK＃X 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 CWND：20 20 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11パイプ：19 19 18 NNRNNNNNNNNを：送信18 17 16 15 14 13 12 11 10 10 10 10 10 10 10 10
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rate-Halving (Linux) ack# X 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 cwnd: 20 20 19 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 11 pipe: 19 19 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 11 10 sent: N N R N N N N N N N N
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レート半減する（Linux）＃X 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 CWND ACK：20 20 19 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 11パイプNNRNNNNNNNN：送信19 19 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 11 10
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR ack# X 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 pipe: 19 19 18 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 10 sent: N N R N N N N N N N N RB: s s
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRRのACK＃1 X 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19パイプ：19 19 18 18 18 17 17 16 16 15 15 14 14 13 13 12 12 11 10が送信：R N N N N N N N N N N RB：S S
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Cwnd is not shown because PRR does not use it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PRRは、それを使用しないためにcwndは表示されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key for RB s: sndcnt = ssthresh - pipe // from ssthresh b: sndcnt = prr_delivered - prr_out + SMSS // from banked d: sndcnt = DeliveredData + SMSS // from DeliveredData (Sometimes, more than one applies.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RBのためのキー：sndcnt = SSTHRESH  -  SSTHRESH Bからのパイプ//：sndcnt = prr_delivered  -  prr_out + SMSS //バンクDから：sndcntは= DeliveredData + SMSS // DeliveredDataから（時には、複数が適用されます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that all 3 algorithms send the same total amount of data. RFC 6675 experiences a &#34;half window of silence&#34;, while the Rate-Halving and PRR spread the voluntary window reduction across an entire RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての3つのアルゴリズムは、データの同じ総量を送ることに注意してください。レート-半減とPRRは全体RTT間で自主的なウィンドウの削減を広めながら、RFC 6675には、「沈黙の半分の窓」を経験します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Next, we consider the same initial conditions when the first 15 packets (0-14) are lost. During the remainder of the lossy RTT, only 5 ACKs are returned to the sender. We examine each of these algorithms in succession.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、我々は最初の15のパケット（0-14）が失われたときに、同じ初期条件を検討してください。非可逆RTTの残りの期間中、唯一の5 ACKは送信者に返されます。私たちは、連続してこれらのアルゴリズムのそれぞれを調べます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6675 ack# X X X X X X X X X X X X X X X 15 16 17 18 19 cwnd: 20 20 11 11 11 pipe: 19 19 4 10 10 sent: N N 7R R R
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 6675のACK＃X X X X X X X X X X X X X X X 15 16 17 18 19 CWND：20 20 11 11 11パイプ：19 19 4 10 10の送信：N N 7R R R
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rate-Halving (Linux) ack# X X X X X X X X X X X X X X X 15 16 17 18 19 cwnd: 20 20 5 5 5 pipe: 19 19 4 4 4 sent: N N R R R
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レート半減する（Linux）＃X X X X X X X X X X X X X X X 15 16 17 18 19 CWND ACK：20 20 5 5 5管：送信19 19 4 4 4：N N R R R
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-CRB ack# X X X X X X X X X X X X X X X 15 16 17 18 19 pipe: 19 19 4 4 4 sent: N N R R R RB: b b b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-CRB ACK番号X X X X X X X X X X X X X X X 15 16 17 18 19パイプ：19 19 4 4 4が送信：N N R R R RB：B BはB
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-SSRB ack# X X X X X X X X X X X X X X X 15 16 17 18 19 pipe: 19 19 4 5 6 sent: N N 2R 2R 2R RB: bd d d
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信19 19 4 5 6：＃X X X X X X X X X X X X X X X 15 16 17 18 19パイプACK PRR-SSRB N N 2R 2R 2R RB：BD D D
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this specific situation, RFC 6675 is more aggressive because once Fast Retransmit is triggered (on the ACK for segment 17), TCP immediately retransmits sufficient data to bring pipe up to cwnd. Our measurement data (see Section 5) indicates that RFC 6675 significantly outperforms Rate-Halving, PRR-CRB, and some other similarly conservative algorithms that we tested, showing that it is significantly common for the actual losses to exceed the window reduction determined by the congestion control algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一度高速再送信は、（セグメント17のためのACKに）トリガーされるので、この特定の状況では、RFC 6675には、より積極的で、TCPはすぐにcwndをするまでのパイプを持って来るために十分なデータを再送します。我々の測定データ（セクション5を参照）RFC 6675が有意レート半減、PRR-CRB、我々は実際の損失により決定ウィンドウの減少を超えるすることが有意に共通であることを示し、試験されたいくつかの他の同様の保存的アルゴリズムよりも性能が優れていることを示し輻輳制御アルゴリズム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Linux implementation of Rate-Halving includes an early version of the Conservative Reduction Bound [RHweb]. In this situation, the 5 ACKs trigger exactly 1 transmission each (2 new data, 3 old data), and cwnd is set to 5. At a window size of 5, it takes 3 round trips to retransmit all 15 lost segments. Rate-Halving does not raise the window at all during recovery, so when recovery finally completes, TCP will slow start cwnd from 5 up to 10. In this example, TCP operates at half of the window chosen by the congestion control for more than 3 RTTs, increasing the elapsed time and exposing it to timeouts in the event that there are additional losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
率半減のLinuxの実装は、[RHweb]バウンド保守党削減の初期バージョンが含まれています。この状況では、5個のACKが正確に1回の送信毎（2つの新しいデータ、3古いデータ）をトリガし、CWNDは5のウィンドウサイズでは5に設定され、それはすべての15個の失われたセグメントを再送する3ラウンドトリップを取ります。レート-半減は、リカバリ中にすべてのウィンドウを上げていないので、回復が最終的に完了すると、TCPは、この例では10までに5からスタートcwndのが遅くなります、TCPは、3つ以上のための輻輳制御により選択されたウィンドウの半分で動作しますRTTは、経過時間を増やし、追加の損失があることをイベントでタイムアウトにそれをさらします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-CRB implements a Conservative Reduction Bound. Since the total losses bring pipe below ssthresh, data is sent such that the total data transmitted, prr_out, follows the total data delivered to the receiver as reported by returning ACKs. Transmission is controlled by the sending limit, which is set to prr_delivered - prr_out. This is indicated by the RB:b tagging in the figure. In this case, PRR-CRB is exposed to exactly the same problems as Rate-Halving; the excess window reduction causes it to take excessively long to recover the losses and exposes it to additional timeouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-CRBは、バインドされた保守派の削減を実現します。総損失がSSTHRESH下にパイプを持っているので、データは、全データを送信するように送信され、prr_out、ACKを返すことによって報告されるように受信機に送出される総データに従います。 prr_out  - 送信はprr_deliveredするように設定されている送信制限によって制御されます。これは、RBで示されます。図にタグ付けbを。この場合、PRR-CRBは、レート半減とまったく同じ問題にさらされています。余分なウィンドウの減少は、それが損失を回復するために過度に長く取ることが原因となり、追加のタイムアウトにそれを公開します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-SSRB increases the window by exactly 1 segment per ACK until pipe rises to ssthresh during recovery. This is accomplished by setting limit to one greater than the data reported to have been delivered to the receiver on this ACK, implementing slow start during recovery, and indicated by RB:d tagging in the figure. Although increasing the window during recovery seems to be ill advised, it is important to remember that this is actually less aggressive than permitted by RFC 5681, which sends the same quantity of additional data as a single burst in response to the ACK that triggered Fast Retransmit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パイプは、リカバリ中SSTHRESHに上昇するまでPRR-SSRBはACKあたり正確に1つのセグメントによりウィンドウを増加させます。図中Dタギング：これは、回復時にスロースタートを実施し、このACKに受信機に送られ、RBで示されたと報告されたデータよりも大きいものに制限を設定することによって達成されます。リカバリ時にウィンドウを大きくすると、病気に助言されると思われるが、高速再送信をトリガACKに応じて、単一のバーストなどの追加データの同じ量を送り、RFC 5681によって許可さよりも、これは実際にはあまり積極的であることを覚えておくことが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For less extreme events, where the total losses are smaller than the difference between FlightSize and ssthresh, PRR-CRB and PRR-SSRB have identical behaviors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
総損失がFlightSizeおよびSSTHRESHの差よりも小さい少ない極端なイベントのために、PRR-CRBとPRR-SSRBは同じ挙動を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Properties
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. [プロパティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following properties are common to both PRR-CRB and PRR-SSRB, except as noted:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のプロパティが注目されている場合を除き、PRR-CRBとPRR-SSRBの両方に共通です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR maintains TCP&#39;s ACK clocking across most recovery events, including burst losses. RFC 6675 can send large unclocked bursts following burst losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRRは、バースト損失を含むほとんどの回復イベント、全体でTCPのACKクロッキングを維持します。 RFC 6675は、バースト損失、次の大規模な非クロックバーストを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Normally, PRR will spread voluntary window reductions out evenly across a full RTT. This has the potential to generally reduce the burstiness of Internet traffic, and could be considered to be a type of soft pacing. Hypothetically, any pacing increases the probability that different flows are interleaved, reducing the opportunity for ACK compression and other phenomena that increase traffic burstiness. However, these effects have not been quantified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常、PRRはフルRTTに均等に自主的なウィンドウの削減を広げます。これは、一般的にインターネットトラフィックのバースト性を削減する可能性があり、ソフトペーシングのタイプであると考えられます。仮に、任意のペースは異なるフローは、ACK圧縮およびトラフィックのバースト性を高める他の現象のための機会を減らし、インターリーブされる確率を高めます。しかし、これらの効果は定量化されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there are minimal losses, PRR will converge to exactly the target window chosen by the congestion control algorithm. Note that as TCP approaches the end of recovery, prr_delivered will approach RecoverFS and sndcnt will be computed such that prr_out approaches ssthresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小限の損失がある場合は、PRRは、輻輳制御アルゴリズムにより選択された正確にターゲットウィンドウに収束します。 TCPは、回復の終わりに近づくにつれて、prr_delivered RecoverFSに近づくとsndcntがprr_outがSSTHRESHに近づくように計算されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implicit window reductions, due to multiple isolated losses during recovery, cause later voluntary reductions to be skipped. For small numbers of losses, the window size ends at exactly the window chosen by the congestion control algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リカバリ中に複数の分離損失による暗黙のウィンドウの削減は、スキップする後で自主的な削減を引き起こします。損失の少数のために、ウィンドウサイズは、輻輳制御アルゴリズムにより選択された正確ウィンドウで終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For burst losses, earlier voluntary window reductions can be undone by sending extra segments in response to ACKs arriving later during recovery. Note that as long as some voluntary window reductions are not undone, the final value for pipe will be the same as ssthresh, the target cwnd value chosen by the congestion control algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バースト損失のために、以前の自主的な窓の減少は回復中に、後に到着したACKに応じて追加のセグメントを送信することにより、元に戻すことができます。いくつかの自発的窓削減が取り消されていない限り、パイプの最終値がSSTHRESH、輻輳制御アルゴリズムによって選択された目標CWND値と同じになることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR with either Reduction Bound improves the situation when there are application stalls, e.g., when the sending application does not queue data for transmission quickly enough or the receiver stops advancing rwnd (receiver window). When there is an application stall early during recovery, prr_out will fall behind the sum of the transmissions permitted by sndcnt. The missed opportunities to send due to stalls are treated like banked voluntary window reductions; specifically, they cause prr_delivered - prr_out to be significantly positive. If the application catches up while TCP is still in recovery, TCP will send a partial window burst to catch up to exactly where it would have been had the application never stalled. Although this burst might be viewed as being hard on the network, this is exactly what happens every time there is a partial RTT application stall while not in recovery. We have made the partial RTT stall behavior uniform in all states. Changing this behavior is out of scope for this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信側アプリケーションはすぐに十分な伝送のためのデータをキューイングしないか、受信機が進んRWND（受信ウィンドウを）停止したときにバインドされたいずれかの削減とPRRは、例えば、アプリケーションの屋台がある状況を改善します。早期復旧時のアプリケーションのストールがある場合は、prr_outはsndcntによって許可された送信の合計の後ろに分類されます。屋台のために送信するために逃した機会がバンク自主的な窓の削減と同様に扱われます。 prr_out有意な正であることを - 具体的には、彼らはprr_deliveredが引き起こします。 TCPは回復にまだある間、アプリケーションが追いついた場合、TCPは、まさにアプリケーションが停止したことがありませんでしたされていたであろう場所に追いつくために、部分ウィンドウのバーストを送信します。このバーストは、ネットワーク上のハードものと見なすことがありますが、これは回復であり、部分的RTTアプリケーションのストールですがないたびに発生まさにです。我々は、すべての州で部分RTTストール行動の制服を行いました。この動作を変更すると、この文書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR with Reduction Bound is less sensitive to errors in the pipe estimator. While in recovery, pipe is intrinsically an estimator, using incomplete information to estimate if un-SACKed segments are actually lost or merely out of order in the network. Under some conditions, pipe can have significant errors; for example, pipe is underestimated when a burst of reordered data is prematurely assumed to be lost and marked for retransmission. If the transmissions are regulated directly by pipe as they are with RFC 6675, a step discontinuity in the pipe estimator causes a burst of data, which cannot be retracted once the pipe estimator is corrected a few ACKs later. For PRR, pipe merely determines which algorithm, PRR or the Reduction Bound, is used to compute sndcnt from DeliveredData. While pipe is underestimated, the algorithms are different by at most 1 segment per ACK. Once pipe is updated, they converge to the same final window at the end of recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バウンド削減とPRRは、パイプ推定におけるエラーの影響を受けにくいです。回復にしながら、パイプは非解雇セグメントが実際に失われた、または単にネットワークにおける順序から外れている場合に推定するために、不完全な情報を使用して、本質的に推定されます。いくつかの条件の下では、パイプは、重大なエラーを持つことができます。並べ替えデータのバーストが早期に失われ、再送信のためにマークされると仮定される場合、例えば、パイプが過小評価されています。これらはRFC 6675であるとして送信がパイプによって直接調節される場合、パイプ推定のステップ不連続パイプ推定器は、いくつかのACK後に補正されると後退することができないデータのバーストを引き起こします。 PRRのために、管は、単に、PRRまたは縮小結合したが、DeliveredDataからsndcntを計算するために使用されるアルゴリズムを判定する。パイプが過小評価されている間、アルゴリズムは、ACK当たりせいぜい1つのセグメントによって異なります。パイプが更新されると、彼らは回復の終わりに同じ最後のウィンドウに収束します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Under all conditions and sequences of events during recovery, PRR-CRB strictly bounds the data transmitted to be equal to or less than the amount of data delivered to the receiver. We claim that this Strong Packet Conservation Bound is the most aggressive algorithm that does not lead to additional forced losses in some environments. It has the property that if there is a standing queue at a bottleneck with no cross traffic, the queue will maintain exactly constant length for the duration of the recovery, except for +1/-1 fluctuation due to differences in packet arrival and exit times. See Appendix A for a detailed discussion of this property.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
回復中のすべての条件とイベントのシーケンスの下で、PRR-CRBは、厳密に等しいか又は受信機に配信されたデータの量よりも少なくなるように、送信されたデータの境界。私たちは、バウンド、この強力なパケット保全は一部の環境では、追加の強制損失につながるものではない最も積極的なアルゴリズムであることを主張します。それはなし、クロストラフィックがボトルネックに立っキューがある場合、キューは+ 1 / -1変動のために起因するパケットの到着と終了時間の差を除いて回復の持続のために正確に一定の長さを、維持するという性質を持っています。このプロパティの詳細については、付録Aを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the Strong Packet Conservation Bound is very appealing for a number of reasons, our measurements summarized in Section 5 demonstrate that it is less aggressive and does not perform as well as RFC 6675, which permits bursts of data when there are bursts of losses. PRR-SSRB is a compromise that permits TCP to send 1 extra segment per ACK as compared to the Packet Conserving Bound. From the perspective of a strict Packet Conserving Bound, PRR-SSRB does indeed open the window during recovery; however, it is significantly less aggressive than RFC 6675 in the presence of burst losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バウンド強力なパケット保全は、多くの理由から非常に魅力的ではあるが、第5章にまとめた我々の測定は、それがあまり積極的であると損失のバーストがあるデータのバーストを許可するRFC 6675、と同様に実行されないことを示しています。 PRR-SSRBは、結合した保全パケットに比べて、ACKあたり1つの余分なセグメントを送信するためにTCPを可能にする妥協案です。バウンド節約厳格なパケットの観点から、PRR-SSRBは確かに回復中にウィンドウを開くありません。しかし、それはバースト損失の存在下で、RFC 6675よりも有意にあまり積極的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Measurements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.測定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a companion IMC11 paper [IMC11], we describe some measurements comparing the various strategies for reducing the window during recovery. The experiments were performed on servers carrying Google production traffic and are briefly summarized here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンパニオンIMC11紙[IMC11]において、我々は、リカバリ時にウィンドウを減らすための様々な戦略を比較するいくつかの測定を説明します。実験では、Googleの生産トラフィックを運ぶのサーバー上で実行され、ここでは簡単に要約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The various window reduction algorithms and extensive instrumentation were all implemented in Linux 2.6. We used the uniform set of algorithms present in the base Linux implementation, including CUBIC [CUBIC], Limited Transmit [RFC3042], threshold transmit (Section 3.1 in [FACK]) (this algorithm was not present in RFC 3517, but a similar algorithm has been added to RFC 6675), and lost retransmission detection algorithms. We confirmed that the behaviors of Rate-Halving (the Linux default), RFC 3517, and PRR were authentic to their respective specifications and that performance and features were comparable to the kernels in production use. All of the different window reduction algorithms were all present in a common kernel and could be selected with a sysctl, such that we had an absolutely uniform baseline for comparing them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
様々なウィンドウ低減アルゴリズムと豊富な計測器は、すべてのLinux 2.6で実装されました。我々は、（このアルゴリズムは、RFC 3517には存在しなかった臨界送信（[FACK]セクション3.1）、リミテッド送信[RFC3042]、[キュービック]キュービックなど、ベースLinuxの実装に存在するアルゴリズムの一様なセットを使用するが、同様のアルゴリズム）RFC 6675に追加され、再送検出アルゴリズムを失ってきました。我々は、レート半減（Linuxのデフォルト）、RFC 3517、およびPRRの行動は、それぞれの仕様に本物だったし、その性能と機能は、生産、使用中のカーネルと同等であったことを確認しました。別のウィンドウ低減アルゴリズムのすべては、すべて共通のカーネルに存在していたと我々は彼らを比較するために絶対的に均一なベースラインを持っていたように、sysctlをして選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our experiments included an additional algorithm, PRR with an unlimited bound (PRR-UB), which sends ssthresh-pipe bursts when pipe falls below ssthresh. This behavior parallels RFC 3517.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々の実験では、パイプがSSTHRESHを下回った場合にSSTHRESHパイプバーストを送信し、追加のアルゴリズム、無制限のバウンド（PRR-UB）とのPRRを、含まれていました。この動作は、RFC 3517に匹敵します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An important detail of this configuration is that CUBIC only reduces the window by 30%, as opposed to the 50% reduction used by traditional congestion control algorithms. This accentuates the tendency for RFC 3517 and PRR-UB to send a burst at the point when Fast Retransmit gets triggered because pipe is likely to already be below ssthresh. Precisely this condition was observed for 32% of the recovery events: pipe fell below ssthresh before Fast Retransmit was triggered, thus the various PRR algorithms started in the Reduction Bound phase, and RFC 3517 sent bursts of segments with the Fast Retransmit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この構成の重要な詳細は、従来の輻輳制御アルゴリズムによって使用される50％の減少とは対照的に、キュービックのみ、30％ウィンドウを減少させることです。これはパイプがすでにSSTHRESHを下回る可能性があるため、高速再送信をトリガます時点でバーストを送信するためにRFC 3517とPRR-UBの傾向を強調する。まさにこの条件は、リカバリイベントの32％で観察された：高速再送信がトリガされる前に、パイプは、このように様々なPRRアルゴリズム還元バウンドフェーズで開始し、SSTHRESHを下回った、およびRFC 3517は、高速再送信とセグメントのバーストを送信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the companion paper, we observe that PRR-SSRB spends the least time in recovery of all the algorithms tested, largely because it experiences fewer timeouts once it is already in recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
コンパニオン論文では、我々はそれが回復にすでにしたら、それは少数のタイムアウトを経験する主な理由、PRR-SSRBが試験した全てのアルゴリズムの回復の中で最も時間を費やしていることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3517 experiences 29% more detected lost retransmissions and 2.6% more timeouts (presumably due to undetected lost retransmissions) than PRR-SSRB. These results are representative of PRR-UB and other algorithms that send bursts when pipe falls below ssthresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 3517人の経験は29％以上失われた再送信とPRR-SSRBよりも（おそらく検出されない失った再送信への）2.6％以上のタイムアウトを検出しました。これらの結果は、PRR-UBとパイプSSTHRESHを下回った場合にバーストを送信する他のアルゴリズムの代表的なものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rate-Halving experiences 5% more timeouts and significantly smaller final cwnd values at the end of recovery. The smaller cwnd sometimes causes the recovery itself to take extra round trips. These results are representative of PRR-CRB and other algorithms that implement strict packet conservation during recovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レート-半減は、回復の最後に5％以上のタイムアウトと大幅に小さく、最終的にcwnd値を経験します。小さい方のcwndは時々余分なラウンドトリップを取るために回復自体が発生します。これらの結果は、PRR-CRBと回復時厳密なパケットの保全を実施する他のアルゴリズムの代表的なものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Conclusion and Recommendations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.結論と提言
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the Strong Packet Conservation Bound used in PRR-CRB is very appealing for a number of reasons, our measurements show that it is less aggressive and does not perform as well as RFC 3517 (and by implication RFC 6675), which permits bursts of data when there are bursts of losses. RFC 3517 and RFC 6675 are conservative in the original sense of Van Jacobson&#39;s packet conservation principle, which included the assumption that presumed lost segments have indeed left the network. PRR-CRB makes no such assumption, following instead a Strong Packet Conservation Bound in which only packets that have actually arrived at the receiver are considered to have left the network. PRR-SSRB is a compromise that permits TCP to send 1 extra segment per ACK relative to the Strong Packet Conservation Bound, to partially compensate for excess losses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-CRBで使用されるバインドされた強力なパケット保全は、多くの理由から非常に魅力的ではあるが、我々の測定は、それはあまり積極的であるとRFC 3517として（と含意RFC 6675によって）データのバーストを可能にし、同様に実行されないことを示していますときの損失のバーストがあります。 RFC 3517およびRFC 6675を推定失われたセグメントは、実際にネットワークを残しているという仮定が含まれていヴァンヤコブソンパケット保全の原則のもとの意味で保守的です。 PRR-CRBではなく、実際に受信機に到着したパケットのみがネットワークを残していると考えられているバインドされた強力なパケット保全を以下、そのような仮定を行うものではありません。 PRR-SSRBは、部分的に過剰損失を補償するために、バインドされた強力なパケットの保全にACKの相対あたり1つの余分なセグメントを送信するためにTCPを許す妥協案です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the perspective of the Strong Packet Conservation Bound, PRR-SSRB does indeed open the window during recovery; however, it is significantly less aggressive than RFC 3517 (and RFC 6675) in the presence of burst losses. Even so, it often outperforms RFC 3517 (and presumably RFC 6675) because it avoids some of the self-inflicted losses caused by bursts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バウンド強力なパケット保全の観点から、PRR-SSRBは確かに回復中にウィンドウを開くありません。しかし、バースト損失の存在下で、RFC 3517（およびRFC 6675）よりも有意に少ない攻撃的です。それがバーストによって引き起こさ自ら招い損失の一部を避けているため、たとえそうであっても、それは多くの場合、RFC 3517（そしておそらくRFC 6675）を凌駕します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this time, we see no reason not to test and deploy PRR-SSRB on a large scale. Implementers worried about any potential impact of raising the window during recovery may want to optionally support PRR-CRB (which is actually simpler to implement) for comparison studies. Furthermore, there is one minor detail of PRR that can be improved by replacing pipe by total_pipe, as defined by Laminar TCP [Laminar].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、我々は大規模にPRR-SSRBをテストして展開しない理由を見ません。リカバリ時にウィンドウを上げるの任意の潜在的な影響を心配実装者は、比較研究のために（実装が実際に簡単です）サポートPRR-CRBをオプションにすることができます。さらに、層TCP [層流]によって定義されるように、total_pipeによりパイプを交換することによって改善することができるPRRのマイナー詳細があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One final comment about terminology: we expect that common usage will drop &#34;Slow Start Reduction Bound&#34; from the algorithm name. This document needed to be pedantic about having distinct names for PRR and every variant of the Reduction Bound. However, we do not anticipate any future exploration of the alternative Reduction Bounds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用語について最後にひとつのコメント：私たちは一般的な使用は、アルゴリズム名から「バウンドスロースタートの削減」をドロップすることを期待しています。この文書では、PRRとバウンド削減のすべてのバリアントのための明確な名前を持っていることについて知識をひけらかすことする必要がありました。しかし、我々は代替削減境界のいずれかの将来の探査を予想していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is based in part on previous incomplete work by Matt Mathis, Jeff Semke, and Jamshid Mahdavi [RHID] and influenced by several discussions with John Heffner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、マット・マシス、ジェフSemke、およびジャムシードMahdaviにより、以前の不完全な仕事[RHID]に一部基づいて、ジョンHeffnerを持ついくつかの議論に影響されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Monia Ghobadi and Sivasankar Radhakrishnan helped analyze the experiments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モニアGhobadiとSivasankarラダクリシュナンは、実験を分析する助けました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ilpo Jarvinen reviewed the code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ilpo Jarvinenはコードをレビュー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark Allman improved the document through his insightful review.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マーク・オールマンは、彼の洞察に満ちたレビューを通じて文書を改善しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR does not change the risk profile for TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRRは、TCPのためのリスクプロファイルを変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementers that change PRR from counting bytes to segments have to be cautious about the effects of ACK splitting attacks [Savage99], where the receiver acknowledges partial segments for the purpose of confusing the sender&#39;s congestion accounting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セグメントにバイトをカウントからPRR変更実装者は、受信者が送信者の混雑会計の混乱のために部分セグメントを承認ACK分割攻撃[Savage99]、の影響については慎重でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0793]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 &#34;TCPの選択確認応答オプション&#34;、RFC 2018、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 &#34;TCP輻輳制御&#34;、RFC 5681、2009年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6675] Blanton, E., Allman, M., Wang, L., Jarvinen, I., Kojo, M., and Y. Nishida, &#34;A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP&#34;, RFC 6675, August 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6675]ブラントン、E.、オールマン、M.、王、L.、Jarvinen、I.、古城、M.、およびY.西田、 &#34;TCPのための選択的確認応答（SACK）に基づいて、保存的損失回復アルゴリズム&#34;、 RFC 6675、2012年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3042] Allman, M., Balakrishnan, H., and S. Floyd, &#34;Enhancing TCP&#39;s Loss Recovery Using Limited Transmit&#34;, RFC 3042, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3042]オールマン、M.、バラクリシュナン、H.、およびS.フロイド、 &#34;株式会社トランスミットを使用したTCPの損失回復の強化&#34;、RFC 3042、2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3517] Blanton, E., Allman, M., Fall, K., and L. Wang, &#34;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&#34;, RFC 3517, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3517]ブラントン、E.、オールマン、M.、秋、K.、およびL.王は、 &#34;保守的な選択的確認応答（SACK）はTCPのために損失回復アルゴリズムをベース&#34;、RFC 3517、2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IMC11] Dukkipati, N., Mathis, M., Cheng, Y., and M. Ghobadi, &#34;Proportional Rate Reduction for TCP&#34;, Proceedings of the 11th ACM SIGCOMM Conference on Internet Measurement 2011, Berlin, Germany, November 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IMC11] Dukkipati、N.、マティス、M.、チェン、Y.、およびM. Ghobadi、 &#34;TCPのための比例レートの低減&#34;、インターネット計測2011年、ベルリン、ドイツ、2011年11月に第11回ACM SIGCOMM会議の議事。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FACK] Mathis, M. and J. Mahdavi, &#34;Forward Acknowledgment: Refining TCP Congestion Control&#34;, ACM SIGCOMM SIGCOMM96, August 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FACK]マシス、M.とJ. Mahdavi、 &#34;フォワード謝辞：精錬TCP輻輳制御&#34;、ACM SIGCOMM SIGCOMM96、1996年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RHID] Mathis, M., Semke, J., and J. Mahdavi, &#34;The Rate-Halving Algorithm for TCP Congestion Control&#34;, Work in Progress, August 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【RHID]マティス、M.、Semke、J.、およびJ. Mahdavi、 &#34;TCP輻輳制御のレート半減アルゴリズム&#34;、進歩、1999年8月ワーク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RHweb] Mathis, M. and J. Mahdavi, &#34;TCP Rate-Halving with Bounding Parameters&#34;, Web publication, December 1997, &lt;http://www.psc.edu/networking/papers/FACKnotes/current/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RHweb]マシス、M.とJ. Mahdavi、 &#34;バウンディングパラメータを指定したTCPレート-半減&#34;、ウェブ出版、1997年12月、&lt;http://www.psc.edu/networking/papers/FACKnotes/current/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CUBIC] Rhee, I. and L. Xu, &#34;CUBIC: A new TCP-friendly high-speed TCP variant&#34;, PFLDnet 2005, February 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CUBIC]李承晩、I.およびL.徐、 &#34;CUBIC：新しいTCPに優しい高速TCP変異体&#34;、PFLDnet 2005、2005年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jacobson88] Jacobson, V., &#34;Congestion Avoidance and Control&#34;, SIGCOMM Comput. Commun. Rev. 18(4), August 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Jacobson88]ジェーコブソン、V.、 &#34;輻輳回避と制御&#34;、SIGCOMM Comput。 COMMUN。牧師18（4）、1988年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Savage99] Savage, S., Cardwell, N., Wetherall, D., and T. Anderson, &#34;TCP congestion control with a misbehaving receiver&#34;, SIGCOMM Comput. Commun. Rev. 29(5), October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【Savage99]サベージ、S.、カードウェル、N.、Wetherall、D.、およびT.アンダーソン、 &#34;不正動作する受信機とTCP輻輳制御&#34;、SIGCOMM Comput。 COMMUN。牧師29（5）、1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Laminar] Mathis, M., &#34;Laminar TCP and the case for refactoring TCP congestion control&#34;, Work in Progress, July 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[層流]マシス、M.、「層のTCPとTCPの輻輳制御をリファクタリングするケース」、進歩、2012年7月での作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Strong Packet Conservation Bound
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
バウンド付録A.強力なパケット保全
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-CRB is based on a conservative, philosophically pure, and aesthetically appealing Strong Packet Conservation Bound, described here. Although inspired by Van Jacobson&#39;s packet conservation principle [Jacobson88], it differs in how it treats segments that are missing and presumed lost. Under all conditions and sequences of events during recovery, PRR-CRB strictly bounds the data transmitted to be equal to or less than the amount of data delivered to the receiver. Note that the effects of presumed losses are included in the pipe calculation, but do not affect the outcome of PRR-CRB, once pipe has fallen below ssthresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PRR-CRBは、ここで説明したバウンド、保守的な哲学的に純粋な、そして審美的に魅力的な強力なパケット保全、に基づいています。ヴァンヤコブソンパケット保全の原則[Jacobson88]に触発されますが、それは行方不明と失われたと推定されているセグメントをどのように扱うかが異なります。回復中のすべての条件とイベントのシーケンスの下で、PRR-CRBは、厳密に等しいか又は受信機に配信されたデータの量よりも少なくなるように、送信されたデータの境界。パイプはSSTHRESHを下回った時点で推定される損失の効果は、パイプの計算に含まれているが、PRR-CRBの結果に影響しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We claim that this Strong Packet Conservation Bound is the most aggressive algorithm that does not lead to additional forced losses in some environments. It has the property that if there is a standing queue at a bottleneck that is carrying no other traffic, the queue will maintain exactly constant length for the entire duration of the recovery, except for +1/-1 fluctuation due to differences in packet arrival and exit times. Any less aggressive algorithm will result in a declining queue at the bottleneck. Any more aggressive algorithm will result in an increasing queue or additional losses if it is a full drop tail queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
私たちは、バウンド、この強力なパケット保全は一部の環境では、追加の強制損失につながるものではない最も積極的なアルゴリズムであることを主張します。それは立っキューは、他のトラフィックを搬送していないボトルネックである場合には、キューが原因パケットの到着の違いに+ 1 / -1の変動を除いて、回復の全期間にわたって正確に一定の長さを維持するという性質を持っていますそして、出口回。どれでもあまり積極的なアルゴリズムがボトルネックに減少したキューになります。それは完全なドロップテールキューである場合は、任意のより積極的なアルゴリズムが増加キューまたは追加的な損失になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We demonstrate this property with a little thought experiment:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は少し思考実験で、このプロパティを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Imagine a network path that has insignificant delays in both directions, except for the processing time and queue at a single bottleneck in the forward path. By insignificant delay, we mean when a packet is &#34;served&#34; at the head of the bottleneck queue, the following events happen in much less than one bottleneck packet time: the packet arrives at the receiver; the receiver sends an ACK that arrives at the sender; the sender processes the ACK and sends some data; the data is queued at the bottleneck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
往路単一ボトルネックでの処理時間とキューを除き、両方向の些細な遅延を持つネットワークパスを想像してみてください。些細な遅延によって、我々は、パケットがボトルネックキューの先頭に「提供」されると、次のイベントが1ボトルネックパケット時間よりもはるかに少ないで起こる意味：パケットが受信機に到着します。受信側は送信側に到着したACKを送信します。送信側はACKを処理し、いくつかのデータを送信します。データがボトルネックにキューイングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If sndcnt is set to DeliveredData and nothing else is inhibiting sending data, then clearly the data arriving at the bottleneck queue will exactly replace the data that was served at the head of the queue, so the queue will have a constant length. If queue is drop tail and full, then the queue will stay exactly full. Losses or reordering on the ACK path only cause wider fluctuations in the queue size, but do not raise its peak size, independent of whether the data is in order or out of order (including loss recovery from an earlier RTT). Any more aggressive algorithm that sends additional data will overflow the drop tail queue and cause loss. Any less aggressive algorithm will under-fill the queue. Therefore, setting sndcnt to DeliveredData is the most aggressive algorithm that does not cause forced losses in this simple network. Relaxing the assumptions (e.g., making delays more authentic and adding more flows, delayed ACKs, etc.) is likely to increase the fine grained fluctuations in queue size but does not change its basic behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sndcntがDeliveredDataに設定されており、他に何もデータを送信して抑制されていない場合は、ボトルネックキューに到着明確にデータが正確にキューの先頭に提供されたデータに置き換えられますので、キューが一定の長さを持つことになります。キューがドロップテール、フルである場合は、キューは正確に完全なままになります。 ACKパス上の損失や並べ替えのみキューサイズの広い変動を引き起こすが、データが順番にまたは（以前のRTTからの損失回復を含む）故障しているかどうかとは無関係に、そのピークの大きさを上げないでください。追加のデータを送信し、任意のより積極的なアルゴリズムは、ドロップテールキューをオーバーフローさせ、損失が発生します。どれでもあまり積極的なアルゴリズムは、キューをアンダーフィルします。したがって、DeliveredDataにsndcntを設定すると、この単純なネットワークに強制的に損失を生じない最も積極的なアルゴリズムです。仮定を緩和（例えば、遅延がより本格的な作り、など多くのフロー、遅延ACKを追加する）キューサイズの微細粒度の変動を増加させる可能性が高いが、その基本的な動作を変更しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the congestion control algorithm implements a broader notion of optimal that includes appropriately sharing the network. Typical congestion control algorithms are likely to reduce the data sent relative to the Packet Conserving Bound implemented by PRR, bringing TCP&#39;s actual window down to ssthresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御アルゴリズムが適切にネットワークを共有含む最適の広い概念を実装していることに注意してください。典型的な輻輳制御アルゴリズムは、パケットの節約に比べて送信されたデータを減少させる可能性が高いダウンSSTHRESHにTCPの実際のウィンドウをもたらす、PRRによって実装結合しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Matt Mathis Google, Inc. 1600 Amphitheatre Parkway Mountain View, California 94043 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マット・マシスグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、カリフォルニア94043 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: mattmathis@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：mattmathis@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nandita Dukkipati Google, Inc. 1600 Amphitheatre Parkway Mountain View, California 94043 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nandita Dukkipatiグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、カリフォルニア94043 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: nanditad@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：nanditad@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yuchung Cheng Google, Inc. 1600 Amphitheatre Parkway Mountain View, California 94043 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yuchungチェングーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、カリフォルニア94043 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EMail: ycheng@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メールアドレス：ycheng@google.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
