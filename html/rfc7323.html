<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7323 - TCP Extensions for High Performance 日本語訳</title>

  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7323 - TCP Extensions for High Performance 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7323">
              https://tools.ietf.org/html/rfc7323
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7323 - ハイパフォーマンスのためのTCP拡張機能</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         D. Borman
Request for Comments: 7323                           Quantum Corporation
Obsoletes: 1323                                                B. Braden
Category: Standards Track              University of Southern California
ISSN: 2070-1721                                              V. Jacobson
                                                            Google, Inc.
                                                   R. Scheffenegger, Ed.
                                                            NetApp, Inc.
                                                          September 2014
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  TCP Extensions for High Performance
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies a set of TCP extensions to improve performance over paths with a large bandwidth * delay product and to provide reliable operation over very high-speed paths. It defines the TCP Window Scale (WS) option and the TCP Timestamps (TS) option and their semantics. The Window Scale option is used to support larger receive windows, while the Timestamps option can be used for at least two distinct mechanisms, Protection Against Wrapped Sequences (PAWS) and Round-Trip Time Measurement (RTTM), that are also described herein.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、大きな帯域幅*遅れ製品でパスを超えるパフォーマンスを向上させるために、非常に高速な経路を介して信頼性の高い動作を提供するために、TCPの拡張機能のセットを指定します。これは、TCPウィンドウスケール（WS）オプションおよびTCPタイムスタンプ（TS）オプションとそれらの意味を定義します。タイムスタンプオプションは、少なくとも2つの別個のメカニズムを使用することができるがウィンドウスケールオプションは、ウィンドウを受け取る大きなサポートするために使用され、また、本明細書に記載されているに対する保護ラップ配列（PAWS）および往復時間測定（RTTM）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document obsoletes RFC 1323 and describes changes from it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書はRFC 1323を廃止し、それからの変更点について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7323.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7323で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
     1.1.  TCP Performance . . . . . . . . . . . . . . . . . . . . .   4
     1.2.  TCP Reliability . . . . . . . . . . . . . . . . . . . . .   5
     1.3.  Using TCP options . . . . . . . . . . . . . . . . . . . .   6
     1.4.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   7
   2.  TCP Window Scale Option . . . . . . . . . . . . . . . . . . .   8
     2.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .   8
     2.2.  Window Scale Option . . . . . . . . . . . . . . . . . . .   8
     2.3.  Using the Window Scale Option . . . . . . . . . . . . . .   9
     2.4.  Addressing Window Retraction  . . . . . . . . . . . . . .  10
   3.  TCP Timestamps Option . . . . . . . . . . . . . . . . . . . .  11
     3.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  11
     3.2.  Timestamps Option . . . . . . . . . . . . . . . . . . . .  12
   4.  The RTTM Mechanism  . . . . . . . . . . . . . . . . . . . . .  14
     4.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  14
     4.2.  Updating the RTO Value  . . . . . . . . . . . . . . . . .  15
     4.3.  Which Timestamp to Echo . . . . . . . . . . . . . . . . .  16
   5.  PAWS - Protection Against Wrapped Sequences . . . . . . . . .  19
     5.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  19
     5.2.  The PAWS Mechanism  . . . . . . . . . . . . . . . . . . .  19
     5.3.  Basic PAWS Algorithm  . . . . . . . . . . . . . . . . . .  20
     5.4.  Timestamp Clock . . . . . . . . . . . . . . . . . . . . .  22
     5.5.  Outdated Timestamps . . . . . . . . . . . . . . . . . . .  24
     5.6.  Header Prediction . . . . . . . . . . . . . . . . . . . .  25
     5.7.  IP Fragmentation  . . . . . . . . . . . . . . . . . . . .  26
     5.8.  Duplicates from Earlier Incarnations of Connection  . . .  26
   6.  Conclusions and Acknowledgments . . . . . . . . . . . . . . .  27
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  27
     7.1.  Privacy Considerations  . . . . . . . . . . . . . . . . .  29
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  29
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  30
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  30
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  30
   Appendix A.  Implementation Suggestions . . . . . . . . . . . . .  34
   Appendix B.  Duplicates from Earlier Connection Incarnations  . .  35
     B.1.  System Crash with Loss of State . . . . . . . . . . . . .  35
     B.2.  Closing and Reopening a Connection  . . . . . . . . . . .  35
   Appendix C.  Summary of Notation  . . . . . . . . . . . . . . . .  37
   Appendix D.  Event Processing Summary . . . . . . . . . . . . . .  38
   Appendix E.  Timestamps Edge Cases  . . . . . . . . . . . . . . .  44
   Appendix F.  Window Retraction Example  . . . . . . . . . . . . .  44
   Appendix G.  RTO Calculation Modification . . . . . . . . . . . .  45
   Appendix H.  Changes from RFC 1323  . . . . . . . . . . . . . . .  46
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TCP protocol [RFC0793] was designed to operate reliably over almost any transmission medium regardless of transmission rate, delay, corruption, duplication, or reordering of segments. Over the years, advances in networking technology have resulted in ever-higher transmission speeds, and the fastest paths are well beyond the domain for which TCP was originally engineered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPプロトコル[RFC0793]は、ほぼすべての伝送媒体に関係なく、伝送レート、遅延、破損、複製、またはセグメントの並べ替えの確実にわたって動作するように設計されました。長年にわたり、ネットワーク技術の進歩は、ますます高い伝送速度をもたらしている、と最速のパスは、TCPが最初に設計されたため、ドメインをはるかに超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines a set of modest extensions to TCP to extend the domain of its application to match the increasing network capability. It is an update to and obsoletes [RFC1323], which in turn is based upon and obsoletes [RFC1072] and [RFC1185].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、増加ネットワーク機能と一致するように、そのアプリケーションのドメインを拡張するためにTCPにささやかな拡張セットを定義します。それは、順番に基づいている[RFC1323]、および時代遅れ[RFC1072]及び[RFC1185]および時代遅れの更新です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Changes between [RFC1323] and this document are detailed in Appendix H. These changes are partly due to errata in [RFC1323], and partly due to the improved understanding of how the involved components interact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1323]とこのドキュメント間の変更は、これらの変更は、部分的に[RFC1323]で正誤表に、かつ部分的に関与コンポーネントがどのように相互作用するかの理解向上に起因している付録H.に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For brevity, the full discussions of the merits and history behind the TCP options defined within this document have been omitted. [RFC1323] should be consulted for reference. It is recommended that a modern TCP stack implements and make use of the extensions described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
簡潔にするために、このドキュメント内で定義されたTCPオプションの後ろのメリットと歴史の完全な議論が省略されています。 [RFC1323]は、参照のために相談すべきです。これは、近代的なTCPスタックを実装することを推奨し、この文書で説明した拡張機能を利用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. TCP Performance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。 TCPの性能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP performance problems arise when the bandwidth * delay product is large. A network having such paths is referred to as a &#34;long, fat network&#34; (LFN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
帯域幅*遅延積が大きい場合、TCPのパフォーマンスの問題が発生します。そのような経路を有するネットワークが「長い、脂肪ネットワーク」（LFN）と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two fundamental performance problems with basic TCP over LFN paths:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LFNパスを超える基本的なTCPを持つ2つの基本的なパフォーマンスの問題があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) Window Size Limit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）ウィンドウサイズ制限
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        The TCP header uses a 16-bit field to report the receive window
        size to the sender.  Therefore, the largest window that can be
        used is 2^16 = 64 KiB.  For LFN paths where the bandwidth *
        delay product exceeds 64 KiB, the receive window limits the
        maximum throughput of the TCP connection over the path, i.e.,
        the amount of unacknowledged data that TCP can send in order to
        keep the pipeline full.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To circumvent this problem, Section 2 of this memo defines a TCP option, &#34;Window Scale&#34;, to allow windows larger than 2^16. This option defines an implicit scale factor, which is used to multiply the window size value found in a TCP header to obtain the true window size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この問題を回避するには、このメモのセクション2は2 ^ 16よりも窓を大きくできるようにするTCPオプション、「ウィンドウスケール」を、定義されています。このオプションは、真のウィンドウサイズを得るために、TCPヘッダに見出されるウィンドウサイズの値を乗算するために使用される暗黙的なスケールファクタを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It must be noted that the use of large receive windows increases the chance of too quickly wrapping sequence numbers, as described below in Section 1.2, (1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
大規模の使用は、1.2節で後述するように、あまりにも早く包むシーケンス番号のチャンスを高める窓を受けることに留意しなければならない（1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) Recovery from Losses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）損失からの回復を
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Packet losses in an LFN can have a catastrophic effect on
        throughput.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To generalize the Fast Retransmit / Fast Recovery mechanism to handle multiple packets dropped per window, Selective Acknowledgments are required. Unlike the normal cumulative acknowledgments of TCP, Selective Acknowledgments give the sender a complete picture of which segments are queued at the receiver and which have not yet arrived.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数のパケットは、ウィンドウごとにドロップ処理するための高速再送/高速リカバリメカニズムを一般化するには、選択的な謝辞が必要とされています。 TCPの正規累積確認応答とは異なり、選択謝辞は、送信者に、セグメントが受信機にキューイングされているのと、まだ到着していないその全体像を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Selective Acknowledgments and their use are specified in separate documents, &#34;TCP Selective Acknowledgment Options&#34; [RFC2018], &#34;An Extension to the Selective Acknowledgement (SACK) Option for TCP&#34; [RFC2883], and &#34;A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP&#34; [RFC6675], and are not further discussed in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択謝辞およびその使用は別の文書で指定されている、「TCP選択確認応答オプション」[RFC2018]、「TCPのための選択確認応答（SACK）オプションの拡張」[RFC2883]、および「保守的な損失回復アルゴリズム選択確認応答に基づいて、 TCP用（SACK）」[RFC6675]、さらに本書では説明しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. TCP Reliability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。 TCPの信頼性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An especially serious kind of error may result from an accidental reuse of TCP sequence numbers in data segments. TCP reliability depends upon the existence of a bound on the lifetime of a segment: the &#34;Maximum Segment Lifetime&#34; or MSL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エラーの特に深刻な種類は、データセグメント内のTCPシーケンス番号を誤って再利用から生じ得ます。 TCPの信頼性は、セグメントの寿命上の結合の存在に依存：「最大セグメント生涯」やMSLを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Duplication of sequence numbers might happen in either of two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シーケンス番号の重複は、2つの方法のいずれかで発生する可能性があります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) Sequence number wrap-around on the current connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）シーケンス番号がラップアラウンド現在の接続に
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        A TCP sequence number contains 32 bits.  At a high enough
        transfer rate of large volumes of data (at least 4 GiB in the
        same session), the 32-bit sequence space may be &#34;wrapped&#34;
        (cycled) within the time that a segment is delayed in queues.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) Earlier incarnation of the connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）接続の以前の化身を
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Suppose that a connection terminates, either by a proper close
        sequence or due to a host crash, and the same connection (i.e.,
        using the same pair of port numbers) is immediately reopened.  A
        delayed segment from the terminated connection could fall within
        the current window for the new incarnation and be accepted as
        valid.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Duplicates from earlier incarnations, case (2), are avoided by enforcing the current fixed MSL of the TCP specification, as explained in Section 5.8 and Appendix B. In addition, the randomizing of ephemeral ports can also help to probabilistically reduce the chances of duplicates from earlier connections. However, case (1), avoiding the reuse of sequence numbers within the same connection, requires an upper bound on MSL that depends upon the transfer rate, and at high enough rates, a dedicated mechanism is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、5.8節および付録Bで説明したように、以前の化身、ケース（2）からの重複が、TCP仕様の現在の固定MSLを実施することによって回避され、エフェメラルポートのランダム化は、また、確率的重複の可能性を減らすのを助けることができます以前の接続から。しかし、ケース（1）は、同じ接続内のシーケンス番号の再利用を避け、転送レートに依存MSLの上限を必要とし、十分に高い速度で、専用の機構が必要となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A possible fix for the problem of cycling the sequence space would be to increase the size of the TCP sequence number field. For example, the sequence number field (and also the acknowledgment field) could be expanded to 64 bits. This could be done either by changing the TCP header or by means of an additional option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
系列スペースを循環の問題のための可能な修正は、TCPシーケンス番号フィールドのサイズを大きくすることであろう。例えば、シーケンス番号フィールド（および確認応答フィールド）が64ビットに拡張することができます。これは、TCPヘッダを変更するか、追加オプションによってどちらか行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 5 presents a different mechanism, which we call PAWS, to extend TCP reliability to transfer rates well beyond the foreseeable upper limit of network bandwidths. PAWS uses the TCP Timestamps option defined in Section 3.2 to protect against old duplicates from the same connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第5節では、我々は、PAWSを呼び出すだけでなく、ネットワーク帯域幅の予見可能な上限を超えて速度を転送するためにTCPの信頼性を拡張するために別のメカニズムを提示します。 PAWSは同じ接続からの古い写しから保護するために、3.2節で定義されたTCPタイムスタンプオプションを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Using TCP options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。 TCPオプションを使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The extensions defined in this document all use TCP options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてこの文書で定義された拡張は、TCPオプションを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When [RFC1323] was published, there was concern that some buggy TCP implementation might crash on the first appearance of an option on a non-&lt;SYN&gt; segment. However, bugs like that can lead to denial-of-service (DoS) attacks against a TCP. Research has shown that most TCP implementations will properly handle unknown options on non-&lt;SYN&gt; segments ([Medina04], [Medina05]). But it is still prudent to be conservative in what you send, and avoiding buggy TCP implementation is not the only reason for negotiating TCP options on &lt;SYN&gt; segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1323]が出版されたときに、いくつかのバグのTCP実装は非&lt;SYN&gt;セグメント上のオプションの最初の出現にクラッシュする可能性があります懸念がありました。しかし、そのようなバグは、TCPに対するサービス拒否（DoS）攻撃につながることができます。研究は、ほとんどのTCPの実装が適切に非&lt;SYN&gt;セグメント（[Medina04]、[Medina05]）に未知のオプションを処理することが示されています。しかし、まだあなたが送信するもので保守的であることが賢明である、とバギーTCPの実装を回避することは、&lt;SYN&gt;セグメント上のTCPオプションを交渉するための唯一の理由ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Window Scale option negotiates fundamental parameters of the TCP session. Therefore, it is only sent during the initial handshake. Furthermore, the Window Scale option will be sent in a &lt;SYN,ACK&gt; segment only if the corresponding option was received in the initial &lt;SYN&gt; segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウィンドウスケールオプションは、TCPセッションの基本的なパラメータをネゴシエートします。そのため、それが唯一の初期ハンドシェイク中に送信されます。また、ウィンドウスケールオプションは、対応するオプションが初期&lt;SYN&gt;セグメントで受信された場合にのみ、&lt;SYN、ACK&gt;セグメントで送信されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Timestamps option may appear in any data or &lt;ACK&gt; segment, adding 10 bytes (up to 12 bytes including padding) to the 20-byte TCP header. It is required that this TCP option will be sent on all non-&lt;SYN&gt; segments after an exchange of options on the &lt;SYN&gt; segments has indicated that both sides understand this extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプオプションは、20バイトのTCPヘッダに10バイト（パディングを含む12バイトまで）を添加すること、任意のデータまたは&lt;ACK&gt;セグメントに表示されてもよいです。 &lt;SYN&gt;セグメントのオプションの交換は両側がこの拡張を理解することが示された後に、このTCPオプションは、すべての非&lt;SYN&gt;セグメントで送信されることが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Research has shown that the use of the Timestamps option to take additional RTT samples within each RTT has little effect on the ultimate retransmission timeout value [Allman99]. However, there are other uses of the Timestamps option, such as the Eifel mechanism ([RFC3522], [RFC4015]) and PAWS (see Section 5), which improve overall TCP security and performance. The extra header bandwidth used by this option should be evaluated for the gains in performance and security in an actual deployment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
研究では、タイムスタンプオプションを使用すると、各RTT以内に追加のRTTサンプルを取ることが示されている[Allman99]究極の再送タイムアウト値にほとんど影響を与えません。しかし、全体的なTCPのセキュリティとパフォーマンスを向上させるようなアイフェル機構（[RFC3522]、[RFC4015]）とPAWSとしてタイムスタンプ・オプションの他の用途は、（セクション5を参照）があります。このオプションで使用される追加のヘッダーの帯域幅は、実際の展開でのパフォーマンスとセキュリティの利益のために評価されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A contains a recommended layout of the options in TCP headers to achieve reasonable data field alignment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録Aには、合理的なデータフィールドのアラインメントを達成するために、TCPヘッダ内のオプションの推奨レイアウトが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finally, we observe that most of the mechanisms defined in this document are important for LFNs and/or very high-speed networks. For low-speed networks, it might be a performance optimization to NOT use these mechanisms. A TCP vendor concerned about optimal performance over low-speed paths might consider turning these extensions off for low-speed paths, or allow a user or installation manager to disable them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後に、私たちは、この文書で定義されたメカニズムのほとんどはLFNsおよび/または非常に高速ネットワークのために重要であることを確認します。低速ネットワークの場合、これらのメカニズムを使用しないようにパフォーマンスを最適化するかもしれません。低速経路を介して、最適なパフォーマンスを懸念TCPベンダーは、低速パスにこれらの拡張機能をオフにすることを検討し、またはそれらを無効にするユーザーまたはインストールマネージャを許可するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4。用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this document, these words will appear with that interpretation only when in UPPER CASE. Lower case uses of these words are not to be interpreted as carrying [RFC2119] significance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、これらの言葉はときにのみ大文字でその解釈に表示されます。小文字は、[RFC2119]意味を運ぶものとして解釈されるべきではないこれらの言葉の使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. TCP Window Scale Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. TCPウィンドウスケールオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。前書き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The window scale extension expands the definition of the TCP window to 30 bits and then uses an implicit scale factor to carry this 30-bit value in the 16-bit window field of the TCP header (SEG.WND in [RFC0793]). The exponent of the scale factor is carried in a TCP option, Window Scale. This option is sent only in a &lt;SYN&gt; segment (a segment with the SYN bit on), hence the window scale is fixed in each direction when a connection is opened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウィンドウスケール拡張は、30ビットにTCPウィンドウの定義を拡張した後、TCPヘッダ（[RFC0793]でSEG.WND）の16ビットのウィンドウフィールドに、この30ビットの値を運ぶために、暗黙のスケールファクタを使用しています。スケール係数の指数は、TCPオプション、ウィンドウスケールで行われます。このオプションは、したがって、ウィンドウスケールは、接続が開かれる各方向に固定されている&lt;SYN&gt;セグメント（上のSYNビットを有するセグメント）で送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The maximum receive window, and therefore the scale factor, is determined by the maximum receive buffer space. In a typical modern implementation, this maximum buffer space is set by default but can be overridden by a user program before a TCP connection is opened. This determines the scale factor, and therefore no new user interface is needed for window scaling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最大ウィンドウ、したがってスケールファクタを受信し、バッファスペースを受け取る最大ことによって決定されます。典型的な近代的な実装では、この最大バッファ・スペースは、デフォルトで設定されていますが、TCP接続が開かれる前に、ユーザプログラムで上書きすることができます。これは、スケールファクタを決定し、したがって、新しいユーザーインターフェイスは、ウィンドウスケーリングのために必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Window Scale Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。ウィンドウスケールオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The three-byte Window Scale option MAY be sent in a &lt;SYN&gt; segment by a TCP. It has two purposes: (1) indicate that the TCP is prepared to both send and receive window scaling, and (2) communicate the exponent of a scale factor to be applied to its receive window. Thus, a TCP that is prepared to scale windows SHOULD send the option, even if its own scale factor is 1 and the exponent 0. The scale factor is limited to a power of two and encoded logarithmically, so it may be implemented by binary shift operations. The maximum scale exponent is limited to 14 for a maximum permissible receive window size of 1 GiB (2^(14+16)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3バイトのウィンドウスケールオプションはTCPで、&lt;SYN&gt;セグメントで送信することができます。 （1）TCPは、送信およびウィンドウスケーリングを受信し、（2）スケール係数の指数は、その受信ウィンドウに適用される通信の両方に用意されていることを示している：それは2つの目的を有しています。したがって、ウィンドウを拡張する準備がTCPは、独自のスケールファクタが1であり、指数0は、スケールファクタが2の累乗に制限され、対数符号化され、それは、バイナリシフトによって実現することができる場合であっても、オプションを送るべきですオペレーション。最大規模の指数は、1ジブの最大許容受信ウィンドウサイズのために14に制限され（2 ^（14 + 16））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP Window Scale option (WSopt):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPウィンドウスケールオプション（WSopt）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kind: 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
種類：3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Length: 3 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
長さ：3つのバイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          +---------+---------+---------+
          | Kind=3  |Length=3 |shift.cnt|
          +---------+---------+---------+
               1         1         1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This option is an offer, not a promise; both sides MUST send Window Scale options in their &lt;SYN&gt; segments to enable window scaling in either direction. If window scaling is enabled, then the TCP that sent this option will right-shift its true receive-window values by &#39;shift.cnt&#39; bits for transmission in SEG.WND. The value &#39;shift.cnt&#39;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオプションは提供、ない約束です。両側はいずれの方向にウィンドウスケーリングを可能にするために、それらの&lt;SYN&gt;セグメントにウィンドウスケールオプションを送らなければなりません。ウィンドウスケーリングが有効になっている場合は、このオプションを送られたTCPは、SEG.WNDでの伝送のための「shift.cnt」ビットによって、その真の受信ウィンドウ値を右シフトします。値「shift.cnt」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MAY be zero (offering to scale, while applying a scale factor of 1 to the receive window).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（受信ウィンドウ1のスケールファクタを適用しながら、一定の縮尺で提供）0であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This option MAY be sent in an initial &lt;SYN&gt; segment (i.e., a segment with the SYN bit on and the ACK bit off). If a Window Scale option was received in the initial &lt;SYN&gt; segment, then this option MAY be sent in the &lt;SYN,ACK&gt; segment. A Window Scale option in a segment without a SYN bit MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このオプションは、最初の&lt;SYN&gt;セグメント（すなわち、上のSYNビットとACK有するセグメントがオフビット）で送信することができます。ウィンドウスケールオプションが初期&lt;SYN&gt;セグメント内で受信された場合、このオプションは&lt;SYN、ACK&gt;セグメントで送信することができます。 SYNビットなしのセグメントにウィンドウスケールオプションを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The window field in a segment where the SYN bit is set (i.e., a &lt;SYN&gt; or &lt;SYN,ACK&gt;) MUST NOT be scaled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SYNビットが設定されているセグメント内のウィンドウのフィールド（すなわち、&lt;SYN&gt;または&lt;SYN、ACK&gt;）スケーリングされてはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Using the Window Scale Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3。ウィンドウスケールオプションを使用します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A model implementation of window scaling is as follows, using the notation of [RFC0793]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0793]の表記法を使用して、次のようにウィンドウスケーリングのモデルの実装は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The connection state is augmented by two window shift counters, Snd.Wind.Shift and Rcv.Wind.Shift, to be applied to the incoming and outgoing window fields, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O接続の状態は、2つのウィンドウのシフトカウンタ、Snd.Wind.ShiftとRcv.Wind.Shift、によって増大され、それぞれ、着信および発信ウィンドウ・フィールドに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o If a TCP receives a &lt;SYN&gt; segment containing a Window Scale option, it SHOULD send its own Window Scale option in the &lt;SYN,ACK&gt; segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPは、ウィンドウスケールオプションを含む&lt;SYN&gt;セグメントを受信した場合、O、それは&lt;SYN、ACK&gt;セグメントに独自のウィンドウスケールオプションを送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The Window Scale option MUST be sent with shift.cnt = R, where R is the value that the TCP would like to use for its receive window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oウィンドウスケールオプションは、Rは、TCPがその受信ウィンドウに使用したいと値であるshift.cnt = Rで送信されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Upon receiving a &lt;SYN&gt; segment with a Window Scale option containing shift.cnt = S, a TCP MUST set Snd.Wind.Shift to S and MUST set Rcv.Wind.Shift to R; otherwise, it MUST set both Snd.Wind.Shift and Rcv.Wind.Shift to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O shift.cnt = Sを含むウィンドウスケールオプションで&lt;SYN&gt;セグメントを受け取ると、TCPは、SにSnd.Wind.Shiftを設定しなければなりません、そして、RにRcv.Wind.Shiftを設定しなければなりません。それ以外の場合は、ゼロにSnd.Wind.ShiftとRcv.Wind.Shiftの両方を設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The window field (SEG.WND) in the header of every incoming segment, with the exception of &lt;SYN&gt; segments, MUST be left-shifted by Snd.Wind.Shift bits before updating SND.WND:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oウィンドウフィールド&lt;SYN&gt;セグメントを除いて、すべての受信セグメントのヘッダに（SET.END）、AND.ENDを更新する前にSnd.Wind.Shiftビットだけ左シフトされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SND.WND = SEG.WND &lt;&lt; Snd.Wind.Shift
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SND.WND = SEG.WND &lt;&lt; Snd.Wind.Shift
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(assuming the other conditions of [RFC0793] are met, and using the &#34;C&#34; notation &#34;&lt;&lt;&#34; for left-shift).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（[RFC0793]の他の条件を仮定すると出会い、左シフトのために、「C」の表記を「&lt;&lt;」を使用しています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The window field (SEG.WND) of every outgoing segment, with the exception of &lt;SYN&gt; segments, MUST be right-shifted by Rcv.Wind.Shift bits:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての発信セグメントのウィンドウフィールド（SET.END）O、&lt;SYN&gt;セグメントを除いて、Rcv.Wind.Shiftビットだけ右シフトしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.WND = RCV.WND &gt;&gt; Rcv.Wind.Shift
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.AND = RCV.END &gt;&gt; Rcv.Wind.Shift
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP determines if a data segment is &#34;old&#34; or &#34;new&#34; by testing whether its sequence number is within 2^31 bytes of the left edge of the window, and if it is not, discarding the data as &#34;old&#34;. To insure that new data is never mistakenly considered old and vice versa, the left edge of the sender&#39;s window has to be at most 2^31 away from the right edge of the receiver&#39;s window. The same is true of the sender&#39;s right edge and receiver&#39;s left edge. Since the right and left edges of either the sender&#39;s or receiver&#39;s window differ by the window size, and since the sender and receiver windows can be out of phase by at most the window size, the above constraints imply that two times the maximum window size must be less than 2^31, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPは、データ・セグメントは、そのシーケンス番号がウィンドウの左端の2 ^ 31バイト以内であるか否かをテストすることによって「古い」または「新規」であるかどうかを判断し、そうでない場合、「古い」としてデータを破棄する。新しいデータが誤って古いとその逆と見なされないことを保証するために、送信者のウィンドウの左端には、最大2 ^ 31離れた受信側のウィンドウの右端からにする必要があります。同じことは、送信者の右端と受信機の左端の事実です。送信者と受信者のウィンドウが最大ウィンドウサイズによって位相がずれすることができるので、送信者や受信者のウィンドウはウィンドウサイズによって異なり、どちらかの左右の端ので、上記の制約を意味するものでは2倍の最大ウィンドウサイズがなければならないこと以下の2 ^ 31ですか、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
max window &lt; 2^30
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Maxウィンドウ&lt;2 ^ 30
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since the max window is 2^S (where S is the scaling shift count) times at most 2^16 - 1 (the maximum unscaled window), the maximum window is guaranteed to be &lt; 2^30 if S &lt;= 14. Thus, the shift count MUST be limited to 14 (which allows windows of 2^30 = 1 GiB). If a Window Scale option is received with a shift.cnt value larger than 14, the TCP SHOULD log the error but MUST use 14 instead of the specified value. This is safe as a sender can always choose to only partially use any signaled receive window. If the receiver is scaling by a factor larger than 14 and the sender is only scaling by 14, then the receive window used by the sender will appear smaller than it is in reality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最大ウィンドウは2 ^ S（Sはスケーリングシフト・カウントである）回最も2 ^ 16であるので、1  - （最大スケーリングされていないウィンドウ）このようにS &lt;= 14の場合、最大ウィンドウは、&lt;2 ^ 30であることが保証され、シフト数は（2 ^ 30 = 1ジブの窓を可能にする）14に制限されなければなりません。ウィンドウスケールオプションがshift.cnt値よりも大きい14で受信された場合、TCPはエラーをログに記録すべきであるが、指定された値の代わりに14を使用しなければなりません。送信者は、常に部分的にしかに選択した任意のウィンドウを受け取る合図使用することができますので、これは安全です。受信機は、14よりも大きい係数によってスケーリングされ、送信者がわずか14によってスケーリングされている場合、送信者によって使用されるザは受信ウィンドウは、それが実際にあるよりも小さく表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The scale factor applies only to the window field as transmitted in the TCP header; each TCP using extended windows will maintain the window values locally as 32-bit numbers. For example, the &#34;congestion window&#34; computed by slow start and congestion avoidance (see [RFC5681]) is not affected by the scale factor, so window scaling will not introduce quantization into the congestion window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スケールファクタは、TCPヘッダで送信されるよう、ウィンドウ・フィールドに適用されます。拡張されたウィンドウを使用して、各TCPは、32ビットの数値としてローカルウィンドウ値を維持します。例えば、スロースタートと輻輳回避によって計算「輻輳ウィンドウは」（[RFC5681]を参照）スケールファクターによって影響されないので、ウィンドウ・スケーリングは、輻輳ウィンドウに量子化を導入しないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. Addressing Window Retraction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4。ウィンドウの後退に対処
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a non-zero scale factor is in use, there are instances when a retracted window can be offered -- see Appendix F for a detailed example. The end of the window will be on a boundary based on the granularity of the scale factor being used. If the sequence number is then updated by a number of bytes smaller than that granularity, the TCP will have to either advertise a new window that is beyond what it previously advertised (and perhaps beyond the buffer) or will have to advertise a smaller window, which will cause the TCP window to shrink. Implementations MUST ensure that they handle a shrinking window, as specified in Section 4.2.2.16 of [RFC1122].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
詳細な例については、付録Fを参照してください - 非ゼロのスケール係数が使用されている場合、インスタンスは後退ウィンドウを提供することができる場合があります。ウィンドウの端は、使用されるスケールファクタの粒度に基づいて、境界にあろう。シーケンス番号は、その粒度よりも小さいバイト数によって更新された場合、TCPは、それが以前に広告を出し（そしておそらくバッファを越えて）以下のウィンドウを宣伝する必要があります何を超えて新しいウィンドウを宣伝するためのいずれかになりますこれは、TCPウィンドウが縮小するようになります。実装は、[RFC1122]のセクション4.2.2.16に指定されている彼らは、縮小ウインドウを扱う確実にしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For the receiver, this implies that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機の場合、これはその意味します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) The receiver MUST honor, as in window, any segment that would have been in window for any &lt;ACK&gt; sent by the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）受信機は、ウィンドウのように、任意の&lt;ACK&gt;受信機によって送信されるための窓であったであろう任意のセグメントを尊重しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) When window scaling is in effect, the receiver SHOULD track the actual maximum window sequence number (which is likely to be greater than the window announced by the most recent &lt;ACK&gt;, if more than one segment has arrived since the application consumed any data in the receive buffer).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウィンドウスケーリングが有効な場合2）、受信機は、&lt;ACK&gt;、複数のセグメントが到着した場合、アプリケーションは、任意の最新の消費のでによって発表されたウィンドウよりも大きくなる可能性がある実際の最大ウィンドウシーケンス番号（トラックSHOULD受信バッファ内のデータ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On the sender side:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者側では：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) The initial transmission MUST be within the window announced by the most recent &lt;ACK&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3）最初の送信は、&lt;ACK&gt;直近で発表されたウィンドウ内になければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4) On first retransmission, or if the sequence number is out of window by less than 2^Rcv.Wind.Shift, then do normal retransmission(s) without regard to the receiver window as long as the original segment was in window when it was sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4）最初の再送で、またはシーケンス番号が2未満^ Rcv.Wind.Shiftによってウィンドウの外にある場合、限りときに、元のセグメントがウィンドウにあったように、受信機ウィンドウに関係なく、通常の再送（単数または複数）を行います送信されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5) Subsequent retransmissions MAY only be sent if they are within the window announced by the most recent &lt;ACK&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らは&lt;ACK&gt;直近で発表されたウィンドウ内にある場合5）以降の再送信にのみ送信されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. TCP Timestamps Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. TCPタイムスタンプオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。前書き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Timestamps option is introduced to address some of the issues mentioned in Sections 1.1 and 1.2. The Timestamps option is specified in a symmetrical manner, so that Timestamp Value (TSval) timestamps are carried in both data and &lt;ACK&gt; segments and are echoed in Timestamp Echo Reply (TSecr) fields carried in returning &lt;ACK&gt; or data segments. Originally used primarily for timestamping individual segments, the properties of the Timestamps option allow for taking time measurements (Section 4) as well as additional uses (Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプオプションは、セクション1.1と1.2で述べた問題点のいくつかに対処するために導入されます。そのようにタイムスタンプ値タイムスタンプオプションは、対称的に指定されている（TSval）タイムスタンプは、データと&lt;ACK&gt;セグメントの両方で実施さ​​れ、&lt;ACK&gt;またはデータセグメントを返すで運ばタイムスタンプエコー応答（TSecr）フィールドにエコーされます。もともと個々のセグメントをタイムスタンプするために主に使用され、タイムスタンプオプションの特性は、（セクション4）並びに追加の用途（セクション5）時間測定を行うことを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is necessary to remember that there is a distinction between the Timestamps option conveying timestamp information and the use of that information. In particular, the RTTM mechanism must be viewed independently from updating the Retransmission Timeout (RTO) (see Section 4.2). In this case, the sample granularity also needs to be taken into account. Other mechanisms, such as PAWS or Eifel, are not built upon the timestamp information itself but are based on the intrinsic property of monotonically non-decreasing values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプ情報とその情報の使用を伝えるタイムスタンプオプションの区別があることを覚えておくことが必要です。特に、RTTM機構再送タイムアウト（RTO）の更新から独立して見なければならない（セクション4.2を参照）。この場合、サンプルの粒度も考慮する必要があります。例えばPAWS又はアイフェルのような他のメカニズムは、タイムスタンプ情報自体に基づいて構築されるのではなく、単調非減少の値の固有の特性に基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Timestamps option is important when large receive windows are used to allow the use of the PAWS mechanism (see Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
大型の窓がPAWSメカニズム（第5節を参照）の使用を可能にするために使用されている受信したときにタイムスタンプオプションが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Furthermore, the option may be useful for all TCPs, since it simplifies the sender and allows the use of additional optimizations such as Eifel ([RFC3522], [RFC4015]) and others ([RFC6817], [Kuzmanovic03], [Kuehlewind10]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、送信者が簡素化され、そのようなアイフェル（[RFC3522]、[RFC4015]）とその他（[RFC6817]、[Kuzmanovic03]、[Kuehlewind10]）などの追加の最適化の使用を可能にするので、このオプションは、すべてのTCPのために有用であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Timestamps Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2。タイムスタンプオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP is a symmetric protocol, allowing data to be sent at any time in either direction, and therefore timestamp echoing may occur in either direction. For simplicity and symmetry, we specify that timestamps always be sent and echoed in both directions. For efficiency, we combine the timestamp and timestamp reply fields into a single TCP Timestamps option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPは、データがいずれかの方向に任意の時間に送信できるように、対称的なプロトコルであるため、タイムスタンプ・エコーは、どちらの方向にも起こり得ます。シンプルさと対称性のために、私たちはタイムスタンプが常に両方向に送信され、エコーされるように指定します。効率化のために、我々は、単一のTCPタイムスタンプオプションにタイムスタンプとタイムスタンプ応答フィールドを兼ね備えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP Timestamps option (TSopt):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPタイムスタンプオプション（TSopt）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Kind: 8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
種類：8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Length: 10 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
長さ：10のバイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          +-------+-------+---------------------+---------------------+
          |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|
          +-------+-------+---------------------+---------------------+
              1       1              4                     4
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Timestamps option carries two four-byte timestamp fields. The TSval field contains the current value of the timestamp clock of the TCP sending the option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプオプションは、2つの4バイトのタイムスタンプフィールドを運びます。 TSvalフィールドには、オプションを送信するTCPのタイムスタンプクロックの現在の値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TSecr field is valid if the ACK bit is set in the TCP header. If the ACK bit is not set in the outgoing TCP header, the sender of that segment SHOULD set the TSecr field to zero. When the ACK bit is set in an outgoing segment, the sender MUST echo a recently received TSval sent by the remote TCP in the TSval field of a Timestamps option. The exact rules on which TSval MUST be echoed are given in Section 4.3. When the ACK bit is not set, the receiver MUST ignore the value of the TSecr field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACKビットはTCPヘッダーに設定されている場合TSecrフィールドが有効です。 ACKビットは、発信TCPヘッダーに設定されていない場合は、そのセグメントの送信者がゼロにTSecrフィールドを設定する必要があります。 ACKビットが送信セグメントに設定されている場合、送信者はタイムスタンプオプションのTSvalフィールドにリモートTCPにより送信された最近受信TSvalをエコーし​​なければなりません。 TSvalがエコーされなければならない上、正確な規則は、セクション4.3に記載されています。 ACKビットがセットされていない場合、受信機はTSecrフィールドの値を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A TCP MAY send the TSopt in an initial &lt;SYN&gt; segment (i.e., segment containing a SYN bit and no ACK bit), and MAY send a TSopt in &lt;SYN,ACK&gt; only if it received a TSopt in the initial &lt;SYN&gt; segment for the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPは、それが最初にTSoptを受信した場合にのみ、&lt;SYN&gt;初期&lt;SYN&gt;セグメント（すなわち、SYNビットを含むセグメントと無ACKビット）でTSoptを送信すること、及び&lt;SYN、ACK&gt;にTSoptを送信することができます接続用セグメント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once TSopt has been successfully negotiated, that is both &lt;SYN&gt; and &lt;SYN,ACK&gt; contain TSopt, the TSopt MUST be sent in every non-&lt;RST&gt; segment for the duration of the connection, and SHOULD be sent in an &lt;RST&gt; segment (see Section 5.2 for details). The TCP SHOULD remember this state by setting a flag, referred to as Snd.TS.OK, to one. If a non-&lt;RST&gt; segment is received without a TSopt, a TCP SHOULD silently drop the segment. A TCP MUST NOT abort a TCP connection because any segment lacks an expected TSopt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TSoptが正常にネゴシエートされた後、それは、両方の&lt;SYN&gt;及び&lt;SYN、ACK&gt;はTSoptを含む、TSoptは、接続の期間毎に非&lt;RST&gt;セグメントで送信されなければならない、そしてRST &lt;で送信されてください&gt;セグメント（詳細はセクション5.2を参照）。 TCPは1つに、Snd.TS.OKと呼ばれるフラグを設定することで、この状態を覚えておいてください。非&lt;RST&gt;セグメントTSoptなしで受信された場合、TCPは、サイレントセグメントを削除すべきです。任意のセグメントが期待TSoptがないため、TCPはTCP接続を中止してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations are strongly encouraged to follow the above rules for handling a missing Timestamps option and the order of precedence mentioned in Section 5.3 when deciding on the acceptance of a segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装は強く欠落しているタイムスタンプオプションとセグメントの受け入れを決定する際に、5.3節で述べた優先順位を処理するために上記のルールに従うことを奨励されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a receiver chooses to accept a segment without an expected Timestamps option, it must be clear that undetectable data corruption may occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機は、予想されるタイムスタンプオプションを使用せずにセグメントを受け入れることを選択した場合、検出不可能なデータの破損が発生することが明らかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Such a TCP receiver may experience undetectable wrapped-sequence effects, such as data (payload) corruption or session stalls. In order to maintain the integrity of the payload data, in particular on high-speed networks, it is paramount to follow the described processing rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのようなTCP受信機は、データ（ペイロード）破損やセッションストールとして検出不可能ラップ配列の効果を経験し得ます。ペイロードデータの整合性を維持するために、高速ネットワーク上の特定には、説明した処理ルールに従うことが最も重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, it has been mentioned that under some circumstances, the above guidelines are too strict, and some paths sporadically suppress the Timestamps option, while maintaining payload integrity. A path behaving in this manner should be deemed unacceptable, but it has been noted that some implementations relax the acceptance rules as a workaround and allow TCP to run across such paths [RE-1323BIS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、いくつかの状況下で、上記のガイドラインは、あまりにも厳格であり、ペイロードの整合性を維持しながら、いくつかの経路が散発的に、タイムスタンプオプションを抑制することが言及されています。このように行動経路は許容できないとみなされるべきであるが、いくつかの実装が回避策として受け入れルールを緩和し、TCPは、パス[RE-1323BIS]横切って実行することを可能にすることが注目されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a TSopt is received on a connection where TSopt was not negotiated in the initial three-way handshake, the TSopt MUST be ignored and the packet processed normally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TSoptがTSoptが最初の3ウェイハンドシェイクで交渉されていなかった接続で受信された場合、TSoptを無視しなければなりませんし、パケットが正常に処理されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of crossing &lt;SYN&gt; segments where one &lt;SYN&gt; contains a TSopt and the other doesn&#39;t, both sides MAY send a TSopt in the &lt;SYN,ACK&gt; segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 &lt;SYN&gt;はTSoptおよびその他を含んでいる&lt;SYN&gt;セグメントと交差する場合に、両側は、&lt;SYN、ACK&gt;セグメントにTSoptを送信することがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TSopt is required for the two mechanisms described in Sections 4 and 5. There are also other mechanisms that rely on the presence of the TSopt, e.g., [RFC3522]. If a TCP stopped sending TSopt at any time during an established session, it interferes with these mechanisms. This update to [RFC1323] describes explicitly the previous assumption (see Section 5.2) that each TCP segment must have a TSopt, once negotiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TSoptはTSoptの存在に依存する他のメカニズムが[RFC3522]、例えば、もあるセクション4及び5に記載の二つの機構のために必要とされます。 TCPは確立されたセッション中にいつでもTSoptの送信を停止した場合、それはこれらのメカニズムに干渉する。 [RFC1323]は、明示的に以前の仮定を説明するこのアップデートでは、各TCPセグメントがTSopt、一度に交渉を持たなければならないこと（5.2節を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. The RTTM Mechanism
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. RTTMメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。前書き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One use of the Timestamps option is to measure the round-trip time (RTT) of virtually every packet acknowledged. The RTTM mechanism requires a Timestamps option in every measured segment, with a TSval that is obtained from a (virtual) &#34;timestamp clock&#34;. Values of this clock MUST be at least approximately proportional to real time, in order to measure actual RTT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプオプションの用途の1つは、すべてのパケットが認めた事実上のラウンドトリップ時間（RTT）を測定することです。 RTTM機構は、（仮想）「タイムスタンプクロック」から得られTSvalで、すべての測定されたセグメントのタイムスタンプオプションを必要とします。このクロックの値は、実際のRTTを測定するために、リアルタイムに少なくともほぼ比例しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP measures the RTT, primarily for the purpose of arriving at a reasonable value for the RTO timer interval. Accurate and current RTT estimates are necessary to adapt to changing traffic conditions, while a conservative estimate of the RTO interval is necessary to minimize spurious RTOs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPは、主に、RTOタイマー間隔のための合理的な値に到達するために、RTTを測定します。 RTO間隔の控えめな見積もりは、スプリアスのRTOを最小限に抑えるために必要であるが、正確で現在RTT推定値は、交通状況の変化に適応するために必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These TSval values are echoed in TSecr values in the reverse direction. The difference between a received TSecr value and the current timestamp clock value provides an RTT measurement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのTSval値は逆方向にTSecr値にエコーされます。受信TSecr値と現在のタイムスタンプクロック値との差がRTT測定値を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When timestamps are used, every segment that is received will contain a TSecr value. However, these values cannot all be used to update the measured RTT. The following example illustrates why. It shows a one-way data flow with segments arriving in sequence without loss. Here A, B, C... represent data blocks occupying successive blocks of sequence numbers, and ACK(A),... represent the corresponding cumulative acknowledgments. The two timestamp fields of the Timestamps option are shown symbolically as &lt;TSval=x,TSecr=y&gt;. Each TSecr field contains the value most recently received in a TSval field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプが使用される場合、受信されたすべてのセグメントがTSecr値を含むであろう。しかし、これらの値は、すべての測定されたRTTを更新するために使用することはできません。次の例では、理由を示しています。これは、損失なしの順序で到着するセグメントを有する一方向のデータフローを示します。ここでA、B、C ...のシーケンス番号の連続したブロックを占有するデータブロックを表し、ACK（A）は、...対応する累積確認応答を表します。タイムスタンプオプションの2つのタイムスタンプフィールドは、&lt;TSval = X、TSecr = Y&gt;として象徴的に示されています。各TSecrフィールドは、最近TSvalフィールドに受信した値が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP A TCP B
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP A TCP B
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             &lt;A,TSval=1,TSecr=120&gt; -----&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  &lt;---- &lt;ACK(A),TSval=127,TSecr=1&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             &lt;B,TSval=5,TSecr=127&gt; -----&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  &lt;---- &lt;ACK(B),TSval=131,TSecr=5&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               . . . . . . . . . . . . . . . . . . . . . .
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             &lt;C,TSval=65,TSecr=131&gt; ----&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  &lt;---- &lt;ACK(C),TSval=191,TSecr=65&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(etc.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（等。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The dotted line marks a pause (60 time units long) in which A had nothing to send. Note that this pause inflates the RTT, which B could infer from receiving TSecr=131 in data segment C. Thus, in one-way data flows, RTTM in the reverse direction measures a value that is inflated by gaps in sending data. However, the following rule prevents a resulting inflation of the measured RTT:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
点線はAが送信するために何も持っていなかったした一時停止（60時間単位の長い）をマークします。このポーズは、Bは、一方向のデータフローでは、このようにデータ・セグメントCにTSecr = 131を受信することから推論できたRTTを、膨張することに注意し、RTTMは逆方向にデータを送信することでギャップによって膨張される値を測定します。ただし、以下のルールが測定されたRTTの結果としてインフレを防ぎます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTTM Rule: A TSecr value received in a segment MAY be used to update the averaged RTT measurement only if the segment advances the left edge of the send window, i.e., SND.UNA is increased.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTTMルール：セグメントで受信TSecr値は、セグメント、すなわち、SND.UNAを増加させる、送信ウィンドウの左端を進める場合にのみ、平均RTT測定値を更新するために使用され得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since TCP B is not sending data, the data segment C does not acknowledge any new data when it arrives at B. Thus, the inflated RTTM measurement is not used to update B&#39;s RTTM measurement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP Bがデータを送信していないので、それはこのようにBに到達したとき、データセグメントCは、任意の新たなデータを確認しない、膨張RTTM測定は、BのRTTM測定値を更新するために使用されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Updating the RTO Value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。 RTO値を更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When [RFC1323] was originally written, it was perceived that taking RTT measurements for each segment, and also during retransmissions, would contribute to reduce spurious RTOs, while maintaining the timeliness of necessary RTOs. At the time, RTO was also the only mechanism to make use of the measured RTT. It has been shown that taking more RTT samples has only a very limited effect to optimize RTOs [Allman99].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1323]が元々書き込まれたときには、各セグメントのRTTの測定を行うことが知覚された、また、再送時、必要のRTOの適時性を維持しながら、スプリアスのRTOを減少させるために貢献します。当時、RTOは、測定されたRTTを利用する唯一のメカニズムでもありました。より多くのRTTのサンプルを採取するのRTO [Allman99]を最適化するために非常に限られた効果を有することが示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementers should note that with timestamps, multiple RTTMs can be taken per RTT. The [RFC6298] RTT estimator has weighting factors, alpha and beta, based on an implicit assumption that at most one RTTM will be sampled per RTT. When multiple RTTMs per RTT are available to update the RTT estimator, an implementation SHOULD try to adhere to the spirit of the history specified in [RFC6298]. An implementation suggestion is detailed in Appendix G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装者は、タイムスタンプと、複数のRTTMsはRTTごとに撮影することができますことに注意してください。 [RFC6298] RTT推定器は、多くても1つのRTTMはRTTごとにサンプリングされるという暗黙の仮定に基づいて、重み係数、α及びβを有します。 RTTごとに複数のRTTMsはRTT推定を更新するために利用されている場合は、実装は、[RFC6298]で指定された歴史の精神を遵守してみてください。実装の提案は、付録Gに詳述されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ludwig00] and [Floyd05] have highlighted the problem that an unmodified RTO calculation, which is updated with per-packet RTT samples, will truncate the path history too soon. This can lead to an increase in spurious retransmissions, when the path properties vary in the order of a few RTTs, but a high number of RTT samples are taken on a much shorter timescale.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ludwig00]と[Floyd05]パケットごとのRTTサンプルで更新された未修正のRTO計算は、あまりにも早くパス履歴を切り捨てるという問題を強調しています。これは、パスのプロパティがいくつかのRTTのために、異なるスプリアス再送の増加につながることができますが、RTTサンプルの数が多いと、はるかに短い時間スケールで撮影されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Which Timestamp to Echo
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。これはタイムスタンプエコー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If more than one Timestamps option is received before a reply segment is sent, the TCP must choose only one of the TSvals to echo, ignoring the others. To minimize the state kept in the receiver (i.e., the number of unprocessed TSvals), the receiver should be required to retain at most one timestamp in the connection control block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
返信セグメントが送信される前に、複数のタイムスタンプオプションを受信した場合、TCPは、他の人を無視して、エコーTSvalsの一つだけを選択する必要があります。受信機に保持状態を最小限にするために（すなわち、未処理TSvalsの数）は、受信機は、接続制御ブロックに最も1つのタイムスタンプに保持するために必要とされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are three situations to consider:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
考慮すべき3つの状況があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(A) Delayed ACKs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（A）ACKを遅延。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Many TCPs acknowledge only every second segment out of a group
        of segments arriving within a short time interval; this policy
        is known generally as &#34;delayed ACKs&#34;.  The data-sender TCP must
        measure the effective RTT, including the additional time due to
        delayed ACKs, or else it will retransmit unnecessarily.  Thus,
        when delayed ACKs are in use, the receiver SHOULD reply with the
        TSval field from the earliest unacknowledged segment.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(B) A hole in the sequence space (segment(s) has been lost).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（B）配列空間の穴（セグメント（単数または複数）が失われています）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        The sender will continue sending until the window is filled, and
        the receiver may be generating &lt;ACK&gt;s as these out-of-order
        segments arrive (e.g., to aid &#34;Fast Retransmit&#34;).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The lost segment is probably a sign of congestion, and in that situation the sender should be conservative about retransmission. Furthermore, it is better to overestimate than underestimate the RTT. An &lt;ACK&gt; for an out-of-order segment SHOULD, therefore, contain the timestamp from the most recent segment that advanced RCV.NXT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
失われたセグメントは、おそらく輻輳の兆候であり、そのような状況で、送信者は、再送信について保守的でなければなりません。また、RTTを過小評価よりも過大評価することをお勧めします。 &lt;ACK&gt;アウト・オブ・オーダーセグメントのために、したがって、RCV.NXTを進めた最新のセグメントからのタイムスタンプを含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same situation occurs if segments are reordered by the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セグメントがネットワークによって並べ替えされている場合、同じような状況が発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(C) A filled hole in the sequence space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
配列空間における（C）A充填穴。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        The segment that fills the hole and advances the window
        represents the most recent measurement of the network
        characteristics.  An RTT computed from an earlier segment would
        probably include the sender&#39;s retransmit timeout, badly biasing
        the sender&#39;s average RTT estimate.  Thus, the timestamp from the
        latest segment (which filled the hole) MUST be echoed.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An algorithm that covers all three cases is described in the following rules for Timestamps option processing on a synchronized connection:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての3つのケースをカバーするアルゴリズムは、同期接続でのタイムスタンプオプションの処理のために、以下の規則に記述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) The connection state is augmented with two 32-bit slots:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）接続状態が2つの32ビットスロットで拡張されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        TS.Recent holds a timestamp to be echoed in TSecr whenever a
        segment is sent, and Last.ACK.sent holds the ACK field from the
        last segment sent.  Last.ACK.sent will equal RCV.NXT except when
        &lt;ACK&gt;s have been delayed.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) If:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）の場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.TSval &gt;= TS.Recent and SEG.SEQ &lt;= Last.ACK.sent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.TSval&gt; = TS.RecentとSEG.SEQ &lt;= Last.ACK.sent
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
then SEG.TSval is copied to TS.Recent; otherwise, it is ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その後、SEG.TSvalはTS.Recentにコピーされます。それ以外の場合は無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) When a TSopt is sent, its TSecr field is set to the current TS.Recent value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TSoptが送信されると（3）、そのTSecrフィールドが現在TS.Recent値に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following examples illustrate these rules. Here A, B, C... represent data segments occupying successive blocks of sequence numbers, and ACK(A),... represent the corresponding acknowledgment segments. Note that ACK(A) has the same sequence number as B. We show only one direction of timestamp echoing, for clarity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例では、これらのルールを説明します。ここでA、B、C ...のシーケンス番号の連続したブロックを占有するデータ・セグメントを表し、ACK（A）は、...対応する肯定応答セグメントを表します。 ACK（A）は、我々は明確にするために、エコータイムスタンプの一方向のみを示しBと同じシーケンス番号を有することに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Segments arrive in sequence, and some of the &lt;ACK&gt;s are delayed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oセグメントが順次到着し、&lt;ACK&gt; Sの一部が遅延されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By case (A), the timestamp from the oldest unacknowledged segment is echoed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（A）によって、最も古い不承認のセグメントからのタイムスタンプをエコーし​​ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                  TS.Recent
                &lt;A, TSval=1&gt; -------------------&gt;
                                                      1
                &lt;B, TSval=2&gt; -------------------&gt;
                                                      1
                &lt;C, TSval=3&gt; -------------------&gt;
                                                      1
                         &lt;---- &lt;ACK(C), TSecr=1&gt;
                (etc.)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Segments arrive out of order, and every segment is acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oセグメントは、順不同で到着し、すべてのセグメントが認められています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
By case (B), the timestamp from the last segment that advanced the left window edge is echoed until the missing segment arrives; it is echoed according to case (C). The same sequence would occur if segments B and D were lost and retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（B）によって、欠落セグメントが到着するまで左ウィンドウエッジがエコーされて前進最後のセグメントからのタイムスタンプ。それはケース（C）に係るエコーれます。セグメントB及びDは、失われたと再送信された場合、同じシーケンスが起こります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                  TS.Recent
                &lt;A, TSval=1&gt; -------------------&gt;
                                                      1
                         &lt;---- &lt;ACK(A), TSecr=1&gt;
                                                      1
                &lt;C, TSval=3&gt; -------------------&gt;
                                                      1
                         &lt;---- &lt;ACK(A), TSecr=1&gt;
                                                      1
                &lt;B, TSval=2&gt; -------------------&gt;
                                                      2
                         &lt;---- &lt;ACK(C), TSecr=2&gt;
                                                      2
                &lt;E, TSval=5&gt; -------------------&gt;
                                                      2
                         &lt;---- &lt;ACK(C), TSecr=2&gt;
                                                      2
                &lt;D, TSval=4&gt; -------------------&gt;
                                                      4
                         &lt;---- &lt;ACK(E), TSecr=4&gt;
                (etc.)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. PAWS - Protection Against Wrapped Sequences
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. PAWS  - に対する保護ラップシーケンス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。前書き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another use for the Timestamps option is the PAWS mechanism. Section 5.2 describes a simple mechanism to reject old duplicate segments that might corrupt an open TCP connection. PAWS operates within a single TCP connection, using state that is saved in the connection control block. Section 5.8 and Appendix H discuss the implications of the PAWS mechanism for avoiding old duplicates from previous incarnations of the same connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプオプションの別の使用は、PAWSメカニズムです。 5.2節ではその可能性があります破損しているオープンTCPコネクション古い重複セグメントを拒否するための簡単なメカニズムについて説明します。 PAWSは、接続制御ブロックに保存された状態を使用して、単一のTCP接続内で動作します。セクション5.8および付録Hは、同じ接続の以前の肉体化からの古い重複を避けるためPAWSメカニズムの影響を議論します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. The PAWS Mechanism
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。 PAWSメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWS uses the TCP Timestamps option described earlier and assumes that every received TCP segment (including data and &lt;ACK&gt; segments) contains a timestamp SEG.TSval whose values are monotonically non-decreasing in time. The basic idea is that a segment can be discarded as an old duplicate if it is received with a timestamp SEG.TSval less than some timestamps recently received on this connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWSは、前述のTCPタイムスタンプオプションを使用し、すべてが（データおよび&lt;ACK&gt;セグメントを含む）、TCPセグメントを受信したと仮定し、その値が時間的に単調非減少であるタイムスタンプSEG.TSvalを含んでいます。基本的な考え方は、それが最近、この接続で受信されたいくつかのタイムスタンプより小さいタイムスタンプSEG.TSvalで受信された場合、セグメントが古い重複として廃棄することができるということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the PAWS mechanism, the &#34;timestamps&#34; are 32-bit unsigned integers in a modular 32-bit space. Thus, &#34;less than&#34; is defined the same way it is for TCP sequence numbers, and the same implementation techniques apply. If s and t are timestamp values,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWS機構において、「タイムスタンプ」とは、モジュラー32ビット空間で32ビットの符号なし整数です。このように、「未満」とは、TCPシーケンス番号のためであるのと同じ方法で定義されており、同じ実装技術が適用されます。 sおよびtは、タイムスタンプ値がある場合は、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
s &lt; t if 0 &lt; (t - s) &lt; 2^31,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;2 ^ 31、 -  S &lt;T &lt;（S t）が0の場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
computed in unsigned 32-bit arithmetic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
符号なし32ビット演算で計算。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The choice of incoming timestamps to be saved for this comparison MUST guarantee a value that is monotonically non-decreasing. For example, an implementation might save the timestamp from the segment that last advanced the left edge of the receive window, i.e., the most recent in-sequence segment. For simplicity, the value TS.Recent introduced in Section 4.3 is used instead, as using a common value for both PAWS and RTTM simplifies the implementation. As Section 4.3 explained, TS.Recent differs from the timestamp from the last in-sequence segment only in the case of delayed &lt;ACK&gt;s, and therefore by less than one window. Either choice will, therefore, protect against sequence number wrap-around.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この比較のために保存する、着信タイムスタンプの選択は単調非減少されている値を保証しなければなりません。例えば、実装は、最後の受信ウィンドウ、即ち、最も最近に配列セグメントの左端を前進セグメントからのタイムスタンプを保存するかもしれません。簡単にするために、4.3節で導入値TS.RecentはPAWSとRTTM実装を簡素化の両方のための共通の値を使用するなど、代わりに使用されます。セクション4.3で説明したように、TS.Recentのみ&lt;ACK&gt; S、したがって未満のウィンドウだけ遅延した場合に最後に、配列セグメントからのタイムスタンプとは異なります。どちらの選択は、そのため、シーケンス番号のラップアラウンドに対する保護します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWS submits all incoming segments to the same test, and therefore protects against duplicate &lt;ACK&gt; segments as well as data segments. (An alternative non-symmetric algorithm would protect against old duplicate &lt;ACK&gt;s: the sender of data would reject incoming &lt;ACK&gt; segments whose TSecr values were less than the TSecr saved from the last segment whose ACK field advanced the left edge of the send window. This algorithm was deemed to lack economy of mechanism and symmetry.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWSは同じ試験にすべての受信セグメントを送信し、したがって重複&lt;ACK&gt;セグメントとデータ・セグメントから保護します。 （代替の非対称アルゴリズムは、古い重複に対して保護する&lt;ACK&gt; S：データの送信者は、そのTSecr値TSecrは、そのACKフィールドの左端を前進最後のセグメントから保存されたよりも低かった着信&lt;ACK&gt;セグメントを拒否するウィンドウを送信する。このアルゴリズムは、メカニズムと対称性の経済を欠いていると考えられました。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TSval timestamps sent on &lt;SYN&gt; and &lt;SYN,ACK&gt; segments are used to initialize PAWS. PAWS protects against old duplicate non-&lt;SYN&gt; segments and duplicate &lt;SYN&gt; segments received while there is a synchronized connection. Duplicate &lt;SYN&gt; and &lt;SYN,ACK&gt; segments received when there is no connection will be discarded by the normal 3-way handshake and sequence number checks of TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上で送信TSvalタイムスタンプ&lt;SYN&gt;及び&lt;SYN、ACK&gt;セグメントはPAWSを初期化するために使用されます。 PAWSは、古い重複に対して非&lt;SYN&gt;セグメントを保護し、同期接続があるが重複&lt;SYN&gt;セグメントが受信されました。 &lt;SYN&gt;及び&lt;SYN、ACK&gt;セグメント重複しない接続は、TCPの通常の3ウェイハンドシェイクおよびシーケンス番号チェックにより存在破棄されませんされたときに受信しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1323] recommended that &lt;RST&gt; segments NOT carry timestamps and that they be acceptable regardless of their timestamp. At that time, the thinking was that old duplicate &lt;RST&gt; segments should be exceedingly unlikely, and their cleanup function should take precedence over timestamps. More recently, discussions about various blind attacks on TCP connections have raised the suggestion that if the Timestamps option is present, SEG.TSecr could be used to provide stricter acceptance tests for &lt;RST&gt; segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1323]は&lt;RST&gt;セグメントがタイムスタンプを運ばないことを、彼らは関係なく、タイムスタンプの許容されることをお勧め。当時、考え方は古い重複&lt;RST&gt;セグメントは非常にそうであるべきであり、彼らのクリーンアップ機能は、タイムスタンプよりも優先すべきであるということでした。さらに最近では、TCPコネクション上の様々な盲目の攻撃に関する議論はタイムスタンプオプションが存在する場合、SEG.TSecrは&lt;RST&gt;セグメントのための厳格な受け入れテストを提供するために使用することができることを示唆し調達しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While still under discussion, to enable research into this area it is now RECOMMENDED that when generating an &lt;RST&gt;, if the segment causing the &lt;RST&gt; to be generated contains a Timestamps option, the &lt;RST&gt; should also contain a Timestamps option. In the &lt;RST&gt; segment, SEG.TSecr SHOULD be set to SEG.TSval from the incoming segment and SEG.TSval SHOULD be set to zero. If an &lt;RST&gt; is being generated because of a user abort, and Snd.TS.OK is set, then a Timestamps option SHOULD be included in the &lt;RST&gt;. When an &lt;RST&gt; segment is received, it MUST NOT be subjected to the PAWS check by verifying an acceptable value in SEG.TSval, and information from the Timestamps option MUST NOT be used to update connection state information. SEG.TSecr MAY be used to provide stricter &lt;RST&gt; acceptance checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まだ議論の下で、この分野の研究を可能にする一方で、今の生成時に、&lt;RST&gt;生成させるセグメントがタイムスタンプオプションが含まれている場合は、&lt;RST&gt;、、&lt;RST&gt;また、タイムスタンプオプションを含めることをお勧めします。 &lt;RST&gt;セグメントにおいて、SEG.TSecr着信セグメントからSEG.TSvalに設定されるべきであり、SEG.TSvalはゼロに設定されるべきです。 &lt;RST&gt;ので、ユーザアボートの生成され、そしてSnd.TS.OKが設定されている場合、タイムスタンプオプションが&lt;RST&gt;に含まれるべきです。 &lt;RST&gt;セグメントが受信されると、それはSEG.TSvalで許容値を検証することによってPAWSチェックに供してはいけません、およびタイムスタンプオプションからの情報は、接続状態情報を更新するために使用してはいけません。 SEG.TSecrは厳しい&lt;RST&gt;受入検査を提供するために用いることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Basic PAWS Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。基本PAWSアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the PAWS algorithm is used, the following processing MUST be performed on all incoming segments for a synchronized connection. Also, PAWS processing MUST take precedence over the regular TCP acceptability check (Section 3.3 in [RFC0793]), which is performed after verification of the received Timestamps option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWSアルゴリズムが使用される場合、以下の処理が同期接続のためにすべての着信セグメント上で実行されなければなりません。また、PAWS処理は、受信タイムスタンプ・オプションの検証後に行われる定期的なTCPの良否検査（[RFC0793]セクション3.3）、優先しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
R1) If there is a Timestamps option in the arriving segment, SEG.TSval &lt; TS.Recent, TS.Recent is valid (see later discussion), and if the RST bit is not set, then treat the arriving segment as not acceptable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
到着セグメントのタイムスタンプオプションがある場合は、SEG.TSval &lt;TS.Recentは、TS.Recent（）は、後で説明を参照してください、とRSTビットが設定されていない場合は、受け入れられないとして到着したセグメントを扱う有効であるR1）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           Send an acknowledgment in reply as specified in Section 3.9
           of [RFC0793], page 69, and drop the segment.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: it is necessary to send an &lt;ACK&gt; segment in order to retain TCP&#39;s mechanisms for detecting and recovering from half-open connections. For an example, see Figure 10 of [RFC0793].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注意：検出して、ハーフオープン接続から回復するためのTCPのメカニズムを保持するために、&lt;ACK&gt;セグメントを送信する必要があります。例えば、[RFC0793]の図10を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
R2) If the segment is outside the window, reject it (normal TCP processing).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
R2）は、セグメントが窓の外にある場合、）（通常のTCP処理を、それを拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
R3) If an arriving segment satisfies SEG.TSval &gt;= TS.Recent and SEG.SEQ &lt;= Last.ACK.sent (see Section 4.3), then record its timestamp in TS.Recent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
R3）到着セグメント満たすSEG.TSval&gt; = TS.RecentとSEG.SEQ &lt;= Last.ACK.sent場合（4.3節を参照）、次いでTS.Recentにタイムスタンプを記録します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
R4) If an arriving segment is in sequence (i.e., at the left window edge), then accept it normally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
到着セグメント（すなわち、）左ウィンドウエッジでシーケンスである場合R4）は、次いで、通常はそれを受け入れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
R5) Otherwise, treat the segment as a normal in-window, out-of-sequence TCP segment (e.g., queue it for later delivery to the user).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
R5）そうでなければ、正常にウィンドウ、アウトオブシーケンスTCPセグメント（例えば、ユーザへの後の送達のためにそれをキュー）としてセグメントを扱います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Steps R2, R4, and R5 are the normal TCP processing steps specified by [RFC0793].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ステップR2、R4、及びR5は、[RFC0793]で指定された通常のTCP処理ステップです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is important to note that the timestamp MUST be checked only when a segment first arrives at the receiver, regardless of whether it is in sequence or it must be queued for later delivery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セグメントが最初にかかわらず、それが配列であるか、それは後で配信のためにキューイングされなければならないかどうかの、受信機に到達した場合にのみ、タイムスタンプをチェックしなければなりませんことに注意することが重要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例を考えてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose the segment sequence: A.1, B.1, C.1, ..., Z.1 has been sent, where the letter indicates the sequence number and the digit represents the timestamp. Suppose also that segment B.1 has been lost. The timestamp in TS.Recent is 1 (from A.1), so C.1, ..., Z.1 are considered acceptable and are queued. When B is retransmitted as segment B.2 (using the latest timestamp), it fills the hole and causes all the segments through Z to be acknowledged and passed to the user. The timestamps of the queued segments are *not* inspected again at this time, since they have already been accepted. When B.2 is accepted, TS.Recent is set to 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セグメントのシーケンスとします文字は、シーケンス番号と桁はタイムスタンプを表し示し、A.1、B.1、C.1を...、Z.1は、送信されています。セグメントB.1が失われたこともあるとします。 TS.Recentのタイムスタンプは、（A.1）1、C.1ので、...、Z.1許容されると考えられるし、キューイングされています。 Bが（最新のタイムスタンプを使用して）セグメントB.2として再送される場合には、穴を充填してユーザに確認され、渡されるZを介してすべてのセグメントを引き起こします。彼らはすでに承認されているので、キューイングされたセグメントのタイムスタンプは*、この時点で再度検査されていません。 B.2が受け入れられると、TS.Recentは2に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This rule allows reasonable performance under loss. A full window of data is in transit at all times, and after a loss a full window less one segment will show up out of sequence to be queued at the receiver (e.g., up to ~2^30 bytes of data); the Timestamps option must not result in discarding this data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この規則は、損失の下で合理的なパフォーマンスを可能にします。データの完全なウィンドウは常にトランジットであり、損失の後に完全なウィンドウ以下つのセグメントは、（例えば、データの〜2 ^ 30バイトまで）受信機でキューイングされるべき配列のうちの表示されます。タイムスタンプオプションは、このデータを破棄するにはなりませしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In certain unlikely circumstances, the algorithm of rules R1-R5 could lead to discarding some segments unnecessarily, as shown in the following example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例に示すように、一定の低い状況では、ルールR1-R5のアルゴリズムは、不必要にいくつかのセグメントを廃棄につながります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose again that segments: A.1, B.1, C.1, ..., Z.1 have been sent in sequence and that segment B.1 has been lost. Furthermore, suppose delivery of some of C.1, ... Z.1 is delayed until *after* the retransmission B.2 arrives at the receiver. These delayed segments will be discarded unnecessarily when they do arrive, since their timestamps are now out of date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1、B.1、C.1、...、Z.1シーケンスで送信されてきたし、そのセグメントB.1が失われた：セグメントがあることを再びとします。さらに、C.1のいくつかの仮定する配信は、... Z.1は再送B.2が受信機に到着* *後まで延期されます。彼らが到着しないとき、そのタイムスタンプが古くなりましたので、これらの遅れのセグメントは、不必要に破棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This case is very unlikely to occur. If the retransmission was triggered by a timeout, some of the segments C.1, ... Z.1 must have been delayed longer than the RTO time. This is presumably an unlikely event, or there would be many spurious timeouts and retransmissions. If B&#39;s retransmission was triggered by the &#34;Fast Retransmit&#34; algorithm, i.e., by duplicate &lt;ACK&gt;s, then the queued segments that caused these &lt;ACK&gt;s must have been received already.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このケースが発生するのは非常に低いです。再送がタイムアウトによってトリガーされた場合は、セグメントC.1の一部は、... Z.1は長いRTO時間よりも遅れている必要があります。これはおそらく、万が一の場合、または多くの偽のタイムアウトおよび再送信が存在することになります。 Bの再送が「高速再送信」アルゴリズム、すなわちによってトリガされた場合は、重複した&lt;ACK&gt; Sにより、これらの&lt;ACK&gt;の原因とキューに入れられたセグメントが既に受信されている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Even if a segment were delayed past the RTO, the Fast Retransmit mechanism [Jacobson90c] will cause the delayed segments to be retransmitted at the same time as B.2, avoiding an extra RTT and, therefore, causing a very small performance penalty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セグメントはRTOを越えて遅延した場合でも、高速再送信機構は、[Jacobson90c】遅延セグメントは、非常に小さなパフォーマンスの低下を引き起こし、従って、余分なRTTを回避し、B.2と同時に再送信することになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We know of no case with a significant probability of occurrence in which timestamps will cause performance degradation by unnecessarily discarding segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、タイムスタンプが不必要にセグメントを破棄することにより、パフォーマンスの低下の原因となるで発生重要な確率で、いかなる場合を知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Timestamp Clock
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。タイムスタンプ時計
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is important to understand that the PAWS algorithm does not require clock synchronization between the sender and receiver. The sender&#39;s timestamp clock is used as a source of monotonic non-decreasing values to stamp the segments. The receiver treats the timestamp value as simply a monotonically non-decreasing serial number, without any connection to time. From the receiver&#39;s viewpoint, the timestamp is acting as a logical extension of the high-order bits of the sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWSアルゴリズムは、送信者と受信者の間のクロック同期を必要としないことを理解することが重要です。送信者のタイムスタンプクロックは、セグメントをスタンプする単調非減少の値のソースとして使用されます。受信機は、時間への接続なしで、単に単調非減少シリアル番号としてタイムスタンプ値を処理します。受信機の観点から、タイムスタンプ、シーケンス番号の上位ビットの論理的な拡張として機能しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The receiver algorithm does place some requirements on the frequency of the timestamp clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機アルゴリズムは、タイムスタンプクロックの周波数にいくつかの要件を置くありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(a) The timestamp clock must not be &#34;too slow&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（a）は、タイムスタンプのクロックは「遅すぎる」であってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        It MUST tick at least once for each 2^31 bytes sent.  In fact,
        in order to be useful to the sender for round-trip timing, the
        clock SHOULD tick at least once per window&#39;s worth of data, and
        even with the window extension defined in Section 2.2, 2^31
        bytes must be at least two windows.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To make this more quantitative, any clock faster than 1 tick/sec will reject old duplicate segments for link speeds of ~8 Gbps. A 1 ms timestamp clock will work at link speeds up to 8 Tbps (8*10^12) bps!
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、より定量的にするために、1チック/秒より速い任意のクロックは〜8 Gbpsののリンク速度の古い重複セグメントを拒否します。リンクで動作する1ミリ秒のタイムスタンプクロックは8 Tbpsの（8 * 10 ^ 12）bpsにスピードアップ！
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) The timestamp clock must not be &#34;too fast&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）は、タイムスタンプのクロックは、「速すぎる」であってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        The recycling time of the timestamp clock MUST be greater than
        MSL seconds.  Since the clock (timestamp) is 32 bits and the
        worst-case MSL is 255 seconds, the maximum acceptable clock
        frequency is one tick every 59 ns.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, it is desirable to establish a much longer recycle period, in order to handle outdated timestamps on idle connections (see Section 5.5), and to relax the MSL requirement for preventing sequence number wrap-around. With a 1 ms timestamp clock, the 32-bit timestamp will wrap its sign bit in 24.8 days. Thus, it will reject old duplicates on the same connection if MSL is 24.8 days or less. This appears to be a very safe figure; an MSL of 24.8 days or longer can probably be assumed in the Internet without requiring precise MSL enforcement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、アイドル状態の接続（5.5節を参照）に時代遅れのタイムスタンプを処理するために、はるかに長い再利用期間を確立すること、およびラップアラウンドシーケンス番号を防ぐためのMSLの要件を緩和することが望ましいです。 1ミリ秒のタイムスタンプクロックで、32ビットのタイムスタンプは24.8日でその符号ビットをラップします。 MSLは24.8日以下であればこのように、それは同じ接続で古い写しを拒否します。これは非常に安全な数字であるように思われます。 24.8日以上のMSLは、おそらく正確なMSLの施行を必要とせずにインターネットで想定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Based upon these considerations, we choose a timestamp clock frequency in the range 1 ms to 1 sec per tick. This range also matches the requirements of the RTTM mechanism, which does not need much more resolution than the granularity of the retransmit timer, e.g., tens or hundreds of milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの考察に基づいて、我々は、ダニあたり1秒の範囲で1ミリ秒のタイムスタンプのクロック周波数を選択します。この範囲はまた、再送信タイマーの細かさよりもはるかに解像度を必要としないRTTMメカニズムの要件を、一致して、例えば、数十または数百ミリ秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PAWS mechanism also puts a strong monotonicity requirement on the sender&#39;s timestamp clock. The method of implementation of the timestamp clock to meet this requirement depends upon the system hardware and software.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWSメカニズムはまた、送信者のタイムスタンプ時計に強い単調性要件を置きます。この要件を満たすためにタイムスタンプクロックの実装方法は、システムのハードウェアとソフトウェアに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o Some hosts have a hardware clock that is guaranteed to be monotonic between hardware resets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
O一部のホストは、ハードウェアのリセットの間で単調であることが保証されているハードウェアクロックを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A clock interrupt may be used to simply increment a binary integer by 1 periodically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oクロック割り込みが単に定期1進整数をインクリメントするために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o The timestamp clock may be derived from a system clock that is subject to being abruptly changed by adding a variable offset value. This offset is initialized to zero. When a new timestamp clock value is needed, the offset can be adjusted as necessary to make the new value equal to or larger than the previous value (which was saved for this purpose).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oタイムスタンプクロックが急激に可変のオフセット値を加算することによって変更される対象であるシステムクロックから導出することができます。このオフセットはゼロに初期化されます。新しいタイムスタンプクロック値が必要とされる場合、オフセットに等しいか（この目的のために保存した）前の値よりも大きい新しい値を作るために必要に応じて調整することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
o A random offset may be added to the timestamp clock on a per-connection basis. See [RFC6528], Section 3, on randomizing the initial sequence number (ISN). The same function with a different secret key can be used to generate the per-connection timestamp offset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Oランダムは、接続ごとにタイムスタンプクロックに添加することができるオフセット。初期シーケンス番号（ISN）をランダムに、[RFC6528]、セクション3を参照。異なる秘密鍵で同じ機能は、オフセット、接続ごとのタイムスタンプを生成するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Outdated Timestamps
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。古いタイムスタンプ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a connection remains idle long enough for the timestamp clock of the other TCP to wrap its sign bit, then the value saved in TS.Recent will become too old; as a result, the PAWS mechanism will cause all subsequent segments to be rejected, freezing the connection (until the timestamp clock wraps its sign bit again).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続はその符号ビットをラップするために他のTCPのタイムスタンプクロックのために十分に長いアイドル状態のままであれば、TS.Recentに保存された値があまりにも古いとなります。結果として、PAWSメカニズムは、接続を（タイムスタンプクロックが再びその符号ビットをラップするまで）凍結、後続のすべてのセグメントが拒否されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the chosen range of timestamp clock frequencies (1 sec to 1 ms), the time to wrap the sign bit will be between 24.8 days and 24800 days. A TCP connection that is idle for more than 24 days and then comes to life is exceedingly unusual. However, it is undesirable in principle to place any limitation on TCP connection lifetimes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプクロック周波数（1ミリ秒〜1秒）の選択された範囲で、符号ビットをラップする時間が24.8日24800日の間であろう。以上24日間アイドル状態で、その後の人生に来るTCP接続は非常に珍しいです。しかし、それはTCPコネクションの寿命に何らかの制限を配置するために、原則的には望ましくありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We therefore require that an implementation of PAWS include a mechanism to &#34;invalidate&#34; the TS.Recent value when a connection is idle for more than 24 days. (An alternative solution to the problem of outdated timestamps would be to send keep-alive segments at a very low rate, but still more often than the wrap-around time for timestamps, e.g., once a day. This would impose negligible overhead. However, the TCP specification has never included keep-alives, so the solution based upon invalidation was chosen.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって、我々は、PAWSの実装は接続が24以上の日のためにアイドル状態のときTS.Recent値を「無効」にする機構を備えている必要があります。 （時代遅れのタイムスタンプの問題に対する別の解決策は、非常に低いレートでキープアライブのセグメントを送ることであろうが、それでも多くの場合例えば、タイムスタンプ、用ラップアラウンド時間よりも、一日一回。これは無視できるオーバーヘッドを課す。しかし、 、TCP仕様はキープアライブを、無効化に基づくソリューションを選択したので、含まれていませんでした。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that a TCP does not know the frequency, and therefore the wrap-around time, of the other TCP, so it must assume the worst. The validity of TS.Recent needs to be checked only if the basic PAWS timestamp check fails, i.e., only if SEG.TSval &lt; TS.Recent. If TS.Recent is found to be invalid, then the segment is accepted, regardless of the failure of the timestamp check, and rule R3 updates TS.Recent with the TSval from the new segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPは、周波数を知らないことに注意してくださいので、ラップアラウンドタイム、他のTCPの、それは最悪の事態を想定する必要があります。 TS.Recentの妥当性は、唯一SEG.TSval &lt;TS.Recent場合、すなわち、基本的なPAWSのタイムスタンプチェックが失敗した場合にのみチェックする必要があります。 TS.Recentが無効であることが判明した場合、そのセグメントに関係なく、タイムスタンプチェックの失敗の、受け入れ、そして新しいセグメントからTSvalとR3アップデートTS.Recentを支配されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To detect how long the connection has been idle, the TCP MAY update a clock or timestamp value associated with the connection whenever TS.Recent is updated, for example. The details will be implementation dependent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TS.Recentが更新されるたびに、接続がアイドル状態になっている時間の長さを検出するために、TCPは、例えば、接続に関連したクロックやタイムスタンプ値を更新することができます。詳細は、実装依存することになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6. Header Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.6。ヘッダー予測
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;Header prediction&#34; [Jacobson90a] is a high-performance transport protocol implementation technique that is most important for high-speed links. This technique optimizes the code for the most common case, receiving a segment correctly and in order. Using header prediction, the receiver asks the question, &#34;Is this segment the next in sequence?&#34; This question can be answered in fewer machine instructions than the question, &#34;Is this segment within the window?&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ヘッダ予測は、」[Jacobson90a]高速リンクのために最も重要である高性能なトランスポートプロトコルの実装技術です。この技術は、正しく順序でセグメントを受信し、最も一般的なケースのためのコードを最適化します。ヘッダー予測を使用して、受信機は質問を、「このセグメントは、シーケンス内の次のですか？」この質問は、「ウィンドウ内のこのセグメントはありますか？」、質問よりも少ない機械語命令に答えることができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Adding header prediction to our timestamp procedure leads to the following recommended sequence for processing an arriving TCP segment:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちのタイムスタンププロシージャにヘッダー予測を追加すると、到着したTCPセグメントを処理するために、次の推奨手順につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
H1) Check timestamp (same as step R1 above).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記ステップR1と同じH1）空タイムスタンプ（）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
H2) Do header prediction: if the segment is next in sequence and if there are no special conditions requiring additional processing, accept the segment, record its timestamp, and skip H3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
H2）ヘッダ予測を行います。セグメントはシーケンス内の次であれば追加の処理を必要とする特別な条件がない場合、セグメントを受け入れて、そのタイムスタンプを記録し、及びH3をスキップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
H3) Process the segment normally, as specified in RFC 793. This includes dropping segments that are outside the window and possibly sending acknowledgments, and queuing in-window, out-of-sequence segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
H3）は、RFC 793で指定されるように、通常、セグメントを処理し、このウィンドウ外にあるセグメントをドロップし、おそらくは、肯定応答を送信し、そしてインキューイングウィンドウ外の配列セグメントを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Another possibility would be to interchange steps H1 and H2, i.e., to perform the header prediction step H2 *first*, and perform H1 and H3 only when header prediction fails. This could be a performance improvement, since the timestamp check in step H1 is very unlikely to fail, and it requires unsigned modulo arithmetic. To perform this check on every single segment is contrary to the philosophy of header prediction. We believe that this change might produce a measurable reduction in CPU time for TCP protocol processing on high-speed networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
別の可能性は、最初*ヘッダ予測ステップH2を実行するために、即ちステップH1及びH2を、交換、及びヘッダ予測が失敗した場合にのみ、H1とH3を実行することであろう。ステップH1でのタイムスタンプのチェックが失敗するのは非常にそうです、そして、それは符号なしのモジュロ演算を必要とするので、これは、パフォーマンスの向上である可能性があります。すべての単一のセグメントでこのチェックを実行すると、ヘッダ予測の哲学とは対照的です。私たちは、この変更は、高速ネットワーク上のTCPプロトコル処理のためのCPU時間の測定可能な減少をもたらす可能性があると信じています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, putting H2 first would create a hazard: a segment from 2^32 bytes in the past might arrive at exactly the wrong time and be accepted mistakenly by the header-prediction step. The following reasoning has been introduced in [RFC1185] to show that the probability of this failure is negligible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、パッティングH2は、第危険を作成します。過去に2 ^ 32バイトのセグメントが正確に間違った時刻に到着する可能性があり、ヘッダ予測ステップによって誤って受け入れられます。次の理由は、この失敗の確率が無視できることを示すために、[RFC1185]に導入されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If all segments are equally likely to show up as old duplicates, then the probability of an old duplicate exactly matching the left window edge is the maximum segment size (MSS) divided by the size of the sequence space. This ratio must be less than 2^-16, since MSS must be &lt; 2^16; for example, it will be (2^12)/(2^32) = 2^-20 for [a 100 Mbit/s] link. However, the older a segment is, the less likely it is to be retained in the Internet, and under any reasonable model of segment lifetime the probability of an old duplicate exactly at the left window edge must be much smaller than 2^-16.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのセグメントが同じくらい古い重複を表示することも同様に可能性がある場合、正確左ウィンドウエッジをマッチング古い重複の確率は、配列空間のサイズで割った最大セグメントサイズ（MSS）です。 MSSは&lt;^ 16 2でなければならないので、この比率は、2 ^ -16未満でなければなりません。例えば、それは、（2 ^ 12）/（2 ^ 32）= 100メガビット/ s]のリンクのための2 ^ -20となります。しかし、古いセグメントは、可能性が低いことは、インターネット内に保持されるようになっている、セグメント生涯のいずれかの合理的なモデルで正確に左のウィンドウの端にある古い重複の確率は2 ^ -16よりもはるかに小さくなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 16 bit TCP checksum also allows a basic unreliability of one part in 2^16. A protocol mechanism whose reliability exceeds the reliability of the TCP checksum should be considered &#34;good enough&#34;, i.e., it won&#39;t contribute significantly to the overall error rate. We therefore believe we can ignore the problem of an old duplicate being accepted by doing header prediction before checking the timestamp. [Note: the notation for exponentiation has been changed from how it appeared in RFC 1185.]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
16ビットのTCPチェックサムも2 ^ 16分の1の基本的な信頼性の欠如することができます。その信頼性TCPチェックサムの信頼性を超えたプロトコルメカニズムは、すなわち、それは全体の誤差率に大きく貢献していないだろう、「十分に良い」と考えるべきです。そこで我々は、我々は、タイムスタンプをチェックする前に、ヘッダー予測を行うことによって受け入れられている古い重複の問題を無視することができると信じています。 [注：べき乗のための表記法は、それがRFC 1185に現れ方法から変更されています]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, this probabilistic argument is not universally accepted, and the consensus at present is that the performance gain does not justify the hazard in the general case. It is therefore recommended that H2 follow H1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、この確率論引数が普遍的に受け入れていない、そして現在のコンセンサスは、パフォーマンスの向上は、一般的なケースでは危険を正当化しないということです。したがって、H2はH1に従うことをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7. IP Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.7。 IPフラグメンテーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
At high data rates, the protection against old segments provided by PAWS can be circumvented by errors in IP fragment reassembly (see [RFC4963]). The only way to protect against incorrect IP fragment reassembly is to not allow the segments to be fragmented. This is done by setting the Don&#39;t Fragment (DF) bit in the IP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
高いデータレートでは、PAWSが提供する古いセグメントに対する保護は、（[RFC4963]を参照）IPフラグメント再構成中にエラーが発生することによって回避することができます。間違ったIPフラグメント再構成から保護する唯一の方法は、セグメントを細分化することを許可しないことです。これは、IPヘッダにDo not Fragment（DF）ビットを設定することによって行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Setting the DF bit implies the use of Path MTU Discovery as described in [RFC1191], [RFC1981], and [RFC4821]; thus, any TCP implementation that implements PAWS MUST also implement Path MTU Discovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1191]、[RFC1981]及び[RFC4821]に記載されているようにDFビットを設定すると、パスMTU探索の使用を意味します。したがって、PAWSを実装する任意のTCPの実装はまた、パスMTUディスカバリを実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8. Duplicates from Earlier Incarnations of Connection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.8。接続の以前のインカネーションからの重複
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The PAWS mechanism protects against errors due to sequence number wrap-around on high-speed connections. Segments from an earlier incarnation of the same connection are also a potential cause of old duplicate errors. In both cases, the TCP mechanisms to prevent such errors depend upon the enforcement of an MSL by the Internet (IP) layer (see the Appendix of RFC 1185 for a detailed discussion). Unlike the case of sequence space wrap-around, the MSL required to prevent old duplicate errors from earlier incarnations does not depend upon the transfer rate. If the IP layer enforces the recommended 2-minute MSL of TCP, and if the TCP rules are followed, TCP connections will be safe from earlier incarnations, no matter how high the network speed. Thus, the PAWS mechanism is not required for this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWSメカニズムは、高速接続のシーケンス番号ラップアラウンドによる誤差を防ぎます。同じ接続の以前の化身からのセグメントは、古い重複エラーの潜在的な原因です。両方の場合において、このようなエラーを防止するために、TCPメカニズムはインターネット（IP）層（詳細な議論のためにRFC 1185の付録を参照）MSLの施行に依存します。シーケンス空間の場合とは異なり、ラップアラウンド、以前の化身から古い重複エラーを防止するために必要なMSLは、転送速度に依存しません。 IP層は、TCPの推奨2分MSLを強制する場合は、TCPのルールに従っている場合、および、TCP接続がどんなに高いネットワーク速度、以前の化身から安全ではないでしょう。このように、PAWSメカニズムはこの場合には必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We may still ask whether the PAWS mechanism can provide additional security against old duplicates from earlier connections, allowing us to relax the enforcement of MSL by the IP layer. Appendix B explores this question, showing that further assumptions and/or mechanisms are required, beyond those of PAWS. This is not part of the current extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
我々はまだPAWSメカニズムは、私たちは、IP層でMSLの施行を緩和することができ、以前の接続から古い写しに対して追加のセキュリティを提供できるかどうかを尋ねることができます。付録Bは、さらに仮定および/または機構は、PAWSのそれを超えて、必要とされていることを示し、この質問を探ります。これは、現在の拡張機能の一部ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Conclusions and Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.結論と謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This memo presented a set of extensions to TCP to provide efficient operation over large bandwidth * delay product paths and reliable operation over very high-speed paths. These extensions are designed to provide compatible interworking with TCP stacks that do not implement the extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモは、大きな帯域幅にわたって効率的な動作を提供するために、TCPの拡張セットを提示*遅延製品のパスと非常に高速な経路を介して信頼性の高い動作。これらの拡張機能は、拡張機能を実装していないTCPスタックとの互換性のインターワーキングを提供するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These mechanisms are implemented using TCP options for scaled windows and timestamps. The timestamps are used for two distinct mechanisms: RTTM and PAWS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのメカニズムは、スケールの窓やタイムスタンプのためのTCPオプションを使用して実装されています。 RTTMとPAWS：タイムスタンプは、2つの別個の機構のために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Window Scale option was originally suggested by Mike St. Johns of USAF/DCA. The present form of the option was suggested by Mike Karels of UC Berkeley in response to a more cumbersome scheme defined by Van Jacobson. Lixia Zhang helped formulate the PAWS mechanism description in [RFC1185].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウィンドウスケールオプションはもともとUSAF / DCAのマイク・セントジョンズによって示唆されました。オプションの現在の形は、バン・ジェイコブソンによって定義され、より面倒なスキームに応じて、UCバークレー校のマイク・Karelsによって示唆されました。 Lixiaチャンは、[RFC1185]でPAWSメカニズムの説明を策定助けました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Finally, much of this work originated as the result of discussions within the End-to-End Task Force on the theoretical limitations of transport protocols in general and TCP in particular. Task force members and others on the end2end-interest list have made valuable contributions by pointing out flaws in the algorithms and the documentation. Continued discussion and development since the publication of [RFC1323] originally occurred in the IETF TCP Large Windows Working Group, later on in the End-to-End Task Force, and most recently in the IETF TCP Maintenance Working Group. The authors are grateful for all these contributions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後に、この作業の多くは、一般、特にTCPでのトランスポートプロトコルの理論的な限界にエンドツーエンドのタスクフォース内での議論の結果として始まりました。 end2end金利リスト上のタスクフォースのメンバーや他の人はアルゴリズムやドキュメントの不備を指摘することで、貴重な貢献をしました。 [RFC1323]の出版以来、議論と開発を続け、もともとIETF TCPメンテナンス作業部会の中で最も最近のエンドツーエンドのタスクフォースでは、後に、IETF TCP大Windowsのワーキンググループで発生した、と。著者は、これらすべての貢献に感謝しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TCP sequence space is a fixed size, and as the window becomes larger, it becomes easier for an attacker to generate forged packets that can fall within the TCP window and be accepted as valid segments. While use of timestamps and PAWS can help to mitigate this, when using PAWS, if an attacker is able to forge a packet that is acceptable to the TCP connection, a timestamp that is in the future would cause valid segments to be dropped due to PAWS checks. Hence, implementers should take care to not open the TCP window drastically beyond the requirements of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPシーケンススペースは、固定サイズであり、ウィンドウが大きいほど、それはTCPウィンドウ内に入ることができ、有効なセグメントとして受け入れられる偽造パケットを生成するために、攻撃者が容易になります。タイムスタンプとPAWSの使用は、攻撃者がTCP接続に許容されるパケットを偽造することができる場合、PAWSを使用した場合、これを緩和するのに役立ちますが、将来的にあるタイムスタンプはPAWSのためにドロップされる、有効なセグメントを引き起こしますチェック。したがって、実装者は、接続の要件を超えて大幅にTCPウィンドウを開かないように注意しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See [RFC5961] for mitigation strategies to blind in-window attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
で、窓の攻撃を盲目にする緩和戦略のために[RFC5961]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A naive implementation that derives the timestamp clock value directly from a system uptime clock may unintentionally leak this information to an attacker. This does not directly compromise any of the mechanisms described in this document. However, this may be valuable information to a potential attacker. It is therefore RECOMMENDED to generate a random, per-connection offset to be used with the clock source when generating the Timestamps option value (see Section 5.4). By carefully choosing this random offset, further improvements as described in [RFC6191] are possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
システム稼働時間クロックから直接タイムスタンプクロック値を導出する単純な実装は、意図せずに攻撃者にこの情報を漏洩してもよいです。これは、直接、この文書で説明するメカニズムのいずれかを妥協しません。しかし、これは潜在的な攻撃者に貴重な情報であってもよいです。したがって、（5.4節を参照）タイムスタンプ・オプション値を生成するときに、クロック・ソースで使用するオフセットごとの接続、ランダムに生成することが推奨されます。 [RFC6191]で説明されるように慎重にこのランダムオフセット、さらなる改善を選択することによって可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Expanding the TCP window beyond 64 KiB for IPv6 allows Jumbograms [RFC2675] to be used when the local network supports packets larger than 64 KiB. When larger TCP segments are used, the TCP checksum becomes weaker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPv6の64 KiBのを超えてTCPウィンドウを展開すると、ローカルネットワークが64 KiBのより大きなパケットをサポートしているときジャンボグラム[RFC2675]を使用することができます。大きなTCPセグメントが使用される場合、TCPチェックサムが弱くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mechanisms to protect the TCP header from modification should also protect the TCP options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
修正からTCPヘッダを保護するためのメカニズムも、TCPオプションを保護する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Middleboxes and TCP options:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MiddleboxesとTCPオプション：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some middleboxes have been known to remove the TCP options described in this document from TCP segments [Honda11]. Middleboxes that remove TCP options described in this document from the &lt;SYN&gt; segment interfere with the selection of parameters appropriate for the session. Removing any of these options in a &lt;SYN,ACK&gt; segment will leave the end hosts in a state that destroys the proper operation of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのミドルボックスは、TCPセグメント[Honda11]からこの文書で説明したTCPオプションを削除することが知られています。 &lt;SYN&gt;セグメントからこの文書に記載されたTCPオプションを削除する中間装置は、セッションのための適切なパラメータの選択を妨害します。 &lt;SYN、ACK&gt;セグメントにおけるこれらのオプションのいずれかを削除すると、プロトコルの適切な動作を破壊状態でエンドホストを残します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* If a Window Scale option is removed from a &lt;SYN,ACK&gt; segment, the end hosts will not negotiate the window scaling factor correctly. Middleboxes must not remove or modify the Window Scale option from &lt;SYN,ACK&gt; segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*ウィンドウスケールオプションは、&lt;SYN、ACK&gt;セグメントから削除された場合、エンドホストが正しくウィンドウ倍率を交渉しません。 Middleboxesは&lt;SYN、ACK&gt;セグメントからウィンドウスケールオプションを削除または修正してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* If a stateful firewall uses the window field to detect whether a received segment is inside the current window, and does not support the Window Scale option, it will not be able to correctly determine whether or not a packet is in the window. These middle boxes must also support the Window Scale option and apply the scale factor when processing segments. If the window scale factor cannot be determined, it must not do window-based processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*ステートフルファイアウォールは、受信したセグメントは、現在のウィンドウ内で、ウィンドウスケールオプションをサポートしていないかどうかを検出するウィンドウフィールドを使用している場合、それは正しくパケットがウィンドウ内にあるかどうかを判断することはできません。これらの中間のボックスはまた、ウィンドウスケールオプションをサポートし、セグメントを処理するときにスケールファクタを適用する必要があります。ウィンドウスケールファクタを決定することができない場合は、ウィンドウ・ベースの処理をしない必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* If the Timestamps option is removed from the &lt;SYN&gt; or &lt;SYN,ACK&gt; segments, high speed connections that need PAWS would not have that protection. Successful negotiation of the Timestamps option enforces a stricter verification of incoming segments at the receiver. If the Timestamps option was removed from a subsequent data segment after a successful negotiation (e.g., as part of resegmentation), the segment is discarded by the receiver without further processing. Middleboxes should not remove the Timestamps option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプオプションは、&lt;SYN&gt;または&lt;SYN、ACK&gt;セグメントから削除された場合*、PAWSを必要とする高速接続は、その保護を持っていないでしょう。タイムスタンプオプションのネゴシエーション成功は、受信機で受信したセグメントの厳格な検証を実施します。タイムスタンプオプションが成功した交渉の後に後続のデータセグメントから削除された場合（例えば、再セグメンテーションの一部として）、セグメントがさらなる処理なしに受信機によって破棄されます。ミドルボックスは、タイムスタンプオプションを削除してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
* It must be noted that [RFC1323] doesn&#39;t address the case of the Timestamps option being dropped or selectively omitted after being negotiated, and that the update in this document may cause some broken middlebox behavior to be detected (potentially unresponsive TCP sessions).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* [RFC1323]は、ネゴシエートされた後に廃棄されるか、または選択的に省略されているタイムスタンプオプションのケースに対処していないこと、およびこのドキュメントの更新は、いくつかの壊れたミドルの挙動を検出することが原因となる場合があることに留意しなければならない（潜在的に応答しなくTCPセッション） 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementations that depend on PAWS could provide a mechanism for the application to determine whether or not PAWS is in use on the connection and choose to terminate the connection if that protection doesn&#39;t exist. This is not just to protect the connection against middleboxes that might remove the Timestamps option, but also against remote hosts that do not have Timestamp support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PAWSに依存実装は、PAWSは、接続に使用されているかどうかを判断し、その保護が存在しない場合は接続を終了することを選択するためのアプリケーションのためのメカニズムを提供することができます。これは、単にタイムスタンプオプションを削除可能性があるミドルボックスに対して、だけでなく、タイムスタンプをサポートしていないリモートホストに対する接続を保護することではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Privacy Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。プライバシーの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TCP options described in this document do not expose individual user&#39;s data. However, a naive implementation simply using the system clock as a source for the Timestamps option will reveal characteristics of the TCP, potentially allowing more targeted attacks. It is therefore RECOMMENDED to generate a random, per-connection offset to be used with the clock source when generating the Timestamps option value (see Section 5.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書で説明したTCPオプションは、個々のユーザーのデータが公開されていません。しかし、単純にタイムスタンプオプションのソースとしてシステムクロックを使用した素朴な実装は、潜在的によりターゲットを絞った攻撃が可能、TCPの特性を明らかにします。したがって、（5.4節を参照）タイムスタンプ・オプション値を生成するときに、クロック・ソースで使用するオフセットごとの接続、ランダムに生成することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Furthermore, the combination, relative ordering, and padding of the TCP options described in Sections 2.2 and 3.2 will reveal additional clues to allow the fingerprinting of the system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さらに、セクション2.2と3.2で説明したTCPオプションの組み合わせ、相対的な順序、およびパディングは、システムのフィンガープリントを可能にするために、追加の手がかりを明らかにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The described TCP options are well known from the superceded [RFC1323]. IANA has updated the &#34;TCP Option Kind Numbers&#34; table under &#34;TCP Parameters&#34; to list this document (RFC 7323) as the reference for &#34;Window Scale&#34; and &#34;Timestamps&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
説明TCPオプションはよく取って代わら[RFC1323]から知られています。 IANAは、「ウィンドウスケール」と「タイムスタンプ」の基準として、この文書（RFC 7323）を一覧表示するには、「TCPパラメータ」の下に「TCPオプション種類番号」テーブルを更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC793]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1191] Mogul, J. and S. Deering, &#34;Path MTU discovery&#34;, RFC 1191, November 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1191]ムガール人、J.とS.デアリング、 &#34;パスMTUディスカバリ&#34;、RFC 1191、1990年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Allman99] Allman, M. and V. Paxson, &#34;On Estimating End-to-End Network Path Properties&#34;, Proceedings of the ACM SIGCOMM Technical Symposium, Cambridge, MA, September 1999, &lt;http://aciri.org/mallman/papers/estimation-la.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Allman99]オールマン、M.およびV.パクソン、「推定エンドツーエンドのネットワークパスの性質について」、ACM SIGCOMM技術シンポジウム、ケンブリッジ、MA、1999年9月、&lt;http://aciri.org/mallmanの議事録/papers/estimation-la.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Floyd05] Floyd, S., &#34;Subject: Re: [tcpm] RFC 1323: Timestamps option&#34;, message to the TCPM mailing list, 26 January 2007, &lt;http://www.ietf.org/mail-archive/web/tcpm/current/ msg02508.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Floyd05]フロイド、S.、 &#34;件名：再：[tcpm] RFC 1323：タイムスタンプオプション&#34;、TCPMメーリングリストへのメッセージ、2007年1月26日、&lt;http://www.ietf.org/mail-archive/web / tcpm /現在/ msg02508.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Garlick77] Garlick, L., Rom, R., and J. Postel, &#34;Issues in Reliable Host-to-Host Protocols&#34;, Proceedings of the Second Berkeley Workshop on Distributed Data Management and Computer Networks, March 1977, &lt;http://www.rfc-editor.org/ien/ien12.txt&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Garlick77]ガーリック、L.、ROM、R.、およびJ.ポステル、「信頼性の高いホスト間のプロトコルでの問題」、分散データ管理およびコンピュータネットワーク上の第二バークレーワークショップの議事録、1977年3月、&lt;のhttp： //www.rfc-editor.org/ien/ien12.txt&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Honda11] Honda, M., Nishida, Y., Raiciu, C., Greenhalgh, A., Handley, M., and H. Tokuda, &#34;Is it Still Possible to Extend TCP?&#34;, Proceedings of the ACM Internet Measurement Conference (IMC) &#39;11, November 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Honda11]ホンダ、M.、西田、Y.、Raiciu、C.、グリーンハル、A.は、ハンドリー、M.、およびH.徳田は、 &#34;TCPを拡張することは可能ですか？&#34;、ACMインターネット計測の議事録会議（IMC）&#39;11、2011年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Jacobson88a] Jacobson, V., &#34;Congestion Avoidance and Control&#34;, SIGCOMM &#39;88, Stanford, CA, August 1988, &lt;http://ee.lbl.gov/papers/congavoid.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Jacobson88a]ジェーコブソン、V.、 &#34;輻輳回避とコントロール&#34;、SIGCOMM &#39;88、スタンフォード大学、カリフォルニア州、1988年8月、&lt;http://ee.lbl.gov/papers/congavoid.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Jacobson90a] Jacobson, V., &#34;4BSD Header Prediction&#34;, ACM Computer Communication Review, April 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Jacobson90a]ジェーコブソン、V.、 &#34;4BSDヘッダー予測&#34;、ACMコンピュータコミュニケーションレビュー、1990年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Jacobson90c] Jacobson, V., &#34;Subject: modified TCP congestion avoidance algorithm&#34;, message to the End2End-Interest mailing list, 30 April 1990, &lt;ftp://ftp.isi.edu/end2end/ end2end-interest-1990.mail&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Jacobson90c]ジェーコブソン、V.、 &#34;件名：変更されたTCP輻輳回避アルゴリズム&#34;、End2End・インタレストメーリングリストへのメッセージ、1990年4月30日、&lt;ftp://ftp.isi.edu/end2end/ end2end金利-1990。メール&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Karn87] Karn, P. and C. Partridge, &#34;Estimating Round-Trip Times in Reliable Transport Protocols&#34;, Proceedings of SIGCOMM &#39;87, August 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Karn87]カーン、P.とC.ヤマウズラ、「信頼性の高いトランスポートプロトコルに往復タイムズの推定」、SIGCOMM &#39;87の議事録、1987年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Kuehlewind10] Kuehlewind, M. and B. Briscoe, &#34;Chirping for Congestion Control - Implementation Feasibility&#34;, November 2010, &lt;http://bobbriscoe.net/projects/netsvc_i-f/ chirp_pfldnet10.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【Kuehlewind10] Kuehlewind、M.及びB.ブリスコウ、 &#34;輻輳制御のためのチャープ - 実装の可能性&#34;、2010年11月、&lt;http://bobbriscoe.net/projects/netsvc_i-f/ chirp_pfldnet10.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Kuzmanovic03] Kuzmanovic, A. and E. Knightly, &#34;TCP-LP: Low-Priority Service via End-Point Congestion Control&#34;, 2003, &lt;www.cs.northwestern.edu/~akuzma/doc/TCP-LP-ToN.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Kuzmanovic03] Kuzmanovic、A.とE.騎士、 &#34;TCP-LP：エンドポイントの輻輳制御を経由して、優先度の低いサービス&#34;、2003年、&lt;www.cs.northwestern.edu/~akuzma/doc/TCP-LP-ToN .PDF&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ludwig00] Ludwig, R. and K. Sklower, &#34;The Eifel Retransmission Timer&#34;, ACM SIGCOMM Computer Communication Review Volume 30 Issue 3, July 2000, &lt;http://ccr.sigcomm.org/archive/2000/july00/ LudwigFinal.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Ludwig00]ルートヴィヒ、R.とK. Sklower、 &#34;アイフェル再送信タイマー&#34;、ACM SIGCOMMコンピュータコミュニケーションレビュー30巻3号、2000年7月、&lt;http://ccr.sigcomm.org/archive/2000/july00/ LudwigFinal .PDF&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Martin03] Martin, D., &#34;Subject: [Tsvwg] RFC 1323.bis&#34;, message to the TSVWG mailing list, 30 September 2003, &lt;http://www.ietf.org/mail-archive/web/tsvwg/current/ msg04435.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Martin03]マーティン、D.は、：、TSVWGメーリングリストへのメッセージ、2003年9月30日、&lt;http://www.ietf.org/mail-archive/web/tsvwg/を &#34;件名[TSVWG] RFCは1323.bis&#34;現在/ msg04435.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Medina04] Medina, A., Allman, M., and S. Floyd, &#34;Measuring Interactions Between Transport Protocols and Middleboxes&#34;, Proceedings of the ACM SIGCOMM/USENIX Internet Measurement Conference, October 2004, &lt;http://www.icir.net/tbit/tbit-Aug2004.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Medina04]メディナ、A.、オールマン、M.、およびS.フロイド、 &#34;トランスポートプロトコルとのMiddleboxes間の相互作用を測定する&#34;、ACM SIGCOMM / USENIXインターネット測定コンファレンス、2004年10月の議事録、&lt;のhttp：//www.icir .NET / TBIT / TBIT-Aug2004.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Medina05] Medina, A., Allman, M., and S. Floyd, &#34;Measuring the Evolution of Transport Protocols in the Internet&#34;, ACM Computer Communication Review Volume 35, No. 2, April 2005, &lt;http://icir.net/floyd/papers/TCPevolution-Mar2005.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Medina05]メディナ、A.、オールマン、M.、およびS.フロイド、 &#34;インターネットにおけるトランスポートプロトコルの進化を測定する&#34;、ACMコンピュータコミュニケーションレビュー35巻、第2号、2005年4月、&lt;のhttp：// icir .NET /フロイド/論文/ TCPevolution-Mar2005.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RE-1323BIS] Oppermann, A., &#34;Subject: Re: [tcpm] I-D Action: draft-ietf.tcpm-1323bis-13.txt&#34;, message to the TCPM mailing list, 01 June 2013, &lt;http://www.ietf.org/ mail-archive/web/tcpm/current/msg08001.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RE-1323BIS] Oppermannの、A.、 &#34;件名：再：[tcpm] IDアクション：ドラフト-ietf.tcpm-1323bis-13.txt&#34;、TCPMメーリングリストへのメッセージ、2013年6月1日、&lt;のhttp：// www.ietf.org/メールアーカイブ/ウェブ/ tcpm /現在/ msg08001.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1072] Jacobson, V. and R. Braden, &#34;TCP extensions for long-delay paths&#34;, RFC 1072, October 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1072]ジェーコブソン、V.およびR.ブレーデン、 &#34;長時間の遅延経路のためのTCP拡張&#34;、RFC 1072、1988年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1122] Braden, R., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1122]ブレーデン、R.、 &#34;インターネットホストのための要件 - 通信層&#34;、STD 3、RFC 1122、1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1185] Jacobson, V., Braden, B., and L. Zhang, &#34;TCP Extension for High-Speed Paths&#34;, RFC 1185, October 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1185]ジェーコブソン、V.、ブレーデン、B.、およびL.チャン、 &#34;高速パスのTCP拡張&#34;、RFC 1185、1990年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1323] Jacobson, V., Braden, B., and D. Borman, &#34;TCP Extensions for High Performance&#34;, RFC 1323, May 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1323]ジェーコブソン、V.、ブレーデン、B.、およびD.ボーマン、 &#34;ハイパフォーマンスのためのTCP拡張&#34;、RFC 1323、1992年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1981] McCann, J., Deering, S., and J. Mogul, &#34;Path MTU Discovery for IP version 6&#34;, RFC 1981, August 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1981]マッキャン、J.、デアリング、S.、およびJ.ムガール人、RFC 1981、1996年8月 &#34;IPバージョン6のパスMTUディスカバリー&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 &#34;TCPの選択確認応答オプション&#34;、RFC 2018、1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2675] Borman, D., Deering, S., and R. Hinden, &#34;IPv6 Jumbograms&#34;, RFC 2675, August 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2675]ボーマン、D.、デアリング、S.、およびR. Hindenと &#34;IPv6のジャンボグラム&#34;、RFC 2675、1999年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, &#34;An Extension to the Selective Acknowledgement (SACK) Option for TCP&#34;, RFC 2883, July 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2883]フロイド、S.、Mahdavi、J.、マティス、M.、およびM.ポドルスキー、 &#34;TCPのための選択的確認応答（SACK）オプションの拡張&#34;、RFC 2883、2000年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3522] Ludwig, R. and M. Meyer, &#34;The Eifel Detection Algorithm for TCP&#34;, RFC 3522, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC3522]ルートヴィヒ、R.及びM.マイヤー、 &#34;TCPのためのアイフェル検出アルゴリズム&#34;、RFC 3522、2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4015] Ludwig, R. and A. Gurtov, &#34;The Eifel Response Algorithm for TCP&#34;, RFC 4015, February 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4015]ルートヴィヒ、R.とA. Gurtov、 &#34;TCPのためのアイフェルレスポンスアルゴリズム&#34;、RFC 4015、2005年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4821] Mathis, M. and J. Heffner, &#34;Packetization Layer Path MTU Discovery&#34;, RFC 4821, March 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4821]マシス、M.とJ. Heffner、 &#34;パケット化レイヤのパスMTUディスカバリ&#34;、RFC 4821、2007年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4963] Heffner, J., Mathis, M., and B. Chandler, &#34;IPv4 Reassembly Errors at High Data Rates&#34;, RFC 4963, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4963] Heffner、J.、マティス、M.、およびB.チャンドラー、 &#34;高速データレートでのIPv4の再構築エラー&#34;、RFC 4963、2007年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 &#34;TCP輻輳制御&#34;、RFC 5681、2009年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5961] Ramaiah, A., Stewart, R., and M. Dalal, &#34;Improving TCP&#39;s Robustness to Blind In-Window Attacks&#34;, RFC 5961, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5961] Ramaiah、A.、スチュワート、R.、およびM. Dalal、RFC 5961、2010年8月 &#34;ブラインドウィンドウ攻撃に対してTCPのロバスト性を向上させます&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6191] Gont, F., &#34;Reducing the TIME-WAIT State Using TCP Timestamps&#34;, BCP 159, RFC 6191, April 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6191] Gont、F.、 &#34;TCPタイムスタンプを使用してTIME-WAIT状態の削減&#34;、BCP 159、RFC 6191、2011年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 6298, June 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 &#34;コンピューティングTCPの再送信タイマー&#34;、RFC 6298、2011年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6528] Gont, F. and S. Bellovin, &#34;Defending against Sequence Number Attacks&#34;, RFC 6528, February 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6528] Gont、F.およびS. Bellovin氏、 &#34;シーケンス番号攻撃からの保護&#34;、RFC 6528、2012年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6675] Blanton, E., Allman, M., Wang, L., Jarvinen, I., Kojo, M., and Y. Nishida, &#34;A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP&#34;, RFC 6675, August 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6675]ブラントン、E.、オールマン、M.、王、L.、Jarvinen、I.、古城、M.、およびY.西田、 &#34;TCPのための選択的確認応答（SACK）に基づいて、保存的損失回復アルゴリズム&#34;、 RFC 6675、2012年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6691] Borman, D., &#34;TCP Options and Maximum Segment Size (MSS)&#34;, RFC 6691, July 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6691]ボーマン、D.、 &#34;TCPオプションと最大セグメントサイズ（MSS）&#34;、RFC 6691、2012年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6817] Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind, &#34;Low Extra Delay Background Transport (LEDBAT)&#34;, RFC 6817, December 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC6817] Shalunov、S.、ヘーゼル、G.、アイアンガー、J.、およびM. Kuehlewind、 &#34;低余分な遅延の背景トランスポート（LEDBAT）&#34;、RFC 6817、2012年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. Implementation Suggestions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A.実装の提案
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP Option Layout
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCPオプションのレイアウト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following layout is recommended for sending options on non-&lt;SYN&gt; segments to achieve maximum feasible alignment of 32-bit and 64-bit machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のレイアウトは、32ビットおよび64ビットマシンの最大可能アラインメントを達成するために、非&lt;SYN&gt;セグメントのオプションを送信するために推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   +--------+--------+--------+--------+
                   |   NOP  |  NOP   |  TSopt |   10   |
                   +--------+--------+--------+--------+
                   |          TSval timestamp          |
                   +--------+--------+--------+--------+
                   |          TSecr timestamp          |
                   +--------+--------+--------+--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Interaction with the TCP Urgent Pointer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP緊急ポインタとの相互作用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TCP Urgent Pointer, like the TCP window, is a 16-bit value. Some of the original discussion for the TCP Window Scale option included proposals to increase the Urgent Pointer to 32 bits. As it turns out, this is unnecessary. There are two observations that should be made:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP緊急ポインタは、TCPウィンドウのように、16ビット値です。 TCPウィンドウスケールオプションの元の議論の中には、32ビットに緊急ポインタを増加させるための提案が含まれています。結局のところ、これは不要です。なされるべきである2つの観測があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) With IP version 4, the largest amount of TCP data that can be sent in a single packet is 65495 bytes (64 KiB - 1 - size of fixed IP and TCP headers).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）IPバージョン4では、単一のパケットで送信できるTCPデータの最大量は65495バイト（ -  1  - 固定IPおよびTCPヘッダのサイズ64 KiBの）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) Updates to the Urgent Pointer while the user is in &#34;urgent mode&#34; are invisible to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）緊急ポインタの更新、ユーザが「緊急モード」であるときに、ユーザーには見えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This means that if the Urgent Pointer points beyond the end of the TCP data in the current segment, then the user will remain in urgent mode until the next TCP segment arrives. That segment will update the Urgent Pointer to a new offset, and the user will never have left urgent mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは緊急ポインタが現在のセグメントにおけるTCPデータの終わりを超えて指す場合には、次のTCPセグメントが到着するまで、ユーザは緊急モードのままにすることを意味します。そのセグメントは、新しいオフセットに緊急ポインタが更新され、ユーザーは緊急モードを残したことがないだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thus, to properly implement the Urgent Pointer, the sending TCP only has to check for overflow of the 16-bit Urgent Pointer field before filling it in. If it does overflow, than a value of 65535 should be inserted into the Urgent Pointer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって、適切に緊急ポインタを実装するために、送信側TCPのみでそれを充填する前に16ビット緊急ポインタフィールドのオーバーフローをチェックする。それはオーバーフローした場合は、緊急ポインタに挿入されるべきである65535の値よりも有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same technique applies to IP version 6, except in the case of IPv6 Jumbograms. When IPv6 Jumbograms are supported, [RFC2675] requires additional steps for dealing with the Urgent Pointer; these steps are described in Section 5.2 of [RFC2675].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じ技術は、IPv6ジャンボグラムの場合を除いて、IPバージョン6に適用されます。 IPv6のジャンボグラムがサポートされている場合は、[RFC2675]は緊急ポインタに対処するための追加の手順が必要です。これらの手順は、[RFC2675]のセクション5.2に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Duplicates from Earlier Connection Incarnations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録B.重複以前の接続のインカネーションから
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two cases to be considered: (1) a system crashing (and losing connection state) and restarting, and (2) the same connection being closed and reopened without a loss of host state. These will be described in the following two sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
考慮すべき2つのケースがある：（1）システムがクラッシュ（および接続状態を失う）と再起動、及び（2）のホスト状態を失うことなく、同じ接続を閉じて再び開いています。これらは、以下の2つのセクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1. System Crash with Loss of State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1。国家の損失でシステムクラッシュ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TCP&#39;s quiet time of one MSL upon system startup handles the loss of connection state in a system crash/restart. For an explanation, see, for example, &#34;Knowing When to Keep Quiet&#34; in the TCP protocol specification [RFC0793]. The MSL that is required here does not depend upon the transfer speed. The current TCP MSL of 2 minutes seemed acceptable as an operational compromise, when many host systems used to take this long to boot after a crash. Current host systems can boot considerably faster.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
システムの起動時に1 MSLのTCPの静かな時間は、システムクラッシュ/再起動で接続状態の損失を処理します。説明については、例えば、TCPプロトコル仕様[RFC0793]で「静かにするときに知って」を参照してください。ここで必要とされるMSLは、転送速度に依存しません。多くのホストシステムがクラッシュした後に起動するために、この長いを取るために使用された場合2分の現在のTCP MSLは、運用の妥協として許容可能なように見えました。現在のホストシステムがかなり速く起動することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Timestamps option may be used to ease the MSL requirements (or to provide additional security against data corruption). If timestamps are being used and if the timestamp clock can be guaranteed to be monotonic over a system crash/restart, i.e., if the first value of the sender&#39;s timestamp clock after a crash/restart can be guaranteed to be greater than the last value before the restart, then a quiet time is unnecessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプオプションは、MSLの要件を緩和するために（またはデータ破損に対する追加のセキュリティを提供するために）使用することができます。タイムスタンプが使用されている場合は、クラッシュ/再起動前の最後の値よりも大きくなるように、送信者のタイムスタンプクロックの最初の値が保証することができた後ならば、タイムスタンプのクロックは、すなわち、システムクラッシュ/再起動で単調であることが保証できるのであれば再起動は、その後、静かな時間が不要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To dispense totally with the quiet time would require that the host clock be synchronized to a time source that is stable over the crash/ restart period, with an accuracy of one timestamp clock tick or better. We can back off from this strict requirement to take advantage of approximate clock synchronization. Suppose that the clock is always resynchronized to within N timestamp clock ticks and that booting (extended with a quiet time, if necessary) takes more than N ticks. This will guarantee monotonicity of the timestamps, which can then be used to reject old duplicates even without an enforced MSL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストクロックが1つのタイムスタンプのクロックティック以上の精度で、クラッシュ/再起動にわたって安定したタイムソースに同期させることが必要となる静かな時間で完全に不要にします。私たちは、おおよそのクロック同期を活用するために、この厳格な要件から後退することができます。クロックは常にNのタイムスタンプクロックティックと（必要に応じて、静かな時間を延長）は、そのブートがNティック以上かかる以内に再同期されていることとします。これは、その後も、強制MSLせずに古い写しを拒絶するために使用することができ、タイムスタンプ、の単調性が保証されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2. Closing and Reopening a Connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2。接続を閉じると再オープン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a TCP connection is closed, a delay of 2*MSL in TIME-WAIT state ties up the socket pair for 4 minutes (see Section 3.5 of [RFC0793]). Applications built upon TCP that close one connection and open a new one (e.g., an FTP data transfer connection using Stream mode) must choose a new socket pair each time. The TIME-WAIT delay serves two different purposes: (a) Implement the full-duplex reliable close handshake of TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合TCP接続が（[RFC0793]のセクション3.5を参照）、TIME-WAIT状態の関係において2 * MSL最大4分間ソケットペアの遅延を閉じています。一つの接続を閉じ、新しいもの（例えば、ストリームモードを使用してFTPのデータ転送接続）を開き、TCP上に構築されたアプリケーションは、新しいソケットペアを毎回選択する必要があります。 TIME-WAIT遅延は二つの異なる目的を果たす：（a）は、TCPの全二重信頼近いハンドシェイクを実装します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        The proper time to delay the final close step is not really
        related to the MSL; it depends instead upon the RTO for the FIN
        segments and, therefore, upon the RTT of the path.  (It could be
        argued that the side that is sending a FIN knows what degree of
        reliability it needs, and therefore it should be able to
        determine the length of the TIME-WAIT delay for the FIN&#39;s
        recipient.  This could be accomplished with an appropriate TCP
        option in FIN segments.)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although there is no formal upper bound on RTT, common network engineering practice makes an RTT greater than 1 minute very unlikely. Thus, the 4-minute delay in TIME-WAIT state works satisfactorily to provide a reliable full-duplex TCP close. Note again that this is independent of MSL enforcement and network speed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTT上の正式な上限はありませんが、一般的なネットワークエンジニアリングの実践は、RTTよりも大きい1分が非常に低くなります。このように、TIME-WAIT状態で4分の遅延が信頼性の高い全二重TCPクローズを提供するために、満足に動作します。これは、MSLの施行とネットワーク速度とは無関係であることを再度注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TIME-WAIT state could cause an indirect performance problem if an application needed to repeatedly close one connection and open another at a very high frequency, since the number of available TCP ports on a host is less than 2^16. However, high network speeds are not the major contributor to this problem; the RTT is the limiting factor in how quickly connections can be opened and closed. Therefore, this problem will be no worse at high transfer speeds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストで使用可能なTCPポートの数が2未満^ 16であるため、アプリケーションは、繰り返し近い一つの接続に必要な、非常に高い周波数で別のを開くと、TIME-WAIT状態は、間接的なパフォーマンス上の問題を引き起こす可能性があります。しかし、高いネットワーク速度は、この問題に対する主要な貢献者ではありません。 RTTは、開閉することができるどのように迅速な接続の制限要因です。したがって、この問題は、高い転送速度で悪くないことはないだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) Allow old duplicate segments to expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）は、古い重複セグメントが失効することを許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        To replace this function of TIME-WAIT state, a mechanism would
        have to operate across connections.  PAWS is defined strictly
        within a single connection; the last timestamp (TS.Recent) is
        kept in the connection control block and discarded when a
        connection is closed.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An additional mechanism could be added to the TCP, a per-host cache of the last timestamp received from any connection. This value could then be used in the PAWS mechanism to reject old duplicate segments from earlier incarnations of the connection, if the timestamp clock can be guaranteed to have ticked at least once since the old connection was open. This would require that the TIME-WAIT delay plus the RTT together must be at least one tick of the sender&#39;s timestamp clock. Such an extension is not part of the proposal of this RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
追加のメカニズムはTCP、任意の接続から受信した最後のタイムスタンプのホストごとのキャッシュに追加することができます。タイムスタンプのクロックは、古い接続がオープンして以来、少なくとも一度はチェックが入っていることを保証することができた場合、この値は、接続の以前の化身から古い重複セグメントを拒絶するようにPAWSメカニズムで使用することができます。これは、RTTプラスTIME-WAIT遅延が一緒に送信者のタイムスタンプクロックの少なくとも1つの目盛りでなければならないことを必要とするであろう。このような拡張は、このRFCの提案の一部ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that this is a variant on the mechanism proposed by Garlick, Rom, and Postel [Garlick77], which required each host to maintain connection records containing the highest sequence numbers on every connection. Using timestamps instead, it is only necessary to keep one quantity per remote host, regardless of the number of simultaneous connections to that host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、すべての接続上の最高のシーケンス番号を含む接続レコードを維持するために、各ホストが必要ガーリック、ROM、およびポステル[Garlick77]によって提案された機構、オン変異体であることに留意されたいです。代わりにタイムスタンプを使用して、関係なく、そのホストへの同時接続数の、リモートホストごとに1つの量を維持するために必要なだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix C. Summary of Notation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
表記の付録C.まとめ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following notation has been used in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下の表記は、このドキュメントで使用されてきました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Options
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
WSopt: TCP Window Scale option TSopt: TCP Timestamps option
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
WSopt：TCPウィンドウスケールオプションのTSopt：TCPタイムスタンプオプション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Option Fields
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オプションフィールド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
shift.cnt: Window scale byte in WSopt TSval: 32-bit Timestamp Value field in TSopt TSecr: 32-bit Timestamp Reply field in TSopt
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TSopt TSecr 32ビットタイムスタンプ値フィールド：shift.cnt：WSopt TSvalにおけるウィンドウスケールバイトは32ビットタイムスタンプTSoptのフィールドを返信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Option Fields in Current Segment
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のセグメントにおけるオプションフィールド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.TSval: TSval field from TSopt in current segment SEG.TSecr: TSecr field from TSopt in current segment SEG.WSopt: 8-bit value in WSopt
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.TSval：現在のセグメントSEG.TSecrでTSoptからTSvalフィールド：現在のセグメントSEG.WSoptでTSoptからTSecrフィールド：WSopt 8ビット値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Clock Values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロック値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
my.TSclock: System-wide source of 32-bit timestamp values my.TSclock.rate: Period of my.TSclock (1 ms to 1 sec) Snd.TSoffset: An offset for randomizing Snd.TSclock Snd.TSclock: my.TSclock + Snd.TSoffset
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
my.TSclock：32ビットのタイムスタンプ値my.TSclock.rateのシステム全体源：my.TSclockの期間（1秒に1ミリ秒）Snd.TSoffset：Snd.TSclock Snd.TSclockをランダム化するためのオフセットmy.TSclock + Snd.TSoffset
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Per-Connection State Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
接続ごとの状態変数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
TS.Recent: Latest received Timestamp Last.ACK.sent: Last ACK field sent Snd.TS.OK: 1-bit flag Snd.WS.OK: 1-bit flag Rcv.Wind.Shift: Receive window scale exponent Snd.Wind.Shift: Send window scale exponent Start.Time: Snd.TSclock value when the segment being timed was sent (used by code from before RFC 1323).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TS.Recent：最新のタイムスタンプLast.ACK.sentを受けた：最後のACKフィールドがSnd.TS.OKを送った：1ビットのフラグSnd.WS.OK：1ビットのフラグRcv.Wind.Shift：ウィンドウスケール指数Snd.Windを受信.Shift：ウィンドウスケール指数Start.Timeを送る：Snd.TSclock値をセグメントが送信されたタイミングされたときに（RFC 1323の前のコードによって使用されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Procedure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
手順
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Update_SRTT(m) Procedure to update the smoothed RTT and RTT variance estimates, using the rules of [Jacobson88a], given m, a new RTT measurement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Update_SRTT（M）手順[Jacobson88a]、与えられたM、新たなRTT測定のルールを使用して、平滑化RTTとRTT分散の推定値を更新します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Send Sequence Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シーケンス変数を送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SND.UNA: Send unacknowledged SND.NXT: Send next SND.WND: Send window ISS: Initial send sequence number
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SND.UNA：未確認SND.NXTを送信：次のSND.ANDを送信：ウィンドウISSを送る：初期送信シーケンス番号を
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Receive Sequence Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シーケンス変数を受け取ります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RCV.NXT: Receive next RCV.WND: Receive window IRS: Initial receive sequence number
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RCV.NXT：次RCV.AND：受信ウィンドウIRSを受信：初期シーケンス番号を受け取ります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix D. Event Processing Summary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録D.イベント処理の概要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix attempts to specify the algorithms unambiguously by presenting modifications to the Event Processing rules in Section 3.9 of RFC 793. The change bars (&#34;|&#34;) indicate lines that are different from RFC 793.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録では、RFC 793のセクション3.9にイベント処理ルールに変更を提示することによって明確に変更バーをアルゴリズムを指定しようとします（「|」）RFC 793と異なっている行を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPEN Call
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPENコール
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 An initial send sequence number (ISS) is selected. Send a &lt;SYN&gt; | segment of the form: | | &lt;SEQ=ISS&gt;&lt;CTL=SYN&gt;&lt;TSval=Snd.TSclock&gt;&lt;WSopt=Rcv.Wind.Shift&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
初期送信シーケンス番号（ISS）が選択されています。送信&lt;SYN&gt; |フォームのセグメント：| | &lt;SEQ = ISS&gt; &lt;CTL = SYN&gt; &lt;TSval = Snd.TSclock&gt; &lt;WSopt = Rcv.Wind.Shift&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEND Call
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コールを送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLOSED STATE (i.e., TCB does not exist)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLOSED状態（すなわちTCBが存在しません）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LISTEN STATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LISTEN状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 If active and the foreign socket is specified, then change the connection from passive to active, select an ISS. Send a SYN | segment containing the options: &lt;TSval=Snd.TSclock&gt; and | &lt;WSopt=Rcv.Wind.Shift&gt;. Set SND.UNA to ISS, SND.NXT to ISS+1. Enter SYN-SENT state. ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アクティブおよび外部ソケットが指定されている場合、ISSを選択し、アクティブにパッシブからの接続を変更します。 SYNを送ります|オプションを含むセグメント：&lt;TSval = Snd.TSclock&gt;と| &lt;WSopt = Rcv.Wind.Shift&gt;。 ISS、ISS + 1にSND.NXTにSND.UNAを設定します。 SYN-SENT状態を入力します。 ...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      SYN-SENT STATE
      SYN-RECEIVED STATE
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ESTABLISHED STATE CLOSE-WAIT STATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ESTABLISHED状態CLOSE-WAIT状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Segmentize the buffer and send it with a piggybacked acknowledgment (acknowledgment value = RCV.NXT). ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バッファをSegmentizeとピギーバック肯定応答（アクノレッジメント値= RCV.NXT）でそれを送ります。 ...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the urgent flag is set ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
緊急フラグが設定されている場合...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| If the Snd.TS.OK flag is set, then include the TCP Timestamps | option &lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; in each data | segment. | | Scale the receive window for transmission in the segment | header: | | SEG.WND = (RCV.WND &gt;&gt; Rcv.Wind.Shift).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| Snd.TS.OKフラグが設定されている場合、TCPタイムスタンプを含めます|各データ内のオプション&lt;TSval = Snd.TSclock、TSecr = TS.Recent&gt; |セグメント。 | |セグメント内の伝送のための受信ウィンドウを拡大縮小|ヘッダ：| | SEG.WND =（RCV.WND &gt;&gt; Rcv.Wind.Shift）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEGMENT ARRIVES
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セグメントが到着します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the state is LISTEN then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状態である場合、LISTEN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
first check for an RST
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RSTのための最初のチェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
second check for an ACK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACKのための第2のチェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
third check for a SYN
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SYNのための第三のチェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the SYN bit is set, check the security. If the ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SYNビットがセットされている場合は、セキュリティを確認してください。もし...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the SEG.PRC is less than the TCB.PRC then continue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.PRCがTCB.PRC未満であれば、続けています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| Check for a Window Scale option (WSopt); if one is found, | save SEG.WSopt in Snd.Wind.Shift and set Snd.WS.OK flag on. | Otherwise, set both Snd.Wind.Shift and Rcv.Wind.Shift to | zero and clear Snd.WS.OK flag. | | Check for a TSopt option; if one is found, save SEG.TSval in | the variable TS.Recent and turn on the Snd.TS.OK bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
|ウィンドウスケールオプション（WSopt）をチェックしてください。 1が発見された場合、| Snd.Wind.ShiftでSEG.WSoptを保存し、上Snd.WS.OKフラグを設定します。 |それ以外の場合は、Snd.Wind.ShiftとRcv.Wind.Shiftの両方を設定します|ゼロクリアSnd.WS.OKフラグ。 | | TSoptオプションをチェックします。 1が見つかった場合、中SEG.TSvalを保存|変数TS.RecentとSnd.TS.OKビットをオンにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ and any
            other control or text should be queued for processing later.
            ISS should be selected and a SYN segment sent of the form:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ=ISS&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=SYN,ACK&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ = ISS&gt; &lt;ACK = RCV.NXT&gt; &lt;CTL = SYN、ACK&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| If the Snd.WS.OK bit is on, include a WSopt | &lt;WSopt=Rcv.Wind.Shift&gt; in this segment. If the Snd.TS.OK | bit is on, include a TSopt &lt;TSval=Snd.TSclock, | TSecr=TS.Recent&gt; in this segment. Last.ACK.sent is set to | RCV.NXT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| | Snd.WS.OKビットがオンになっている場合は、WSoptが含まれます&lt;WSopt = Rcv.Wind.Shift&gt;このセグメントです。 Snd.TS.OKもし|ビットはTSoptが含まれ、オンになっている&lt;TSval = Snd.TSclock、| TSecr = TS.Recent&gt;このセグメントです。 Last.ACK.sentに設定します| RCV.NXT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            SND.NXT is set to ISS+1 and SND.UNA to ISS.  The connection
            state should be changed to SYN-RECEIVED.  Note that any
            other incoming control or data (combined with SYN) will be
            processed in the SYN-RECEIVED state, but processing of SYN
            and ACK should not be repeated.  If the listen was not fully
            specified (i.e., the foreign socket was not fully
            specified), then the unspecified fields should be filled in
            now.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fourth other text or control
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第四他のテキストまたはコントロール
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the state is SYN-SENT then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
状態は、SYN-SENTである場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
first check the ACK bit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のACKビットをチェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fourth check the SYN bit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第四SYNビットをチェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the SYN bit is on and the security/compartment and precedence are acceptable then, RCV.NXT is set to SEG.SEQ+1, IRS is set to SEG.SEQ. SND.UNA should be advanced to equal SEG.ACK (if there is an ACK), and any segments on the retransmission queue which are thereby acknowledged should be removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SYNビットがオンで、セキュリティ/コンパートメントと優先順位は、次に許容可能である場合、RCV.NXTにSEG.SEQ + 1に設定され、IRSはSEG.SEQに設定されています。 SND.UNAは（ACKがある場合）に等しいSEG.ACKに進めなければならない、それによって認められている再送キュー上の任意のセグメントが除去されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| Check for a Window Scale option (WSopt); if it is found, | save SEG.WSopt in Snd.Wind.Shift; otherwise, set both | Snd.Wind.Shift and Rcv.Wind.Shift to zero. |
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
|ウィンドウスケールオプション（WSopt）をチェックしてください。それが発見された場合、| Snd.Wind.ShiftでSEG.WSoptを保存します。それ以外の場合は、両方を設定します|ゼロにSnd.Wind.ShiftとRcv.Wind.Shift。 |
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| Check for a TSopt option; if one is found, save SEG.TSval in | variable TS.Recent and turn on the Snd.TS.OK bit in the | connection control block. If the ACK bit is set, use | Snd.TSclock - SEG.TSecr as the initial RTT estimate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| TSoptオプションをチェックします。 1が見つかった場合、中SEG.TSvalを保存|変数TS.RecentとでSnd.TS.OKビットをオンにします|接続制御ブロック。 ACKビットがセットされている場合は、使用し| Snd.TSclock  - 初期RTT推定値としてSEG.TSecr。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            If SND.UNA &gt; ISS (our SYN has been ACKed), change the
            connection state to ESTABLISHED, form an &lt;ACK&gt; segment:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ = SND.NXT&gt; &lt;ACK = RCV.NXT&gt; &lt;CTL = ACK&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| and send it. If the Snd.TS.OK bit is on, include a TSopt | option &lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; in this &lt;ACK&gt; | segment. Last.ACK.sent is set to RCV.NXT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
|そしてそれを送ります。 | Snd.TS.OKビットがオンになっている場合は、TSoptが含まれますオプション&lt;TSval = Snd.TSclock、TSecr = TS.Recent&gt;この中に&lt;ACK&gt; |セグメント。 Last.ACK.sentはRCV.NXTに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            Data or controls that were queued for transmission may be
            included.  If there are other controls or text in the
            segment, then continue processing at the sixth step below
            where the URG bit is checked; otherwise, return.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Otherwise, enter SYN-RECEIVED, form a &lt;SYN,ACK&gt; segment:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうでない場合は、SYN-RECEIVED入力し、&lt;SYN、ACK&gt;セグメントを形成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ=ISS&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=SYN,ACK&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ = ISS&gt; &lt;ACK = RCV.NXT&gt; &lt;CTL = SYN、ACK&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| and send it. If the Snd.TS.OK bit is on, include a TSopt | option &lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; in this segment. | If the Snd.WS.OK bit is on, include a WSopt option | &lt;WSopt=Rcv.Wind.Shift&gt; in this segment. Last.ACK.sent is | set to RCV.NXT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
|そしてそれを送ります。 | Snd.TS.OKビットがオンになっている場合は、TSoptが含まれますこのセグメントにおけるオプション&lt;TSval = Snd.TSclock、TSecr = TS.Recent&gt;。 | | Snd.WS.OKビットがオンの場合、WSoptオプションを含めます&lt;WSopt = Rcv.Wind.Shift&gt;このセグメントです。 Last.ACK.sentされます| RCV.NXTに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            If there are other controls or text in the segment, queue
            them for processing after the ESTABLISHED state has been
            reached, return.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fifth, if neither of the SYN or RST bits is set then drop the segment and return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SYNまたはRSTビットのどちらが設定されている場合に第五のは、セグメントを削除し返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Otherwise
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そうでなければ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
first check the sequence number
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初のシーケンス番号をチェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SYN-RECEIVED STATE ESTABLISHED STATE FIN-WAIT-1 STATE FIN-WAIT-2 STATE CLOSE-WAIT STATE CLOSING STATE LAST-ACK STATE TIME-WAIT STATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
STATE ESTABLISHED状態FIN-WAIT-1状態FIN-WAIT-2状態CLOSE-WAIT状態閉状態をSYN-RECEIVED LAST-ACK状態TIME-WAIT状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Segments are processed in sequence. Initial tests on arrival are used to discard old duplicates, but further processing is done in SEG.SEQ order. If a segment&#39;s contents straddle the boundary between old and new, only the new parts should be processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セグメントは順番に処理されます。到着時に最初のテストは古い写しを破棄するために使用されているが、更なる処理はSEG.SEQの順序で行われます。セグメントの内容は、新旧の間の境界をまたぐ場合は、新しい部分だけが処理されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| Rescale the received window field: | | TrueWindow = SEG.WND &lt;&lt; Snd.Wind.Shift, | | and use &#34;TrueWindow&#34; in place of SEG.WND in the following | steps. | | Check whether the segment contains a Timestamps option and | if bit Snd.TS.OK is on. If so: | | If SEG.TSval &lt; TS.Recent and the RST bit is off: | | If the connection has been idle more than 24 days, | save SEG.TSval in variable TS.Recent, else the segment | is not acceptable; follow the steps below for an | unacceptable segment. | | If SEG.TSval &gt;= TS.Recent and SEG.SEQ &lt;= Last.ACK.sent, | then save SEG.TSval in variable TS.Recent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
|受信ウィンドウのフィールドを再スケール：| | TrueWindow = SEG.WND &lt;&lt; Snd.Wind.Shift、| |そして次にSEG.WNDの代わりに「TrueWindow」を使用|手順。 | |セグメントは、タイムスタンプオプションが含まれているかどうかを確認し、|ビットSnd.TS.OKがオンになっている場合。その場合：| | SEG.TSval &lt;TS.RecentとRSTビットがオフの場合：| |接続は、24以上の日アイドル状態になっている場合は、|他のセグメント変数TS.Recent、中SEG.TSvalを保存|許容ではありません。以下の手順に従ってください|容認できないセグメント。 | |もしSEG.TSval&gt; = TS.RecentとSEG.SEQ &lt;= Last.ACK.sent、|その後、変数TS.RecentでSEG.TSvalを保存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            There are four cases for the acceptability test for an
            incoming segment:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an incoming segment is not acceptable, an acknowledgment should be sent in reply (unless the RST bit is set; if so drop the segment and return):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
着信セグメントが受け入れられない場合（RSTビットが設定されていない限り、そうセグメントをドロップして戻す場合）、確認応答が応答で送信されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ = SND.NXT&gt; &lt;ACK = RCV.NXT&gt; &lt;CTL = ACK&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| Last.ACK.sent is set to SEG.ACK of the acknowledgment. If | the Snd.TS.OK bit is on, include the Timestamps option | &lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; in this &lt;ACK&gt; segment. Set Last.ACK.sent to SEG.ACK and send the &lt;ACK&gt; segment. After sending the acknowledgment, drop the unacceptable segment and return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| Last.ACK.sentは確認のSEG.ACKに設定されています。もし| | Snd.TS.OKビットは、上でタイムスタンプオプションを含めます&lt;TSval = Snd.TSclock、TSecr = TS.Recent&gt;この&lt;ACK&gt;セグメントです。 SEG.ACKと&lt;ACK&gt;セグメントを送信するためにLast.ACK.sentを設定します。肯定応答を送信した後、容認できないセグメントとリターンをドロップ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
fifth check the ACK field,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第五ACKフィールドをチェックし、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if the ACK bit is off drop the segment and return
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACKビットは、セグメントとリターンをドロップオフの場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if the ACK bit is on
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACKビットがオンの場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ESTABLISHED STATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ESTABLISHED状態
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 If SND.UNA &lt; SEG.ACK &lt;= SND.NXT then, set SND.UNA &lt;- | SEG.ACK. Also compute a new estimate of round-trip time. | If Snd.TS.OK bit is on, use Snd.TSclock - SEG.TSecr; | otherwise, use the elapsed time since the first segment | in the retransmission queue was sent. Any segments on the retransmission queue that are thereby entirely acknowledged...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SND.UNA &lt;SEG.ACK &lt;= SND.NXTはその後、SND.UNA &lt;設定されている場合 - を| SEG.ACK。また、ラウンドトリップ時間の新しい推定値を計算します。 | Snd.TS.OKビットがオンになっている場合は、Snd.TSclockを使用する -  SEG.TSecrを。 |それ以外の場合は、最初のセグメントからの経過時間を使います|再送キューに送信されました。これにより、完全に承認される再送キュー上の任意のセグメント...
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
seventh, process the segment text,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第七、プロセスセグメントテキスト、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ESTABLISHED STATE FIN-WAIT-1 STATE FIN-WAIT-2 STATE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ESTABLISHED状態FIN-WAIT-1状態FIN-WAIT-2 STATE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Send an acknowledgment of the form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フォームの確認応答を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ=SND.NXT&gt;&lt;ACK=RCV.NXT&gt;&lt;CTL=ACK&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;SEQ = SND.NXT&gt; &lt;ACK = RCV.NXT&gt; &lt;CTL = ACK&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
| If the Snd.TS.OK bit is on, include the Timestamps option | &lt;TSval=Snd.TSclock,TSecr=TS.Recent&gt; in this &lt;ACK&gt; segment. | Set Last.ACK.sent to SEG.ACK of the acknowledgment, and send | it. This acknowledgment should be piggybacked on a segment being transmitted if possible without incurring undue delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
| | Snd.TS.OKビットがオンの場合、タイムスタンプオプションを含めます&lt;TSval = Snd.TSclock、TSecr = TS.Recent&gt;この&lt;ACK&gt;セグメントです。 |確認のSEG.ACKにLast.ACK.sentを設定し、送信|それ。この肯定応答は過度の遅延を招くことなく、可能な場合に送信されるセグメント上にピギーバックされるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix E. Timestamps Edge Cases
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録E.タイムスタンプのエッジケース
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the rules laid out for when to calculate RTTM produce the correct results most of the time, there are some edge cases where an incorrect RTTM can be calculated. All of these situations involve the loss of segments. It is felt that these scenarios are rare, and that if they should happen, they will cause a single RTTM measurement to be inflated, which mitigates its effects on RTO calculations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルールはRTTMは、ほとんどの時間正しい結果を生成する計算する場合のレイアウトが、誤っRTTMを計算することができるいくつかのエッジ場合があります。これらの状況のすべては、セグメントの損失を伴います。これらのシナリオは稀であると感じている、と彼らは起こる必要がある場合、彼らはRTOの計算に及ぼす影響を軽減され、単一RTTM測定を膨張させることになるという。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[Martin03] cites two similar cases when the returning &lt;ACK&gt; is lost, and before the retransmission timer fires, another returning &lt;ACK&gt; segment arrives, which acknowledges the data. In this case, the RTTM calculated will be inflated:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【Martin03]復帰&lt;ACK&gt;が失われ、再送タイマーが起動する前に、別の戻り&lt;ACK&gt;セグメントがデータを承認れ、到達されたときに、2つの類似事例を引用。この場合、計算RTTMが膨張されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          clock
            tc=1   &lt;A, TSval=1&gt; -------------------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            tc=2   (lost) &lt;---- &lt;ACK(A), TSecr=1, win=n&gt;
                (RTTM would have been 1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   (receive window opens, window update is sent)
            tc=5        &lt;---- &lt;ACK(A), TSecr=1, win=m&gt;
                   (RTTM is calculated at 4)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
One thing to note about this situation is that it is somewhat bounded by RTO + RTT, limiting how far off the RTTM calculation will be. While more complex scenarios can be constructed that produce larger inflations (e.g., retransmissions are lost), those scenarios involve multiple segment losses, and the connection will have other more serious operational problems than using an inflated RTTM in the RTO calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような状況で1つ注意することは、それが多少RTTM計算がされるか遠く制限、RTO + RTTで囲まれていることです。より複雑なシナリオ（例えば、再送信が失われている）が大きくinflationsを生成するように構築することができるが、これらのシナリオは、複数のセグメントの損失を伴う、および接続はRTOの計算に膨張RTTMを使用するよりも他のより深刻な操作上の問題を有することになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix F. Window Retraction Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録F.ウィンドウ撤回例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider an established TCP connection using a scale factor of 128, Snd.Wind.Shift=7 and Rcv.Wind.Shift=7, that is running with a very small window because the receiver is bottlenecked and both ends are doing small reads and writes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機がボトルネックされ、両端がやっている小さな読み取りおよび書き込むため、それは非常に小さなウィンドウで実行されて、128のスケールファクタを使用して確立されたTCP接続、Snd.Wind.Shift = 7とRcv.Wind.Shift = 7を検討。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the ACKs coming back:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
戻ってくるACKを考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.ACK SEG.WIN computed SND.WIN receiver&#39;s actual window 1000 2 1256 1300
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.ACK SEG.WINはSND.WIN受信機の実際のウィンドウ2 1256 1300 1000計算しました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sender writes 40 bytes and receiver ACKs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者は40のバイトと受信ACKを書き込みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1040 2 1296 1300
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
１０４０ ２ １２９６ １３００
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sender writes 5 additional bytes and the receiver has a problem. Two choices:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者は、5つの追加のバイトを書き込み、受信機に問題があります。二つの選択肢：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1045 2 1301 1300 - BEYOND BUFFER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1045 2 1301 1300  -  BEYOND BUFFER
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1045 1 1173 1300 - RETRACTED WINDOW
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 1173 1300 1045  - 引っ込めWINDOW
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is a general problem and can happen any time the sender does a write, which is smaller than the window scale factor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、一般的な問題であり、送信側がウィンドウスケールファクタよりも小さい書き込みを行い、いつでも起こることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In most stacks, it is at least partially obscured when the window size is larger than some small number of segments because the stacks prefer to announce windows that are an integral number of segments, rounded up to the next scale factor. This plus silly window suppression tends to cause less frequent, larger window updates. If the window was rounded down to a segment size, there is more opportunity to advance the window, the BEYOND BUFFER case above, rather than retracting it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ほとんどのスタックでは、スタックはセグメントの整数であるウィンドウをアナウンスすることを好むので、ウィンドウサイズはセグメントのいくつかの小さな数よりも大きい場合、それは、少なくとも部分的に隠されて、次のスケールファクタに切り上げ。このプラス愚かな窓の抑制はそれほど頻繁に、より大きなウィンドウの更新を引き起こす傾向があります。ウィンドウは、セグメントサイズに切り捨てた場合、むしろそれを後退させるよりも、窓、上記BEYONDバッファケースを進めるより機会があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix G. RTO Calculation Modification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録G. RTO計算修正
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taking multiple RTT samples per window would shorten the history calculated by the RTO mechanism in [RFC6298], and the below algorithm aims to maintain a similar history as originally intended by [RFC6298].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウィンドウごとに複数のRTTのサンプルを採取して、[RFC6298]でRTO機構によって算出履歴を短縮し、以下のアルゴリズムは、もともと[RFC6298]で意図したとおりに同様の履歴を維持することを目的とするであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is roughly known how many samples a congestion window worth of data will yield, not accounting for ACK compression, and ACK losses. Such events will result in more history of the path being reflected in the final value for RTO, and are uncritical. This modification will ensure that a similar amount of time is taken into account for the RTO estimation, regardless of how many samples are taken per window:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
大体ACK圧縮を占め、およびACK損失ではない、データの輻輳ウィンドウの価値が得られますどのように多くのサンプルが知られています。経路のより歴史になり、このようなイベントは、RTOの最終値に反映され、無批判されています。この変更は、時間の同様の量にかかわらず、ウィンドウごとに取得されますどのように多くのサンプルを、RTO推定に考慮されていることを確認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ExpectedSamples = ceiling(FlightSize / (SMSS * 2))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ExpectedSamples =天井（FlightSize /（SMSS * 2））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
alpha&#39; = alpha / ExpectedSamples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アルファ」=アルファ/ ExpectedSamples
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
beta&#39; = beta / ExpectedSamples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ベータ」=ベータ/ ExpectedSamples
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the factor 2 in ExpectedSamples is due to &#34;Delayed ACKs&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ExpectedSamplesの要因2が「遅延ACK」によるものであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Instead of using alpha and beta in the algorithm of [RFC6298], use alpha&#39; and beta&#39; instead:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
代わりに、[RFC6298]のアルゴリズムにアルファおよびベータを使用するのではなく、代わりに、α「およびβ」を使用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTTVAR &lt;- (1 - beta&#39;) * RTTVAR + beta&#39; * |SRTT - R&#39;|
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTTVAR &lt; - （1  - ベータ &#39;）* RTTVAR +ベータ&#39; * | SRTT  -  R &#39;|
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SRTT &lt;- (1 - alpha&#39;) * SRTT + alpha&#39; * R&#39;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SRTT &lt; - （1  - アルファ &#39;）* SRTT +アルファ&#39; * R」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(for each sample R&#39;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（各サンプルR &#39;用）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix H. Changes from
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録H.変更から
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Several important updates and clarifications to the specification in RFC 1323 are made in this document. The technical changes are summarized below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC 1323での仕様にいくつかの重要な更新と説明は、このドキュメントで作られています。技術的な変更は以下のとおりであります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(a) A wrong reference to SND.WND was corrected to SEG.WND in Section 2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（a）はAND.ENDへの誤った参照は、2.3節でSET.ENDに修正されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) Section 2.4 was added describing the unavoidable window retraction issue and explicitly describing the mitigation steps necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）は2.4節は避けられない窓後退の問題を説明し、明示的に必要な軽減ステップを説明する追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(c) In Section 3.2, the wording how the Timestamps option negotiation is to be performed was updated with RFC2119 wording. Further, a number of paragraphs were added to clarify the expected behavior with a compliant implementation using TSopt, as RFC 1323 left room for interpretation -- e.g., potential late enablement of TSopt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（c）は3.2節では、タイムスタンプオプションのネゴシエーションが実行される方法文言は、RFC2119文言を更新しました。 TSoptの例えば、潜在的な遅い有効化を -  RFC 1323の解釈のために部屋を出ようさらに、段落の数は、TSoptを使用して準拠した実装と予想される動作を明確にするために添加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(d) The description of which TSecr values can be used to update the measured RTT has been clarified. Specifically, with timestamps, the Karn algorithm [Karn87] is disabled. The Karn algorithm disables all RTT measurements during retransmission, since it is ambiguous whether the &lt;ACK&gt; is for the original segment, or the retransmitted segment. With timestamps, that ambiguity is removed since the TSecr in the &lt;ACK&gt; will contain the TSval from whichever data segment made it to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（D）TSecr値が測定されたRTTを更新するために使用することができるの説明が明らかにされています。具体的には、タイムスタンプと、カーンアルゴリズム[Karn87]は無効になっています。 &lt;ACK&gt;オリジナルのセグメント、または再送セグメントのためのものであるか否か曖昧であるため、カーンアルゴリズムは、再送時にすべてのRTT測定値を無効にします。タイムスタンプと、その曖昧さは、&lt;ACK&gt;にTSecrは、いずれのデータセグメントからTSvalを含有するので、削除された宛先にそれを作りました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(e) RTTM update processing explicitly excludes segments not updating SND.UNA. The original text could be interpreted to allow taking RTT samples when SACK acknowledges some new, non-continuous data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（E）RTTM更新処理を明示的にセグメントがSND.UNAを更新しない除外する。元のテキストは、SACKはいくつかの新しい、非連続的なデータを認識したときにRTTのサンプルを採取できるように解釈できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(f) In RFC 1323, Section 3.4, step (2) of the algorithm to control which timestamp is echoed was incorrect in two regards:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（F）RFC 1323で、第3.4項、タイムスタンプはエコーさを制御するためのアルゴリズムのステップ（2）は、2つの点で正しくありませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        (1)  It failed to update TS.Recent for a retransmitted segment
             that resulted from a lost &lt;ACK&gt;.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) It failed if SEG.LEN = 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEG.LEN = 0の場合（2）が失敗しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the new algorithm, the case of SEG.TSval &gt;= TS.Recent is included for consistency with the PAWS test.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいアルゴリズムでは、SEG.TSval&gt; = TS.Recentの場合は、PAWSテストとの整合性のために含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(g) It is now recommended that the Timestamps option is included in &lt;RST&gt; segments if the incoming segment contained a Timestamps option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（G）現在の着信セグメントがタイムスタンプオプションが含まれている場合、タイムスタンプオプションが&lt;RST&gt;セグメントに含まれていることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(h) &lt;RST&gt; segments are explicitly excluded from PAWS processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（H）&lt;RST&gt;セグメントが明示的PAWS処理から除外されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(i) Added text to clarify the precedence between regular TCP [RFC0793] and this document&#39;s Timestamps option / PAWS processing. Discussion about combined acceptability checks are ongoing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（i）は、通常のTCP [RFC0793]とこのドキュメントのタイムスタンプオプション/ PAWS処理間の優先順位を明確にするために、テキストを追加しました。組み合わせ受容性チェックについての議論が進行中です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(j) Snd.TSoffset and Snd.TSclock variables have been added. Snd.TSclock is the sum of my.TSclock and Snd.TSoffset. This allows the starting points for timestamp values to be randomized on a per-connection basis. Setting Snd.TSoffset to zero yields the same results as [RFC1323]. Text was added to guide implementers to the proper selection of these offsets, as entirely random offsets for each new connection will conflict with PAWS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（J）Snd.TSoffsetとSnd.TSclock変数が追加されました。 Snd.TSclockはmy.TSclockとSnd.TSoffsetの合計です。これは、タイムスタンプ値の出発点は、接続ごとにランダム化することを可能にします。ゼロにSnd.TSoffsetを設定すると、[RFC1323]と同じ結果が得られます。テキストはPAWSと競合するそれぞれの新しい接続のための完全にランダムなオフセットとして、これらのオフセットの適切な選択に実装を導くために追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(k) Appendix A has been expanded with information about the TCP Urgent Pointer. An earlier revision contained text around the TCP MSS option, which was split off into [RFC6691].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（k）は、付録AはTCP緊急ポインタについての情報が拡張されました。 [RFC6691]にオフに分割されたTCP MSSオプション、周りの以前のリビジョン含まれるテキスト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(l) One correction was made to the Event Processing Summary in Appendix D. In SEND CALL/ESTABLISHED STATE, RCV.WND is used to fill in the SEG.WND value, not SND.WND.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（L）一点の補正が送信呼び出しの付録Dのイベント処理の概要/ ESTABLISHED状態になされたもので、RCV.WNDはSND.WND、SEG.WND値でない埋めるために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(m) Appendix G was added to exemplify how an RTO calculation might be updated to properly take the much higher RTT sampling frequency enabled by the Timestamps option into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（m）の付録Gは、RTOの計算が適切に考慮にタイムスタンプオプションで有効になってはるかに高いRTTのサンプリング周波数を取るために更新されるかもしれない方法を例示するために追加されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Editorial changes to the document, that don&#39;t impact the implementation or function of the mechanisms described in this document, include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本書で説明されたメカニズムの実装や機能に影響を与えていないドキュメントに編集上の変更は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(a) Removed much of the discussion in Section 1 to streamline the document. However, detailed examples and discussions in Sections 2, 3, and 5 are kept as guidelines for implementers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（a）の文書を合理化するための第1節での議論の多くを削除しました。しかし、詳細な例及びセクション2、3、及び5での議論は、実装のためのガイドラインとして保持されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) Added short text that the use of WS increases the chances of sequence number wrap, thus the PAWS mechanism is required in certain environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）は、WSの使用は、このようPAWS機構は、特定の環境で必要とされるシーケンス番号ラップの機会を増加させる短いテキストを追加しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(c) Removed references to &#34;new&#34; options, as the options were introduced in [RFC1323] already. Changed the text in Section 1.3 to specifically address TS and WS options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（C）オプションが既に[RFC1323]で導入されたように、「新たな」オプションへの参照を削除。特にTSおよびWSオプションに対処するために、セクション1.3にテキストを変更しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(d) Section 1.4 was added for [RFC2119] wording. Normative text was updated with the appropriate phrases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（d）の1.4節は、[RFC2119]表現のために添加しました。規範的テキストは、適切なフレーズで更新されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(e) Added &lt; &gt; brackets to mark specific types of segments, and replaced most occurrences of &#34;packet&#34; with &#34;segment&#34;, where TCP segments are referred to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（E）を添加し、&lt;&gt;括弧は、セグメントの特定のタイプをマークし、TCPセグメントが参照される「セグメント」と「パケット」の最も出現を置換します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(f) Updated the text in Section 3 to take into account what has been learned since [RFC1323].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（f）は、[RFC1323]以来、学習されたものを考慮に入れるために、セクション3のテキストを更新しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(g) Removed some unused references.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（g）は、いくつかの未使用の参照を削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(h) Removed the list of changes between [RFC1323] and prior versions. These changes are mentioned in Appendix C of [RFC1323].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（h）は[RFC1323]と以前のバージョン間の変更のリストを削除しました。これらの変更は、[RFC1323]の付録Cに記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(i) Moved &#34;Changes from RFC 1323&#34; to the end of the appendices for easier lookup. In addition, the entries were split into a technical and an editorial part, and sorted to roughly correspond with the sections in the text where they apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（i）は、簡単に検索のための付録の末尾に「RFC 1323からの変更点」を移動しました。また、エントリが技術的および編集部分に分け、それらが適用されたテキストのセクションと概ね一致するように選別しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
David Borman Quantum Corporation Mendota Heights, MN 55120 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デビッド・ボーマンQuantum社メンドタハイツ、ミネソタ55120 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: david.borman@quantum.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：david.borman@quantum.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Bob Braden University of Southern California 4676 Admiralty Way Marina del Rey, CA 90292 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
南カリフォルニアのボブブレーデン大学4676アドミラルティWayマリナデルレイ、CA 90292 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: braden@isi.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：braden@isi.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Van Jacobson Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヴァンヤコブソングーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043 USA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: vanj@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：vanj@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Richard Scheffenegger (editor) NetApp, Inc. Am Euro Platz 2 Vienna, 1120 Austria
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リチャードScheffenegger（編集者）のNetApp、Inc.のEUR場所2ウィーン、オーストリア1120年には
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: rs@netapp.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：rs@netapp.com
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
