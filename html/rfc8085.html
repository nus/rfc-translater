<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8085 - UDP Usage Guidelines 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8085</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8085 - UDP Usage Guidelines 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8085">
              https://tools.ietf.org/html/rfc8085
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8085 - UDP使用上のガイドライン</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         L. Eggert
Request for Comments: 8085                                        NetApp
BCP: 145                                                    G. Fairhurst
Obsoletes: 5405                                   University of Aberdeen
Category: Best Current Practice                              G. Shepherd
ISSN: 2070-1721                                            Cisco Systems
                                                              March 2017
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                          UDP Usage Guidelines
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The User Datagram Protocol (UDP) provides a minimal message-passing transport that has no inherent congestion control mechanisms. This document provides guidelines on the use of UDP for the designers of applications, tunnels, and other protocols that use UDP. Congestion control guidelines are a primary focus, but the document also provides guidance on other topics, including message sizes, reliability, checksums, middlebox traversal, the use of Explicit Congestion Notification (ECN), Differentiated Services Code Points (DSCPs), and ports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータグラムプロトコル（UDP）がない固有の輻輳制御機構を有していない最小のメッセージパッシングの輸送を提供します。この文書では、アプリケーション、トンネル、およびUDPを使用する他のプロトコルの設計者のためのUDPの使用に関するガイドラインを提供します。輻輳制御のガイドラインが主な焦点ですが、ドキュメントは、メッセージのサイズ、信頼性、チェックサム、ミドルトラバーサル、明示的輻輳通知（ECN）、DiffServコードポイント（DSCPを）、およびポートの使用を含め、他のトピックに関するガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because congestion control is critical to the stable operation of the Internet, applications and other protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and to establish some degree of fairness with concurrent traffic. They may also need to implement additional mechanisms, depending on how they use UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御は、インターネットの安定動作に重要であるため、インターネット・トランスポートとしてUDPを使用することを選択したアプリケーションや他のプロトコルは、輻輳崩壊を防ぐために同時トラフィックとの公平性をある程度確立するためのメカニズムを使用しなければなりません。彼らはまた、彼らはUDPを使用する方法に応じて、追加のメカニズムを実装する必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some guidance is also applicable to the design of other protocols (e.g., protocols layered directly on IP or via IP-based tunnels), especially when these protocols do not themselves provide congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのガイダンスは、これらのプロトコル自体が輻輳制御を提供しない場合は特に、（例えば、プロトコルはIPまたはIPベースのトンネルを経由して直接重ね）も、他のプロトコルの設計に適用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes RFC 5405 and adds guidelines for multicast UDP usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書はRFC 5405を廃止し、マルチキャストUDPの使用のためのガイドラインを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo documents an Internet Best Current Practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモはインターネット最も良い現在の練習を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on BCPs is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 BCPの詳細については、RFC 7841のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8085.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc8085で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2017 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................3
   2. Terminology .....................................................5
   3. UDP Usage Guidelines ............................................5
      3.1. Congestion Control Guidelines ..............................6
      3.2. Message Size Guidelines ...................................19
      3.3. Reliability Guidelines ....................................21
      3.4. Checksum Guidelines .......................................22
      3.5. Middlebox Traversal Guidelines ............................25
      3.6. Limited Applicability and Controlled Environments .........27
   4. Multicast UDP Usage Guidelines .................................28
      4.1. Multicast Congestion Control Guidelines ...................30
      4.2. Message Size Guidelines for Multicast .....................32
   5. Programming Guidelines .........................................32
      5.1. Using UDP Ports ...........................................34
      5.2. ICMP Guidelines ...........................................37
   6. Security Considerations ........................................38
   7. Summary ........................................................40
   8. References .....................................................42
      8.1. Normative References ......................................42
      8.2. Informative References ....................................43
   Appendix A. .......................................................53
   Acknowledgments ...................................................55
   Authors&#39; Addresses ................................................55
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The User Datagram Protocol (UDP) [RFC768] provides a minimal, unreliable, best-effort, message-passing transport to applications and other protocols (such as tunnels) that wish to operate over IP. Both are simply called &#34;applications&#34; in the remainder of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータグラムプロトコル（UDP）[RFC768] IP上で操作したい（例えばトンネルなど）のアプリケーションやその他のプロトコルに最小限の、信頼できない、ベストエフォート、メッセージパッシング輸送を提供します。どちらも、単にこの文書の残りの部分で、「アプリケーション」と呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compared to other transport protocols, UDP and its UDP-Lite variant [RFC3828] are unique in that they do not establish end-to-end connections between communicating end systems. UDP communication consequently does not incur connection establishment and teardown overheads, and there is minimal associated end-system state. Because of these characteristics, UDP can offer a very efficient communication transport to some applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のトランスポートプロトコルと比較すると、UDPおよびそのUDP-Liteの変種[RFC3828]は、彼らがエンドシステムを通信間のエンドツーエンド接続を確立していないという点でユニークです。 UDP通信は、結果として、接続確立およびティアダウンオーバーヘッドが発生せず、最小限の関連するエンドシステムの状態があります。これらの特徴により、UDPは、いくつかのアプリケーションに非常に効率的な通信の輸送を提供することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A second unique characteristic of UDP is that it provides no inherent congestion control mechanisms. On many platforms, applications can send UDP datagrams at the line rate of the platform&#39;s link interface, which is often much greater than the available end-to-end path capacity, and doing so contributes to congestion along the path. [RFC2914] describes the best current practice for congestion control
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPの第2の特有の特徴は、それが固有の輻輳制御メカニズムを提供しないことです。多くのプラットフォームでは、アプリケーションでは、多くの場合、可能なエンド・ツー・エンドのパス容量よりもはるかに大きい、そしてそうすることがパスに沿って混雑に貢献プラットフォームのリンクインターフェイスのラインレートでUDPデータグラムを送信することができます。 [RFC2914]は、輻輳制御のためのベストプラクティスを説明し、現在の
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in the Internet. It identifies two major reasons why congestion control mechanisms are critical for the stable operation of the Internet:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インタネットの中には。これは、輻輳制御メカニズムは、インターネットの安定動作のために重要である理由を二つの主要な理由を識別します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The prevention of congestion collapse, i.e., a state where an increase in network load results in a decrease in useful work done by the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.輻輳崩壊、すなわち、有用な仕事の減少ネットワーク負荷結果の増加がネットワークによって行わ状態の予防に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The establishment of a degree of fairness, i.e., allowing multiple flows to share the capacity of a path reasonably equitably.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.複数のフローが合理的公平パスの容量を共有することを可能にする公平性の程度、すなわち、確立。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because UDP itself provides no congestion control mechanisms, it is up to the applications that use UDP for Internet communication to employ suitable mechanisms to prevent congestion collapse and establish a degree of fairness. [RFC2309] discusses the dangers of congestion-unresponsive flows and states that &#34;all UDP-based streaming applications should incorporate effective congestion avoidance mechanisms.&#34; [RFC7567] reaffirms this statement. This is an important requirement, even for applications that do not use UDP for streaming. In addition, congestion-controlled transmission is of benefit to an application itself, because it can reduce self-induced packet loss, minimize retransmissions, and hence reduce delays. Congestion control is essential even at relatively slow transmission rates. For example, an application that generates five 1500-byte UDP datagrams in one second can already exceed the capacity of a 56 Kb/s path. For applications that can operate at higher, potentially unbounded data rates, congestion control becomes vital to prevent congestion collapse and establish some degree of fairness. Section 3 describes a number of simple guidelines for the designers of such applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP自体は輻輳制御メカニズムを提供しないので、輻輳崩壊を防ぐと公平性の度合いを確立するための適切な機構を採用するインターネット通信にUDPを使用するアプリケーション次第です。 [RFC2309]は輻輳無応答フローの危険性を説明し、と述べている「すべてのUDPベースのストリーミングアプリケーションが有効な輻輳回避メカニズムを組み込むべきです。」 [RFC7567]はこの文を再確認します。これはさえストリーミングにUDPを使用しないアプリケーションのために、重要な要件です。それは、自己誘導パケット損失を減らす再送を最小化し、したがって遅延を減らすことができるので、また、輻輳制御送信は、アプリケーション自体に有益です。輻輳制御が比較的遅い伝送速度で不可欠です。例えば、1秒間に5 1500バイトのUDPデータグラムを生成するアプリケーションは既に56 KB / Sパスの容量を超えることができます。高い、潜在的に無制限のデータレートで動作するアプリケーションの場合は、輻輳制御、輻輳崩壊を防ぐと公平性をある程度確立することが重要になります。第3節では、このようなアプリケーションの設計者のための簡単なガイドラインの数を示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP datagram is carried in a single IP packet and is hence limited to a maximum payload of 65,507 bytes for IPv4 and 65,527 bytes for IPv6. The transmission of large IP packets usually requires IP fragmentation. Fragmentation decreases communication reliability and efficiency and should be avoided. IPv6 allows the option of transmitting large packets (&#34;jumbograms&#34;) without fragmentation when all link layers along the path support this [RFC2675]. Some of the guidelines in Section 3 describe how applications should determine appropriate message sizes. Other sections of this document provide guidance on reliability, checksums, middlebox traversal and use of multicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPデータグラムは、単一のIPパケットで運ばれ、したがって、IPv4の65507バイト、IPv6の65527バイトの最大ペイロードに限定されます。大規模なIPパケットの送信は、通常、IPフラグメンテーションが必要です。断片化は、通信の信頼性と効率を低下させ、避けるべきです。 IPv6は、パスに沿ってすべてのリンク層は、この[RFC2675]をサポートしている場合、断片化することなく、大きなパケット（「ジャンボグラム」）を送信するオプションを可能にします。第3節のガイドラインのいくつかは、アプリケーションが適切なメッセージサイズを決定する方法を説明します。このドキュメントの他のセクションでは、マルチキャストの信頼性、チェックサム、ミドルトラバーサルおよび使用に関するガイダンスを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document provides guidelines and recommendations. Although most UDP applications are expected to follow these guidelines, there do exist valid reasons why a specific application may decide not to follow a given guideline. In such cases, it is RECOMMENDED that application designers cite the respective section(s) of this document in the technical specification of their application or protocol and explain their rationale for their design choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、ガイドラインと推奨事項を提供します。ほとんどのUDPアプリケーションは、これらのガイドラインに従うことが期待されていますが、特定のアプリケーションが特定のガイドラインに従うことを決めるかもしれない理由を正当な理由が存在します。このような場合には、アプリケーションの設計者は、アプリケーションやプロトコルの技術仕様で、このドキュメントのそれぞれのセクション（複数可）を引用し、その設計上の選択のための彼らの論理的根拠を説明することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] was scoped to provide guidelines for unicast applications only, whereas this document also provides guidelines for UDP flows that use IP anycast, multicast, broadcast, and applications that use UDP tunnels to support IP flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書はまた、IPエニーキャスト、マルチキャスト、ブロードキャスト、およびIPフローをサポートするためにUDPトンネルを使用するアプリケーションを使用するUDPフローのためのガイドラインを提供するのに対し、[RFC5405]は、ユニキャストアプリケーションのためのガイドラインを提供するためにスコープしました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, although this document specifically refers to usage of UDP, the spirit of some of its guidelines also applies to other message-passing applications and protocols (specifically on the topics of congestion control, message sizes, and reliability). Examples include signaling, tunnel or control applications that choose to run directly over IP by registering their own IP protocol number with IANA. This document is expected to provide useful background reading to the designers of such applications and protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、特にUDPの使用に言及しているが、最終的に、そのガイドラインの一部の精神は、他のメッセージパッシングアプリケーションとプロトコル（具体的には輻輳制御のトピックに関する、メッセージサイズ、および信頼性）に適用されます。例としては、IANAで、独自のIPプロトコル番号を登録することにより、IP上で直接実行することを選択したシグナリング、トンネルや制御のアプリケーションが含まれます。この文書は、そのようなアプリケーションとプロトコルの設計者に読んで有益な背景を提供することが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、 &#34;SHALL&#34;、 &#34;SHOULD&#34;、 &#34;ないもの&#34;、 &#34;推奨&#34; &#34;ない（SHOULD NOT）&#34;、 &#34;MAY&#34;、 &#34;推奨NOT&#34;、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. UDP Usage Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. UDP使用上のガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet paths can have widely varying characteristics, including transmission delays, available bandwidths, congestion levels, reordering probabilities, supported message sizes, or loss rates. Furthermore, the same Internet path can have very different conditions over time. Consequently, applications that may be used on the Internet MUST NOT make assumptions about specific path characteristics. They MUST instead use mechanisms that let them operate safely under very different path conditions. Typically, this requires conservatively probing the current conditions of the Internet path they communicate over to establish a transmission behavior that it can sustain and that is reasonably fair to other traffic sharing the path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネットパスは伝送遅延、利用可能な帯域幅、渋滞度、並び替え確率、サポートされているメッセージのサイズ、又は損失率を含む多種多様な特性を有することができます。さらに、同じインターネットパスは、時間をかけて非常に異なる条件を持つことができます。そのため、インターネット上で使用できるアプリケーションは、特定のパスの特性についての仮定をしてはなりません。彼らは代わりに、彼らは非常に異なるパス条件の下で安全に動作させメカニズムを使用しなければなりません。通常、これは控えめに、彼らはそれを維持することができ、送信動作を確立する上で通信インターネットパスの現在の状況を探査する必要があり、それはパスを共有する他のトラフィックに合理的に公平です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These mechanisms are difficult to implement correctly. For most applications, the use of one of the existing IETF transport protocols is the simplest method of acquiring the required mechanisms. Doing so also avoids issues that protocols using a new IP protocol number face when being deployed over the Internet, where middleboxes that only support TCP and UDP are sometimes present. Consequently, the RECOMMENDED alternative to the UDP usage described in the remainder of this section is the use of an IETF transport protocol such as TCP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらのメカニズムは正確に実施することが困難です。ほとんどのアプリケーションでは、既存のIETFのトランスポートプロトコルの1つの使用は、必要なメカニズムを取得する最も簡単な方法です。そうすることだけTCPおよびUDPをサポートするミドルボックスが時々存在しているインターネット上で展開されているときに、新しいIPプロトコル番号の顔を使用してプロトコルの問題を回避します。したがって、このセクションの残りの部分で説明UDP使用することを推奨代替は、TCPのようなIETFトランスポートプロトコルの使用であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793], Stream Control Transmission Protocol (SCTP) [RFC4960], and SCTP Partial Reliability Extension (SCTP-PR) [RFC3758], or Datagram Congestion Control Protocol (DCCP) [RFC4340] with its different congestion control types [RFC4341][RFC4342][RFC5622], or transport protocols specified by the IETF in the future. (UDP-encapsulated SCTP [RFC6951] and DCCP [RFC6773] can offer support for traversing firewalls and other middleboxes where the native protocols are not supported.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]、ストリーム制御伝送プロトコル（SCTP）[RFC4960]、およびSCTP部分信頼性拡張（SCTP-PR）[RFC3758]、またはデータグラム輻輳制御プロトコル（DCCP）[RFC4340]の異なる輻輳制御タイプと[RFC4341] [ RFC4342]、[RFC5622]、または将来的にIETFによって指定されるトランスポートプロトコル。 （UDPカプセル化SCTP [RFC6951]とDCCP [RFC6773]は、ネイティブプロトコルがサポートされていないファイアウォールや他の中間装置を横断するためのサポートを提供することができます。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If used correctly, these more fully featured transport protocols are not as &#34;heavyweight&#34; as often claimed. For example, the TCP algorithms have been continuously improved over decades, and they have reached a level of efficiency and correctness that custom application-layer mechanisms will struggle to easily duplicate. In addition, many TCP implementations allow connections to be tuned by an application to its purposes. For example, TCP&#39;s &#34;Nagle&#34; algorithm [RFC1122] can be disabled, improving communication latency at the expense of more frequent -- but still congestion controlled -- packet transmissions. Another example is the TCP SYN cookie mechanism [RFC4987], which is available on many platforms. TCP with SYN cookies does not require a server to maintain per-connection state until the connection is established. TCP also requires the end that closes a connection to maintain the TIME-WAIT state that prevents delayed segments from one connection instance from interfering with a later one. Applications that are aware of and designed for this behavior can shift maintenance of the TIME-WAIT state to conserve resources by controlling which end closes a TCP connection [FABER]. Finally, TCP&#39;s built-in capacity-probing and awareness of the maximum transmission unit supported by the path (PMTU) results in efficient data transmission that quickly compensates for the initial connection setup delay, in the case of transfers that exchange more than a few segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正しく使用した場合、これらのより完全な機能をトランスポートプロトコルは、多くの場合、記載の「ヘビー級」としてではありません。たとえば、TCPアルゴリズムは、継続的に数十年にわたり改善されている、と彼らは、カスタムアプリケーション層のメカニズムを簡単に複製するために苦労しそうだ効率と正確の水準に達しています。また、多くのTCP実装は、接続がその目的に適用することによって調整することを可能にします。例えば、TCPの「ネーグル」アルゴリズム[RFC1122]はより頻繁に犠牲に通信遅延を改善し、無効にすることができます - しかし、まだ混雑は制御 - パケット伝送。別の例は、多くのプラットフォームで利用可能であるTCP SYNクッキーメカニズム[RFC4987]、です。 SYNクッキーとのTCP接続が確立されるまで、接続ごとの状態を維持するためにサーバを必要としません。 TCPはまた、後で一つと干渉つの接続インスタンスからの遅延セグメントを防止TIME-WAIT状態を維持するために、接続を閉じ端を必要とします。意識して、この動作のために設計されたアプリケーションは、TCPコネクション[FABER]を閉じる終了制御することにより、リソースを節約するためにTIME-WAIT状態の維持をシフトすることができます。最後に、TCPの内蔵容量プロービングかつ迅速に少数のセグメントよりも交換転送の場合には、最初の接続セットアップ遅延を補償する効率的なデータ伝送における経路（PMTU）の結果によってサポートされる最大伝送ユニットの意識。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Congestion Control Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 輻輳制御のガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application or protocol chooses not to use a congestion-controlled transport protocol, it SHOULD control the rate at which it sends UDP datagrams to a destination host, in order to fulfill the requirements of [RFC2914]. It is important to stress that an application SHOULD perform congestion control over all UDP traffic it sends to a destination, independently from how it generates this traffic. For example, an application that forks multiple worker processes or otherwise uses multiple sockets to generate UDP datagrams SHOULD perform congestion control over the aggregate traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションまたはプロトコルが輻輳制御トランスポートプロトコルを使用しないことを選択した場合、それは[RFC2914]の要件を満たすために、宛先ホストにUDPデータグラムを送信する速度を制御すべきです。アプリケーションが、それがこのトラフィックを生成する方法とは独立して、宛先に送信するすべてのUDPトラフィック上で輻輳制御を実行すべきであることを強調することが重要です。例えば、複数のワーカープロセスをフォークまたはその他のUDPデータグラムを生成するために複数のソケットを使用するアプリケーションは、集約トラフィック上輻輳制御を実行すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several approaches to perform congestion control are discussed in the remainder of this section. This section describes generic topics with an intended emphasis on unicast and anycast [RFC1546] usage. Not all approaches discussed below are appropriate for all UDP-transmitting applications. Section 3.1.2 discusses congestion control options for applications that perform bulk transfers over UDP. Such applications can employ schemes that sample the path over several subsequent round-trips during which data is exchanged to determine a sending rate that the path at its current load can support. Other applications only exchange a few UDP datagrams with a destination. Section 3.1.3 discusses congestion control options for such &#34;low data-volume&#34; applications. Because they typically do not transmit enough data to iteratively sample the path to determine a safe sending rate, they need to employ different kinds of congestion control mechanisms. Section 3.1.11 discusses congestion control considerations when UDP is used as a tunneling protocol. Section 4 provides additional recommendations for broadcast and multicast usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御を実行するためのいくつかのアプローチは、このセクションの残りの部分に記載されています。このセクションでは、ユニキャストとエニーキャスト[RFC1546]の使用上の意図重点を置いて一般的なトピックについて説明します。以下で説明されていないすべてのアプローチは、すべてのUDP-送信するアプリケーションに適しています。 3.1.2は、UDP上でバルク転送を実行するアプリケーションのための輻輳制御オプションについて説明します。そのようなアプリケーションは、データが現在の負荷に経路がサポート可能送信レートを決定するために交換される時に、いくつかの後続のラウンドトリップ経路上をサンプリング方式を採用することができます。他のアプリケーションは唯一の目的地で少数のUDPデータグラムを交換します。 3.1.3項では、このような「低データ・ボリューム」のアプリケーションのための輻輳制御オプションについて説明します。彼らは通常、反復的に安全な送信レートを決定するために、パスをサンプリングするのに十分なデータを送信することはありませんので、彼らは輻輳制御メカニズムの異なる種類を採用する必要があります。 UDPは、トンネリングプロトコルとして使用されている場合、セクション3.1.11は、輻輳制御の考慮事項について説明します。第4章では、ブロードキャストやマルチキャストの使用のための追加の推奨事項を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that congestion control should not be viewed as an add-on to a finished application. Many of the mechanisms discussed in the guidelines below require application support to operate correctly. Application designers need to consider congestion control throughout the design of their application, similar to how they consider security aspects throughout the design process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御がアドオン完成したアプリケーションへと見るべきではないことに注意することが重要です。以下のガイドラインで議論メカニズムの多くは、正常に動作するアプリケーションのサポートを必要とします。アプリケーション設計者は、彼らが設計プロセス全体でセキュリティ面を考慮してどのように類似し、そのアプリケーションの設計、全体の輻輳制御を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the past, the IETF has also investigated integrated congestion control mechanisms that act on the traffic aggregate between two hosts, i.e., a framework such as the Congestion Manager [RFC3124], where active sessions may share current congestion information in a way that is independent of the transport protocol. Such mechanisms have currently failed to see deployment, but would otherwise simplify the design of congestion control mechanisms for UDP sessions, so that they fulfill the requirements in [RFC2914].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
過去には、IETFはまた、アクティブなセッションが独立しているように、現在の渋滞情報を共有することができるような輻輳マネージャとしてフレームワーク[RFC3124]を、二つのホスト、すなわち間のトラフィック集合に作用する統合された輻輳制御メカニズムを調査しましたトランスポートプロトコルの。このようなメカニズムは、現在展開を見ることができなかったが、彼らは[RFC2914]で要件を満たすように、それ以外の場合は、UDPセッションのための輻輳制御機構の設計を簡素化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Protocol Timer Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. プロトコルタイマーのガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Understanding the latency between communicating endpoints is usually a crucial part of effective congestion control implementations for protocols and applications. Latency estimation can be used in a number of protocol functions, such as calculating a congestion-controlled transmission rate, triggering retransmission, and detecting packet loss. Additional protocol functions, for example, determining an interval for probing a path, determining an interval between keep-alive messages, determining an interval for measuring the quality of experience, or determining if a remote endpoint has responded to a request to perform an action, typically operate over longer timescales than congestion control and therefore are not covered in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信エンドポイント間のレイテンシを理解することは、通常、プロトコルおよびアプリケーションのための効果的な輻輳制御の実装の重要な部分です。レイテンシ推定は例えば、輻輳制御透過率を算出再送をトリガし、パケットロスを検出するように、プロトコル機能の数で使用することができます。追加のプロトコル機能、例えば、キープアライブメッセージの間隔を決定し、経路を探索する体験の質を測定するための間隔を決定する、またはリモートエンドポイントがアクションを実行する要求に応答したかどうかを決定するための間隔を決定します、一般的に、輻輳制御よりも長い時間スケールで動作し、したがって、このセクションに記載されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general recommendation in this document is that applications SHOULD leverage existing congestion control techniques and the latency estimators specified therein (see next subsection). The following guidelines are provided for applications that need to design their own latency estimation mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書に記載されている一般的な推奨事項は、アプリケーションが（次のサブセクションを参照）、既存の輻輳制御技術およびそこ指定待ち時間推定量を利用しなければならないということです。次のガイドラインは、自身のレイテンシの推定メカニズムを設計する必要があるアプリケーションのために提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guidelines are framed in terms of &#34;latency&#34; and not &#34;round-trip time&#34; because some situations require characterizing only the network-based latency (e.g., TCP-Friendly Rate Control (TFRC) [RFC5348]), while other cases necessitate inclusion of the time required by the remote endpoint to provide feedback (e.g., developing an understanding of when to retransmit a message).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの状況でのみ、ネットワークベースの待ち時間を特徴付ける必要とするためのガイドラインは、「レイテンシー」とない「往復時間」の面で囲まれ（例えば、TCPフレンドリーレート制御（TFRC）[RFC5348]）、その他の場合は、含有を必要としながら、フィードバックを提供するために、リモートエンドポイントが必要とする時間の（例えば、メッセージを再送する際の理解を開発）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The latency between endpoints is generally a dynamic property. Therefore, estimates SHOULD represent some sort of averaging of multiple recent measurement samples to account for variance. Leveraging an Exponentially Weighted Moving Average (EWMA) has proven useful for this purpose (e.g., in TCP [RFC6298] and TFRC [RFC5348]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイント間の待ち時間は、一般的に動的特性です。したがって、推定値は分散を考慮して、複数の最近の測定サンプルの平均のいくつかの並べ替えを表現して下さい。活用指数加重移動平均（EWMA）が（例えば、TCPにおける[RFC6298]及びTFRC [RFC5348]）は、この目的のために有用であることが証明されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Independent latency estimates SHOULD be maintained for each destination with which an endpoint communicates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
独立した待ち時間の推定値は、エンドポイントが通信する宛先毎に維持されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Latency samples MUST NOT be derived from ambiguous transactions. The canonical example is in a protocol that retransmits data, but subsequently cannot determine which copy is being acknowledged. This ambiguity makes correct computation of the latency problematic. See the discussion of Karn&#39;s algorithm in [RFC6298]. This requirement ensures a sender establishes a sound estimate of the latency without relying on misleading measurements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レイテンシのサンプルは、あいまいな取引から派生してはなりません。標準的な例では、データを再送するプロトコルであるが、その後に肯定応答されているコピーを決定することができません。この曖昧さは、レイテンシ問題の正しい計算を行います。 [RFC6298]でカーンのアルゴリズムの説明を参照してください。この要件は、送信者が誤解を招くような測定に頼ることなく、待ち時間の音推定値を確立し保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a latency estimate is used to arm a timer that provides loss detection -- with or without retransmission -- expiry of the timer MUST be interpreted as an indication of congestion in the network, causing the sending rate to be adapted to a safe conservative rate (e.g., TCP collapses the congestion window to one segment [RFC5681]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再送の有無にかかわらず -   - レイテンシ推定値は損失検出を提供するタイマーアームために使用される場合、タイマの満了は、送信速度が安全な保守的なレートに適合させる、ネットワークの輻輳の指標として解釈されなければなりません（例えば、TCPは、一つのセグメント[RFC5681]に輻輳ウィンドウを崩壊します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications require an initial latency estimate before the latency between endpoints can be empirically sampled. For instance, when arming a retransmission timer, an initial value is needed to protect the messages sent before the endpoints sample the latency. This initial latency estimate SHOULD generally be as conservative (large) as possible for the given application. For instance, in the absence of any knowledge about the latency of a path, TCP requires the initial Retransmission Timeout (RTO) to be set to no less than 1 second [RFC6298]. UDP applications SHOULD similarly use an initial latency estimate of 1 second. Values shorter than 1 second can be problematic (see the data analysis in the appendix of [RFC6298]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイント間のレイテンシは、経験的にサンプリングすることができる前に、一部のアプリケーションでは、初期遅延の推定値を必要としています。再送タイマを武装する場合たとえば、初期値は、エンドポイントは、待ち時間をサンプリングする前に送信されたメッセージを保護するために必要とされます。この初期待ち時間推定値は、一般に、所与の用途のために可能な限り保存的（大）であるべきです。例えば、パスの待ち時間についての知識が存在しない場合に、TCPはない1以上の次の[RFC6298]に設定される初期再送タイムアウト（RTO）を必要とします。 UDPアプリケーションは、同様に1秒の初期待ち時間の推定値を使用すべきです。 1秒より短い値が問題となる可能性がある（付録におけるデータ解析参照[RFC6298]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. Bulk-Transfer Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. バルク転送アプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that perform bulk transmission of data to a peer over UDP, i.e., applications that exchange more than a few UDP datagrams per RTT, SHOULD implement TFRC [RFC5348], window-based TCP-like congestion control, or otherwise ensure that the application complies with the congestion control principles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP上のピアへのデータのバルク転送を実行するアプリケーション、すなわち、RTTあたり数UDPデータグラム以上を交換するアプリケーションは、ウィンドウベースのTCPのような輻輳制御をTFRC [RFC5348]を実装し、またはそうでなければ、そのアプリケーションの準拠を保証しなければなりません輻輳制御の原理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFRC has been designed to provide both congestion control and fairness in a way that is compatible with the IETF&#39;s other transport protocols. If an application implements TFRC, it need not follow the remaining guidelines in Section 3.1.2, because TFRC already addresses them, but it SHOULD still follow the remaining guidelines in the subsequent subsections of Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFRCは、IETFの他のトランスポートプロトコルと互換性のある方法で輻輳制御と公平性の両方を提供するように設計されています。アプリケーションは、TFRCを実装する場合、TFRCはすでにそれらを解決するためには、3.1.2の残りのガイドラインに従う必要はないが、それはまだ第3節の以降のサブセクションの残りのガイドラインに従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bulk-transfer applications that choose not to implement TFRC or TCP-like windowing SHOULD implement a congestion control scheme that results in bandwidth (capacity) use that competes fairly with TCP within an order of magnitude.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFRCまたはTCPのようなウィンドウを実装しないことを選択したバルク転送アプリケーションは、桁以内TCPと公平に競合する帯域幅（容量）使用することになる輻輳制御方式を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2 of [RFC3551] suggests that applications SHOULD monitor the packet-loss rate to ensure that it is within acceptable parameters. Packet loss is considered acceptable if a TCP flow across the same network path under the same network conditions would achieve an average throughput, measured on a reasonable timescale, that is not less than that of the UDP flow. The comparison to TCP cannot be specified exactly, but is intended as an &#34;order-of-magnitude&#34; comparison in timescale and throughput. The recommendations for managing timers specified in Section 3.1.1 also apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551]のセクション2は、アプリケーションが、それが許容パラメータの範囲内であることを保証するためにパケット損失率を監視すべきであることを示唆しています。同じネットワーク条件下で同じネットワーク・パスを横切るTCPフローは、UDPフローのそれ以上である合理的なタイムスケールで測定した平均スループットを達成ならばパケットロスが許容されると考えられます。 TCPとの比較を正確に特定することはできないが、タイムスケールとスループットの「桁違い」の比較として意図されています。 3.1.1項で指定されたタイマーを管理するための推奨事項も適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, some bulk-transfer applications may choose not to implement any congestion control mechanism and instead rely on transmitting across reserved path capacity (see Section 3.1.9). This might be an acceptable choice for a subset of restricted networking environments, but is by no means a safe practice for operation over the wider Internet. When the UDP traffic of such applications leaks out into unprovisioned Internet paths, it can significantly degrade the performance of other traffic sharing the path and even result in congestion collapse. Applications that support an uncontrolled or unadaptive transmission behavior SHOULD NOT do so by default and SHOULD instead require users to explicitly enable this mode of operation, and they SHOULD verify that sufficient path capacity has been reserved for them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、いくつかのバルク転送アプリケーションは、任意の輻輳制御機構を実装し、代わりに、予約パス能力を横切って伝達に依存しないように選択することができる（セクション3.1.9参照）。これは、制限されたネットワーク環境のサブセットのために許容可能な選択肢かもしれませんが、ノーによって、より広いインターネット上での操作のための安全な練習を意味しています。このようなアプリケーションのUDPトラフィックがプロビジョニングされていないインターネットの経路に漏れ出した場合、それが大幅にパスを共有する他のトラフィックのパフォーマンスが低下しても、輻輳崩壊につながることができます。制御不能またはunadaptive伝送の動作をサポートするアプリケーションは、デフォルトでは、そうすべきではなく、代わりに、明示的にこの動作モードを有効にするために、ユーザーが必要な場合、彼らは十分なパス能力が彼らのために予約されていることを確認する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. Low Data-Volume Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. 低いデータ容量アプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When applications that at any time exchange only a few UDP datagrams with a destination implement TFRC or one of the other congestion control schemes in Section 3.1.2, the network sees little benefit, because those mechanisms perform congestion control in a way that is only effective for longer transmissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それらのメカニズムが唯一の効果的な方法で輻輳制御を行うので、いつでも交換で先とほんの数UDPデータグラムは、TFRCを実装するか、3.1.2項では、他の輻輳制御方式の一つのアプリケーションは、ネットワークは、ほとんど利益を見ているとき長い伝送のため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that at any time exchange only a few UDP datagrams with a destination SHOULD still control their transmission behavior by not sending on average more than one UDP datagram per RTT to a destination. Similar to the recommendation in [RFC1536], an application SHOULD maintain an estimate of the RTT for any destination with which it communicates using the methods specified in Section 3.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いつでも交換で先とほんの数UDPデータグラムは、まだ先に平均でRTTごとに複数のUDPデータグラムを送信しないことにより、それらの送信動作を制御する必要がありますアプリケーション。 [RFC1536]で推薦と同様、アプリケーションはセクション3.1.1で指定された方法を使用して通信する任意の宛先のRTTの推定値を維持しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications cannot maintain a reliable RTT estimate for a destination. These applications do not need to or are unable to use protocol timers to measure the RTT (Section 3.1.1). Two cases can be identified:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションでは、目的地のための信頼性の高いRTT推定値を維持することはできません。これらのアプリケーションは、必要にまたはRTT（セクション3.1.1）を測定するプロトコルタイマーを使用することはできませんしないでください。二つのケースを識別することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The first case is that of applications that exchange too few UDP datagrams with a peer to establish a statistically accurate RTT estimate but that can monitor the reliability of transmission (Section 3.3). Such applications MAY use a predetermined transmission interval that is exponentially backed off when packets are deemed lost. TCP specifies an initial value of 1 second [RFC6298], which is also RECOMMENDED as an initial value for UDP applications. Some low data-volume applications, e.g., SIP [RFC3261] and General Internet Signaling Transport (GIST) [RFC5971] use an interval of 500 ms, and shorter values are likely problematic in many cases. As in the previous case, note that the initial timeout is not the maximum possible timeout, see Section 3.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.最初のケースは、統計的に正確なRTT推定を確立するためにピアと少なすぎるUDPデータグラムを交換するが、それは、送信（セクション3.3）の信頼性を監視することができるアプリケーションのことです。そのようなアプリケーションは、パケットが失われたとみなされる場合、指数関数的バックオフされた所定の送信間隔を使用するかもしれません。 TCPはまた、UDPアプリケーションのための初期値として推奨されている1次の[RFC6298]の初期値を指定します。いくつかの低データ・ボリューム・アプリケーション、例えば、SIP [RFC3261]および一般インターネットシグナリングトランスポート（GIST）[RFC5971] 500ミリ秒の間隔を使用し、より短い値は、多くの場合、可能性が問題となります。前の場合のように、セクション3.1.1を参照してください、最初のタイムアウトが可能な最大タイムアウトではないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A second case of applications cannot maintain an RTT estimate for a destination, because the destination does not send return traffic. Such applications SHOULD NOT send more than one UDP datagram every 3 seconds and SHOULD use an even less aggressive rate when possible. Shorter values are likely problematic in many cases. Note that the sending rate in this case must be more conservative than in the previous cases, because the lack of return traffic prevents the detection of packet loss, i.e., congestion, and the application therefore cannot perform exponential back off to reduce load.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宛先はリターントラフィックを送信しないので、2アプリケーションの第二の場合は、送信先のRTT推定値を維持することはできません。このようなアプリケーションは、複数のUDPデータグラムごとに3秒を送るべきではありませんし、可能な場合でも、あまり積極的でレートを使用すべきです。短い値は、多くの場合、可能性が問題となっています。リターントラフィックの欠如が、すなわち、輻輳、パケット損失の検出を防止するため、この場合の送信レートは、前のケースよりも保守的でなければならないことに注意してください、そしてアプリケーションは、したがって、負荷を軽減するバックオフ指数行うことができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.4. Applications Supporting Bidirectional Communications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.4. 双方向通信をサポートするアプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that communicate bidirectionally SHOULD employ congestion control for both directions of the communication. For example, for a client-server, request-response-style application, clients SHOULD congestion-control their request transmission to a server, and the server SHOULD congestion-control its responses to the clients. Congestion in the forward and reverse directions is uncorrelated, and an application SHOULD either independently detect and respond to congestion along both directions or limit new and retransmitted requests based on acknowledged responses across the entire round-trip path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双方向通信アプリケーションは、通信の両方向のための輻輳制御を採用するべきです。例えば、クライアント・サーバー、リクエスト・レスポンス・スタイルのアプリケーションのために、クライアントはサーバーへのリクエスト送信を混雑制御する必要があり、サーバはクライアントへの応答を輻輳制御する必要があります。前方で渋滞と逆方向には無相関であり、アプリケーションは単独検出し、両方の方向に沿って混雑に応じるか、全体の往復路を挟んで認め応答に基づいて、新たな再送要求を制限する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.5. Implications of RTT and Loss Measurements on Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.5. 輻輳制御のRTTの影響と損失の測定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transports such as TCP, SCTP, and DCCP provide timely detection of congestion that results in an immediate reduction of their maximum sending rate when congestion is experienced. This reaction is typically completed 1-2 RTTs after loss/congestion is encountered. Applications using UDP SHOULD implement a congestion control scheme that provides a prompt reaction to signals indicating congestion (e.g., by reducing the rate within the next RTT following a congestion signal).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このようTCP、SCTPとして搬送し、DCCPは輻輳が経験されたときに彼らの最大送信レートの即時減少をもたらす輻輳のタイムリーな検出を提供します。損失/輻輳が発生した後、この反応は、典型的には1-2のRTTを完了しています。 UDPを使用するアプリケーションは、（輻輳信号の次のRTT内の速度を減少させることによって、例えば）輻輳を示す信号にプロンプ​​ト反応を提供する輻輳制御方式を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operation of a UDP congestion control algorithm can be very different from the way TCP operates. This includes congestion controls that respond on timescales that fit applications that cannot usefully work within the &#34;change rate every RTT&#34; model of TCP. Applications that experience a low or varying RTT are particularly vulnerable to sampling errors (e.g., due to measurement noise or timer accuracy). This suggests the need to average loss/congestion and RTT measurements over a longer interval; however, this also can contribute additional delay in detecting congestion. Some applications may not react by reducing their sending rate immediately for various reasons, including the following: RTT and loss measurements are only made periodically (e.g., using RTCP), additional time is required to filter information, or the application is only able to change its sending rate at predetermined interval (e.g., some video codecs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP輻輳制御アルゴリズムの動作は、TCPの動作方法とは全く異なる可能性があります。これは有効「変化率ごとにRTT」TCPのモデル内で働くことができない用途に合わせてタイムスケールに対応輻輳コントロールが含まれています。低いまたは変化RTTを経験するアプリケーションは、サンプリングエラー（例えば、起因する測定ノイズやタイマ精度）を特に受けやすいです。これは、より長い間隔にわたって平均損失/輻輳及びRTT測定する必要性を示唆しています。しかし、これはまた、輻輳を検出する際の追加の遅延を貢献することができます。一部のアプリケーションでは、以下を含む、様々な理由のためにすぐに送信速度を低下させることによって反応しないことがあります。RTTおよび損失測定が周期的にのみ形成されている（例えば、RTCPを使用して）、追加の時間が情報をフィルタリングするために必要な、またはアプリケーションが変更することができるだけです所定の間隔でその送信レート（例えば、いくつかのビデオコーデック）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When designing a congestion control algorithm, the designer therefore needs to consider the total time taken to reduce the load following a lack of feedback or a congestion event. An application where the most recent RTT measurement is smaller than the actual RTT or the measured loss rate is smaller than the current rate, can result in over estimating the available capacity. Such over-estimation can result in a sending rate that creates congestion to the application or other flows sharing the path capacity, and can contribute to congestion collapse -- both of these need to be avoided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御アルゴリズムを設計する場合、設計者は、したがって、フィードバックの欠如や輻輳イベント、次の負荷を軽減するのに要する合計時間を考慮する必要があります。最新のRTT測定値が実際のRTTよりも小さい又は測定損失率が現在のレートよりも小さくなるアプリケーションは、利用可能な容量を推定する上で生じ得ます。これらの両方を回避する必要がある - そのような過大評価は、アプリケーションやパス能力を共有する他のフローに輻輳を生成し、輻輳崩壊に寄与することができる送信速度をもたらすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A congestion control designed for UDP SHOULD respond as quickly as possible when it experiences congestion, and it SHOULD take into account both the loss rate and the response time when choosing a new rate. The implemented congestion control scheme SHOULD result in bandwidth (capacity) use that is comparable to that of TCP within an order of magnitude, so that it does not starve other flows sharing a common bottleneck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは混雑を経験するとき、UDPのために設計された輻輳制御が可能な限り迅速に対応すべきである、と新しいレートを選択する際に、それを考慮に損失率と応答時間の両方を取る必要があります。実施輻輳制御方式は、共通のボトルネックを共有している他のフローを飢えさせないように、大きさのオーダー以内にそのTCPのそれに匹敵する帯域幅を使用する（容量）をもたらすはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.6. Burst Mitigation and Pacing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.6. バースト緩和とペーシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP applications SHOULD provide mechanisms to regulate the bursts of transmission that the application may send to the network. Many TCP and SCTP implementations provide mechanisms that prevent a sender from generating long bursts at line-rate, since these are known to induce early loss to applications sharing a common network bottleneck. The use of pacing with TCP [ALLMAN] has also been shown to improve the coexistence of TCP flows with other flows. The need to avoid excessive transmission bursts is also noted in specifications for applications (e.g., [RFC7143]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPアプリケーションは、アプリケーションがネットワークに送信することができる伝送のバーストを調節するためのメカニズムを提供しなければなりません。これらは一般的なネットワークのボトルネックを共有しているアプリケーションへの早期の損失を誘発することが知られているので、多くのTCPとSCTPの実装は、ラインレートで長いバーストを生成するから、送信者を防ぐメカニズムを提供します。 TCP [ALLMAN]とペーシングの使用はまた、TCPの共存を改善することが示されている他のフローと流れます。過剰な送信バーストを回避する必要性は、アプリケーション（例えば、[RFC7143]）の仕様にも留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even low data-volume UDP flows may benefit from packet pacing, e.g., an application that sends three copies of a packet to improve robustness to loss is RECOMMENDED to pace out those three packets over several RTTs, to reduce the probability that all three packets will be lost due to the same congestion event (or other event, such as burst corruption).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
でも低いデータボリュームUDPフローは、パケットペーシング、例えばから利益を得ることができる、損失への堅牢性を向上させるために、パケットの3つのコピーを送信するアプリケーションは、すべての3つのパケットがする確率を減らすために、いくつかのRTTを超えるこれらの3つのパケットをペーシングする推奨されます同じ輻輳イベントのために失わ（又はバースト破損などの他のイベント）します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.7. Explicit Congestion Notification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.7. 明示的輻輳通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet applications can use Explicit Congestion Notification (ECN) [RFC3168] to gain benefits for the services they support [RFC8087].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネットアプリケーションは、明示的輻輳通知（ECN）、彼らがサポートするサービスのために利益を得るために[RFC3168] [RFC8087]を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet transports, such as TCP, provide a set of mechanisms that are needed to utilize ECN. ECN operates by setting an ECN-capable codepoint (ECT(0) or ECT(1)) in the IP header of packets that are sent. This indicates to ECN-capable network devices (routers and other devices) that they may mark (set the congestion experienced, Congestion Experience (CE) codepoint) rather than drop the IP packet as a signal of incipient congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPのようなインターネットのトランスポートは、ECNを利用するために必要なメカニズムのセットを提供します。 ECNは、送信されるパケットのIPヘッダ内のECN-可能なコードポイント（ECT（0）かECT（1））を設定することによって動作します。これは、彼らが（経験輻輳を設定する輻輳エクスペリエンス（CE）コードポイント）よりもむしろ初期輻輳信号としてIPパケットをドロップマークすることができることがECN対応のネットワークデバイス（ルータおよび他のデバイス）に示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP applications can also benefit from enabling ECN, providing that the API supports ECN and that they implement the required protocol mechanisms to support ECN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPアプリケーションは、APIがECNをサポートしており、彼らはECNをサポートするために必要なプロトコルメカニズムを実装することをことを提供し、ECNを有効にするの恩恵を受けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of mechanisms required for an application to use ECN over UDP are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP上でECNを使用するアプリケーションに必要な一連のメカニズムは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sender MUST provide a method to determine (e.g., negotiate) that the corresponding application is able to provide ECN feedback using a compatible ECN method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O送信者は、対応するアプリケーションが互換性ECN法を使用してECNフィードバックを提供することが可能であること（例えば、交渉）を決定するための方法を提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A receiver that enables the use of ECN for a UDP port MUST check the ECN field at the receiver for each UDP datagram that it receives on this port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O UDPポートのECNの使用を可能に受信機は、それがこのポートで受信した各UDPデータグラムの受信機でのECNフィールドをチェックしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The receiving application needs to provide feedback of congestion information to the sending application. This MUST report the presence of datagrams received with a CE-mark by providing a mechanism to feed this congestion information back to the sending application. The feedback MAY also report the presence of ECT(1) and ECT(0)/Not-ECT packets [RFC7560]. ([RFC3168] and [RFC7560] specify methods for TCP.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O受信側アプリケーションは、送信側アプリケーションに渋滞情報のフィードバックを提供する必要があります。これは、送信側アプリケーションに戻し、この輻輳情報を供給するための機構を提供することによって、CEマークを用いて、受信したデータグラムの存在を報告しなければなりません。フィードバックはまた、ECT（1）及びECT（0）/未-ECTパケット[RFC7560]の存在を報告することがあります。 （[RFC3168]及び[RFC7560] TCPのための方法を指定してください。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An application sending ECN-capable datagrams MUST provide an appropriate congestion reaction when it receives feedback indicating that congestion has been experienced. This ought to result in reduction of the sending rate by the UDP congestion control method (see Section 3.1) that is not less than the reaction of TCP under equivalent conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは混雑が経験されたことを示すフィードバックを受信した場合、O ECN-可能なデータグラムを送信するアプリケーションは、適切な輻輳反応を提供しなければなりません。これは、同等の条件下で、TCPの反応よりも小さくないUDP輻輳制御方法（3.1節を参照）によって送信速度の低下をもたらすべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sender SHOULD detect network paths that do not support the ECN field correctly. When detected, they need to either conservatively react to congestion or even fall back to not using ECN [RFC8087]. This method needs to be robust to changes within the network path that may occur over the lifetime of a session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O送信者が正しくECNフィールドをサポートしていないネットワークパスを検出する必要があります。検出されたとき、彼らはどちらか控えめに混雑に反応したりしてもECN [RFC8087]を使用していないにフォールバックする必要があります。この方法は、セッションの寿命にわたって起こり得るネットワーク経路内の変化に対してロバストである必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sender is encouraged to provide a mechanism to detect and react appropriately to misbehaving receivers that fail to report CE-marked packets [RFC8087].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O送信者が検出およびCE-マーキングされたパケット[RFC8087]を報告することができない受信機の誤動作に適切に反応するメカニズムを提供することが奨励されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679] provides guidance and an example of this support, by describing a method to allow ECN to be used for UDP-based applications using the Real-Time Protocol (RTP). Applications that cannot provide this set of mechanisms, but wish to gain the benefits of using ECN, are encouraged to use a transport protocol that already supports ECN (such as TCP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679]はECNは、リアルタイムプロトコル（RTP）を使用して、UDPベースのアプリケーションに使用できるようにする方法を説明することによって、指導及びこのサポートの例を提供します。メカニズムのこのセットを提供しますが、ECNを使用することの利点を得ることを望むことができないアプリケーションは、既に（TCPのような）ECNをサポートするトランスポートプロトコルを使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.8. Differentiated Services Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.8. 差別化サービスモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application using UDP can use the differentiated services (DiffServ) Quality of Service (QoS) framework. To enable differentiated services processing, a UDP sender sets the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPを使用するアプリケーションは、差別化サービス（DiffServの）サービス品質（QoS）のフレームワークを使用することができます。差別化サービス処理を有効にするには、UDP送信者が設定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Differentiated Services Code Point (DSCP) field [RFC2475] in packets sent to the network. Normally, a UDP source/destination port pair will set a single DSCP value for all packets belonging to a flow, but multiple DSCPs can be used as described later in this section. A DSCP may be chosen from a small set of fixed values (the class selector code points), or from a set of recommended values defined in the Per Hop Behavior (PHB) specifications, or from values that have purely local meanings to a specific network that supports DiffServ. In general, packets may be forwarded across multiple networks between source and destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークに送信されたパケット内のDSCP（Differentiated Services Code Point）フィールド[RFC2475]。通常、UDP送信元/宛先ポートのペアは、フローに属するすべてのパケットのための単一のDSCP値を設定しますが、このセクションで後述するように複数のDSCPを使用することができます。 DSCPは、特定のネットワークに固定値（クラスセレクタコードポイント）の小集合から、又はパーホップの動作（PHB）の仕様で定義された推奨値のセットから、または純粋にローカルな意味を有する値から選択することができますそれは、DiffServのをサポートしています。一般的に、パケットが送信元と宛先との間に複数のネットワークを介して転送されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In setting a non-default DSCP value, an application must be aware that DSCP markings may be changed or removed between the traffic source and destination. This has implications on the design of applications that use DSCPs. Specifically, applications SHOULD be designed not to rely on implementation of a specific network treatment; they need instead to implement congestion control methods to determine if their current sending rate is inducing congestion in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デフォルト以外のDSCP値を設定する際に、アプリケーションは、DSCPマーキングは、トラフィック送信元と宛先の間で変更または削除されてもよいことに注意しなければなりません。これは、のDSCPを使用するアプリケーションの設計上の意味合いを持っています。具体的には、アプリケーションが特定のネットワーク処理の実装に依存しないように設計されるべきです。彼らは現在の送信レートは、ネットワーク内の輻輳を誘導しているかどうかを判断する輻輳制御方法を実装する代わりに、必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657] describes the implications of using DSCPs and provides recommendations on using multiple DSCPs within a single network five-tuple (source and destination addresses, source and destination ports, and the transport protocol used, in this case, UDP or UDP-Lite), and particularly the expected impact on transport protocol interactions, with congestion control or reliability functionality (e.g., retransmission, reordering). Use of multiple DSCPs can result in reordering by increasing the set of network forwarding resources used by a sender. It can also increase exposure to resource depletion or failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657]のDSCPを使用することの意味を説明し、単一のネットワーク内で複数のDSCPを使用して、5タプル（送信元アドレスと宛先アドレス、送信元ポートと宛先ポート、及び、この場合には、UDPまたはUDP-Liteの使用されるトランスポートプロトコル）に勧告を提供輻輳制御や信頼性機能（例えば、再送、並べ替え）を有するトランスポートプロトコル相互作用に、特に期待される影響、。複数のDSCPを使用すると、送信者が使用するネットワーク転送リソースのセットを増やすことで、並べ替えにつながることができます。また、資源の枯渇や故障への露出を増やすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.9. QoS, Pre-Provisioned, or Reserved Capacity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.9.  QoSの、事前プロビジョニング、または予約済み容量
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF usually specifies protocols for use within the Best Effort General Internet. Sometimes it is relevant to specify protocols with a different applicability. An application using UDP can use the integrated services QoS framework. This framework is usually made available within controlled environments (e.g., within a single administrative domain or bilaterally agreed connection between domains). Applications intended for the Internet SHOULD NOT assume that QoS mechanisms are supported by the networks they use, and therefore need to provide congestion control, error recovery, etc., in case the actual network path does not provide provisioned service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、通常、ベストエフォート一般的なインターネット内で使用するためのプロトコルを指定します。時には異なる適用でプロトコルを指定することが適切です。 UDPを使用するアプリケーションは、統合サービスのQoSフレームワークを使用することができます。このフレームワークは、通常、（例えば、単一の管理ドメイン内または両側がドメイン間の接続を合意した）制御された環境内で利用可能になります。インターネットのために意図されたアプリケーションは、QoSメカニズムは、彼らが使用するネットワークによってサポートされていることを前提とし、そのため実際のネットワークパスがプロビジョニングされたサービスを提供していない場合には、などの輻輳制御、エラー回復を提供する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some UDP applications are only expected to be deployed over network paths that use pre-provisioned capacity or capacity reserved using dynamic provisioning, e.g., through the Resource Reservation Protocol (RSVP). Multicast applications are also used with pre-provisioned capacity (e.g., IPTV deployments within access networks). These applications MAY choose not to implement any congestion control mechanism and instead rely on transmitting only on paths where the capacity is provisioned and reserved for this use. This might be an acceptable choice for a subset of restricted networking environments, but is by no means a safe practice for operation over the wider Internet. Applications that choose this option SHOULD carefully and in detail describe the provisioning and management procedures that result in the desired containment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのUDPアプリケーションは、唯一の事前プロビジョニング能力又は容量を使用してネットワークパス上に展開されると予想されるリソース予約プロトコル（RSVP）を介して、例えば、動的プロビジョニングを使用して予約。マルチキャストアプリケーションはまた、事前にプロビジョニングされた容量が使用されている（例えば、アクセスネットワーク内のIPTVの展開）。これらのアプリケーションは、任意の輻輳制御機構を実装し、代わりにだけ容量がプロビジョニングおよびこの使用のために予約されているパスに送信するに依存しないこともできます。これは、制限されたネットワーク環境のサブセットのために許容可能な選択肢かもしれませんが、ノーによって、より広いインターネット上での操作のための安全な練習を意味しています。このオプションを選択するアプリケーションは、慎重かつ詳細に必要な封じ込めにつながるプロビジョニングと管理手順を記述する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that support an uncontrolled or unadaptive transmission behavior SHOULD NOT do so by default and SHOULD instead require users to explicitly enable this mode of operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御不能またはunadaptive伝送の動作をサポートするアプリケーションは、デフォルトでは、そうすべきではなく、代わりに、明示的にこの動作モードを有効にするには、ユーザーに要求すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications designed for use within a controlled environment (see Section 3.6) may be able to exploit network management functions to detect whether they are causing congestion, and react accordingly. If the traffic of such applications leaks out into unprovisioned Internet paths, it can significantly degrade the performance of other traffic sharing the path and even result in congestion collapse. Protocols designed for such networks SHOULD provide mechanisms at the network edge to prevent leakage of traffic into unprovisioned Internet paths (e.g., [RFC7510]). To protect other applications sharing the same path, applications SHOULD also deploy an appropriate circuit breaker, as described in Section 3.1.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御された環境内で使用するために設計されたアプリケーション（セクション3.6を参照）は、輻輳を引き起こし、それに応じて反応しているかどうかを検出するために、ネットワーク管理機能を利用することができるかもしれません。このようなアプリケーションのトラフィックがプロビジョニングされていないインターネットの経路に漏れ出した場合、それが大幅にパスを共有する他のトラフィックのパフォーマンスが低下しても、輻輳崩壊につながることができます。このようなネットワークのために設計されたプロトコルは、プロビジョニングされていないインターネット経路（例えば、[RFC7510]）にトラフィックの漏洩を防止するために、ネットワークエッジでのメカニズムを提供しなければなりません。セクション3.1.10に記載したのと同じ経路を共有する他のアプリケーションを保護するために、アプリケーションはまた、適切な回路ブレーカを展開する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An IETF specification targeting a controlled environment is expected to provide an applicability statement that restricts the application to the controlled environment (see Section 3.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御された環境をターゲットにIETF仕様は、制御された環境（セクション3.6を参照）への応用を制限適用性声明を提供することが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.10. Circuit Breaker Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.10. サーキットブレーカーのメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A transport circuit breaker is an automatic mechanism that is used to estimate the congestion caused by a flow, and to terminate (or significantly reduce the rate of) the flow when excessive congestion is detected [RFC8084]. This is a safety measure to prevent congestion collapse (starvation of resources available to other flows), essential for an Internet that is heterogeneous and for traffic that is hard to predict in advance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
搬送回路遮断器は、流れによって生じる輻輳を推定するために使用される自動機構であり、終了（または有意の速度を低下させる）ために、過剰な輻輳が検出された流量[RFC8084]。これは不均一であり、インターネットのために事前に予測することは困難である交通渋滞のために不可欠の崩壊を防止するための安全対策（他のフローに利用可能なリソースの飢餓）、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A circuit breaker is intended as a protection mechanism of last resort. Under normal circumstances, a circuit breaker should not be triggered; it is designed to protect things when there is severe overload. The goal is usually to limit the maximum transmission rate that reflects the available capacity of a network path. Circuit breakers can operate on individual UDP flows or traffic aggregates, e.g., traffic sent using a network tunnel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
回路ブレーカーが最後の保護メカニズムとして意図されています。通常の状況下では、回路遮断器がトリガされるべきではありません。厳しい過負荷があるとき、物事を保護するように設計されています。目標は、ネットワーク経路の利用可能な容量を反映最大伝送レートを制限することが通常です。回路遮断器は、例えば、個々のUDPフローまたはトラフィック凝集体のネットワークトンネルを使用して送信されるトラフィックを操作することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8084] provides guidance and examples on the use of circuit breakers. The use of a circuit breaker in RTP is specified in [RFC8083].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8084]は回路遮断器の使用に関する指針および例を提供します。 RTPにおける回路遮断器の使用は、[RFC8083]で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications used in the general Internet SHOULD implement a transport circuit breaker if they do not implement congestion control or operate a low data-volume service (see Section 3.6). All applications MAY implement a transport circuit breaker [RFC8084] and are encouraged to consider implementing at least a slow-acting transport circuit breaker to provide a protection of last resort for their network traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らは、低データ・ボリューム・サービスを輻輳制御を実装したり、動作しない場合は、一般的なインターネットで使用されるアプリケーションは、トランスポート遮断器を実装する必要があります（セクション3.6を参照してください）。すべてのアプリケーションは、トランスポート遮断器[RFC8084]を実装するかもしれなくて、自分のネットワークトラフィックのために最後の保護を提供するために、少なくとも遅効性輸送遮断器の実装を検討することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.11. UDP Tunnels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.11.  UDPトンネル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One increasingly popular use of UDP is as a tunneling protocol [INT-TUNNELS], where a tunnel endpoint encapsulates the packets of another protocol inside UDP datagrams and transmits them to another tunnel endpoint, which decapsulates the UDP datagrams and forwards the original packets contained in the payload. One example of such a protocol is Teredo [RFC4380]. Tunnels establish virtual links that appear to directly connect locations that are distant in the physical Internet topology and can be used to create virtual (private) networks. Using UDP as a tunneling protocol is attractive when the payload protocol is not supported by middleboxes that may exist along the path, because many middleboxes support transmission using UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPの一のますます普及使用は、トンネルエンドポイントは、UDPデータグラム内の別のプロトコルのパケットをカプセル化し、UDPデータグラムのカプセル化を解除し、別のトンネルエンドポイントに送信し、中に含まれる元のパケットを転送する[INT-TUNNELS]、トンネリングプロトコルとしてですペイロード。そのようなプロトコルの一例は、Teredoの[RFC4380]です。トンネルは、直接物理的なインターネット・トポロジーで離れていると仮想（プライベート）ネットワークを作成するために使用することができる場所を接続するために表示される仮想リンクを確立します。ペイロードプロトコルは経路に沿って存在し得る中間装置によってサポートされていない場合、多くの中間装置は、UDPを用いて送信をサポートするため、トンネリングプロトコルとしてUDPを使用することは、魅力的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Well-implemented tunnels are generally invisible to the endpoints that happen to transmit over a path that includes tunneled links. On the other hand, to the routers along the path of a UDP tunnel, i.e., the routers between the two tunnel endpoints, the traffic that a UDP tunnel generates is a regular UDP flow, and the encapsulator and decapsulator appear as regular UDP-sending and UDP-receiving applications. Because other flows can share the path with one or more UDP tunnels, congestion control needs to be considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まあ、実装のトンネルは、トンネルのリンクを含むパスを経由送信するために起こるのエンドポイントに、一般的には見えません。一方、UDPトンネルの経路に沿ったルータに、すなわち、2つのトンネルエンドポイント間のルータは、UDPトンネルが生成するトラフィックは、通常のUDPフローであり、カプセル化およびカプセル開放装置は、通常のUDP-送信として表示しますそして、アプリケーションをUDP-受けます。他のフローは、1つまたは複数のUDPトンネルでパスを共有することができるので、輻輳制御を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two factors determine whether a UDP tunnel needs to employ specific congestion control mechanisms: first, whether the payload traffic is IP-based; and second, whether the tunneling scheme generates UDP traffic at a volume that corresponds to the volume of payload traffic carried within the tunnel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
二つの要因がUDPトンネルが特定の輻輳制御機構を採用する必要があるかどうかを判断する第一、ペイロードトラフィックはIPベースであるかどうか。第二、トンネリング方式は、トンネル内で搬送されるペイロードトラフィックの量に相当する量でUDPトラフィックを生成するかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP-based unicast traffic is generally assumed to be congestion controlled, i.e., it is assumed that the transport protocols generating IP-based unicast traffic at the sender already employ mechanisms that are sufficient to address congestion on the path. Consequently, a tunnel carrying IP-based unicast traffic should already interact appropriately with other traffic sharing the path, and specific congestion control mechanisms for the tunnel are not necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPベースのユニキャストトラフィックは、一般的に、輻輳制御であると仮定され、すなわち、送信時にIPベースのユニキャストトラフィックを生成するトランスポート・プロトコルが既に経路上のアドレスの輻輳するのに十分なメカニズムを採用しているものとします。その結果、トンネル運ぶIPベースのユニキャストトラフィックは既にパスを共有する他のトラフィックと適切に相互作用する必要があり、トンネルのための特定の輻輳制御機構は不要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, if the IP traffic in the tunnel is known not to be congestion controlled, additional measures are RECOMMENDED to limit the impact of the tunneled traffic on other traffic sharing the path. For the specific case of a tunnel that carries IP multicast traffic, see Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トンネル内のIPトラフィックが輻輳制御ではないことが知られている場合には、追加的な措置がパスを共有する他のトラフィックにトンネルトラフィックの影響を制限するために推奨されています。 IPマルチキャストトラフィックを運ぶトンネルの特定の場合については、セクション4.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following guidelines define these possible cases in more detail:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のガイドラインは、より詳細にこれらの可能なケースを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is IP based and congestion controlled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.トンネルは、ペイロードトラフィックの量に相当する量でUDPトラフィックを生成し、ペイロードトラフィックはIPベースの輻輳を制御します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       This is arguably the most common case for Internet tunnels.  In
       this case, the UDP tunnel SHOULD NOT employ its own congestion
       control mechanism, because congestion losses of tunneled traffic
       will already trigger an appropriate congestion response at the
       original senders of the tunneled traffic.  A circuit breaker
       mechanism may provide benefit by controlling the envelope of the
       aggregated traffic.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that this guideline is built on the assumption that most IP-based communication is congestion controlled. If a UDP tunnel is used for IP-based traffic that is known to not be congestion controlled, the next set of guidelines applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
このガイドラインは、ほとんどのIPベースの通信が輻輳制御であることを前提に構築されていることに注意してください。 UDPトンネルが輻輳制御されていないことが知られているIPベースのトラフィックに使用されている場合は、ガイドラインの次のセットが適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is not known to be IP based, or is known to be IP based but not congestion controlled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.トンネルがペイロードトラフィックの量に相当する量でUDPトラフィックを生成し、ペイロードトラフィックがIPをベースとしていることが知られていない、またはIPベースではなく、輻輳を制御することが知られています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       This can be the case, for example, when some link-layer protocols
       are encapsulated within UDP (but not all link-layer protocols;
       some are congestion controlled).  Because it is not known that
       congestion losses of tunneled non-IP traffic will trigger an
       appropriate congestion response at the senders, the UDP tunnel
       SHOULD employ an appropriate congestion control mechanism or
       circuit breaker mechanism designed for the traffic it carries.
       Because tunnels are usually bulk-transfer applications as far as
       the intermediate routers are concerned, the guidelines in
       Section 3.1.2 apply.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. A tunnel generates UDP traffic at a volume that does not correspond to the volume of payload traffic, independent of whether the payload traffic is IP based or congestion controlled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.トンネルがペイロードトラフィックをIPベースまたは輻輳が制御されているかどうかとは無関係にペイロードトラフィックの量に対応していないボリュームでUDPトラフィックを生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       Examples of this class include UDP tunnels that send at a
       constant rate, increase their transmission rates under loss, for
       example, due to increasing redundancy when Forward Error
       Correction is used, or are otherwise unconstrained in their
       transmission behavior.  These specialized uses of UDP for
       tunneling go beyond the scope of the general guidelines given in
       this document.  The implementer of such specialized tunnels
       SHOULD carefully consider congestion control in the design of
       their tunneling mechanism and SHOULD consider use of a circuit
       breaker mechanism.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type of encapsulated payload might be identified by a UDP port; identified by an Ethernet Type or IP protocol number. A tunnel SHOULD provide mechanisms to restrict the types of flows that may be carried by the tunnel. For instance, a UDP tunnel designed to carry IP needs to filter out non-IP traffic at the ingress. This is particularly important when a generic tunnel encapsulation is used (e.g., one that encapsulates using an EtherType value). Such tunnels SHOULD provide a mechanism to restrict the types of traffic that are allowed to be encapsulated for a given deployment (see [INT-TUNNELS]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カプセル化されたペイロードのタイプは、UDPポートによって識別される可能性があります。イーサネットタイプまたはIPプロトコル番号で識別されます。トンネルは、トンネルによって実施することができるフローのタイプを制限するためのメカニズムを提供しなければなりません。たとえば、IPを運ぶために設計されたUDPトンネルは入口で非IPトラフィックをフィルタリングする必要があります。一般的なトンネルカプセル化が使用される場合、これは特に重要である（例えば、イーサタイプ（EtherType）値を使用してカプセル化するもの）。このようなトンネルは、（[INT-TUNNELS]参照）指定された展開のためにカプセル化することが許可されているトラフィックのタイプを制限するためのメカニズムを提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Designing a tunneling mechanism requires significantly more expertise than needed for many other UDP applications, because tunnels are usually intended to be transparent to the endpoints transmitting over them, so they need to correctly emulate the behavior of an IP link [INT-TUNNELS], for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トンネリングメカニズムを設計することトンネルは通常、それらの上に送信するエンドポイントに透明であることを意図しているので、他の多くのUDPアプリケーションのために必要とされるよりもはるかに多くの専門知識が必要なので、彼らは[INT-TUNNELS]正しくIPリンクの動作をエミュレートする必要がある、のために例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Requirements for tunnels that carry or encapsulate using ECN code points [RFC6040].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
搬送又はECNコードポイント[RFC6040]を使用してカプセル化するトンネルのO要件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Usage of the IP DSCP field by tunnel endpoints [RFC2983].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トンネルエンドポイント[RFC2983]でIP DSCPフィールドのOの使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Encapsulation considerations in the design of tunnels [ENCAP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トンネルの設計におけるOのカプセル化の考慮事項[ENCAP]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Usage of ICMP messages [INT-TUNNELS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INT-TUNNELS] ICMPメッセージのOの使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Handling of fragmentation and packet size for tunnels [INT-TUNNELS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トンネルのフラグメンテーションおよびパケットサイズのO処理[INT-TUNNELS]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Source port usage for tunnels designed to support equal cost multipath (ECMP) routing (see Section 5.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
等価コストマルチパス（ECMP）ルーティングをサポートするように設計されたトンネルのOソースポートの使用（5.1.1項を参照してください）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Guidance on the need to protect headers [INT-TUNNELS] and the use of checksums for IPv6 tunnels (see Section 3.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダー[INT-トンネル]保護する必要があり、IPv6トンネルのためのチェックサムの使用に関する指針（セクション3.4.1を参照）O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Support for operations and maintenance [INT-TUNNELS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O操作や保守のためのサポート[INT-TUNNELS]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the same time, the tunneled traffic is application traffic like any other from the perspective of the networks the tunnel transmits over. This document only touches upon the congestion control considerations for implementing UDP tunnels; a discussion of other required tunneling behavior is out of scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これと同時に、トンネルトラフィックは、トンネル上に送信ネットワークの観点から、他のようなアプリケーショントラフィックです。この文書では、唯一のUDPトンネルを実装するための輻輳制御考慮に触れます。他の必要なトンネルの挙動の議論は範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Message Size Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. メッセージサイズのガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP fragmentation lowers the efficiency and reliability of Internet communication. The loss of a single fragment results in the loss of an entire fragmented packet, because even if all other fragments are received correctly, the original packet cannot be reassembled and delivered. This fundamental issue with fragmentation exists for both IPv4 and IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPフラグメンテーションは、インターネット通信の効率と信頼性を低下させます。全フラグメントパケットの損失に単一フラグメント結果の損失、他のすべてのフラグメントが正しく受信された場合でも、元のパケットを再組み立てして配信することができないからです。フラグメンテーションとこの根本的な問題は、IPv4とIPv6の両方のために存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, some network address translators (NATs) and firewalls drop IP fragments. The network address translation performed by a NAT only operates on complete IP packets, and some firewall policies also require inspection of complete IP packets. Even with these being the case, some NATs and firewalls simply do not implement the necessary reassembly functionality; instead, they choose to drop all fragments. Finally, [RFC4963] documents other issues specific to IPv4 fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、一部のネットワークアドレス変換（NAT）とファイアウォールは、IPフラグメントをドロップします。 NATが実行するネットワークアドレス変換は、唯一の完全なIPパケットで動作し、一部のファイアウォールポリシーは、完全なIPパケットの検査を必要とします。でも、これらはケースであることに、いくつかのNATやファイアウォールは、単純に、必要な再構築機能を実装していません。代わりに、彼らはすべてのフラグメントをドロップすることを選択しました。最後に、[RFC4963]はIPv4のフラグメンテーションに固有の他の問題に関して説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to these issues, an application SHOULD NOT send UDP datagrams that result in IP packets that exceed the Maximum Transmission Unit (MTU) along the path to the destination. Consequently, an application SHOULD either use the path MTU information provided by the IP layer or implement Path MTU Discovery (PMTUD) itself [RFC1191] [RFC1981] [RFC4821] to determine whether the path to a destination will support its desired message size without fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの問題のため、アプリケーションは、目的地への経路に沿って最大転送単位（MTU）を超えるIPパケットにつながるUDPデータグラムを送るべきではありません。したがって、アプリケーションは、IP層によって提供される経路MTU情報を使用するか、または宛先へのパスが断片化することなく、その所望のメッセージサイズをサポートするかどうかを決定するために、パスMTUディスカバリ（PMTUD）自体[RFC1191]、[RFC1981]、[RFC4821]を実装すべきであるいずれか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the ICMP messages that enable path MTU discovery are being increasingly filtered by middleboxes (including Firewalls) [RFC4890]. When the path includes a tunnel, some devices acting as a tunnel ingress discard ICMP messages that originate from network devices over which the tunnel passes, preventing these from reaching the UDP endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
しかし、パスMTU探索を有効にICMPメッセージはますます[RFC4890]（ファイアウォールを含む）中間装置によってフィルタリングされます。経路はトンネルを含む場合、トンネル入口として作用するいくつかのデバイスは、UDPエンドポイントに到達し、これらを防止する、トンネルが通過する上のネットワークデバイスから発信ICMPメッセージを廃棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packetization Layer Path MTU Discovery (PLPMTUD) [RFC4821] does not rely upon network support for ICMP messages and is therefore considered more robust than standard PMTUD. It is not susceptible to &#34;black holing&#34; of ICMP messages. To operate, PLPMTUD requires changes to the way the transport is used: both to transmit probe packets and to account for the loss or success of these probes. This not only updates the PMTU algorithm, it also impacts loss recovery, congestion control, etc. These updated mechanisms can be implemented within a connection-oriented transport (e.g., TCP, SCTP, DCCP), but they are not a part of UDP; this type of feedback is not typically present for unidirectional applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットレイヤパスMTUディスカバリ（PLPMTUD）[RFC4821]はICMPメッセージのネットワークサポートに依存しないため、標準のPMTUDよりも強固と考えられています。これは、ICMPメッセージの「ブラックホール」の影響を受けません。プローブパケットを送信するために、これらのプローブの損失や成功を説明するために、両方：動作させるためには、PLPMTUDは、トランスポートが使用されている方法を変更する必要があります。これは、PMTUアルゴリズムを更新していないだけで、それも影響等が挙げられる。これらの更新のメカニズムは、接続指向のトランスポート（例えば、TCP、SCTP、DCCP）内に実装することができますが、彼らはUDPの一部ではない損失回復、輻輳制御、;フィードバックのこのタイプは、一方向の用途のために一般的に存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, PLPMTUD places additional design requirements on a UDP application that wishes to use this method. This is especially true for UDP tunnels, because the overhead of sending probe packets needs to be accounted for and may require adding a congestion control mechanism to the tunnel (see Section 3.1.11) as well as complicating the data path at a tunnel decapsulator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、PLPMTUDは、この方法を使用することを希望するUDPアプリケーションの追加設計要件を課します。プローブパケットを送信するオーバーヘッドが考慮される必要があり、トンネルに輻輳制御機構を追加することが必要かもしれないので、これは（セクション3.1.11を参照のこと）、ならびにトンネルカプセル開放装置におけるデータパスを複雑化、UDPトンネルに特に当てはまります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that do not follow the recommendation to do PMTU/PLPMTUD discovery SHOULD still avoid sending UDP datagrams that would result in IP packets that exceed the path MTU. Because the actual path MTU is unknown, such applications SHOULD fall back to sending messages that are shorter than the default effective MTU for sending (EMTU_S in [RFC1122]). For IPv4, EMTU_S is the smaller of 576 bytes and the first-hop MTU [RFC1122]. For IPv6, EMTU_S is 1280 bytes [RFC2460]. The effective PMTU for a directly connected destination (with no routers on the path) is the configured interface MTU, which could be less than the maximum link payload size. Transmission of minimum-sized UDP datagrams is inefficient over paths that support a larger PMTU, which is a second reason to implement PMTU discovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PMTU / PLPMTUD検出を行うための勧告に従わないアプリケーションは、まだパスMTUを超えるIPパケットにつながるUDPデータグラムを送信することは避けてください。実際のパスMTUが不明であるため、このようなアプリケーションは、（[RFC1122]でEMTU_S）を送信するためのデフォルトの有効MTUよりも短いメッセージの送信にフォールバックすべきです。 IPv4の場合、EMTU_Sは576バイトと最初のホップMTU [RFC1122]の小さい方です。 IPv6の場合、EMTU_S 1280バイト[RFC2460]です。 （パスにはルータで）直接接続された宛先の有効なPMTUは、最大リンクペイロードサイズよりも小さい可能性が設定されたインターフェイスMTUです。最小サイズのUDPデータグラムの送信は、PMTUディスカバリを実装するための第2の理由は、より大きなPMTUをサポートする経路上に非効率的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine an appropriate UDP payload size, applications MUST subtract the size of the IP header (which includes any IPv4 optional headers or IPv6 extension headers) as well as the length of the UDP header (8 bytes) from the PMTU size. This size, known as the Maximum Segment Size (MSS), can be obtained from the TCP/IP stack [RFC1122].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適切なUDPペイロードサイズを決定するために、アプリケーションは、（任意のIPv4オプションヘッダまたはIPv6拡張ヘッダを含む）IPヘッダのサイズならびにPMTUサイズからUDPヘッダ（8バイト）の長さを減算しなければなりません。最大セグメントサイズ（MSS）として知られるこのサイズは、TCP / IPスタック[RFC1122]から得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that do not send messages that exceed the effective PMTU of IPv4 or IPv6 need not implement any of the above mechanisms. Note that the presence of tunnels can cause an additional reduction of the effective PMTU [INT-TUNNELS], so implementing PMTU discovery may be beneficial.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4またはIPv6の有効PMTUを超えるメッセージを送信しないアプリケーションでは、上記のメカニズムのいずれかを実装する必要はありません。トンネルの存在は非常に有益であり得るPMTUディスカバリを実装する、有効なPMTU [INT-TUNNELS]の追加の減少を引き起こすことができることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that fragment an application-layer message into multiple UDP datagrams SHOULD perform this fragmentation so that each datagram can be received independently, and be independently retransmitted in the case where an application implements its own reliability mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のUDPデータグラムにアプリケーション層メッセージを断片化アプリケーションは、各データグラムは、独立して受信することができるように、この断片化を実行する必要があり、かつ独立して、アプリケーションが独自の信頼性メカニズムを実装する場合に再送されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Reliability Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 信頼性のガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application designers are generally aware that UDP does not provide any reliability, e.g., it does not retransmit any lost packets. Often, this is a main reason to consider UDP as a transport protocol. Applications that do require reliable message delivery MUST implement an appropriate mechanism themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーション設計者は、一般的にUDPは、任意の信頼性を提供しないことを知っている、例えば、それが失われたパケットを再送しません。多くの場合、これはトランスポートプロトコルとしてUDPを検討する主な理由です。信頼性の高いメッセージ配信を必要としないアプリケーションでは、適切なメカニズム自体を実装しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP also does not protect against datagram duplication, i.e., an application may receive multiple copies of the same UDP datagram, with some duplicates arriving potentially much later than the first. Application designers SHOULD handle such datagram duplication gracefully, and they may consequently need to implement mechanisms to detect duplicates. Even if UDP datagram reception triggers only idempotent operations, applications may want to suppress duplicate datagrams to reduce load.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPはまたすなわち、アプリケーションは、いくつかの重複がかなり後に最初よりも潜在的に到着して、同一のUDPデータグラムの複数のコピーを受信することができる、データグラム複製から保護しません。アプリケーション設計者は、正常なデータグラムの重複を処理する必要があり、彼らは結果的に重複を検出するためのメカニズムを実装する必要があるかもしれません。 UDPデータグラムの受信のみが冪等の操作をトリガとしても、アプリケーションの負荷を軽減するために、重複データグラムを抑制することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that require ordered delivery MUST reestablish datagram ordering themselves. The Internet can significantly delay some packets with respect to others, e.g., due to routing transients, intermittent connectivity, or mobility. This can cause reordering, where UDP datagrams arrive at the receiver in an order different from the transmission order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注文の配信を必要とするアプリケーションは、自分自身を注文データグラムを再確立する必要があります。インターネットは有意により過渡、断続的な接続、又は移動性をルーティングのために、例えば、他の人に対していくつかのパケットを遅延させることができます。これは、UDPデータグラムが送信順序と異なる順序で受信機に到達並べ替えを引き起こすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that use multiple transport ports need to be robust to reordering between sessions. Load-balancing techniques within the network, such as Equal Cost Multipath (ECMP) forwarding can also result in a lack of ordering between different transport sessions, even between the same two network endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のトランスポート・ポートを使用するアプリケーションは、セッション間で並べ替えに堅牢である必要があります。そのような等価コストマルチパス（ECMP）転送など、ネットワーク内の負荷分散技術は、またあっても同じ2つのネットワークエンドポイントとの間で、異なるトランスポートセッションの間に注文の欠如をもたらすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that the time by which packets are reordered or after which duplicates can still arrive can be very large. Even more importantly, there is no well-defined upper boundary here. [RFC793] defines the maximum delay a TCP segment should experience -- the Maximum Segment Lifetime (MSL) -- as 2 minutes. No other RFC defines an MSL for other transport protocols or IP itself. The MSL value defined for TCP is conservative enough that it SHOULD be used by other protocols, including UDP. Therefore, applications SHOULD be robust to the reception of delayed or duplicate packets that are received within this 2-minute interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重複がまだ到着することができた後に、パケットの順序が変更されたことで、時間やが非常に大きくなる可能性があることに注意することが重要です。さらに重要なのは、ここではノー明確に定義された上限があります。 2分として - 最大セグメント寿命（MSL） -  [RFC793] TCPセグメントが経験する最大遅延を定義します。他のRFCは、他のトランスポートプロトコルやIP自身のためにMSLを定義していません。 TCPのために定義されたMSL値は、UDPを含む他のプロトコルによって使用されるべきであることを十分に保守的です。したがって、アプリケーションは、この2分間隔内に受信された遅延または重複パケットの受信に対してロバストであるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retransmission of lost packets or messages is a common reliability mechanism. Such retransmissions can increase network load in response to congestion, worsening that congestion. Any application that uses retransmission is responsible for congestion control of its retransmissions (as well as the application&#39;s original traffic); hence, it is subject to the Congestion Control guidelines in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
失われたパケットまたはメッセージの再送信は、共通の信頼性メカニズムです。このような再送信は、その渋滞を悪化、混雑に応じて、ネットワークの負荷を増やすことができます。再送を使用するすべてのアプリケーションは、輻輳その再送制御（だけでなく、アプリケーションの元のトラフィック）に責任があります。したがって、それはにおける輻輳制御のガイドラインに従うもの
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 3.1. Guidance on the appropriate measurement of RTT in Section 3.1.1 also applies for timers used for retransmission packet-loss detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.1節。セクション3.1.1におけるRTTの適切な測定に関するガイダンスはまた、再送パケットロス検出のために使用されるタイマーに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead of implementing these relatively complex reliability mechanisms by itself, an application that requires reliable and ordered message delivery SHOULD whenever possible choose an IETF standard transport protocol that provides these features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代わりに、それ自体で、これらの比較的複雑な信頼性メカニズムを実装する、信頼性の順序付きメッセージ配信を必要とするアプリケーションは、可能な限り、これらの機能を提供するIETF標準のトランスポートプロトコルを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Checksum Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. チェックサムのガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UDP header includes an optional, 16-bit one&#39;s complement checksum that provides an integrity check. These checks are not strong from a coding or cryptographic perspective and are not designed to detect physical-layer errors or malicious modification of the datagram [RFC3819]. Application developers SHOULD implement additional checks where data integrity is important, e.g., through a Cyclic Redundancy Check (CRC) or keyed or non-keyed cryptographic hash included with the data to verify the integrity of an entire object/file sent over the UDP service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPヘッダは、整合性チェックを提供するオプション、16ビットの1の補数チェックサムを含んでいます。これらのチェックは、符号化または暗号化の観点から強くなく、物理層エラーやデータグラム[RFC3819]の悪意のある変更を検出するように設計されていません。アプリケーション開発者は、データの整合性が重要である追加のチェックを実装する必要があり、例えば、巡回冗長検査（CRC）、またはキー入力または非キー付き暗号ハッシュを介してUDPサービスを介して送信される全オブジェクト/ファイルの完全性を検証するために、データに含ま。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UDP checksum provides a statistical guarantee that the payload was not corrupted in transit. It also allows the receiver to verify that it was the intended destination of the packet, because it covers the IP addresses, port numbers, and protocol number, and it verifies that the packet is not truncated or padded, because it covers the size field. Therefore, it protects an application against receiving corrupted payload data in place of, or in addition to, the data that was sent. More description of the set of checks performed using the checksum field is provided in Section 3.1 of [RFC6396].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPチェックサムはペイロードが輸送中に破損していない統計的な保証を提供します。それはIPアドレス、ポート番号、およびプロトコル番号をカバーしているので、それはまた、受信機は、パケットの意図された宛先であったことを確認することができ、そしてそれは、サイズフィールドをカバーするため、パケットは、切り捨てまたはパディングされていないことを検証します。したがって、それはの、または送信されたデータに加えて、代わりに、破損したペイロードデータを受信に対してアプリケーションを保護します。チェックサムフィールドを使用して実行されるチェックのセットのより多くの説明は、[RFC6396]のセクション3.1に提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications SHOULD enable UDP checksums [RFC1122]. For IPv4, [RFC768] permits an option to disable their use, by setting a zero checksum value. An application is permitted to optionally discard UDP datagrams with a zero checksum [RFC1122].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、UDPチェックサム[RFC1122]を有効にする必要があります。 IPv4の場合、[RFC768]ゼロチェックサム値を設定することにより、それらの使用を無効にするオプションを可能にします。アプリケーションは、ゼロチェックサム[RFC1122]と廃棄UDPデータグラムを任意に許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When UDP is used over IPv6, the UDP checksum is relied upon to protect both the IPv6 and UDP headers from corruption (because IPv6 lacks a checksum) and MUST be used as specified in [RFC2460]. Under specific conditions, a UDP application is allowed to use a zero UDP zero-checksum mode with a tunnel protocol (see Section 3.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPは、IPv6の上で使用される場合、UDPチェックサム（IPv6は、チェックサムがないため）腐敗からIPv6およびUDPヘッダーの両方を保護するために依存され、[RFC2460]で指定されるように使用されなければなりません。特定の条件下で、UDPアプリケーションは、トンネルプロトコル（セクション3.4.1を参照）とゼロUDPゼロチェックサムモードを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that choose to disable UDP checksums MUST NOT make assumptions regarding the correctness of received data and MUST behave correctly when a UDP datagram is received that was originally sent to a different destination or is otherwise corrupted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPチェックサムを無効にすることを選択したアプリケーションは、受信したデータの正しさに関する仮定してはならないとUDPデータグラムは、それはもともと別の宛先に送信されたか、そうでない場合は破損している受信されたときに正しく動作しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1. IPv6 Zero UDP Checksum
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1.  IPv6のゼロUDPチェックサム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6935] defines a method that enables use of a zero UDP zero-checksum mode with a tunnel protocol, providing that the method satisfies the requirements in [RFC6936]. The application MUST implement mechanisms and/or usage restrictions when enabling this mode. This includes defining the scope for usage and measures to prevent leakage of traffic to other UDP applications (see Appendix A and Section 3.6). These additional design requirements for using a zero IPv6 UDP checksum are not present for IPv4, since the IPv4 header validates information that is not protected in an IPv6 packet. Key requirements are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6935]はこの方法は、[RFC6936]での要件を満たすことを提供し、トンネルプロトコルでゼロUDPゼロチェックサムモードの使用を可能にする方法を定義します。このモードを有効にすると、アプリケーションがメカニズムおよび/または使用制限を実装しなければなりません。これは、使用状況やその他のUDPアプリケーションへのトラフィックの漏洩を防止するための措置のためのスコープを定義することを含む（付録Aおよび第3.6節を参照してください）。 IPv4ヘッダは、IPv6パケットに保護されていない情報を検証するため、ゼロIPv6のUDPチェックサムを使用するため、これらの追加の設計要件は、IPv4の場合は存在しません。主な要件は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Use of the UDP checksum with IPv6 MUST be the default configuration for all implementations [RFC6935]. The receiving endpoint MUST only allow the use of UDP zero-checksum mode for IPv6 on a UDP destination port that is specifically enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O IPv6でUDPチェックサムを使用すると、すべての実装[RFC6935]のデフォルト設定でなければなりません。受信エンドポイントにのみ特異的に有効になっているUDP宛先ポート上のIPv6のUDPゼロチェックサムモードの使用を可能にしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An application that supports a checksum different than that in [RFC2460] MUST comply with all implementation requirements specified in Section 4 of [RFC6936] and with the usage requirements specified in Section 5 of [RFC6936].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O [RFC2460]に比べて異なるチェックサムをサポートするアプリケーションは、[RFC6936]のセクション4及び[RFC6936]のセクション5で指定された使用要件で指定されたすべての実装要件を遵守しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A UDP application MUST check that the source and destination IPv6 addresses are valid for any packets with a UDP zero-checksum and MUST discard any packet for which this check fails. To protect from misdelivery, new encapsulation designs SHOULD include an integrity check at the transport layer that includes at least the IPv6 header, the UDP header and the shim header for the encapsulation, if any [RFC6936].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O UDPアプリケーションが送信元と宛先IPv6アドレスはUDPゼロのチェックサムを持つパケットのために有効であり、このチェックが失敗する任意のパケットを破棄しなければならないことをチェックしなければなりません。誤配信から保護するために、新たなカプセルの設計は、少なくともIPv6ヘッダ、UDPヘッダおよびカプセル化のためのシムヘッダを含むトランスポート層での完全性チェック、もしあれば、[RFC6936]を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o One way to help satisfy the requirements of [RFC6936] may be to limit the usage of such tunnels, e.g., to constrain traffic to an operator network, as discussed in Section 3.6. The encapsulation defined for MPLS in UDP [RFC7510] chooses this approach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O [RFC6936]の要件を満たすのに役立つ一つの方法は、セクション3.6で議論するように、オペレータネットワークへのトラフィックを制限するために、例えば、そのようなトンネルの使用を制限することであってもよいです。 UDP [RFC7510]でMPLS用に定義されたカプセル化は、このアプローチを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As in IPv4, IPv6 applications that choose to disable UDP checksums MUST NOT make assumptions regarding the correctness of received data and MUST behave correctly when a UDP datagram is received that was originally sent to a different destination or is otherwise corrupted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4の場合と同様に、UDPチェックサムを無効にすることを選択したIPv6アプリケーションは、受信したデータの正しさに関する仮定してはならないとUDPデータグラムは、それはもともと別の宛先に送信されたか、そうでない場合は破損している受信されたときに正しく動作しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6 datagrams with a zero UDP checksum will not be passed by any middlebox that validates the checksum based on [RFC2460] or that updates the UDP checksum field, such as NATs or firewalls. Changing this behavior would require such middleboxes to be updated to correctly handle datagrams with zero UDP checksums. To ensure end-to-end robustness, applications that may be deployed in the general Internet MUST provide a mechanism to safely fall back to using a checksum when a path change occurs that redirects a zero UDP checksum flow over a path that includes a middlebox that discards IPv6 datagrams with a zero UDP checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゼロUDPチェックサムとIPv6データグラムは、[RFC2460]に基づいてチェックサムを検証し、またはそのようなのNATやファイアウォールとして、UDPチェックサムフィールドを更新任意ミドルによって渡されません。この動作を変更すると、正しくゼロUDPチェックサムを持つデータグラムを処理するように更新されるように、このようなミドルボックスを必要とします。経路変更がそれがミドルボックスを含むパス上ゼロUDPチェックサム・フローをリダイレクト発生した場合、エンドツーエンドのロバスト性を確保するために、一般的なインターネットに展開することができるアプリケーションが安全にチェックサムを使用してフォールバックするためのメカニズムを提供しなければならないことゼロUDPチェックサムとIPv6データグラムを破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2. UDP-Lite
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2.  UDP-Liteの
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A special class of applications can derive benefit from having partially damaged payloads delivered, rather than discarded, when using paths that include error-prone links. Such applications can tolerate payload corruption and MAY choose to use the Lightweight User Datagram Protocol (UDP-Lite) [RFC3828] variant of UDP instead of basic UDP. Applications that choose to use UDP-Lite instead of UDP should still follow the congestion control and other guidelines described for use with UDP in Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの特別なクラスは、エラープローンリンクを含むパスを使用する場合、部分的に破損してペイロードは廃棄するのではなく、配信持っていることから利益を得ることができます。このようなアプリケーションは、ペイロードの破損に耐えることができますし、UDPの代わりに、基本的なUDPの軽量ユーザーデータグラムプロトコル（UDP-Liteは）[RFC3828]バリアントを使用することもできます。代わりにUDPのUDP-Liteの使用を選択したアプリケーションは、まだ第3節ではUDPで使用するために説明した輻輳制御およびその他のガイドラインに従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Lite changes the semantics of the UDP &#34;payload length&#34; field to that of a &#34;checksum coverage length&#34; field. Otherwise, UDP-Lite is semantically identical to UDP. The interface of UDP-Lite differs from that of UDP by the addition of a single (socket) option that communicates the checksum coverage length: at the sender, this specifies the intended checksum coverage, with the remaining unprotected part of the payload called the &#34;error-insensitive part&#34;. By default, the UDP-Lite checksum coverage extends across the entire datagram. If required, an application may dynamically modify this length value, e.g., to offer greater protection to some messages. UDP-Lite always verifies that a packet was delivered to the intended destination, i.e., always verifies the header fields. Errors in the insensitive part will not cause a UDP datagram to be discarded by the destination. Therefore, applications using UDP-Lite MUST NOT make assumptions regarding the correctness of the data received in the insensitive part of the UDP-Lite payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Liteは、「チェックサム・カバレッジ・長さ」フィールドのそれとUDP「ペイロード長」フィールドのセマンティクスを変更します。それ以外の場合は、UDP-LiteはUDPと意味的に同じです。 UDP-Liteとのインタフェースは、単一の（ソケット）の添加により、UDPとは異なるチェックサム・カバレッジ・長さを通信オプション：送信者に、これは意図したチェックサム適用範囲を指定し、ペイロードの残りの保護されていない部分と」と呼ばれますエラーと小文字を区別しない部分」。デフォルトでは、UDP-Liteのチェックサム適用範囲は、データグラム全体を横切って延びます。必要な場合は、アプリケーションが動的にいくつかのメッセージに大きな保護を提供するために、例えば、この長さの値を変更することがあります。 UDP-Liteは、常にパケットを、即ち、常にヘッダフィールドを検証し、意図された宛先に配信されたことを検証します。小文字を区別しない部分のエラーは、UDPデータグラムが宛先によって破棄されることはありません。したがって、UDP-Liteの使用するアプリケーションは、UDP-Liteのペイロードの影響を受けない部分で受信したデータの正当性に関する仮定をしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP-Lite sender SHOULD select the minimum checksum coverage to include all sensitive payload information. For example, applications that use the Real-Time Protocol (RTP) [RFC3550] will likely want to protect the RTP header against corruption. Applications, where appropriate, MUST also introduce their own appropriate validity checks for protocol information carried in the insensitive part of the UDP-Lite payload (e.g., internal CRCs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Liteの送信者は、すべての機密ペイロード情報を含めるように最低限のチェックサム適用範囲を選択する必要があります。例えば、リアルタイムプロトコル（RTP）[RFC3550]を使用するアプリケーションは、おそらく腐敗RTPヘッダを保護することになるでしょう。アプリケーションは、適切な場合、また、UDP-Liteのペイロード（例えば、内部のCRC）の非感受性部分で運ばれるプロトコル情報のための独自の適切な妥当性チェックを導入しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP-Lite receiver MUST set a minimum coverage threshold for incoming packets that is not smaller than the smallest coverage used by the sender [RFC3828]. The receiver SHOULD select a threshold that is sufficiently large to block packets with an inappropriately short coverage field. This may be a fixed value, or it may be negotiated by an application. UDP-Lite does not provide mechanisms to negotiate the checksum coverage between the sender and receiver. Therefore, this needs to be performed by the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Liteの受信機は、送信者[RFC3828]で使用される最小のカバレッジよりも小さくない着信パケットの最小カバレッジしきい値を設定しなければなりません。受信機は、不適切に短いカバレッジ・フィールドを有するパケットをブロックするのに十分な大きさの閾値を選択すべきです。これは、固定値であってもよいし、アプリケーションによって交渉されてもよいです。 UDP-Liteは、送信者と受信者の間のチェックサムカバレッジを交渉する仕組みを提供していません。したがって、これは、アプリケーションによって実行される必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications can still experience packet loss when using UDP-Lite. The enhancements offered by UDP-Lite rely upon a link being able to intercept the UDP-Lite header to correctly identify the partial coverage required. When tunnels and/or encryption are used, this can result in UDP-Lite datagrams being treated the same as UDP datagrams, i.e., result in packet loss. Use of IP fragmentation can also prevent special treatment for UDP-Lite datagrams, and this is another reason why applications SHOULD avoid IP fragmentation (Section 3.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Liteの使用時にアプリケーションは、まだパケット損失を体験することができます。 UDP-Liteのが提供する拡張機能が正しく必要な部分カバレッジを識別するために、UDP-Liteのヘッダを傍受することができるというリンクに依存しています。トンネルおよび/または暗号化が使用される場合、これはすなわち、パケット損失につながる、UDPデータグラムと同じように扱われているUDP-Liteのデータグラムをもたらすことができます。 IPフラグメンテーションの使用は、UDP-Liteのデータグラムのための特別な処理を防ぐことができ、そしてこれは、アプリケーションがIPフラグメンテーション（3.2節）を避けなければならないもう一つの理由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Lite is supported in some endpoint protocol stacks. Current support for middlebox traversal using UDP-Lite is poor, because UDP-Lite uses a different IPv4 protocol number or IPv6 &#34;next header&#34; value than that used for UDP; therefore, few middleboxes are currently able to interpret UDP-Lite and take appropriate actions when forwarding the packet. This makes UDP-Lite less suited for applications needing general Internet support, until such time as UDP-Lite has achieved better support in middleboxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Liteは、いくつかのエンドポイントプロトコルスタックでサポートされています。 UDP-LiteはUDPに使用されるものとは異なるIPv4プロトコル番号またはIPv6の「次のヘッダー」値を使用するため、UDP-Liteの使用ミドルトラバーサルのための現在のサポートは、不良です。そのため、いくつかのミドルボックスは現在、UDP-Liteは解釈してパケットを転送するときに、適切な行動をとることができます。 UDP-Liteのような時間がミドルボックスでより良いサポートを達成したまでこれは、一般的なインターネットのサポートを必要とするアプリケーションのためのUDP-Liteはあまり適しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Middlebox Traversal Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. ミドルトラバーサルのガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATs and firewalls are examples of intermediary devices (&#34;middleboxes&#34;) that can exist along an end-to-end path. A middlebox typically performs a function that requires it to maintain per-flow state. For connection-oriented protocols, such as TCP, middleboxes snoop and parse the connection-management information, and create and destroy per-flow state accordingly. For a connectionless protocol such as UDP, this approach is not possible. Consequently, middleboxes can create per-flow state when they see a packet that -- according to some local criteria -- indicates a new flow, and destroy the state after some time during which no packets belonging to the same flow have arrived.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NAT及びファイアウォールは、エンドツーエンドの経路に沿って存在することができる中間デバイス（「中間装置」）の一例です。ミドルボックスは、典型的には、フローごとの状態を維持することを必要とする機能を果たします。 TCPなどのコネクション型プロトコルのために、スヌープを中間装置と接続管理情報を解析し、それに応じてフローごとの状態を作成し、破壊します。 UDPのようなコネクションレスプロトコルの場合、このアプローチは不可能です。いくつかの地域の基準に従って -   - 新しい流れを示し、同じフローに属するパケットが到着していない、その間いくつかの時間後の状態を破壊し、彼らがパケットを見たときにその結果、ミドルボックスは、フローごとの状態を作成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the specific function that the middlebox performs, this behavior can introduce a time-dependency that restricts the kinds of UDP traffic exchanges that will be successful across the middlebox. For example, NATs and firewalls typically define the partial path on one side of them to be interior to the domain they serve, whereas the partial path on their other side is defined to be exterior to that domain. Per-flow state is typically created when the first packet crosses from the interior to the exterior, and while the state is present, NATs and firewalls will forward return traffic. Return traffic that arrives after the per-flow state has timed out is dropped, as is other traffic that arrives from the exterior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミドルが実行する特定の機能に応じて、この動作は、ミドル全体で成功するUDPトラフィック交換の種類を制限時間依存性を導入することができます。例えば、のNAT及びファイアウォールは、典型的には、その反対側の部分経路がそのドメインの外側になるように定義され、一方、それらの一方の側の部分経路は、彼らが提供ドメインに対して内部であると定義します。最初のパケットが内部から外部に交差し、状態が存在している間、NATのファイアウォールは、リターントラフィックを転送する際に、フローごとの状態は、一般的に作成されます。外部から到着した他のトラフィックがあるとして、フローごとの状態がタイムアウトした後に到着したリターントラフィックは、廃棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many applications that use UDP for communication operate across middleboxes without needing to employ additional mechanisms. One example is the Domain Name System (DNS), which has a strict request-response communication pattern that typically completes within seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信のためにUDPを使用する多くのアプリケーションは、追加の機構を使用することなく、ミドルボックス間で動作します。一例では、典型的には、数秒以内に完了した厳密な要求 - 応答通信パターンを有するドメインネームシステム（DNS）、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other applications may experience communication failures when middleboxes destroy the per-flow state associated with an application session during periods when the application does not exchange any UDP traffic. Applications SHOULD be able to gracefully handle such communication failures and implement mechanisms to re-establish application-layer sessions and state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミドルボックスは、期間中のアプリケーションセッションに関連付けられたフローごとの状態を破壊するときにアプリケーションが任意のUDPトラフィックを交換しない場合に他のアプリケーションは、通信障害が発生することがあります。アプリケーションが正常にこのような通信障害を処理し、アプリケーション層のセッション状態を再確立するためのメカニズムを実装することができるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some applications, such as media transmissions, this re-synchronization is highly undesirable, because it can cause user-perceivable playback artifacts. Such specialized applications MAY send periodic keep-alive messages to attempt to refresh middlebox state (e.g., [RFC7675]). It is important to note that keep-alive messages are not recommended for general use -- they are unnecessary for many applications and can consume significant amounts of system and network resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、ユーザが知覚再生アーティファクトを引き起こす可能性があるので、このようなメディアの送信などの一部のアプリケーションでは、この再同期は、非常に望ましくありません。このような特殊なアプリケーションには、ミドル状態（例えば、[RFC7675]）をリフレッシュしようとするために定期的にキープアライブメッセージを送信することができます。そのキープアライブメッセージは、一般的な使用は推奨されていません注意することが重要である - 彼らは多くのアプリケーションのために不必要であり、システムやネットワークのリソースを大量に消費することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application that needs to employ keep-alive messages to deliver useful service over UDP in the presence of middleboxes SHOULD NOT transmit them more frequently than once every 15 seconds and SHOULD use longer intervals when possible. No common timeout has been specified for per-flow UDP state for arbitrary middleboxes. NATs require a state timeout of 2 minutes or longer [RFC4787]. However, empirical evidence suggests that a significant fraction of currently deployed middleboxes unfortunately use shorter timeouts. The timeout of 15 seconds originates with the Interactive Connectivity Establishment (ICE) protocol [RFC5245]. When an application is deployed in a controlled environment, the deployer SHOULD investigate whether the target environment allows applications to use longer intervals, or whether it offers mechanisms to explicitly control middlebox state timeout durations, for example, using the Port Control Protocol (PCP) [RFC6887], Middlebox Communications (MIDCOM) [RFC3303], Next Steps in Signaling (NSIS) [RFC5973], or Universal Plug and Play (UPnP) [UPnP]. It is RECOMMENDED that applications apply slight random variations (&#34;jitter&#34;) to the timing of keep-alive transmissions, to reduce the potential for persistent synchronization between keep-alive transmissions from different hosts [RFC7675].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ミドルボックスの存在下でUDP上で便利なサービスを提供するためにキープアライブメッセージを採用する必要があるアプリケーションは、一回15秒よりも頻繁にそれらを送信するべきではなく、可能な場合はより長い間隔を使用すべきです。共通のタイムアウトは、任意のミドルボックスのためのフローごとのUDPの状態のために指定されていません。 NATは2分以上[RFC4787]の状態のタイムアウトを要求します。しかし、経験的証拠は、現在展開ミドルボックスのかなりの割合が、残念ながら短いタイムアウトを使用することを示唆しています。 15秒のタイムアウトは、インタラクティブ接続確立（ICE）プロトコル[RFC5245]で発信します。アプリケーションが制御された環境で展開されている場合、デプロイヤは、[ポート制御プロトコル（PCP）を使用して、例えば、ターゲット環境は、アプリケーションがより長い間隔を使用することを許可するかどうか、またはそれが明示的にミドル状態のタイムアウト期間を制御するためのメカニズムを提供していますかどうかを調査する必要がありますRFC6887]、ミドル・コミュニケーションズ（MIDCOM）[RFC3303]、シグナリングに次のステップ（NSIS）[RFC5973]、またはユニバーサルプラグアンドプレイ（UPnP）のUPnP]。異なるホスト[RFC7675]からキープアライブ送信の間の永続的な同期のための可能性を低減するために、アプリケーションは、キープアライブ送信のタイミングにわずかなランダムな変動（「ジッタ」）を適用することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending keep-alive messages is not a substitute for implementing a mechanism to recover from broken sessions. Like all UDP datagrams, keep-alive messages can be delayed or dropped, causing middlebox state to time out. In addition, the congestion control guidelines in Section 3.1 cover all UDP transmissions by an application, including the transmission of middlebox keep-alive messages. Congestion control may thus lead to delays or temporary suspension of keep-alive transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キープアライブメッセージを送信すると、壊れたセッションから回復するメカニズムを実装するための代替ではありません。すべてのUDPデータグラムのように、キープアライブメッセージがタイムアウトにミドル状態を引き起こし、遅れたりドロップすることができます。また、3.1節カバーにおける輻輳制御に関するガイドラインミドルキープアライブメッセージの送信など、アプリケーションによってすべてのUDP送信、。輻輳制御は、このような遅延またはキープアライブの送信の一時的な停止につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Keep-alive messages are NOT RECOMMENDED for general use. They are unnecessary for many applications and may consume significant resources. For example, on battery-powered devices, if an application needs to maintain connectivity for long periods with little traffic, the frequency at which keep-alive messages are sent can become the determining factor that governs power consumption, depending on the underlying network technology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キープアライブメッセージは、一般的な使用のために推奨されていません。彼らは多くの用途のために不必要であり、かなりのリソースを消費することがあります。アプリケーションは、交通量の少ない長時間接続を維持する必要がある場合たとえば、バッテリ駆動機器に、キープアライブメッセージが送信される頻度は、基盤となるネットワーク技術に依存し、消費電力を左右する決定要因になることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because many middleboxes are designed to require keep-alive messages for TCP connections at a frequency that is much lower than that needed for UDP, this difference alone can often be sufficient to prefer TCP over UDP for these deployments. On the other hand, there is anecdotal evidence that suggests that direct communication through middleboxes, e.g., by using ICE [RFC5245], does succeed less often with TCP than with UDP. The trade-offs between different transport protocols -- especially when it comes to middlebox traversal -- deserve careful analysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのミドルボックスは、UDPのために必要なものよりもはるかに低い周波数でTCP接続のキープアライブメッセージを必要とするように設計されているので、一人でこの違いは、多くの場合、これらの展開のためにUDP上でTCPを好むのに十分であり得ます。一方、ミドルボックスによる直接通信は、例えば、ICE [RFC5245]を使用することにより、より少ないことが多いTCPとUDPよりも成功しないことを示唆している事例証拠があります。異なるトランスポートプロトコル間のトレードオフ - それはトラバーサルをミドルに来る場合は特に - 慎重な分析に値します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP applications that could be deployed in the Internet need to be designed understanding that there are many variants of middlebox behavior, and although UDP is connectionless, middleboxes often maintain state for each UDP flow. Using multiple UDP flows can consume available state space and also can lead to changes in the way the middlebox handles subsequent packets (either to protect its internal resources, or to prevent perceived misuse). The probability of path failure can increase when applications use multiple UDP flows in parallel (see Section 5.1.2 for recommendations on usage of multiple ports).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターネットで展開することができUDPアプリケーションは、ミドルの行動の多くの変形があることを理解するように設計する必要があり、UDPはコネクションレスですが、ミドルボックスは、多くの場合、各UDPフローの状態を維持します。複数のUDPフローを使用すると、使用可能な状態空間を消費することができ、また、（その内部リソースを保護するため、または認識誤用を防ぐために、どちらかの）ミドルは、後続のパケットを処理する方法に変化をもたらすことができます。アプリケーションは、（複数のポートの使用に関する推奨事項については、セクション5.1.2を参照）は、並列に複数のUDPフローを使用する場合、パス障害の確率を高めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Limited Applicability and Controlled Environments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 限られた適用性と制御された環境
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two different types of applicability have been identified for the specification of IETF applications that utilize UDP:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
適用2つの異なるタイプのUDPを利用IETFアプリケーションの仕様のために確認されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
General Internet. By default, IETF specifications target deployment on the general Internet. Experience has shown that successful protocols developed in one specific context or for a particular application tend to become used in a wider range of contexts. For example, a protocol with an initial deployment within a local area network may subsequently be used over a virtual network that traverses the Internet, or in the Internet in general. Applications designed for general Internet use may experience a range of network device behaviors and, in particular, should consider whether applications need to operate over paths that may include middleboxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般的なインターネット。デフォルトでは、IETF仕様は、一般的なインターネット上での展開を対象としています。経験は、ある特定の状況において、または特定のアプリケーションのために開発に成功したプロトコルは、コンテキストの広い範囲で使用なる傾向があることが示されています。例えば、ローカル・エリア・ネットワーク内の初期配備とプロトコルは、その後インターネットを横断する仮想ネットワーク上、又は一般にインターネットで使用することができます。一般的なインターネットの使用のために設計されたアプリケーションは、ネットワーク機器の動作の範囲を経験することと、特に、アプリケーションがミドルボックスを備えることができるのパス上で動作する必要があるかどうかを検討すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Controlled Environment. A protocol/encapsulation/tunnel could be designed to be used only within a controlled environment. For example, an application designed for use by a network operator might only be deployed within the network of that single network operator or on networks of an adjacent set of cooperating network operators. The application traffic may then be managed to avoid congestion, rather than relying on built-in mechanisms, which are required when operating over the general Internet. Applications that target a limited applicability use case may be able to take advantage of specific hardware (e.g., carrier-grade equipment) or underlying protocol features of the subnetwork over which they are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御された環境。プロトコル/カプセル化/トンネルは、制御された環境内で使用するように設計することができます。例えば、ネットワークオペレータによる使用のために設計されたアプリケーションは、その単一のネットワークオペレータのネットワーク内またはネットワークオペレータの協働の隣接する組のネットワーク上で展開されるかもしれません。アプリケーショントラフィックは、かなり一般的なインターネット上で動作しているときに必要とされる組み込みのメカニズム、に頼るよりも、混雑を避けるために管理することができます。限定された適用のユースケースを対象とするアプリケーションは、特定のハードウェア（例えば、キャリアグレードの機器）、またはそれらが使用される上にサブネットワークの基礎となるプロトコル機能を利用することができるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifications addressing a limited applicability use case or a controlled environment SHOULD identify how, in their restricted deployment, a level of safety is provided that is equivalent to that of a protocol designed for operation over the general Internet (e.g., a design based on extensive experience with deployments of particular methods that provide features that cannot be expected in general Internet equipment and the robustness of the design of MPLS to corruption of headers both helped justify use of an alternate UDP integrity check [RFC7510]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
限られた適用のユースケースや制御された環境に対処仕様はそれが（一般的なインターネット上で動作するように設計されたプロトコルと同等であるか、その制限された展開では、安全性のレベルが用意されて識別すべきであるなど、豊富な経験に基づく設計ヘッダの両方の破損に一般的なインターネット機器およびMPLSの設計の堅牢性には期待できない機能を提供し、特定の方法の展開で）代替UDP整合性チェック[RFC7510]の使用を正当化する助けました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An IETF specification targeting a controlled environment is expected to provide an applicability statement that restricts the application traffic to the controlled environment, and it would be expected to describe how methods can be provided to discourage or prevent escape of corrupted packets from the environment (for example, Section 5 of [RFC7510]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制御された環境をターゲットにIETF仕様は、制御された環境へのアプリケーションのトラフィックを制限適用性声明を提供することが期待され、方法は、例えば（環境から破損したパケットの脱出を阻止または予防するために提供することができる方法を説明することが予想されます、[RFC7510]のセクション5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Multicast UDP Usage Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.マルチキャストUDP使用上のガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section complements Section 3 by providing additional guidelines that are applicable to multicast and broadcast usage of UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、UDPのマルチキャストおよびブロードキャストの使用に適用される追加的な指針を提供することにより、第3節を補完します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast and broadcast transmission [RFC1112] usually employ the UDP transport protocol, although they may be used with other transport protocols (e.g., UDP-Lite).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャスト及びブロードキャスト送信[RFC1112]、それらが他のトランスポートプロトコル（例えば、UDP-Liteと）と共に使用することができるが、通常は、UDPトランスポートプロトコルを使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are currently two models of multicast delivery: the Any-Source Multicast (ASM) model as defined in [RFC1112] and the Source-Specific Multicast (SSM) model as defined in [RFC4607]. ASM group members will receive all data sent to the group by any source, while SSM constrains the distribution tree to only one single source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4607]で定義されるように[RFC1112]とソース固有マルチキャスト（SSM）モデルで定義されたような任意の-ソースマルチキャスト（ASM）モデル：マルチキャスト配信の2つのモデルが現在存在します。 SSMは、ただ1つのソースに配信ツリーを制約しながら、ASMグループのメンバーは、任意のソースによってグループに送信されたすべてのデータを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specialized classes of applications also use UDP for IP multicast or broadcast [RFC919]. The design of such specialized applications requires expertise that goes beyond simple, unicast-specific guidelines, since these senders may transmit to potentially very many receivers across potentially very heterogeneous paths at the same time, which significantly complicates congestion control, flow control, and reliability mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの専門クラスもIPマルチキャスト用のUDPを使用するか、[RFC919]放送します。これらの送信者が、有意輻輳制御を複雑にすると同時に、に潜在的に非常に不均質なパス間で潜在的に非常に多くの受信機に送信するフロー制御、および信頼性メカニズムがあるので、このような特殊なアプリケーションの設計は、単純な、ユニキャスト固有のガイドラインを超えて専門知識を必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides guidance on multicast and broadcast UDP usage. Use of broadcast by an application is normally constrained by routers to the local subnetwork. However, use of tunneling techniques and proxies can and does result in some broadcast traffic traversing Internet paths. These guidelines therefore also apply to broadcast traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、マルチキャストおよびブロードキャストUDPの使用に関するガイダンスを提供します。アプリケーションによってブロードキャストの使用は、通常、ローカルサブネットワークにルータによって制約されています。しかし、トンネリング技術とプロキシの使用は、いくつかのブロードキャストトラフィック横断インターネットパスにつながるんすることができます。これらのガイドラインは、そのためにも、トラフィックをブロードキャストに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF has defined a reliable multicast framework [RFC3048] and several building blocks to aid the designers of multicast applications, such as [RFC3738] or [RFC4654].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETFは、[RFC3738]または[RFC4654]などのマルチキャストアプリケーションの設計者を支援するために信頼性の高いマルチキャストフレームワーク[RFC3048]及びいくつかのビルディングブロックを定義しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Senders to anycast destinations must be aware that successive messages sent to the same anycast IP address may be delivered to different anycast nodes, i.e., arrive at different locations in the topology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エニーキャスト宛先に送信者が同一のエニーキャストIPアドレスに送信された連続したメッセージが異なるエニーキャストノードに配信されても​​よいことに注意しなければならない、すなわち、トポロジ内の異なる位置に到着します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most UDP tunnels that carry IP multicast traffic use a tunnel encapsulation with a unicast destination address, such as Automatic Multicast Tunneling [RFC7450]. These MUST follow the same requirements as a tunnel carrying unicast data (see Section 3.1.11). There are deployment cases and solutions where the outer header of a UDP tunnel contains a multicast destination address, such as [RFC6513]. These cases are primarily deployed in controlled environments over reserved capacity, often operating within a single administrative domain, or between two domains over a bilaterally agreed upon path with reserved capacity, and so congestion control is OPTIONAL, but circuit breaker techniques are still RECOMMENDED in order to restore some degree of service should the offered load exceed the reserved capacity (e.g., due to misconfiguration).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPマルチキャストトラフィックを運ぶほとんどのUDPトンネルは、このような自動マルチキャストトンネリング[RFC7450]などのユニキャスト宛先アドレスとトンネルカプセル化を使用します。これらは、ユニキャストデータを搬送するトンネルと同じ要件に従わなければならない（セクション3.1.11を参照のこと）。このような[RFC6513]としてUDPトンネルの外部ヘッダがマルチキャスト宛先アドレスを含む展開の場合と溶液があります。これらの場合は、主に、多くの場合、単一の管理ドメイン内で動作し、予約された容量にわたって制御された環境に展開され、又は二つのドメイン間にわたって左右予約容量パス合意など輻輳制御は任意であるが、回路遮断器技術は依然としてために推奨されていますサービスのいくつかの学位を復元するために与えられた負荷は、（設定ミスによるものなど、）の予約容量を超えている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Multicast Congestion Control Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. マルチキャスト輻輳制御のガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unicast congestion-controlled transport mechanisms are often not applicable to multicast distribution services, or simply do not scale to large multicast trees, since they require bidirectional communication and adapt the sending rate to accommodate the network conditions to a single receiver. In contrast, multicast distribution trees may fan out to massive numbers of receivers, which limits the scalability of an in-band return channel to control the sending rate, and the one-to-many nature of multicast distribution trees prevents adapting the rate to the requirements of an individual receiver. For this reason, generating TCP-compatible aggregate flow rates for Internet multicast data, either native or tunneled, is the responsibility of the application implementing the congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユニキャスト輻輳制御搬送機構は、多くの場合、マルチキャスト配信サービスに適用できない、またはそれらが双方向通信を必要とし、単一の受信機へのネットワーク条件に適応するように送信速度を適応させるため、単に、大きなマルチキャストツリーに拡張していません。対照的に、マルチキャスト配信ツリーは、大規模な送信レートを制御するために帯域内のリターンチャンネルのスケーラビリティを制限する受信機の数と、マルチキャスト配信ツリーの一対多の性質にファンアウトはにレートを適応を防止することができます個々の受信機の要件。このため、ネイティブまたはトンネリングされたいずれかのインターネットマルチキャストデータのためのTCP互換集約流量を、生成し、輻輳制御を実装するアプリケーションの責任です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications using multicast SHOULD provide appropriate congestion control. Multicast congestion control needs to be designed using mechanisms that are robust to the potential heterogeneity of both the multicast distribution tree and the receivers belonging to a group. Heterogeneity may manifest itself in some receivers experiencing more loss that others, higher delay, and/or less ability to respond to network conditions. Congestion control is particularly important for any multicast session where all or part of the multicast distribution tree spans an access network (e.g., a home gateway). Two styles of congestion control have been defined in the RFC Series:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストを使用するアプリケーションは、適切な輻輳制御を提供する必要があります。マルチキャスト輻輳制御は、マルチキャスト配信ツリーとグループに属する受信機の両方の電位不均一にロバストであるメカニズムを使用して設計する必要があります。不均一性は他の人、高遅延、および/または以下の能力がネットワークの状況に対応するためのより多くの損失を経験して、いくつかの受信機で現れることがあります。輻輳制御は、マルチキャスト配信ツリーの全て又は一部は、アクセスネットワーク（例えば、ホームゲートウェイ）にまたがる任意のマルチキャストセッションのために特に重要です。輻輳制御の2つのスタイルは、RFCシリーズで定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Feedback-based congestion control, in which the sender receives multicast or unicast UDP messages from the receivers allowing it to assess the level of congestion and then adjust the sender rate(s) (e.g., [RFC5740],[RFC4654]). Multicast methods may operate on longer timescales than for unicast (e.g., due to the higher group RTT of a heterogeneous group). A control method could decide not to reduce the rate of the entire multicast group in response to a control message received from a single receiver (e.g., a sender could set a minimum rate and decide to request a congested receiver to leave the multicast group and could also decide to distribute content to these congested receivers at a lower rate using unicast congestion control).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者がマルチキャストか、輻輳のレベルを評価した後、送信元レート（複数可）（例えば、[RFC5740]、[RFC4654]）を調整することを可能にする受信機からのユニキャストUDPメッセージを受信するフィードバックベースの輻輳制御、O。マルチキャスト方法は、（より高い群異種グループのRTTに、例えば）ユニキャストの場合よりも長い時間スケール上で動作してもよいです。制御方法は、単一の受信機（例えば、送信者が最小の速度を設定し、マルチキャストグループを離脱する輻輳受信を要求することを決定し、可能性ができたから受信した制御メッセージに応答して、全体のマルチキャストグループの速度を低減しないことを決定することができまた、ユニキャスト輻輳制御を使用してより低いレート）で、これらの混雑レシーバにコンテンツを配信することを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Receiver-driven congestion control, which does not require a receiver to send explicit UDP control messages for congestion control (e.g., [RFC3738], [RFC5775]). Instead, the sender distributes the data across multiple IP multicast groups (e.g., using a set of {S,G} channels). Each receiver determines its own level of congestion and controls its reception rate using only multicast join/leave messages sent in the network control plane. This method scales to arbitrary large groups of receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O輻輳制御（例えば、[RFC3738]、[RFC5775]）の明示的なUDP制御メッセージを送信するために受信機を必要としない輻輳制御を、受信主導。その代わりに、送信者は、複数のIPマルチキャストグループ間でデータを配信する（例えば、{S、G}チャネルのセットを使用して）。各受信機は、輻輳の独自のレベルを決定し、専用のネットワーク制御プレーンに送信されたメッセージを残す/マルチキャスト参加使用して、その受信速度を制御します。この方法は、受信機の大規模なグループを任意のためにスケーリングします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any multicast-enabled receiver may attempt to join and receive traffic from any group. This may imply the need for rate limits on individual receivers or the aggregate multicast service. Note, at the transport layer, there is no way to prevent a join message propagating to the next-hop router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
どれマルチキャスト対応の受信機には、参加して、任意のグループからのトラフィックを受信しようとすることができます。これは、個々の受信機または集約マルチキャストサービス上のレート制限の必要性を意味し得ます。注、トランスポート層で、ネクストホップルータに伝搬する参加メッセージを防止するための方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some classes of multicast applications support applications that can monitor the user-level quality of the transfer at the receiver. Applications that can detect a significant reduction in user quality SHOULD regard this as a congestion signal (e.g., to leave a group using layered multicast encoding); if not, they SHOULD use this signal to provide a circuit breaker to terminate the flow by leaving the multicast group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストアプリケーションの一部のクラスは、受信機での伝達のユーザレベルの品質を監視することができ、アプリケーションをサポートしています。ユーザ品質の有意な低下を検出することができるアプリケーション（例えば、階層化マルチキャスト符号化を使用してグループを残すように）輻輳信号としてこれを考えるべきです。そうでなければ、彼らは、マルチキャストグループを離脱することにより、フローを終了するために回路遮断器を提供するためにこの信号を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Bulk-Transfer Multicast Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. バルク転送マルチキャストアプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that perform bulk transmission of data over a multicast distribution tree, i.e., applications that exchange more than a few UDP datagrams per RTT, SHOULD implement a method for congestion control. The currently RECOMMENDED IETF methods are as follows: Asynchronous Layered Coding (ALC) [RFC5775], TCP-Friendly Multicast Congestion Control (TFMCC) [RFC4654], Wave and Equation Based Rate Control (WEBRC) [RFC3738], NACK-Oriented Reliable Multicast (NORM) transport protocol [RFC5740], File Delivery over Unidirectional Transport (FLUTE) [RFC6726], Real Time Protocol/Control Protocol (RTP/RTCP) [RFC3550].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャスト配信ツリーを介してデータの一括送信を実行するアプリケーションは、すなわち、RTTあたり数UDPデータグラム以上を交換するアプリケーションは、輻輳制御のための方法を実装する必要があります。非同期階層符号化（ALC）[RFC5775]、TCPフレンドリーマルチキャスト輻輳制御（TFMCC）[RFC4654]、波動と式ベースのレート制御（WEBRC）[RFC3738]、NACK指向リライアブルマルチキャストを次のように現在推奨IETFの方法があります（NORM）トランスポートプロトコル[RFC5740]、単方向トランスポート上でファイル配信（FLUTE）[RFC6726]、リアルタイムプロトコル/制御プロトコル（RTP / RTCP）[RFC3550]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application can alternatively implement another congestion control scheme following the guidelines of [RFC2887] and utilizing the framework of [RFC3048]. Bulk-transfer applications that choose not to implement [RFC4654], [RFC5775], [RFC3738], [RFC5740], [RFC6726], or [RFC3550] SHOULD implement a congestion control scheme that results in bandwidth use that competes fairly with TCP within an order of magnitude.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、代わりに[RFC2887]のガイドラインに従い、[RFC3048]のフレームワークを利用して別の輻輳制御方式を実施することができます。 [RFC4654]、[RFC5775]、[RFC3738]、[RFC5740]、[RFC6726]、またはを実施しないことを選択したバルク転送アプリケーション[RFC3550]の中にTCPと公平に競合する帯域幅を使用することになる輻輳制御方式を実装する必要があります大きさの順。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2 of [RFC3551] states that multimedia applications SHOULD monitor the packet-loss rate to ensure that it is within acceptable parameters. Packet loss is considered acceptable if a TCP flow across the same network path under the same network conditions would achieve an average throughput, measured on a reasonable timescale, that is not less than that of the UDP flow. The comparison to TCP cannot be specified exactly, but is intended as an &#34;order-of-magnitude&#34; comparison in timescale and throughput.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551]のセクション2は、マルチメディアアプリケーションは、それが許容パラメータの範囲内であることを保証するためにパケット損失率を監視すべきであると述べています。同じネットワーク条件下で同じネットワーク・パスを横切るTCPフローは、UDPフローのそれ以上である合理的なタイムスケールで測定した平均スループットを達成ならばパケットロスが許容されると考えられます。 TCPとの比較を正確に特定することはできないが、タイムスケールとスループットの「桁違い」の比較として意図されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Low Data-Volume Multicast Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 低データ・ボリュームマルチキャストアプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All the recommendations in Section 3.1.3 are also applicable to low data-volume multicast applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.1.3項のすべての勧告はまた、低データ・ボリュームのマルチキャストアプリケーションに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Message Size Guidelines for Multicast
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. マルチキャストのメッセージサイズのガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A multicast application SHOULD NOT send UDP datagrams that result in IP packets that exceed the effective MTU as described in Section 3 of [RFC6807]. Consequently, an application SHOULD either use the effective MTU information provided by the &#34;Population Count Extensions to Protocol Independent Multicast (PIM)&#34; [RFC6807] or implement path MTU discovery itself (see Section 3.2) to determine whether the path to each destination will support its desired message size without fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストアプリケーションは、[RFC6807]のセクション3に記載されるように有効なMTUを超えたIPパケットを生じるUDPデータグラムを送るべきではありません。したがって、アプリケーションは、各宛先へのパスがサポートするかどうかを決定する（第3.2節を参照）[RFC6807]「集団はプロトコル独立マルチキャスト（PIM）に拡張カウント」またはパスMTU発見自体を実装によって提供有効MTU情報を使用すべきであるいずれか断片化せずにその所望のメッセージサイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Programming Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.プログラミングのガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The de facto standard application programming interface (API) for TCP/IP applications is the &#34;sockets&#34; interface [POSIX]. Some platforms also offer applications the ability to directly assemble and transmit IP packets through &#34;raw sockets&#34; or similar facilities. This is a second, more cumbersome method of using UDP. The guidelines in this document cover all such methods through which an application may use UDP. Because the sockets API is by far the most common method, the remainder of this section discusses it in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP / IPアプリケーションのための事実上の標準アプリケーション・プログラミング・インターフェース（API）は、「ソケット」インターフェース[POSIX]です。一部のプラットフォームでは、アプリケーションに直接集合し、「生のソケット」または同様の施設を介してIPパケットを送信する機能を提供します。これは、UDPを使用しての第二、より面倒な方法です。この文書のガイドラインは、アプリケーションがUDPを使用することができ、それを通してすべてのそのような方法をカバーしています。ソケットAPIは、これまでで最も一般的な方法であるため、このセクションの残りの部分は、より詳細にそれを説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the sockets API was developed for UNIX in the early 1980s, a wide variety of non-UNIX operating systems also implement it. The sockets API supports both IPv4 and IPv6 [RFC3493]. The UDP sockets API differs from that for TCP in several key ways. Because application programmers are typically more familiar with the TCP sockets API, this section discusses these differences. [STEVENS] provides usage examples of the UDP sockets API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ソケットAPIは、1980年代初頭にUNIX用に開発されましたが、非UNIXオペレーティング・システムの多種多様なもそれを実装します。ソケットAPIは、IPv4とIPv6 [RFC3493]の両方をサポートしています。 UDPソケットAPIは、いくつかの重要な方法でTCPのためのものとは異なります。アプリケーションプログラマは、通常のTCPソケットAPIに精通しているので、このセクションでは、これらの違いについて説明します。 【STEVENS]はUDPソケットAPIの使用例を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP datagrams may be directly sent and received, without any connection setup. Using the sockets API, applications can receive packets from more than one IP source address on a single UDP socket. Some servers use this to exchange data with more than one remote host through a single UDP socket at the same time. Many applications need to ensure that they receive packets from a particular source address; these applications MUST implement corresponding checks at the application layer or explicitly request that the operating system filter the received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPデータグラムは直接送信され、任意の接続設定せずに、受信することができます。ソケットAPIを使用して、アプリケーションは、単一のUDPソケットに複数のIP送信元アドレスからのパケットを受信することができます。一部のサーバーでは、これは同時に、単一のUDPソケットを介して、複数のリモートホストとデータを交換するために使用します。多くのアプリケーションは、彼らが特定の送信元アドレスからのパケットを受信することを確認する必要があります。これらのアプリケーションは、アプリケーション層に対応するチェックを実施するか、明示的に、オペレーティング・システムは、受信したパケットをフィルタリングすることを要求しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many operating systems also allow a UDP socket to be connected, i.e., to bind a UDP socket to a specific pair of addresses and ports. This is similar to the corresponding TCP sockets API functionality. However, for UDP, this is only a local operation that serves to simplify the local send/receive functions and to filter the traffic for the specified addresses and ports. Binding a UDP socket does not establish a connection -- UDP does not notify the remote end when a local UDP socket is bound. Binding a socket also allows configuring options that affect the UDP or IP layers, for example, use of the UDP checksum or the IP Timestamp option. On some stacks, a bound socket also allows an application to be notified when ICMP error messages are received for its transmissions [RFC1122].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多くのオペレーティングシステムは、また、アドレスとポートの特定のペアにUDPソケットを結合すること、すなわち、UDPソケットが接続されることを可能にします。これは、対応するTCPソケットAPIの機能に似ています。しかし、UDPのために、これは、ローカル送信/受信機能と、指定したアドレスとポートのトラフィックをフィルタリングすることを簡素化するのに役立つだけローカル操作です。 UDPソケットをバインドすると、接続を確立していない - ローカルUDPソケットがバインドされたときにUDPがリモートエンドに通知しません。ソケットをバインドするにも、例えば、UDPチェックサムまたはIPタイムスタンプオプションの使用をUDPまたはIP層に影響を与えるオプションを設定することができます。いくつかのスタックでは、バインドされたソケットは、ICMPエラーメッセージがその送信[RFC1122]のために受信されたときにアプリケーションに通知することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client/server application executes on a host with more than one IP interface, the application SHOULD send any UDP responses with an IP source address that matches the IP destination address of the UDP datagram that carried the request (see [RFC1122], Section 4.1.3.5). Many middleboxes expect this transmission behavior and drop replies that are sent from a different IP address, as explained in Section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアント/サーバ・アプリケーションが複数のIPインタフェースを持つホスト上で実行した場合、アプリケーションが要求を実行UDPデータグラムのIP宛先アドレスと一致するIP送信元アドレスと任意のUDP応答を送信すべきである（[RFC1122]、セクションを参照してください4.1.3.5）。多くのミドルボックスは、この送信動作を期待し、3.5節で説明したように、異なるIPアドレスから送信された応答をドロップします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP receiver can receive a valid UDP datagram with a zero-length payload. Note that this is different from a return value of zero from a read() socket call, which for TCP indicates the end of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP受信機は、長さゼロのペイロードを持つ有効なUDPデータグラムを受信することができます。これはTCP接続のための終了を示すリード（）ソケット呼び出し、ゼロからの戻り値と異なることに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP provides no flow-control, i.e., the sender at any given time does not know whether the receiver is able to handle incoming transmissions. This is another reason why UDP-based applications need to be robust in the presence of packet loss. This loss can also occur within the sending host, when an application sends data faster than the line rate of the outbound network interface. It can also occur at the destination, where receive calls fail to return all the data that was sent when the application issues them too infrequently (i.e., such that the receive buffer overflows). Robust flow control mechanisms are difficult to implement, which is why applications that need this functionality SHOULD consider using a full-featured transport protocol such as TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPは、すなわち、任意の時点で送信側が受信側が着信伝送を処理することができるかどうかわからない、何のフロー制御を提供しません。これは、UDPベースのアプリケーションは、パケット損失の存在下で堅牢である必要はもう一つの理由です。この損失は、アプリケーションをより速く送信ネットワークインターフェイスのラインレートよりもデータを送信する際、送信ホスト内で発生することができます。また、受信コールが、それらはあまりにまれに（バッファオーバーフローを受信すること、すなわち、このような）アプリケーションの問題送信されたすべてのデータを返すことができない宛先、で行うことができます。堅牢なフロー制御メカニズムは、この機能を必要とするアプリケーションは、TCPのようなフル機能のトランスポートプロトコルを使用して検討すべき理由である、実施することが困難です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an application closes a TCP, SCTP, or DCCP socket, the transport protocol on the receiving host is required to maintain TIME-WAIT state. This prevents delayed packets from the closed connection instance from being mistakenly associated with a later connection instance that happens to reuse the same IP address and port pairs. The UDP protocol does not implement such a mechanism. Therefore, UDP-based applications need to be robust to reordering and delay. One application may close a socket or terminate, followed in time by another application receiving on the same port. This later application may then receive packets intended for the first application that were delayed in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、TCP、SCTP、またはDCCPソケットを閉じると、受信側ホスト上のトランスポートプロトコルは、TIME-WAIT状態を維持するために必要とされます。これは、誤って同じIPアドレスとポートのペアを再利用するために起こる後、接続インスタンスに関連付けられているから、閉じた接続インスタンスからの遅延パケットを防ぎます。 UDPプロトコルは、このような仕組みを実装していません。したがって、UDPベースのアプリケーションは、並べ替えや遅延に対してロバストである必要があります。 1つの用途は、同じポートで受信する他のアプリケーションによって時間的に続いて、ソケットを閉じるか、終了することができます。この後、アプリケーションは、ネットワーク内で遅延された最初のアプリケーションのために意図されたパケットを受信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Using UDP Ports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.  UDPポートを使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules and procedures for the management of the &#34;Service Name and Transport Protocol Port Number Registry&#34; are specified in [RFC6335]. Recommendations for use of UDP ports are provided in [RFC7605].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「サービス名とトランスポートプロトコルポート番号登録」の管理のための規則と手順は[RFC6335]で指定されています。 UDPポートの使用に関する推奨事項は、[RFC7605]で提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP sender SHOULD NOT use a source port value of zero. A source port number that cannot be easily determined from the address or payload type provides protection at the receiver from data injection attacks by off-path devices. A UDP receiver SHOULD NOT bind to port zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPの送信者はゼロのソースポート値を使用しないでください。簡単アドレスまたはペイロードタイプから決定することができない送信元ポート番号は、オフパス・デバイスによってデータインジェクション攻撃から受信機に保護を提供します。 UDP受信機はポートゼロにバインドすべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications SHOULD implement receiver port and address checks at the application layer or explicitly request that the operating system filter the received packets to prevent receiving packets with an arbitrary port. This measure is designed to provide additional protection from data injection attacks from an off-path source (where the port values may not be known).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、アプリケーション層で受信ポートとアドレスチェックを実施するか、明示的に、オペレーティングシステムは、任意のポートでパケットを受信防ぐために、受信したパケットをフィルタリングすることを要求すべきです。この測定値は、（ポート値が知られていない）をオフパスソースからのデータインジェクション攻撃からの追加保護を提供するように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications SHOULD provide a check that protects from off-path data injection, avoiding an application receiving packets that were created by an unauthorized third party. TCP stacks commonly use a randomized source port to provide this protection [RFC6056]; UDP applications should follow the same technique. Middleboxes and end systems often make assumptions about the system ports or user ports; hence, it is recommended to use randomized ports in the Dynamic and/ or Private Port range. Setting a &#34;randomized&#34; source port also provides greater assurance that reported ICMP errors originate from network systems on the path used by a particular flow. Some UDP applications choose to use a predetermined value for the source port (including some multicast applications), these applications need to therefore employ a different technique. Protection from off-path data attacks can also be provided by randomizing the initial value of another protocol field within the datagram payload, and checking the validity of this field at the receiver (e.g., RTP has random initial sequence number and random media timestamp offsets [RFC3550]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、権限のない第三者によって作成されたパケットを受信するアプリケーションを避け、オフパスデータの注入から保護し、チェックを提供する必要があります。 TCPスタックは、一般的に、この保護[RFC6056]を提供するために、ランダム化された送信元ポートを使用します。 UDPアプリケーションは、同じ手法に従ってください。 Middleboxesとエンドシステムは、多くの場合、システムポートまたはユーザポートについての仮定を行います。したがって、動的および/またはプライベートポートの範囲内でランダム化されたポートを使用することをお勧めします。 「ランダム化」の送信元ポートを設定すると、ICMPエラーは、特定のフローによって使用されるパス上のネットワークシステムに由来報告大きな保証を提供します。いくつかのUDPアプリケーションは、（いくつかのマルチキャストアプリケーションを含む）送信元ポートのための所定の値を使用することを選択し、これらのアプリケーションは、したがって、異なる手法を採用する必要があります。オフパスデータの攻撃から保護データグラムのペイロード内の別のプロトコルフィールドの初期値をランダム化し、受信側でこのフィールドの妥当性をチェックすることによっても提供され得る（例えば、RTPは、[ランダムな初期シーケンス番号とランダムメディアタイムスタンプ・オフセットを有しますRFC3550]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using multicast, IP routers perform a reverse-path forwarding (RPF) check for each multicast packet. This provides protection from off-path data injection, restricting opportunities to forge a packet&#39;s source address. When a receiver joins a multicast group and filters based on the source address the filter verifies the sender&#39;s IP address. This is always the case when using an SSM {S,G} channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マルチキャストを使用する場合、IPルータはリバースパス転送（RPF）を各マルチキャストパケットを確認行います。これは、パケットの送信元アドレスを偽造する機会を制限し、オフパスデータの注入からの保護を提供します。受信機は、送信元アドレスに基づいてマルチキャストグループとフィルタに参加すると、フィルタは、送信者のIPアドレスを検証します。 SSM {S、G}チャネルを使用する場合、これは常にそうです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. Usage of UDP for Source Port Entropy and the IPv6 Flow Label
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. 送信元ポートエントロピーとIPv6フローラベルのためのUDPの使い方
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications use the UDP datagram header as a source of entropy for network devices that implement ECMP [RFC6438]. A UDP tunnel application targeting this usage encapsulates an inner packet using UDP, where the UDP source port value forms a part of the entropy that can be used to balance forwarding of network traffic by the devices that use ECMP. A sending tunnel endpoint selects a source port value in the UDP datagram header that is computed from the inner flow information (e.g., the encapsulated packet headers). To provide sufficient entropy, the sending tunnel endpoint maps the encapsulated traffic to one of a range of UDP source values. The value SHOULD be within the ephemeral port range, i.e., 49152 to 65535, where the high order two bits of the port are set to one. The available source port entropy of 14 bits (using the ephemeral port range) plus the outer IP addresses seems sufficient for entropy for most ECMP applications [ENCAP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一部のアプリケーションでは、ECMP [RFC6438]を実装するネットワークデバイスのエントロピー源としてUDPデータグラムヘッダを使用します。この用法を標的UDPトンネルアプリケーションは、UDPソースポート値がECMPを使用するデバイスによって、ネットワークトラフィックの転送のバランスをとるために使用することができるエントロピの一部を形成するUDPを使用して内部パケットをカプセル化します。送信トンネルエンドポイントは、内側フロー情報（例えば、カプセル化されたパケットのヘッダ）から計算されるUDPデータグラムヘッダの送信元ポートの値を選択します。十分なエントロピーを提供するために、送信トンネルエンドポイントはUDPソース値の範囲のいずれかにカプセル化されたトラフィックをマッピングします。値は49152ポートの上位2ビットが1に設定されている65535、に、即ち、エフェメラルポートの範囲内にあるべきです。 14ビット（エフェメラルポート範囲を使用して）に加え、外側IPアドレスの利用可能なソース・ポート・エントロピーは最もECMPアプリケーション[ENCAP]エントロピーのために十分と思われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid reordering within an IP flow, the same UDP source port value SHOULD be used for all packets assigned to an encapsulated flow (e.g., using a hash of the relevant headers). The entropy mapping for a flow MAY change over the lifetime of the encapsulated flow [ENCAP]. For instance, this could be changed as a Denial of Service (DOS) mitigation, or as a means to effect routing through the ECMP network. However, the source port selected for a flow SHOULD NOT change more than once in every thirty seconds (e.g., as in [RFC8086]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPフロー内の並べ替えを避けるために、同一のUDPソースポート値がカプセル化されたフローに割り当てられたすべてのパケットのために使用されるべきである（例えば、関連ヘッダのハッシュを使用して）。フローに対するエントロピーマッピングは、カプセル化されたフロー[ENCAP]の寿命にわたって変化してもよいです。例えば、これは、サービス拒否（DOS）緩和として、又はECMPネットワークを介してルーティング達成するための手段として変更することができます。しかし、流れのために選択された送信元ポートが一回30秒で（例えば、[RFC8086]のように）より多くを変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the source port field for entropy has several side effects that need to be considered, including:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エントロピーのソースポートフィールドの使用は、含めて検討する必要があるいくつかの副作用があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It can increase the probability of misdelivery of corrupted packets, which increases the need for checksum computation or an equivalent mechanism to protect other UDP applications from misdelivery errors Section 3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれはチェックサム計算または配達ミスエラーセクション3.4から他のUDPアプリケーションを保護するための同等のメカニズムの必要性が増加する、破損したパケットの誤配信の確率を高めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is expected to reduce the probability of successful middlebox traversal Section 3.5. This use of the source port field will often not be suitable for applications targeting deployment in the general Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O成功したミドル横断セクション3.5の確率を低減することが期待されます。ソースポートフィールドの使用は、多くの場合、一般的なインターネットでの展開をターゲットとするアプリケーションに適していないだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It can prevent the field being usable to protect from off-path attacks (described in Section 5.1). Designers therefore need to consider other mechanisms to provide equivalent protection (e.g., to restrict use to a controlled environment [RFC7510] Section 3.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは（セクション5.1に記載）をオフパス攻撃から保護するために使用可能であるフィールドを防止することができます。設計者は、したがって、同等の保護（例えば、制御された環境[RFC7510]セクション3.6に使用を制限する）を提供するために他の機構を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UDP source port number field has also been leveraged to produce entropy with IPv6. However, in the case of IPv6, the &#34;flow label&#34; [RFC6437] may also alternatively be used to provide entropy for load balancing [RFC6438]. This use of the flow label for load balancing is consistent with the definition of the field, although further clarity was needed to ensure the field can be consistently used for this purpose. Therefore, an updated IPv6 flow label [RFC6437] and ECMP routing [RFC6438] usage was specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP送信元ポート番号フィールドは、IPv6でのエントロピーを生成するために活用されています。ただし、IPv6の場合には、「フローラベル」[RFC6437]も代替的にロードバランシング[RFC6438]のためのエントロピーを提供するために使用され得ます。さらに透明性は一貫して、この目的のために使用することができる場を確保するために必要だったが、負荷分散のためのフローラベルの使用は、フィールドの定義と一致しています。したがって、更新されたIPv6フローラベル[RFC6437]とECMPルーティング[RFC6438]使用が指定されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure future opportunities to use the flow label, UDP applications SHOULD set the flow label field, even when an entropy value is also set in the source port field (e.g., An IPv6 tunnel endpoint could copy the source port flow entropy value to the IPv6 flow label field [RFC8086]). Router vendors are encouraged to start using the IPv6 flow label as a part of the flow hash, providing support for IP-level ECMP without requiring use of UDP. The end-to-end use of flow labels for load balancing is a long-term solution. Even if the usage of the flow label has been clarified, there will be a transition time before a significant proportion of endpoints start to assign a good quality flow label to the flows that they originate. The use of load balancing using the transport header fields will likely continue until widespread deployment is finally achieved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローラベルを使用するために、将来の機会を確保するために、UDPアプリケーションは、エントロピー値も（ソースポートフィールドに設定されている場合でも、フローラベルフィールドを設定する必要があります例えば、IPv6へのエントロピー値を流し送信元ポートをコピーすることができたIPv6トンネルエンドポイントフローラベルフィールド[RFC8086]）。ルータベンダは、UDPの使用を必要とせずにIPレベルECMPのためのサポートを提供し、フローハッシュの一部としてのIPv6フローラベルの使用を開始することをお勧めします。負荷分散のためのフローラベルのエンド・ツー・エンドの使用は、長期的な解決策です。フローラベルの使用が明らかにされている場合でも、エンドポイントのかなりの割合は、彼らが発信フローに良質のフローラベルを割り当てるために開始する前に、移行時間があるでしょう。広範囲の展開が最終的に達成されるまで、トランスポート・ヘッダー・フィールドを使用して負荷分散を使用することは、おそらく継続されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. Applications Using Multiple UDP Ports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. 複数のUDPポートを使用したアプリケーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single application may exchange several types of data. In some cases, this may require multiple UDP flows (e.g., multiple sets of flows, identified by different five-tuples). [RFC6335] recommends application developers not to apply to IANA to be assigned multiple well-known ports (user or system). It does not discuss the implications of using multiple flows with the same well-known port or pairs of dynamic ports (e.g., identified by a service name or signaling protocol).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
単一のアプリケーションでは、データのいくつかのタイプを交換してもよいです。いくつかの場合において、これは、複数のUDPフローを必要とし得る（例えば、異なる5タプルによって識別されるフローの複数のセット）。 [RFC6335]は、複数のwell-knownポート（ユーザまたはシステム）を割り当てることがIANAには適用しないアプリケーション開発者をお勧めします。これは、複数の同一の周知のポートを有するフローまたは（例えば、サービス名またはシグナリングプロトコルによって識別される）動的ポートのペアを使用することの意味を説明しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of multiple flows can affect the network in several ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のフローの使用はいくつかの方法でネットワークに影響を与えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Starting a series of successive connections can increase the number of state bindings in middleboxes (e.g., NAPT or Firewall) along the network path. UDP-based middlebox traversal usually relies on timeouts to remove old state, since middleboxes are unaware when a particular flow ceases to be used by an application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oネットワーク・パスに沿ったミドルボックスの状態バインディング（例えば、NAPTまたはファイアウォール）の数を増加させることができる連続した接続のシリーズを開始。特定のフローは、アプリケーションによって使用されなくなるときミドルボックスは気付いていないので、UDPベースのミドル・トラバーサルは通常、古い状態を削除するためにタイムアウトに依存しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Using several flows at the same time may result in seeing different network characteristics for each flow. It cannot be assumed both follow the same path (e.g., when ECMP is used, traffic is intentionally hashed onto different parallel paths based on the port numbers).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同時に複数のフローを用いてoをフローごとに異なるネットワーク特性を見ることをもたらすことができます。これは、両方が同じ経路に従うと仮定することができない（ECMPが使用される場合、例えば、トラフィックは、意図的にポート番号に基づいて、異なる並列経路にハッシュされます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Using several flows can also increase the occupancy of a binding or lookup table in a middlebox (e.g., NAPT or Firewall), which may cause the device to change the way it manages the flow state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、デバイスは、それがフローの状態を管理する方法を変更させることができる、ミドル（例えば、NAPTまたはファイアウォール）に結合またはルックアップテーブルの占有率を高めることができるいくつかのフローを用いて、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Further, using excessive numbers of flows can degrade the ability of a unicast congestion control to react to congestion events, unless the congestion state is shared between all flows in a session. A receiver-driven multicast congestion control requires the sending application to distribute its data over a set of IP multicast groups, each receiver is therefore expected to receive data from a modest number of simultaneously active UDP ports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳状態は、セッション内のすべてのフロー間で共有されていない限り、Oまた、流れの過剰な数を使用して、輻輳イベントに対応するユニキャスト輻輳制御の能力を低下させることができます。受信機駆動型マルチキャスト輻輳制御IPマルチキャストグループのセットの上にそのデータを配信する送信アプリケーションを必要とする、各受信機は、したがって、同時にアクティブUDPポートの適度な数からデータを受信することが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, applications MUST NOT assume consistent behavior of middleboxes when multiple UDP flows are used; many devices respond differently as the number of used ports increases. Using multiple flows with different QoS requirements requires applications to verify that the expected performance is achieved using each individual flow (five-tuple), see Section 3.1.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のUDPフローが使用される場合したがって、アプリケーションは、中間装置の一貫した動作を仮定してはいけません。多くのデバイスが使用されているポートの数が増えると異なる応答します。異なるQoS要件を有する複数のフローを使用すると、期待される性能は、セクション3.1.9を参照して、各個別流（5タプル）を使用して達成されることを確認するアプリケーションを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. ICMP Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.  ICMPのガイドライン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications can utilize information about ICMP error messages that the UDP layer passes up for a variety of purposes [RFC1122]. Applications SHOULD appropriately validate the payload of ICMP messages to ensure these are received in response to transmitted traffic (i.e., a reported error condition that corresponds to a UDP datagram actually sent by the application). This requires context, such as local state about communication instances to each destination, that although readily available in connection-oriented transport protocols is not always maintained by UDP-based applications. Note that not all platforms have the necessary APIs to support this validation, and some platforms already perform this validation internally before passing ICMP information to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、UDP層は、様々な目的のためにアップ渡しICMPエラーメッセージ[RFC1122]についての情報を利用することができます。アプリケーションが適切にこれらが送信されたトラフィックに応答して受信されるようにICMPメッセージのペイロードを検証する必要があり（即ち、実際にアプリケーションによって送信されたUDPデータグラムに対応する報告されたエラー条件）。これは、接続指向のトランスポートプロトコルで容易に入手可能であるが、常にUDPベースのアプリケーションによって維持されていないと、そのような各宛先への通信インスタンスに関するローカル状態として、コンテキストを必要とします。いないすべてのプラットフォームは、この検証をサポートするために必要なAPIを持っている、といくつかのプラットフォームでは、既にアプリケーションにICMP情報を渡す前に、内部でこの検証を行うことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any application response to ICMP error messages SHOULD be robust to temporary routing failures (sometimes called &#34;soft errors&#34;), e.g., transient ICMP &#34;unreachable&#34; messages ought to not normally cause a communication abort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPエラーメッセージは、一時的なルーティング障害に対して堅牢であるべきである（SHOULD）への任意のアプリケーションの応答（場合によっては「ソフトエラー」と呼ばれる）、例えば、過渡ICMP「到達不能」メッセージが正常に通信中断を起こさないはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMP messages are being increasingly filtered by middleboxes. A UDP application therefore SHOULD NOT rely on their delivery for correct and safe operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPメッセージはますますミドルボックスによってフィルタリングされています。 UDPアプリケーションは、したがって、正しく安全運転のためのそれらの送達に依存すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP does not provide communications security. Applications that need to protect their communications against eavesdropping, tampering, or message forgery SHOULD employ end-to-end security services provided by other IETF protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPは、通信のセキュリティを提供しません。他のIETFプロトコルによって提供エンドツーエンドのセキュリティサービスを採用すべき盗聴、改ざん、またはメッセージ偽造に対する彼らの通信を保護する必要があるアプリケーション。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP applications SHOULD provide protection from off-path data injection attacks using a randomized source port or equivalent technique (see Section 5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPアプリケーション（セクション5.1を参照）無作為の送信元ポートまたは同等の技術を使用して、オフパスデータインジェクション攻撃からの保護を提供するはずです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that respond to short requests with potentially large responses are a potential vector for amplification attacks, and SHOULD take steps to minimize their potential for being abused as part of a DoS attack. That could mean authenticating the sender before responding; noting that the source IP address of a request is not a useful authenticator, because it can easily be spoofed. Or it may mean otherwise limiting the cases where short unauthenticated requests produce large responses. Applications MAY also want to offer ways to limit the number of requests they respond to in a time interval, in order to cap the bandwidth they consume.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
潜在的に大きな反応と短い要求に応答するアプリケーションは、増幅攻撃の潜在的なベクトルであり、DoS攻撃の一環として悪用されるため、その可能性を最小限にするための措置をとるべきです。これは、応答する前に、送信者を認証する意味するかもしれません。それは簡単に詐称できるため、要求の送信元IPアドレスは、便利なオーセンティケータではないことを指摘しました。それとも、そうでない場合は、短い非認証の要求は大きな反応を生じる例を制限する意味するかもしれません。アプリケーションはまた、彼らは、彼らが消費する帯域幅をキャップするためには、時間間隔内に応答する要求の数を制限する方法を提供することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One option for securing UDP communications is with IPsec [RFC4301], which can provide authentication for flows of IP packets through the Authentication Header (AH) [RFC4302] and encryption and/or authentication through the Encapsulating Security Payload (ESP) [RFC4303]. Applications use the Internet Key Exchange (IKE) [RFC7296] to configure IPsec for their sessions. Depending on how IPsec is configured for a flow, it can authenticate or encrypt the UDP headers as well as UDP payloads. If an application only requires authentication, ESP with no encryption but with authentication is often a better option than AH, because ESP can operate across middleboxes. An application that uses IPsec requires the support of an operating system that implements the IPsec protocol suite, and the network path must permit IKE and IPsec traffic. This may become more common with IPv6 deployments [RFC6092].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP通信を確保するための1つのオプションは、認証ヘッダ（AH）[RFC4302]およびカプセル化セキュリティペイロード（ESP）を介して、暗号化および/または認証[RFC4303]を介してIPパケットのフローのための認証を提供することができるのIPsec [RFC4301]です。アプリケーションは、そのセッションのためにIPsecを設定するには、インターネット鍵交換（IKE）[RFC7296]を使用します。 IPsecは、フロー用に設定されている方法に応じて、それはUDPヘッダと同様にUDPペイロードを認証または暗号化することができます。アプリケーションが認証のみを必要とする場合はESPがミドルボックスにわたって動作することができるため、暗号化なしが、認証とESPは、多くの場合、AHより良いオプションです。 IPsecを使用するアプリケーションは、IPsecプロトコルスイートを実装して、オペレーティング・システムのサポートを必要とし、ネットワークパスがIKEおよびIPsecトラフィックを許可する必要があります。これは、IPv6の展開[RFC6092]でより一般的になることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although it is possible to use IPsec to secure UDP communications, not all operating systems support IPsec or allow applications to easily configure it for their flows. A second option for securing UDP communications is through Datagram Transport Layer Security (DTLS) [RFC6347][RFC7525]. DTLS provides communication privacy by encrypting UDP payloads. It does not protect the UDP headers. Applications can implement DTLS without relying on support from the operating system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはUDP通信を保護するためにIPsecを使用することも可能であるが、すべてのオペレーティングシステムにはIPsecをサポートしたり、アプリケーションが簡単に彼らのフローのためにそれを設定することはできませ。 UDP通信を保護するための第2のオプションは、データグラムトランスポート層セキュリティ（DTLS）[RFC6347] [RFC7525]を使用することです。 DTLSはUDPペイロードを暗号化することにより、通信のプライバシーを提供します。これは、UDPヘッダを保護することはできません。アプリケーションは、オペレーティングシステムからの支援に頼らずDTLSを実装することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many other options for authenticating or encrypting UDP payloads exist. For example, the GSS-API security framework [RFC2743] or Cryptographic Message Syntax (CMS) [RFC5652] could be used to protect UDP payloads. There exist a number of security options for RTP [RFC3550] over UDP, especially to accomplish key-management, see [RFC7201]. These options covers many usages, including point-to-point, centralized group communication as well as multicast. In some applications, a better solution is to protect larger stand-alone objects, such as files or messages, instead of individual UDP payloads. In these situations, CMS [RFC5652], S/MIME [RFC5751] or OpenPGP [RFC4880] could be used. In addition, there are many non-IETF protocols in this area.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDPペイロードを認証または暗号化するための他の多くの選択肢が存在します。たとえば、GSS-APIのセキュリティフレームワーク[RFC2743]や暗号メッセージ構文（CMS）[RFC5652]はUDPペイロードを保護するために使用することができます。特に、キー管理を実現[RFC7201]を参照して、UDP上のRTP [RFC3550]のセキュリティオプションの数が存在します。これらのオプションは、ポイント・ツー・ポイント、集中グループ通信ならびにマルチキャストを含む多くの用途をカバー。一部のアプリケーションでは、よりよい解決策は、そのようなファイルやメッセージの代わりに、個々のUDPペイロードのような大きなスタンドアロンのオブジェクトを、保護することです。これらの状況では、CMS [RFC5652]において、S / MIME [RFC5751]かのOpenPGP [RFC4880]は使用することができます。また、この地域の多くの非IETFプロトコルがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like congestion control mechanisms, security mechanisms are difficult to design and implement correctly. It is hence RECOMMENDED that applications employ well-known standard security mechanisms such as DTLS or IPsec, rather than inventing their own.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御メカニズムと同様に、セキュリティメカニズムが設計し、正しく実装することは困難です。それ故にアプリケーションではなく、独自の発明よりも、このようなDTLSやIPsecなどの周知の標準的なセキュリティ機構を用いることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Generalized TTL Security Mechanism (GTSM) [RFC5082] may be used with UDP applications when the intended endpoint is on the same link as the sender. This lightweight mechanism allows a receiver to filter unwanted packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意図したエンドポイントは、送信者と同じリンク上にある場合一般TTLセキュリティメカニズム（GTSM）[RFC5082]はUDPアプリケーションで使用することができます。この軽量なメカニズムは、受信機が不要なパケットをフィルタリングすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In terms of congestion control, [RFC2309] and [RFC2914] discuss the dangers of congestion-unresponsive flows to the Internet. [RFC8084] describes methods that can be used to set a performance envelope that can assist in preventing congestion collapse in the absence of congestion control or when the congestion control fails to react to congestion events. This document provides guidelines to designers of UDP-based applications to congestion-control their transmissions, and does not raise any additional security concerns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
輻輳制御の観点から、[RFC2309]及び[RFC2914]は、インターネットに輻輳応答しないフローの危険性を議論します。 [RFC8084]は、輻輳制御場合や輻輳制御が輻輳イベントに反応することができないの非存在下での輻輳崩壊を防ぐのを助けることができる性能エンベロープを設定するために使用することができる方法を記載します。この文書では、輻輳制御への送信をUDPベースのアプリケーションの設計者に指針を提供し、任意の追加のセキュリティ上の問題を提起しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some network operators have experienced surges of UDP attack traffic that are multiple orders of magnitude above the baseline traffic rate for UDP. This can motivate operators to limit the data rate or packet rate of UDP traffic. This may in turn limit the throughput that an application can achieve using UDP and could also result in higher packet loss for UDP traffic that would not be experienced if other transport protocols had been used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかのネットワークオペレータは、UDPのベースライントラフィックレート以上の大きさの複数の注文されているUDP攻撃トラフィックの急増を経験しています。これは、データ・レートまたはUDPトラフィックのパケットレートを制限するために、事業者のやる気を引き出すことができます。これは、順番に、アプリケーションがUDPを使用して実現することができ、また、他のトランスポートプロトコルが使用されていた場合に経験されないUDPトラフィックの高いパケット損失につながることができるとスループットを制限する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP application with a long-lived association between the sender and receiver, ought to be designed so that the sender periodically checks that the receiver still wants (&#34;consents&#34;) to receive traffic and need to be designed to stop if there is no explicit confirmation of this [RFC7675]. Applications that require communications in two directions to implement protocol functions (such as reliability or congestion control) will need to independently check both directions of communication, and may have to exchange keep-alive messages to traverse middleboxes (see Section 3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者と受信者の間で長寿命の関連性を持つUDPアプリケーション、送信者が定期的に受信機がまだトラフィックを受信し、明示的に存在しない場合に停止するように設計する必要があります（「承諾」）望んでいることをチェックするように設計されるべきですこの[RFC7675]の確認。 （例えば、信頼性や輻輳制御など）プロトコル機能を実装するために二方向通信を必要とするアプリケーション（セクション3.5を参照）独立通信の両方の方向を確認する必要があります、そして中間装置を横断するキープアライブメッセージを交換する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Summary
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.まとめ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section summarizes the key guidelines made in Sections 3 - 6 in a tabular format (Table 1) for easy referencing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
簡単に参照するための表形式（表1）に6  - このセクションでは、セクション3で作られたキーのガイドラインをまとめたものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +---------------------------------------------------------+---------+
   | Recommendation                                          | Section |
   +---------------------------------------------------------+---------+
   | MUST tolerate a wide range of Internet path conditions  | 3       |
   | SHOULD use a full-featured transport (e.g., TCP)        |         |
   |                                                         |         |
   | SHOULD control rate of transmission                     | 3.1     |
   | SHOULD perform congestion control over all traffic      |         |
   |                                                         |         |
   | for bulk transfers,                                     | 3.1.2   |
   | SHOULD consider implementing TFRC                       |         |
   | else, SHOULD in other ways use bandwidth similar to TCP |         |
   |                                                         |         |
   | for non-bulk transfers,                                 | 3.1.3   |
   | SHOULD measure RTT and transmit max. 1 datagram/RTT     | 3.1.1   |
   | else, SHOULD send at most 1 datagram every 3 seconds    |         |
   | SHOULD back-off retransmission timers following loss    |         |
   |                                                         |         |
   | SHOULD provide mechanisms to regulate the bursts of     | 3.1.6   |
   | transmission                                            |         |
   |                                                         |         |
   | MAY implement ECN; a specific set of application        | 3.1.7   |
   | mechanisms are REQUIRED if ECN is used.                 |         |
   |                                                         |         |
   | for DiffServ, SHOULD NOT rely on implementation of PHBs | 3.1.8   |
   |                                                         |         |
   | for QoS-enabled paths, MAY choose not to use CC         | 3.1.9   |
   |                                                         |         |
   | SHOULD NOT rely solely on QoS for their capacity        | 3.1.10  |
   | non-CC controlled flows SHOULD implement a transport    |         |
   | circuit breaker                                         |         |
   | MAY implement a circuit breaker for other applications  |         |
   |                                                         |         |
   | for tunnels carrying IP traffic,                        | 3.1.11  |
   | SHOULD NOT perform congestion control                   |         |
   | MUST correctly process the IP ECN field                 |         |
   |                                                         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   | for non-IP tunnels or rate not determined by traffic,   |         |
   | SHOULD perform CC or use circuit breaker                | 3.1.11  |
   | SHOULD restrict types of traffic transported by the     |         |
   | tunnel                                                  |         |
   |                                                         |         |
   | SHOULD NOT send datagrams that exceed the PMTU, i.e.,   | 3.2     |
   | SHOULD discover PMTU or send datagrams &lt; minimum PMTU;  |         |
   | Specific application mechanisms are REQUIRED if PLPMTUD |         |
   | is used.                                                |         |
   |                                                         |         |
   | SHOULD handle datagram loss, duplication, reordering    | 3.3     |
   | SHOULD be robust to delivery delays up to 2 minutes     |         |
   |                                                         |         |
   | SHOULD enable IPv4 UDP checksum                         | 3.4     |
   | SHOULD enable IPv6 UDP checksum; Specific application   | 3.4.1   |
   | mechanisms are REQUIRED if a zero IPv6 UDP checksum is  |         |
   | used.                                                   |         |
   |                                                         |         |
   | SHOULD provide protection from off-path attacks         | 5.1     |
   | else, MAY use UDP-Lite with suitable checksum coverage  | 3.4.2   |
   |                                                         |         |
   | SHOULD NOT always send middlebox keep-alive messages    | 3.5     |
   | MAY use keep-alives when needed (min. interval 15 sec)  |         |
   |                                                         |         |
   | Applications specified for use in limited use (or       | 3.6     |
   | controlled environments) SHOULD identify equivalent     |         |
   | mechanisms and describe their use case.                 |         |
   |                                                         |         |
   | Bulk-multicast apps SHOULD implement congestion control | 4.1.1   |
   |                                                         |         |
   | Low volume multicast apps SHOULD implement congestion   | 4.1.2   |
   | control                                                 |         |
   |                                                         |         |
   | Multicast apps SHOULD use a safe PMTU                   | 4.2     |
   |                                                         |         |
   | SHOULD avoid using multiple ports                       | 5.1.2   |
   | MUST check received IP source address                   |         |
   |                                                         |         |
   | SHOULD validate payload in ICMP messages                | 5.2     |
   |                                                         |         |
   | SHOULD use a randomized source port or equivalent       | 6       |
   | technique, and, for client/server applications, SHOULD  |         |
   | send responses from source address matching request     |         |
   | 5.1                                                     |         |
   | SHOULD use standard IETF security protocols when needed | 6       |
   +---------------------------------------------------------+---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Table 1: Summary of Recommendations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
表1：推奨事項のまとめ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.参照文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC768] Postel, J., &#34;User Datagram Protocol&#34;, STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, &lt;http://www.rfc-editor.org/info/rfc768&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC768]ポステル、J.、 &#34;ユーザ・データグラム・プロトコル&#34;、STD 6、RFC 768、DOI 10.17487 / RFC0768、1980年8月、&lt;http://www.rfc-editor.org/info/rfc768&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, &lt;http://www.rfc-editor.org/info/rfc793&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、&lt;http://www.rfc-editor.org/info/rfc793&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., Ed., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, &lt;http://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]ブレーデン、R.、エド、 &#34;インターネットホストのための要件 - 通信層&#34;。、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、&lt;http://www.rfc-editor.org/info/ RFC1122&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191] Mogul, J. and S. Deering, &#34;Path MTU discovery&#34;, RFC 1191, DOI 10.17487/RFC1191, November 1990, &lt;http://www.rfc-editor.org/info/rfc1191&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191]ムガール人、J.とS.デアリング、 &#34;パスMTUディスカバリ&#34;、RFC 1191、DOI 10.17487 / RFC1191、1990年11月、&lt;http://www.rfc-editor.org/info/rfc1191&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1981] McCann, J., Deering, S., and J. Mogul, &#34;Path MTU Discovery for IP version 6&#34;, RFC 1981, DOI 10.17487/RFC1981, August 1996, &lt;http://www.rfc-editor.org/info/rfc1981&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1981]マッキャン、J.、デアリング、S.、およびJ.ムガール人、RFC 1981 &#34;IPバージョン6のパスMTUディスカバリー&#34;、DOI 10.17487 / RFC1981、1996年8月、&lt;のhttp：//www.rfc-editor。組織/情報/ rfc1981&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, DOI 10.17487/RFC2460, December 1998, &lt;http://www.rfc-editor.org/info/rfc2460&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460]デアリング、S.とR. Hindenと &#34;インターネットプロトコル、バージョン6（IPv6）の仕様&#34;、RFC 2460、DOI 10.17487 / RFC2460、1998年12月、&lt;http://www.rfc-editor.org/info/ RFC2460&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, DOI 10.17487/RFC2914, September 2000, &lt;http://www.rfc-editor.org/info/rfc2914&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914]フロイド、S.、 &#34;輻輳制御の原理&#34;、BCP 41、RFC 2914、DOI 10.17487 / RFC2914、2000年9月、&lt;http://www.rfc-editor.org/info/rfc2914&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3828] Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed., and G. Fairhurst, Ed., &#34;The Lightweight User Datagram Protocol (UDP-Lite)&#34;, RFC 3828, DOI 10.17487/RFC3828, July 2004, &lt;http://www.rfc-editor.org/info/rfc3828&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3828] Larzon、LA。、Degermark、M.、ピンク、S.、ジョンソン、LE。、編、及びG. Fairhurst、編、 &#34;軽量ユーザーデータグラムプロトコル（UDP-Liteの）&#34;、RFC 3828、 DOI 10.17487 / RFC3828、2004年7月、&lt;http://www.rfc-editor.org/info/rfc3828&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4787] Audet, F., Ed. and C. Jennings, &#34;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP&#34;, BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007, &lt;http://www.rfc-editor.org/info/rfc4787&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4787] Audet、F.、エド。そして、C.ジェニングス、 &#34;ネットワークアドレス変換（NAT）ユニキャストUDPのための行動の要件&#34;、BCP 127、RFC 4787、DOI 10.17487 / RFC4787、2007年1月、&lt;http://www.rfc-editor.org/info/rfc4787&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821] Mathis, M. and J. Heffner, &#34;Packetization Layer Path MTU Discovery&#34;, RFC 4821, DOI 10.17487/RFC4821, March 2007, &lt;http://www.rfc-editor.org/info/rfc4821&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821]マシス、M.とJ. Heffner、 &#34;パケット化レイヤのパスMTUディスカバリ&#34;、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、&lt;http://www.rfc-editor.org/info/rfc4821&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, &#34;TCP Friendly Rate Control (TFRC): Protocol Specification&#34;, RFC 5348, DOI 10.17487/RFC5348, September 2008, &lt;http://www.rfc-editor.org/info/rfc5348&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348]フロイド、S.、ハンドリー、M.、Padhye、J.、およびJ.ウィトマー、 &#34;TCPフレンドリーレート制御（TFRC）：プロトコル仕様&#34;、RFC 5348、DOI 10.17487 / RFC5348、2008年9月、&lt;のhttp： //www.rfc-editor.org/info/rfc5348&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] Eggert, L. and G. Fairhurst, &#34;Unicast UDP Usage Guidelines for Application Designers&#34;, BCP 145, RFC 5405, DOI 10.17487/RFC5405, November 2008, &lt;http://www.rfc-editor.org/info/rfc5405&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405]エッゲルト、L.とG. Fairhurst、 &#34;アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項&#34;、BCP 145、RFC 5405、DOI 10.17487 / RFC5405、2008年11月、&lt;http://www.rfc-editor.org/info / rfc5405&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6040] Briscoe, B., &#34;Tunnelling of Explicit Congestion Notification&#34;, RFC 6040, DOI 10.17487/RFC6040, November 2010, &lt;http://www.rfc-editor.org/info/rfc6040&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6040]ブリスコウ、B.、 &#34;明示的輻輳通知のトンネリング&#34;、RFC 6040、DOI 10.17487 / RFC6040、2010年11月、&lt;http://www.rfc-editor.org/info/rfc6040&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 6298, DOI 10.17487/RFC6298, June 2011, &lt;http://www.rfc-editor.org/info/rfc6298&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 &#34;コンピューティングTCPの再送信タイマー&#34;、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、&lt;のhttp：//www.rfc- editor.org/info/rfc6298&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8084] Fairhurst, G., &#34;Network Transport Circuit Breakers&#34;, BCP 208, RFC 8084, DOI 10.17487/RFC8084, March 2017, &lt;http://www.rfc-editor.org/info/rfc8084&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8084] Fairhurst、G.、 &#34;ネットワーク・トランスポートサーキットブレーカー&#34;、BCP 208、RFC 8084、DOI 10.17487 / RFC8084、2017年3月、&lt;http://www.rfc-editor.org/info/rfc8084&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ALLMAN] Allman, M. and E. Blanton, &#34;Notes on burst mitigation for transport protocols&#34;, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
【ALLMAN]オールマン、M.およびE.ブラントン、2005年3月、「トランスポートプロトコルのバースト緩和の注意事項」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BEHAVE-APP] Ford, B., &#34;Application Design Guidelines for Traversal through Network Address Translators&#34;, Work in Progress, draft-ford-behave-app-05, March 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BEHAVE-APP]フォード、B.、進捗状況、ドラフトフォード-振る舞うアプリ-05、2007年3月にワーク &#34;ネットワークを介してトラバーサルのためのアプリケーション設計のガイドラインは、翻訳者アドレス&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ENCAP] Nordmark, E., Ed., Tian, A., Gross, J., Hudson, J., Kreeger, L., Garg, P., Thaler, P., and T. Herbert, &#34;Encapsulation Considerations&#34;, Work in Progress, draft-ietf-rtgwg-dt-encap-02, October 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ENCAP] Nordmarkと、E.、編、天、A.、グロス、J.、ハドソン、J.、Kreeger、L.、ガーグ、P.、ターラー、P.、およびT.ハーバート、 &#34;カプセル化の考慮事項&#34;進捗状況、ドラフト-IETF-rtgwg-DT-ENCAP-02、2016年10月で、作業。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FABER] Faber, T., Touch, J., and W. Yue, &#34;The TIME-WAIT State in TCP and Its Effect on Busy Servers&#34;, Proc. IEEE Infocom, March 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;ビジーサーバー上のTCPとその効果でTIME-WAIT状態&#34; [FABER]フェーバー、T.、タッチ、J.、およびW.越、PROC。 IEEEインフォコム、1999年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INT-TUNNELS] Touch, J. and W. Townsley, &#34;IP Tunnels in the Internet Architecture&#34;, Work in Progress, draft-ietf-intarea-tunnels-03, July 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INT-TUNNELS]タッチ、J.とW. Townsley、 &#34;インターネットアーキテクチャにおけるIPトンネル&#34; が進行中で働いて、ドラフト-IETF-intarea-トンネル-03、2016年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POSIX] IEEE Std. 1003.1-2001, , &#34;Standard for Information Technology - Portable Operating System Interface (POSIX)&#34;, Open Group Technical Standard: Base Specifications Issue 6, ISO/IEC 9945:2002, December 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POSIX] IEEE STD。 1003.1-2001、 &#34;情報技術のための標準 - ポータブルオペレーティングシステムインタフェース（POSIX）&#34;、Open Groupの技術標準：基本仕様6号、ISO / IEC 9945：2002、2001年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC919] Mogul, J., &#34;Broadcasting Internet Datagrams&#34;, STD 5, RFC 919, DOI 10.17487/RFC0919, October 1984, &lt;http://www.rfc-editor.org/info/rfc919&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC919]モーグル、J.、 &#34;放送インターネットデータグラム&#34;、STD 5、RFC 919、DOI 10.17487 / RFC0919、1984年10月、&lt;http://www.rfc-editor.org/info/rfc919&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1112] Deering, S., &#34;Host extensions for IP multicasting&#34;, STD 5, RFC 1112, DOI 10.17487/RFC1112, August 1989, &lt;http://www.rfc-editor.org/info/rfc1112&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1112]デアリング、S.、STD 5、RFC 1112 &#34;IPマルチキャスティングのためのホスト拡大&#34;、DOI 10.17487 / RFC1112、1989年8月、&lt;http://www.rfc-editor.org/info/rfc1112&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1536] Kumar, A., Postel, J., Neuman, C., Danzig, P., and S. Miller, &#34;Common DNS Implementation Errors and Suggested Fixes&#34;, RFC 1536, DOI 10.17487/RFC1536, October 1993, &lt;http://www.rfc-editor.org/info/rfc1536&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1536]クマー、A.、ポステル、J.、ニューマン、C.、ダンツィヒ、P.、およびS. Millerの &#34;一般的なDNS実装エラーおよび推奨修正&#34;、RFC 1536、DOI 10.17487 / RFC1536、1993年10月、&lt; http://www.rfc-editor.org/info/rfc1536&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1546] Partridge, C., Mendez, T., and W. Milliken, &#34;Host Anycasting Service&#34;, RFC 1546, DOI 10.17487/RFC1546, November 1993, &lt;http://www.rfc-editor.org/info/rfc1546&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1546]ウズラ、C.、メンデス、T.、およびW.ミリケン、 &#34;ホストエニーキャストサービス&#34;、RFC 1546、DOI 10.17487 / RFC1546、1993年11月、&lt;http://www.rfc-editor.org/info/ rfc1546&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, &#34;Recommendations on Queue Management and Congestion Avoidance in the Internet&#34;, RFC 2309, DOI 10.17487/RFC2309, April 1998, &lt;http://www.rfc-editor.org/info/rfc2309&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309]ブレーデン、B.、クラーク、D.、クロウクロフト、J.、デイビー、B.、デアリング、S.、Estrin、D.、フロイド、S.、ヤコブソン、V.、Minshall、G.、ヤマウズラ、 C.、ピーターソン、L.、ラマクリシュナン、K.、Shenker、S.、Wroclawski、J.、およびL.チャン、 &#34;インターネットの待ち行列管理と輻輳回避に関する提言&#34;、RFC 2309、DOI 10.17487 / RFC2309、4月1998年、&lt;http://www.rfc-editor.org/info/rfc2309&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2475] Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, &#34;An Architecture for Differentiated Services&#34;, RFC 2475, DOI 10.17487/RFC2475, December 1998, &lt;http://www.rfc-editor.org/info/rfc2475&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2475]ブレイク、S.、ブラ​​ック、D.、カールソン、M.、デイヴィス、E.、王、Z.、およびW.ワイス、 &#34;差別化サービスのためのアーキテクチャ&#34;、RFC 2475、DOI 10.17487 / RFC2475、12月1998年、&lt;http://www.rfc-editor.org/info/rfc2475&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2675] Borman, D., Deering, S., and R. Hinden, &#34;IPv6 Jumbograms&#34;, RFC 2675, DOI 10.17487/RFC2675, August 1999, &lt;http://www.rfc-editor.org/info/rfc2675&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2675]ボーマン、D.、デアリング、S.、およびR. Hindenと &#34;IPv6のジャンボグラム&#34;、RFC 2675、DOI 10.17487 / RFC2675、1999年8月、&lt;http://www.rfc-editor.org/info/rfc2675 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn, J., &#34;Generic Security Service Application Program Interface Version 2, Update 1&#34;, RFC 2743, DOI 10.17487/RFC2743, January 2000, &lt;http://www.rfc-editor.org/info/rfc2743&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743]リン、J.、 &#34;ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1&#34;、RFC 2743、DOI 10.17487 / RFC2743、2000年1月、&lt;http://www.rfc-editor.org/info/rfc2743&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2887] Handley, M., Floyd, S., Whetten, B., Kermode, R., Vicisano, L., and M. Luby, &#34;The Reliable Multicast Design Space for Bulk Data Transfer&#34;, RFC 2887, DOI 10.17487/RFC2887, August 2000, &lt;http://www.rfc-editor.org/info/rfc2887&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2887]ハンドレー、M.、フロイド、S.、Whetten、B.、Kermode、R.、Vicisano、L.、及びM.ルビー、 &#34;バルクデータ転送のための高信頼マルチキャストデザインスペース&#34;、RFC 2887、DOI 10.17487 / RFC2887、2000年8月、&lt;http://www.rfc-editor.org/info/rfc2887&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2983] Black, D., &#34;Differentiated Services and Tunnels&#34;, RFC 2983, DOI 10.17487/RFC2983, October 2000, &lt;http://www.rfc-editor.org/info/rfc2983&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2983]ブラック、D.、 &#34;差別化サービスおよびトンネル&#34;、RFC 2983、DOI 10.17487 / RFC2983、2000年10月、&lt;http://www.rfc-editor.org/info/rfc2983&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3048] Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &#34;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer&#34;, RFC 3048, DOI 10.17487/RFC3048, January 2001, &lt;http://www.rfc-editor.org/info/rfc3048&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3048] Whetten、B.、Vicisano、L.、Kermode、R.、ハンドレー、M.、フロイド、S.、およびM.ルビー、 &#34;信頼できるマルチキャストトランスポート・ビルディング・ブロック一対多バルクデータ転送のための&#34; 、RFC 3048、DOI 10.17487 / RFC3048、2001年1月、&lt;http://www.rfc-editor.org/info/rfc3048&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3124] Balakrishnan, H. and S. Seshan, &#34;The Congestion Manager&#34;, RFC 3124, DOI 10.17487/RFC3124, June 2001, &lt;http://www.rfc-editor.org/info/rfc3124&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3124]バラクリシュナン、H.とS. Seshan、 &#34;輻輳管理&#34;、RFC 3124、DOI 10.17487 / RFC3124、2001年6月、&lt;http://www.rfc-editor.org/info/rfc3124&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, DOI 10.17487/RFC3168, September 2001, &lt;http://www.rfc-editor.org/info/rfc3168&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;IPへの明示的輻輳通知の追加（ECN）&#34; [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、&lt;のhttp：// WWW。 rfc-editor.org/info/rfc3168&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &#34;SIP: Session Initiation Protocol&#34;, RFC 3261, DOI 10.17487/RFC3261, June 2002, &lt;http://www.rfc-editor.org/info/rfc3261&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 &#34;SIP：セッション開始プロトコル&#34; 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、&lt;http://www.rfc-editor.org/info/rfc3261&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3303] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and A. Rayhan, &#34;Middlebox communication architecture and framework&#34;, RFC 3303, DOI 10.17487/RFC3303, August 2002, &lt;http://www.rfc-editor.org/info/rfc3303&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3303] Srisuresh、P.、Kuthan、J.、ローゼンバーグ、J.、モリター、A.、およびA. Rayhan、 &#34;ミドル通信アーキテクチャおよびフレームワーク&#34;、RFC 3303、DOI 10.17487 / RFC3303、2002年8月、&lt;HTTP： //www.rfc-editor.org/info/rfc3303&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &#34;Basic Socket Interface Extensions for IPv6&#34;, RFC 3493, DOI 10.17487/RFC3493, February 2003, &lt;http://www.rfc-editor.org/info/rfc3493&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3493]ギリガン、R.、トムソン、S.、バウンド、J.、マッキャン、J.、およびW.スティーブンス、 &#34;IPv6の基本的なソケットインタフェース拡張&#34;、RFC 3493、DOI 10.17487 / RFC3493、2003年2月、&lt;HTTP ：//www.rfc-editor.org/info/rfc3493&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, &lt;http://www.rfc-editor.org/info/rfc3550&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 &#34;RTP：リアルタイムアプリケーションのためのトランスポートプロトコル&#34;、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 &lt;http://www.rfc-editor.org/info/rfc3550&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551] Schulzrinne, H. and S. Casner, &#34;RTP Profile for Audio and Video Conferences with Minimal Control&#34;, STD 65, RFC 3551, DOI 10.17487/RFC3551, July 2003, &lt;http://www.rfc-editor.org/info/rfc3551&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551] Schulzrinneと、H.とS. Casner、 &#34;最小量のコントロールがあるオーディオとビデオ会議システムのためのRTPプロフィール&#34;、STD 65、RFC 3551、DOI 10.17487 / RFC3551、2003年7月、&lt;のhttp：//www.rfc-editor。組織/情報/ RFC3551&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3738] Luby, M. and V. Goyal, &#34;Wave and Equation Based Rate Control (WEBRC) Building Block&#34;, RFC 3738, DOI 10.17487/RFC3738, April 2004, &lt;http://www.rfc-editor.org/info/rfc3738&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3738]ルビー、M.およびV. Goyal氏、 &#34;波動と式ベースのレート制御（WEBRC）ビルディングブロック&#34;、RFC 3738、DOI 10.17487 / RFC3738、2004年4月、&lt;http://www.rfc-editor.org/情報/ rfc3738&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3758] Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P. Conrad, &#34;Stream Control Transmission Protocol (SCTP) Partial Reliability Extension&#34;, RFC 3758, DOI 10.17487/RFC3758, May 2004, &lt;http://www.rfc-editor.org/info/rfc3758&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3758]スチュワート、R.、Ramalho、M.、謝、Q.、Tuexen、M.、およびP.コンラッド、 &#34;ストリーム制御伝送プロトコル（SCTP）部分信頼拡張子&#34;、RFC 3758、DOI 10.17487 / RFC3758、月2004年、&lt;http://www.rfc-editor.org/info/rfc3758&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3819] Karn, P., Ed., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &#34;Advice for Internet Subnetwork Designers&#34;, BCP 89, RFC 3819, DOI 10.17487/RFC3819, July 2004, &lt;http://www.rfc-editor.org/info/rfc3819&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3819]カーン、P.編、ボルマン、C.、Fairhurst、G.、グロスマン、D.、ルートヴィヒ、R.、Mahdavi、J.、モンテネグロ、G.、タッチ、J.、およびL.ウッド、 &#34;インターネットサブネットワークデザイナーのためのアドバイス&#34;、BCP 89、RFC 3819、DOI 10.17487 / RFC3819、2004年7月、&lt;http://www.rfc-editor.org/info/rfc3819&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4301] Kent, S. and K. Seo, &#34;Security Architecture for the Internet Protocol&#34;, RFC 4301, DOI 10.17487/RFC4301, December 2005, &lt;http://www.rfc-editor.org/info/rfc4301&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4301]ケント、S.とK. Seo、 &#34;インターネットプロトコルのためのセキュリティアーキテクチャ&#34;、RFC 4301、DOI 10.17487 / RFC4301、2005年12月、&lt;http://www.rfc-editor.org/info/rfc4301&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, DOI 10.17487/RFC4302, December 2005, &lt;http://www.rfc-editor.org/info/rfc4302&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302]ケント、S.、 &#34;IP認証ヘッダー&#34;、RFC 4302、DOI 10.17487 / RFC4302、2005年12月、&lt;http://www.rfc-editor.org/info/rfc4302&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303] Kent, S., &#34;IP Encapsulating Security Payload (ESP)&#34;, RFC 4303, DOI 10.17487/RFC4303, December 2005, &lt;http://www.rfc-editor.org/info/rfc4303&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303]ケント、S.、 &#34;IPカプセル化セキュリティペイロード（ESP）&#34;、RFC 4303、DOI 10.17487 / RFC4303、2005年12月、&lt;http://www.rfc-editor.org/info/rfc4303&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4340] Kohler, E., Handley, M., and S. Floyd, &#34;Datagram Congestion Control Protocol (DCCP)&#34;, RFC 4340, DOI 10.17487/RFC4340, March 2006, &lt;http://www.rfc-editor.org/info/rfc4340&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4340]コーラー、E.、ハンドリー、M.、およびS.フロイド、 &#34;データグラム輻輳制御プロトコル（DCCP）&#34;、RFC 4340、DOI 10.17487 / RFC4340、2006年3月、&lt;のhttp：//www.rfc-editor。組織/情報/ RFC4340&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4341] Floyd, S. and E. Kohler, &#34;Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control&#34;, RFC 4341, DOI 10.17487/RFC4341, March 2006, &lt;http://www.rfc-editor.org/info/rfc4341&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4341]フロイド、S.、およびE.コーラー、 &#34;データグラム輻輳制御プロトコルのためのプロファイル（DCCP）輻輳制御ID 2：TCPのような輻輳制御&#34;、RFC 4341、DOI 10.17487 / RFC4341、2006年3月、&lt;のhttp：// www.rfc-editor.org/info/rfc4341&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4342] Floyd, S., Kohler, E., and J. Padhye, &#34;Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)&#34;, RFC 4342, DOI 10.17487/RFC4342, March 2006, &lt;http://www.rfc-editor.org/info/rfc4342&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4342]フロイド、S.、ケーラー、E.、およびJ. Padhye、 &#34;データグラム輻輳制御プロトコル（DCCP）輻輳制御ID 3のプロファイル：TCPフレンドリーレート制御（TFRC）&#34;、RFC 4342、DOI 10.17487 / RFC4342 、2006年3月、&lt;http://www.rfc-editor.org/info/rfc4342&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4380] Huitema, C., &#34;Teredo: Tunneling IPv6 over UDP through Network Address Translations (NATs)&#34;, RFC 4380, DOI 10.17487/RFC4380, February 2006, &lt;http://www.rfc-editor.org/info/rfc4380&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4380]のHuitema、C.、 &#34;のTeredo：ネットワークアドレス変換（NATを）を通じてUDP経由トンネリングのIPv6&#34;、RFC 4380、DOI 10.17487 / RFC4380、2006年2月、&lt;http://www.rfc-editor.org/info/ rfc4380&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4607] Holbrook, H. and B. Cain, &#34;Source-Specific Multicast for IP&#34;, RFC 4607, DOI 10.17487/RFC4607, August 2006, &lt;http://www.rfc-editor.org/info/rfc4607&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4607]ホルブルック、H.、およびB.カイン、 &#34;IPのためのソース固有のマルチキャスト&#34;、RFC 4607、DOI 10.17487 / RFC4607、2006年8月、&lt;http://www.rfc-editor.org/info/rfc4607&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4654] Widmer, J. and M. Handley, &#34;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification&#34;, RFC 4654, DOI 10.17487/RFC4654, August 2006, &lt;http://www.rfc-editor.org/info/rfc4654&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4654]ウィドマー、J.とM.ハンドリー、 &#34;TCPフレンドリーマルチキャスト輻輳制御（TFMCC）：プロトコル仕様&#34;、RFC 4654、DOI 10.17487 / RFC4654、2006年8月、&lt;http://www.rfc-editor.org /情報/ rfc4654&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4880] Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &#34;OpenPGP Message Format&#34;, RFC 4880, DOI 10.17487/RFC4880, November 2007, &lt;http://www.rfc-editor.org/info/rfc4880&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4880]カラス、J.、Donnerhacke、L.、フィニー、H.、ショー、D.、およびR.セイヤー、 &#34;OpenPGPのメッセージフォーマット&#34;、RFC 4880、DOI 10.17487 / RFC4880、2007年11月、&lt;のhttp：// www.rfc-editor.org/info/rfc4880&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4890] Davies, E. and J. Mohacsi, &#34;Recommendations for Filtering ICMPv6 Messages in Firewalls&#34;, RFC 4890, DOI 10.17487/RFC4890, May 2007, &lt;http://www.rfc-editor.org/info/rfc4890&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4890]デイヴィス、E.およびJ. Mohacsi、 &#34;ファイアウォールのフィルタICMPv6メッセージのための推奨事項&#34;、RFC 4890、DOI 10.17487 / RFC4890、2007年5月、&lt;http://www.rfc-editor.org/info/rfc4890&gt; 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960] Stewart, R., Ed., &#34;Stream Control Transmission Protocol&#34;, RFC 4960, DOI 10.17487/RFC4960, September 2007, &lt;http://www.rfc-editor.org/info/rfc4960&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960]スチュワート、R.、エド。、 &#34;ストリーム制御伝送プロトコル&#34;、RFC 4960、DOI 10.17487 / RFC4960、2007年9月、&lt;http://www.rfc-editor.org/info/rfc4960&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4963] Heffner, J., Mathis, M., and B. Chandler, &#34;IPv4 Reassembly Errors at High Data Rates&#34;, RFC 4963, DOI 10.17487/RFC4963, July 2007, &lt;http://www.rfc-editor.org/info/rfc4963&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4963] Heffner、J.、マティス、M.、およびB.チャンドラー、 &#34;高速データレートでのIPv4の再構築エラー&#34;、RFC 4963、DOI 10.17487 / RFC4963、2007年7月、&lt;のhttp：//www.rfc-editor。組織/情報/ rfc4963&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987] Eddy, W., &#34;TCP SYN Flooding Attacks and Common Mitigations&#34;, RFC 4987, DOI 10.17487/RFC4987, August 2007, &lt;http://www.rfc-editor.org/info/rfc4987&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987]エディ、W.、 &#34;TCPのSYNフラッド攻撃と共通の軽減策&#34;、RFC 4987、DOI 10.17487 / RFC4987、2007年8月、&lt;http://www.rfc-editor.org/info/rfc4987&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5082] Gill, V., Heasley, J., Meyer, D., Savola, P., Ed., and C. Pignataro, &#34;The Generalized TTL Security Mechanism (GTSM)&#34;, RFC 5082, DOI 10.17487/RFC5082, October 2007, &lt;http://www.rfc-editor.org/info/rfc5082&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5082]ギル、V.、Heasley、J.、マイヤー、D.、Savola、P.、エド。、およびC. Pignataro、 &#34;一般TTLセキュリティメカニズム（GTSM）&#34;、RFC 5082、DOI 10.17487 / RFC5082、 2007年10月、&lt;http://www.rfc-editor.org/info/rfc5082&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245] Rosenberg, J., &#34;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols&#34;, RFC 5245, DOI 10.17487/RFC5245, April 2010, &lt;http://www.rfc-editor.org/info/rfc5245&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245]ローゼンバーグ、J.、 &#34;インタラクティブ接続確立（ICE）：オファー/回答プロトコルのためのネットワークアドレス変換器（NAT）トラバーサルのための議定書&#34;、RFC 5245、DOI 10.17487 / RFC5245、2010年4月、&lt;のhttp：// WWW .rfc-editor.org /情報/ rfc5245&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5622] Floyd, S. and E. Kohler, &#34;Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)&#34;, RFC 5622, DOI 10.17487/RFC5622, August 2009, &lt;http://www.rfc-editor.org/info/rfc5622&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5622]フロイド、S.、およびE.コーラー、 &#34;データグラム輻輳制御プロトコル（DCCP）輻輳ID 4のプロファイル：スモールパケットのTCPフレンドリーレート制御（TFRC-SP）&#34;、RFC 5622、DOI 10.17487 / RFC5622、月2009年、&lt;http://www.rfc-editor.org/info/rfc5622&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5652] Housley, R., &#34;Cryptographic Message Syntax (CMS)&#34;, STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009, &lt;http://www.rfc-editor.org/info/rfc5652&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5652] Housley氏、R.、 &#34;暗号メッセージ構文（CMS）&#34;、STD 70、RFC 5652、DOI 10.17487 / RFC5652、2009年9月、&lt;http://www.rfc-editor.org/info/rfc5652&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, DOI 10.17487/RFC5681, September 2009, &lt;http://www.rfc-editor.org/info/rfc5681&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 &#34;TCP輻輳制御&#34;、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、&lt;http://www.rfc-editor.org/info/ rfc5681&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5740] Adamson, B., Bormann, C., Handley, M., and J. Macker, &#34;NACK-Oriented Reliable Multicast (NORM) Transport Protocol&#34;, RFC 5740, DOI 10.17487/RFC5740, November 2009, &lt;http://www.rfc-editor.org/info/rfc5740&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5740]アダムソン、B.、ボルマン、C.、ハンドレー、M.、およびJ. Macker、 &#34;NACK指向高信頼マルチキャスト（NORM）トランスポートプロトコル&#34;、RFC 5740、DOI 10.17487 / RFC5740、2009年11月、&lt;HTTP： //www.rfc-editor.org/info/rfc5740&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5751] Ramsdell, B. and S. Turner, &#34;Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification&#34;, RFC 5751, DOI 10.17487/RFC5751, January 2010, &lt;http://www.rfc-editor.org/info/rfc5751&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5751] Ramsdell、B.とS.ターナーは、 &#34;セキュア/多目的インターネットメール拡張（S / MIME）バージョン3.2メッセージ仕様&#34;、RFC 5751、DOI 10.17487 / RFC5751、2010年1月、&lt;のhttp：//www.rfc- editor.org/info/rfc5751&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5775] Luby, M., Watson, M., and L. Vicisano, &#34;Asynchronous Layered Coding (ALC) Protocol Instantiation&#34;, RFC 5775, DOI 10.17487/RFC5775, April 2010, &lt;http://www.rfc-editor.org/info/rfc5775&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5775]ルビー、M.、ワトソン、M.、およびL. Vicisano、 &#34;非同期階層コーディング（ALC）プロトコルのインスタンス化&#34;、RFC 5775、DOI 10.17487 / RFC5775、2010年4月、&lt;HTTP：//www.rfc-editor .ORG /情報/ rfc5775&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5971] Schulzrinne, H. and R. Hancock, &#34;GIST: General Internet Signalling Transport&#34;, RFC 5971, DOI 10.17487/RFC5971, October 2010, &lt;http://www.rfc-editor.org/info/rfc5971&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5971] Schulzrinneと、H.とR.ハンコック、 &#34;GIST：一般的なインターネットシグナリング交通&#34;、RFC 5971、DOI 10.17487 / RFC5971、2010年10月、&lt;http://www.rfc-editor.org/info/rfc5971&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5973] Stiemerling, M., Tschofenig, H., Aoun, C., and E. Davies, &#34;NAT/Firewall NSIS Signaling Layer Protocol (NSLP)&#34;, RFC 5973, DOI 10.17487/RFC5973, October 2010, &lt;http://www.rfc-editor.org/info/rfc5973&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5973] Stiemerling、M.、Tschofenig、H.、アウン、C.、およびE.デイヴィス、 &#34;NAT /ファイアウォールNSISシグナリング層プロトコル（NSLP）&#34;、RFC 5973、DOI 10.17487 / RFC5973、2010年10月、&lt;HTTP： //www.rfc-editor.org/info/rfc5973&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6056] Larsen, M. and F. Gont, &#34;Recommendations for Transport-Protocol Port Randomization&#34;, BCP 156, RFC 6056, DOI 10.17487/RFC6056, January 2011, &lt;http://www.rfc-editor.org/info/rfc6056&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6056]ラーセン、M.とF. Gont、 &#34;トランスポート・プロトコルポートランダム化のための提言&#34;、BCP 156、RFC 6056、DOI 10.17487 / RFC6056、2011年1月、&lt;http://www.rfc-editor.org/info / rfc6056&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6092] Woodyatt, J., Ed., &#34;Recommended Simple Security Capabilities in Customer Premises Equipment (CPE) for Providing Residential IPv6 Internet Service&#34;, RFC 6092, DOI 10.17487/RFC6092, January 2011, &lt;http://www.rfc-editor.org/info/rfc6092&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6092] Woodyatt、J.、エド、RFC 6092 &#34;住宅IPv6インターネットサービスを提供するための顧客宅内機器（CPE）での簡単なセキュリティ機能を推奨&#34;、DOI 10.17487 / RFC6092、2011年1月、&lt;のhttp：。//www.rfc -editor.org/info/rfc6092&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6335] Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, &#34;Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry&#34;, BCP 165, RFC 6335, DOI 10.17487/RFC6335, August 2011, &lt;http://www.rfc-editor.org/info/rfc6335&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6335]コットン、M.、エッゲルト、L.、タッチ、J.、ウェスター、M.、およびS.チェシャー、「IANA（Internet Assigned Numbers Authority）のサービス名とトランスポートプロトコルポート番号レジストリの管理のための手順」、BCP 165、RFC 6335、DOI 10.17487 / RFC6335、2011年8月、&lt;http://www.rfc-editor.org/info/rfc6335&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security Version 1.2&#34;, RFC 6347, DOI 10.17487/RFC6347, January 2012, &lt;http://www.rfc-editor.org/info/rfc6347&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347]レスコラ、E.およびN. Modadugu、 &#34;データグラムトランスポート層セキュリティバージョン1.2&#34;、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、&lt;http://www.rfc-editor.org/info/rfc6347&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6396] Blunk, L., Karir, M., and C. Labovitz, &#34;Multi-Threaded Routing Toolkit (MRT) Routing Information Export Format&#34;, RFC 6396, DOI 10.17487/RFC6396, October 2011, &lt;http://www.rfc-editor.org/info/rfc6396&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6396]ブルンク、L.、Karir、M.、およびC. Labovitz、 &#34;マルチスレッド・ルーティングツールキット（MRT）ルーティング情報エクスポート形式&#34;、RFC 6396、DOI 10.17487 / RFC6396、2011年10月、&lt;のhttp：// WWW .rfc-editor.org /情報/ rfc6396&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6437] Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme, &#34;IPv6 Flow Label Specification&#34;, RFC 6437, DOI 10.17487/RFC6437, November 2011, &lt;http://www.rfc-editor.org/info/rfc6437&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6437] Amante、S.、大工、B.、江、S.、およびJ. Rajahalme、 &#34;IPv6のフローラベル仕様&#34;、RFC 6437、DOI 10.17487 / RFC6437、2011年11月、&lt;のhttp：//www.rfc- editor.org/info/rfc6437&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6438] Carpenter, B. and S. Amante, &#34;Using the IPv6 Flow Label for Equal Cost Multipath Routing and Link Aggregation in Tunnels&#34;, RFC 6438, DOI 10.17487/RFC6438, November 2011, &lt;http://www.rfc-editor.org/info/rfc6438&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6438]大工、B.とS. Amante、 &#34;トンネル内イコールコストマルチパスルーティングおよびリンクアグリゲーションのためのIPv6フローラベルの使用&#34;、RFC 6438、DOI 10.17487 / RFC6438、2011年11月、&lt;のhttp：//www.rfc- editor.org/info/rfc6438&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6513] Rosen, E., Ed. and R. Aggarwal, Ed., &#34;Multicast in MPLS/ BGP IP VPNs&#34;, RFC 6513, DOI 10.17487/RFC6513, February 2012, &lt;http://www.rfc-editor.org/info/rfc6513&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6513]ローゼン、E.、エド。そして、R.アガルワル、エド。、 &#34;マルチキャストMPLS / BGP VPNのIPで&#34;、RFC 6513、DOI 10.17487 / RFC6513、2012年2月、&lt;http://www.rfc-editor.org/info/rfc6513&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679] Westerlund, M., Johansson, I., Perkins, C., O&#39;Hanlon, P., and K. Carlberg, &#34;Explicit Congestion Notification (ECN) for RTP over UDP&#34;, RFC 6679, DOI 10.17487/RFC6679, August 2012, &lt;http://www.rfc-editor.org/info/rfc6679&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679]ウェスター、M.、ヨハンソン、I.、パーキンス、C.、オハンロン、P.、およびK.カールバーグ、 &#34;明示的輻輳通知UDP上のRTPのための（ECN）&#34;、RFC 6679、DOI 10.17487 / RFC6679 、2012年8月、&lt;http://www.rfc-editor.org/info/rfc6679&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6726] Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen, &#34;FLUTE - File Delivery over Unidirectional Transport&#34;, RFC 6726, DOI 10.17487/RFC6726, November 2012, &lt;http://www.rfc-editor.org/info/rfc6726&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6726] Paila、T.、ウォルシュ、R.、ルビー、M.、ロカ、V.、およびR. Lehtonenの、 &#34;FLUTE  - 単方向トランスポート上でファイル配信&#34;、RFC 6726、DOI 10.17487 / RFC6726、2012年11月、&lt; http://www.rfc-editor.org/info/rfc6726&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6773] Phelan, T., Fairhurst, G., and C. Perkins, &#34;DCCP-UDP: A Datagram Congestion Control Protocol UDP Encapsulation for NAT Traversal&#34;, RFC 6773, DOI 10.17487/RFC6773, November 2012, &lt;http://www.rfc-editor.org/info/rfc6773&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6773]フェラン、T.、Fairhurst、G.、およびC.パーキンス、 &#34;DCCP-UDP：データグラム混雑NATトラバーサルのための制御プロトコルUDPカプセル化&#34;、RFC 6773、DOI 10.17487 / RFC6773、2012年11月、&lt;のhttp：/ /www.rfc-editor.org/info/rfc6773&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6807] Farinacci, D., Shepherd, G., Venaas, S., and Y. Cai, &#34;Population Count Extensions to Protocol Independent Multicast (PIM)&#34;, RFC 6807, DOI 10.17487/RFC6807, December 2012, &lt;http://www.rfc-editor.org/info/rfc6807&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6807]ファリナッチ、D.、シェパード、G.、Venaas、S.、およびY.カイ、RFC 6807 &#34;プロトコル独立マルチキャスト（PIM）への人口カウント拡張機能&#34;、DOI 10.17487 / RFC6807、2012年12月、&lt;のhttp： //www.rfc-editor.org/info/rfc6807&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6887] Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and P. Selkirk, &#34;Port Control Protocol (PCP)&#34;, RFC 6887, DOI 10.17487/RFC6887, April 2013, &lt;http://www.rfc-editor.org/info/rfc6887&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6887]ウィング、D.、編、チェシャー、S.、Boucadair、M.、Penno、R.、およびP.セルカーク、 &#34;ポート制御プロトコル（PCP）&#34;、RFC 6887、DOI 10.17487 / RFC6887、2013年4月、&lt;http://www.rfc-editor.org/info/rfc6887&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6935] Eubanks, M., Chimento, P., and M. Westerlund, &#34;IPv6 and UDP Checksums for Tunneled Packets&#34;, RFC 6935, DOI 10.17487/RFC6935, April 2013, &lt;http://www.rfc-editor.org/info/rfc6935&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6935]ユーバンクス、M.、Chimento、P.、およびM.ウェスター、 &#34;トンネリングされたパケットのIPv6およびUDPチェックサム&#34;、RFC 6935、DOI 10.17487 / RFC6935、2013年4月、&lt;のhttp：//www.rfc-editor。組織/情報/ rfc6935&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6936] Fairhurst, G. and M. Westerlund, &#34;Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums&#34;, RFC 6936, DOI 10.17487/RFC6936, April 2013, &lt;http://www.rfc-editor.org/info/rfc6936&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6936] Fairhurst、G.およびM.ウェスター、 &#34;ゼロチェックサムとIPv6のUDPデータグラムを使用するための適用性に関する声明&#34;、RFC 6936、DOI 10.17487 / RFC6936、2013年4月、&lt;http://www.rfc-editor.org /情報/ rfc6936&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6951] Tuexen, M. and R. Stewart, &#34;UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication&#34;, RFC 6951, DOI 10.17487/RFC6951, May 2013, &lt;http://www.rfc-editor.org/info/rfc6951&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6951] Tuexen、M.とR.スチュワート、RFC 6951、DOI 10.17487 / RFC6951、2013年5月、&lt;HTTP &#34;ストリーム制御伝送プロトコル（SCTP）エンドホストへのエンドホスト通信用パケットのUDPカプセル化&#34;：/ /www.rfc-editor.org/info/rfc6951&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7143] Chadalapaka, M., Satran, J., Meth, K., and D. Black, &#34;Internet Small Computer System Interface (iSCSI) Protocol (Consolidated)&#34;, RFC 7143, DOI 10.17487/RFC7143, April 2014, &lt;http://www.rfc-editor.org/info/rfc7143&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7143] Chadalapaka、M.、Satran、J.、メタ、K.、およびD.ブラック、 &#34;インターネット小型コンピュータシステムインタフェース（iSCSIの）プロトコル（連結）&#34;、RFC 7143、DOI 10.17487 / RFC7143、2014年4月、&lt; http://www.rfc-editor.org/info/rfc7143&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7201] Westerlund, M. and C. Perkins, &#34;Options for Securing RTP Sessions&#34;, RFC 7201, DOI 10.17487/RFC7201, April 2014, &lt;http://www.rfc-editor.org/info/rfc7201&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7201]ウェスター、M.とC.パーキンス、 &#34;RTPセッションを確保するためのオプション&#34;、RFC 7201、DOI 10.17487 / RFC7201、2014年4月、&lt;http://www.rfc-editor.org/info/rfc7201&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, &#34;Internet Key Exchange Protocol Version 2 (IKEv2)&#34;, STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, &lt;http://www.rfc-editor.org/info/rfc7296&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7296]コーフマン、C.、ホフマン、P.、ニール、Y.、Eronen、P.、およびT. Kivinen、 &#34;インターネット鍵交換プロトコルバージョン2（IKEv2の）&#34;、STD 79、RFC 7296、DOI 10.17487 / RFC7296 、2014年10月、&lt;http://www.rfc-editor.org/info/rfc7296&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7450] Bumgardner, G., &#34;Automatic Multicast Tunneling&#34;, RFC 7450, DOI 10.17487/RFC7450, February 2015, &lt;http://www.rfc-editor.org/info/rfc7450&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7450] Bumgardner、G.、 &#34;自動マルチキャストトンネリング&#34;、RFC 7450、DOI 10.17487 / RFC7450、2015年2月、&lt;http://www.rfc-editor.org/info/rfc7450&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7510] Xu, X., Sheth, N., Yong, L., Callon, R., and D. Black, &#34;Encapsulating MPLS in UDP&#34;, RFC 7510, DOI 10.17487/RFC7510, April 2015, &lt;http://www.rfc-editor.org/info/rfc7510&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7510]徐、X.、Sheth、N.、龍、L.、Callon、R.、およびD.ブラック、 &#34;UDPでカプセル化MPLS&#34;、RFC 7510、DOI 10.17487 / RFC7510、2015年4月、&lt;のhttp：/ /www.rfc-editor.org/info/rfc7510&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, &#34;Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&#34;, BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, &lt;http://www.rfc-editor.org/info/rfc7525&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7525]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、 &#34;トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のセキュアな利用のための提言&#34;、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、&lt;http://www.rfc-editor.org/info/rfc7525&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7560] Kuehlewind, M., Ed., Scheffenegger, R., and B. Briscoe, &#34;Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback&#34;, RFC 7560, DOI 10.17487/RFC7560, August 2015, &lt;http://www.rfc-editor.org/info/rfc7560&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7560] Kuehlewind、M.編、Scheffenegger、R.、およびB.ブリスコウ、 &#34;問題文と明示的輻輳通知（ECN）フィードバックで高精度の要件&#34;、RFC 7560、DOI 10.17487 / RFC7560、2015年8月、 &lt;http://www.rfc-editor.org/info/rfc7560&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567] Baker, F., Ed. and G. Fairhurst, Ed., &#34;IETF Recommendations Regarding Active Queue Management&#34;, BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, &lt;http://www.rfc-editor.org/info/rfc7567&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567]ベーカー、F.、エド。そして、G. Fairhurst、エド。、 &#34;アクティブキュー管理に関するIETF勧告&#34;、BCP 197、RFC 7567、DOI 10.17487 / RFC7567、2015年7月、&lt;http://www.rfc-editor.org/info/rfc7567&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7605] Touch, J., &#34;Recommendations on Using Assigned Transport Port Numbers&#34;, BCP 165, RFC 7605, DOI 10.17487/RFC7605, August 2015, &lt;http://www.rfc-editor.org/info/rfc7605&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7605]タッチ、J.、 &#34;割り当てられたトランスポート・ポート番号の使用に関する提言&#34;、BCP 165、RFC 7605、DOI 10.17487 / RFC7605、2015年8月、&lt;http://www.rfc-editor.org/info/rfc7605&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657] Black, D., Ed. and P. Jones, &#34;Differentiated Services (Diffserv) and Real-Time Communication&#34;, RFC 7657, DOI 10.17487/RFC7657, November 2015, &lt;http://www.rfc-editor.org/info/rfc7657&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657]ブラック、D.、エド。そして、P.ジョーンズ、 &#34;差別化サービス（DiffServ）のリアルタイムコミュニケーション&#34;、RFC 7657、DOI 10.17487 / RFC7657、2015年11月、&lt;http://www.rfc-editor.org/info/rfc7657&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7675] Perumal, M., Wing, D., Ravindranath, R., Reddy, T., and M. Thomson, &#34;Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness&#34;, RFC 7675, DOI 10.17487/RFC7675, October 2015, &lt;http://www.rfc-editor.org/info/rfc7675&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7675]ペルマル、M.、ウィング、D.、Ravindranath、R.、レディ、T.、およびM.トムソン、RFC 7675、DOI 10.17487 / RFC7675 &#34;セッショントラバーサルユーティリティ同意鮮度のNAT（STUN）使用のための&#34; 、2015年10月、&lt;http://www.rfc-editor.org/info/rfc7675&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8083] Perkins, C. and V. Singh, &#34;Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions&#34;, RFC 8083, DOI 10.17487/RFC8083, March 2017, &lt;http://www.rfc-editor.org/info/rfc8083&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8083]パーキンス、C.およびV.シン、 &#34;マルチメディアの輻輳制御：ユニキャストRTPセッションのためのサーキットブレーカー&#34;、RFC 8083、DOI 10.17487 / RFC8083、2017年3月、&lt;http://www.rfc-editor.org/info / rfc8083&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8086] Yong, L., Ed., Crabbe, E., Xu, X., and T. Herbert, &#34;GRE-in-UDP Encapsulation&#34;, RFC 8086, DOI 10.17487/RFC8086, March 2017, &lt;http://www.rfc-editor.org/info/rfc8086&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8086]ヨンジュン、L.、エド、クラッブ、E.、徐、X.、およびT.ハーバート、 &#34;GRE・イン・UDPカプセル化&#34;、RFC 8086、DOI 10.17487 / RFC8086、2017年3月、&lt;HTTP：/ /www.rfc-editor.org/info/rfc8086&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8087] Fairhurst, G. and M. Welzl, &#34;The Benefits of Using Explicit Congestion Notification (ECN)&#34;, RFC 8087, DOI 10.17487/RFC8087, March 2017, &lt;http://www.rfc-editor.org/info/rfc8087&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8087] Fairhurst、G.およびM. Welzl、 &#34;明示的輻輳通知を使用する利点（ECN）&#34;、RFC 8087、DOI 10.17487 / RFC8087、2017年3月、&lt;http://www.rfc-editor.org/info / rfc8087&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[STEVENS] Stevens, W., Fenner, B., and A. Rudoff, &#34;UNIX Network Programming, The sockets Networking API&#34;, Addison-Wesley, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[STEVENS]スティーブンス、W.、フェナー、B.、およびA. Rudoff、 &#34;UNIXネットワークプログラミング、APIをネットワークソケット&#34;、アディソン・ウェズリー、2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UPnP] UPnP Forum, , &#34;Internet Gateway Device (IGD) Standardized Device Control Protocol V 1.0&#34;, November 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UPnPの] UPnPフォーラム、 &#34;インターネットゲートウェイデバイス（IGD）標準化されたデバイス制御プロトコルV 1.0&#34;、2001年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Case Study of the Use of IPv6 UDP Zero-Checksum Mode
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IPv6のUDPゼロチェックサムモードの使用の付録A.ケーススタディ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix provides a brief review of MPLS-in-UDP as an example of a UDP Tunnel Encapsulation that defines a UDP encapsulation. The purpose of the appendix is to provide a concrete example of which mechanisms were required in order to safely use UDP zero-checksum mode for MPLS-in-UDP tunnels over IPv6. By default, UDP requires a checksum for use with IPv6. An option has been specified that permits a zero IPv6 UDP checksum when used in specific environments, specified in [RFC7510], and defines a set of operational constraints for use of this mode. These are summarized below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この付録では、UDPカプセル化を定義するUDPトンネルカプセル化の一例として、MPLS-で-UDPの簡単なレビューを提供します。付録の目的は、機構が安全にIPv6を介したMPLSインUDPトンネルにUDPゼロチェックサムモードを使用するために必要としたの具体例を提供することです。デフォルトでは、UDPは、IPv6で使用するためのチェックサムを必要とします。オプションは、[RFC7510]で指定された特定の環境で使用される場合、ゼロIPv6のUDPチェックサムを可能にし、このモードを使用するための動作制約のセットを定義する指定されています。これらは、以下に要約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP tunnel or encapsulation using a zero-checksum mode with IPv6 must only be deployed within a single network (with a single network operator) or networks of an adjacent set of cooperating network operators where traffic is managed to avoid congestion, rather than over the Internet where congestion control is required. MPLS-in-UDP has been specified for networks under single administrative control (such as within a single operator&#39;s network) where it is known (perhaps through knowledge of equipment types and lower-layer checks) that packet corruption is exceptionally unlikely and where the operator is willing to take the risk of undetected packet corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6でゼロチェックサムモードを使用して、UDPトンネルまたはカプセル化のみではなく、上のトラフィックが混雑を避けるために管理されるネットワークオペレータが、協働の隣接セットの単一（単一のネットワーク・オペレータとの）ネットワーク又はネットワーク内に展開されなければなりません輻輳制御が必要とされるインターネット。 MPLS-で-UDPは、パケットの破損が非常にそうであることを（おそらく機器の種類及び下層チェックの知識によって）知られており、演算子である（例えば、単一のオペレータのネットワーク内でのような）単一の管理制御下でネットワーク用に指定されています検出されないパケットの破損のリスクを取って喜んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The tunnel encapsulator SHOULD use different IPv6 addresses for each UDP tunnel that uses the UDP zero-checksum mode, regardless of the decapsulator, to strengthen the decapsulator&#39;s check of the IPv6 source address (i.e., the same IPv6 source address SHOULD NOT be used with more than one IPv6 destination address, independent of whether that destination address is a unicast or multicast address). Use of MPLS-in-UDP may be extended to networks within a set of closely cooperating network administrations (such as network operators who have agreed to work together to jointly provide specific services) [RFC7510].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トンネルカプセル化は、IPv6ソースアドレスのカプセル化を解くのチェックを強化するために、カプセル化を解くのにかかわらず、UDPゼロチェックサムモードを使用する各UDPトンネルに異なるIPv6アドレスを使用すべきである（すなわち、同じIPv6送信元アドレスは、より多くのと一緒に使用しないでください1つのIPv6宛先アドレスより、その宛先アドレス）は、ユニキャストまたはマルチキャストアドレスであるか否かとは無関係。 MPLS-UDPでの使用は、（共同で特定のサービスを提供するために協力することに同意した、ネットワークオペレータなど）と密接協働ネットワーク投与[RFC7510]のセット内のネットワークに拡張することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirement for MPLS-in-UDP endpoints to check the source IPv6 address in addition to the destination IPv6 address, plus the strong recommendation against reuse of source IPv6 addresses among MPLS-in-UDP tunnels collectively provide some mitigation for the absence of UDP checksum coverage of the IPv6 header. In addition, the MPLS data plane only forwards packets with valid labels (i.e., labels that have been distributed by the tunnel egress Label Switched Router, LSR), providing some additional opportunity to detect MPLS-in-UDP packet misdelivery when the misdelivered packet contains a label that is not valid for forwarding at the receiving LSR. The expected result for IPv6 UDP zero-checksum mode for MPLS-in-UDP is that corruption of the destination IPv6 address will usually cause packet discard, as offsetting corruptions to the source IPv6 and/or MPLS top label are unlikely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合的にUDPチェックサムの欠如のためにいくつかの緩和を提供する宛先IPv6アドレスに加えて元IPv6アドレスに加えてソースのIPv6の再利用に強い推薦を確認するMPLS-で-UDPエンドポイントの要件は、MPLS-で-UDPトンネルの中アドレスIPv6ヘッダのカバレッジ。また、MPLSデータプレーンは、唯一の有効なラベル誤配信パケットが含まれている場合、MPLS-で-UDPパケットの配達ミスを検出するために、いくつかの追加の機会を提供し、（すなわち、トンネル出口のラベルが配布されているラベルは、ルータ、LSRを交換）してパケットを転送します受信LSRに転送するための有効ではありませんラベル。 MPLS-UDPでのIPv6 UDPゼロチェックサムモードの期待される結果は、宛先IPv6アドレスの破損は、通常はそうであり、および/またはMPLSのトップラベルソースにIPv6を破損を相殺するように、パケット廃棄の原因となることです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional assurance is provided by the restrictions in the above exceptions that limit usage of IPv6 UDP zero-checksum mode to well-managed networks for which MPLS packet corruption has not been a problem in practice. Hence, MPLS-in-UDP is suitable for transmission over lower layers in well-managed networks that are allowed by the exceptions stated above and the rate of corruption of the inner IP packet on such networks is not expected to increase by comparison to MPLS traffic that is not encapsulated in UDP. For these reasons, MPLS-in-UDP does not provide an additional integrity check when UDP zero-checksum mode is used with IPv6, and this design is in accordance with requirements 2, 3, and 5 specified in Section 5 of [RFC6936].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
追加の保証は、MPLSパケットの破損が実際には問題ではなかったため、適切に管理ネットワークへのIPv6 UDPゼロチェックサムモードの使用を制限する上記の例外に制約により提供されます。したがって、MPLS-で-UDPは、上記の例外で許可されており、そのようなネットワーク上で内側IPパケットの破損率はMPLSトラフィックと比較して増加すると予想されていないだけでなく、管理ネットワーク内の下位層を介して送信するのに適していますそれはUDPでカプセル化されていません。 UDPゼロチェックサムモードがIPv6で使用される場合、これらの理由のために、MPLS-で-UDPは、付加的な整合性チェックを提供していない、この設計は、[RFC6936]のセクション5で指定された要件2、3、および5に従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MPLS-in-UDP encapsulation does not provide a mechanism to safely fall back to using a checksum when a path change occurs that redirects a tunnel over a path that includes a middlebox that discards IPv6 datagrams with a zero UDP checksum. In this case, the MPLS-in-UDP tunnel will be black-holed by that middlebox. Recommended changes to allow firewalls, NATs and other middleboxes to support use of an IPv6 zero UDP checksum are described in Section 5 of [RFC6936]. MPLS does not accumulate incorrect state as a consequence of label-stack corruption. A corrupt MPLS label results in either packet discard or forwarding (and forgetting) of the packet without accumulation of MPLS protocol state. Active monitoring of MPLS-in-UDP traffic for errors is REQUIRED because the occurrence of errors will result in some accumulation of error information outside the MPLS protocol for operational and management purposes. This design is in accordance with requirement 4 specified in Section 5 of [RFC6936]. In addition, IPv6 traffic with a zero UDP checksum MUST be actively monitored for errors by the network operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MPLS-で-UDPカプセル化は、安全に経路変更がそのゼロUDPチェックサムとIPv6データグラムを廃棄ミドルボックスを含むパス上のトンネルをリダイレクト発生したときにチェックサムを使用してフォールバックするためのメカニズムを提供しません。この場合、MPLSインUDPトンネルがブラックホールそのミドルによるものであろう。ファイアウォール、NATの及び他の中間装置がIPv6ゼロUDPチェックサムの使用をサポートすることを可能にすることを推奨変更は[RFC6936]のセクション5に記載されています。 MPLSラベルスタックの破損の結果として間違った状態を蓄積しません。パケット廃棄またはMPLSプロトコル状態の蓄積なしにパケットの転送（及び忘却）のいずれかに破損MPLSラベルをもたらします。エラーの発生が運用・管理の目的のためにMPLSプロトコル外のエラー情報のいくつかの蓄積になりますので、エラーのMPLS-で-UDPトラフィックのアクティブな監視が必要です。この設計は、[RFC6936]のセクション5で指定された要件4に従います。また、ゼロUDPチェックサムとIPv6トラフィックを積極的にネットワークオペレータによってエラーを監視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operators SHOULD also deploy packet filters to prevent IPv6 packets with a zero UDP checksum from escaping from the network due to misconfiguration or packet errors. In addition, IPv6 traffic with a zero UDP checksum MUST be actively monitored for errors by the network operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オペレータはまた、設定ミスやパケットエラーによるネットワークから逃げるのゼロUDPチェックサムとIPv6パケットを防ぐために、パケットフィルタを展開する必要があります。また、ゼロUDPチェックサムとIPv6トラフィックを積極的にネットワークオペレータによってエラーを監視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The middlebox traversal guidelines in Section 3.5 incorporate ideas from Section 5 of [BEHAVE-APP] by Bryan Ford, Pyda Srisuresh, and Dan Kegel. The protocol timer guidelines in Section 3.1.1 were largely contributed by Mark Allman.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.5節でミドルトラバーサルガイドラインはブライアン・フォード、Pyda Srisuresh、そしてダンケーゲルで[BEHAVE-APP]のセクション5からのアイデアを取り入れています。 3.1.1項のプロトコルタイマーのガイドラインは、主にマーク・オールマンによって寄与されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
G. Fairhurst received funding from the European Union&#39;s Horizon 2020 research and innovation program 2014-2018 under grant agreement No. 644334 (NEAT). Lars Eggert has received funding from the European Union&#39;s Horizon 2020 research and innovation program 2014-2018 under grant agreement No. 644866 (SSICLOPS). This document reflects only the authors&#39; views and the European Commission is not responsible for any use that may be made of the information it contains.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
G. Fairhurstは、付与契約番号644334（NEAT）の下で、欧州連合（EU）のホライゾン2020研究と技術革新プログラム2014年から2018年から資金提供を受けました。ラースEggertのは、付与契約番号644866（SSICLOPS）の下で、欧州連合（EU）のホライゾン2020年の研究と技術革新プログラム2014年から2018年から資金提供を受けています。この文書では、唯一の著者の見解を反映しており、欧州委員会は、それが含まれている情報を用いることができる任意の使用については責任を負いません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lars Eggert NetApp Sonnenallee 1 Kirchheim 85551 Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ラースEggertのNetAppのSonnenallee 1キルヒハイム85551ドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +49 151 120 55791 Email: lars@netapp.com URI: https://eggert.org/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+49 151 120 55791 Eメール：lars@netapp.com URI：https://eggert.org/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Godred Fairhurst University of Aberdeen Department of Engineering Fraser Noble Building Aberdeen AB24 3UE Scotland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンジニアリング・フレイザーノーブルビルアバディーンAB24 3UEスコットランドのアバディーン部門のGodred Fairhurst大学
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: gorry@erg.abdn.ac.uk URI: http://www.erg.abdn.ac.uk/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：gorry@erg.abdn.ac.uk URI：http://www.erg.abdn.ac.uk/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Greg Shepherd Cisco Systems Tasman Drive San Jose United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アメリカのグレッグ・シェパードシスコシステムズタスマンドライブサンノゼ、米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: gjshep@gmail.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：gjshep@gmail.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
