<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 5905 - Network Time Protocol Version 4: Protocol and Algorithms Specification 日本語訳</title>

  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 5905 - Network Time Protocol Version 4: Protocol and Algorithms Specification 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc5905">
              https://tools.ietf.org/html/rfc5905
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 5905 - ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                          D. Mills
Request for Comments: 5905                                   U. Delaware
Obsoletes: 1305, 4330                                     J. Martin, Ed.
Category: Standards Track                                            ISC
ISSN: 2070-1721                                               J. Burbank
                                                                W. Kasch
                                                                 JHU/APL
                                                               June 2010
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Network Time Protocol Version 4: Protocol and Algorithms Specification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Network Time Protocol (NTP) is widely used to synchronize computer clocks in the Internet. This document describes NTP version 4 (NTPv4), which is backwards compatible with NTP version 3 (NTPv3), described in RFC 1305, as well as previous versions of the protocol. NTPv4 includes a modified protocol header to accommodate the Internet Protocol version 6 address family. NTPv4 includes fundamental improvements in the mitigation and discipline algorithms that extend the potential accuracy to the tens of microseconds with modern workstations and fast LANs. It includes a dynamic server discovery scheme, so that in many cases, specific server configuration is not required. It corrects certain errors in the NTPv3 design and implementation and includes an optional extension mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP（Network Time Protocol）は、インターネットで広くコンピュータのクロックを同期するために使用されます。この文書では、NTPのRFC 1305に記載されたバージョン3（NTPv3）、ならびにプロトコルの以前のバージョンと下位互換性がありNTPバージョン4（NTPv4）を、記載されています。 NTPv4は、インターネットプロトコルバージョン6つのアドレスファミリに対応するために修正されたプロトコル・ヘッダを含みます。 NTPv4は、現代のワークステーションと高速LANを持つ数十マイクロ秒に潜在的な精度を拡張緩和と規律アルゴリズムの基本的な改善が含まれています。多くの場合、特定のサーバーの設定が必要とされないようにそれは、動的なサーバー発見方式を採用しています。これはNTPv3の設計と実装における特定の誤差を補正し、オプションの拡張機構を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5905.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc5905で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................4
      1.1. Requirements Notation ......................................5
   2. Modes of Operation ..............................................6
   3. Protocol Modes ..................................................6
      3.1. Dynamic Server Discovery ...................................7
   4. Definitions .....................................................8
   5. Implementation Model ...........................................10
   6. Data Types .....................................................12
   7. Data Structures ................................................16
      7.1. Structure Conventions .....................................16
      7.2. Global Parameters .........................................16
      7.3. Packet Header Variables ...................................17
      7.4. The Kiss-o&#39;-Death Packet ..................................24
      7.5. NTP Extension Field Format ................................25
   8. On-Wire Protocol ...............................................26
   9. Peer Process ...................................................30
      9.1. Peer Process Variables ....................................31
      9.2. Peer Process Operations ...................................33
   10. Clock Filter Algorithm ........................................37
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   11. System Process ................................................39
      11.1. System Process Variables .................................40
      11.2. System Process Operations ................................41
           11.2.1. Selection Algorithm ...............................43
           11.2.2. Cluster Algorithm .................................44
           11.2.3. Combine Algorithm .................................45
      11.3. Clock Discipline Algorithm ...............................47
   12. Clock-Adjust Process ..........................................51
   13. Poll Process ..................................................51
      13.1. Poll Process Variables ...................................51
      13.2. Poll Process Operations ..................................52
   14. Simple Network Time Protocol (SNTP) ...........................54
   15. Security Considerations .......................................55
   16. IANA Considerations ...........................................58
   17. Acknowledgements ..............................................59
   18. References ....................................................59
      18.1. Normative References .....................................59
      18.2. Informative References ...................................59
   Appendix A.  Code Skeleton  .......................................61
     A.1.  Global Definitions  .......................................61
       A.1.1. Definitions, Constants, Parameters .....................61
       A.1.2. Packet Data Structures .................................65
       A.1.3. Association Data Structures ............................66
       A.1.4. System Data Structures .................................68
       A.1.5. Local Clock Data Structures ............................69
       A.1.6. Function Prototypes ....................................69
     A.2. Main Program and Utility Routines ..........................70
     A.3. Kernel Input/Output Interface ..............................73
     A.4. Kernel System Clock Interface ..............................74
     A.5. Peer Process ...............................................76
       A.5.1. receive() ..............................................77
       A.5.2. clock_filter() .........................................85
       A.5.3. fast_xmit() ............................................88
       A.5.4. access() ...............................................89
       A.5.5. System Process .........................................90
       A.5.6. Clock Adjust Process ..................................103
       A.5.7. Poll Process ..........................................104
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines the Network Time Protocol version 4 (NTPv4), which is widely used to synchronize system clocks among a set of distributed time servers and clients. It describes the core architecture, protocol, state machines, data structures, and algorithms. NTPv4 introduces new functionality to NTPv3, as described in [RFC1305], and functionality expanded from Simple NTP version 4 (SNTPv4) as described in [RFC4330] (SNTPv4 is a subset of NTPv4). This document obsoletes [RFC1305] and [RFC4330]. While certain minor changes have been made in some protocol header fields, these do not affect the interoperability between NTPv4 and previous versions of NTP and SNTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、広く分布するタイムサーバとクライアントのセットのうち、システムクロックを同期させるために使用されるネットワーク・タイム・プロトコルバージョン4（NTPv4）を定義します。これは、コアアーキテクチャ、プロトコル、ステートマシン、データ構造、およびアルゴリズムを記述する。 （SNTPv4は、NTPv4のサブセットである）[RFC1305]に記載されているようにNTPv4は、NTPv3に新しい機能を導入して、[RFC4330]に記載されているような機能は、単純なNTPバージョン4（SNTPv4）から拡大しました。この文書では、[RFC1305]と[RFC4330]を廃止します。特定の軽微な変更は、いくつかのプロトコルヘッダフィールドで行われてきたが、これらはNTPv4とNTPとSNTPの以前のバージョン間の相互運用性には影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NTP subnet model includes a number of widely accessible primary time servers synchronized by wire or radio to national standards. The purpose of the NTP protocol is to convey timekeeping information from these primary servers to secondary time servers and clients via both private networks and the public Internet. Precisely tuned algorithms mitigate errors that may result from network disruptions, server failures, and possible hostile actions. Servers and clients are configured such that values flow towards clients from the primary servers at the root via branching secondary servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPサブネットモデルは、国家規格に有線または無線で同期広くアクセスプライマリタイムサーバーの数を含んでいます。 NTPプロトコルの目的は、両方のプライベートネットワークと公衆インターネットを介して2時間サーバーおよびクライアントにこれらの一次サーバーからの計時情報を伝えることです。正確にチューニングされたアルゴリズムは、ネットワークの中断、サーバの障害、および可能な敵対行為に起因する誤差を軽減します。サーバとクライアントは、値がセカンダリ・サーバを介して分岐ルートに一次サーバからクライアントに向かって流れるように構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NTPv4 design overcomes significant shortcomings in the NTPv3 design, corrects certain bugs, and incorporates new features. In particular, expanded NTP timestamp definitions encourage the use of the floating double data type throughout the implementation. As a result, the time resolution is better than one nanosecond, and frequency resolution is less than one nanosecond per second. Additional improvements include a new clock discipline algorithm that is more responsive to system clock hardware frequency fluctuations. Typical primary servers using modern machines are precise within a few tens of microseconds. Typical secondary servers and clients on fast LANs are within a few hundred microseconds with poll intervals up to 1024 seconds, which was the maximum with NTPv3. With NTPv4, servers and clients are precise within a few tens of milliseconds with poll intervals up to 36 hours.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPv4のデザインは、NTPv3の設計に重大な欠点を克服し、特定のバグを修正し、新機能を搭載しています。特に、拡大NTPタイムスタンプの定義は実装を通じて、フローティングダブル・データ・タイプの使用を奨励します。その結果、時間分解能が1ナノ秒よりも良好であり、周波数分解能は、毎秒1ナノ秒未満です。追加の改善は、システムクロックハードウェアの周波数変動に応答性である新しいクロック規律アルゴリズムが含まれます。最近のマシンを使用して典型的なプライマリサーバは、数十マイクロ秒内の正確なです。高速なLAN上の典型的なセカンダリサーバとクライアントはNTPv3で最大だった1024秒までのポーリング間隔で数百マイクロ秒以内です。 NTPv4では、サーバーとクライアントは、36時間までのポーリング間隔で数十ミリ秒内の正確なです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The main body of this document describes the core protocol and data structures necessary to interoperate between conforming implementations. Appendix A contains a full-featured example in the form of a skeleton program, including data structures and code segments for the core algorithms as well as the mitigation algorithms used to enhance reliability and accuracy. While the skeleton program and other descriptions in this document apply to a particular implementation, they are not intended as the only way the required functions can be implemented. The contents of Appendix A are non-
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書の本体が準拠実装間で相互運用するために必要なコアプロトコル及びデータ構造を記述する。付録Aには、データ構造及びコードセグメントコアアルゴリズムのためだけでなく、信頼性および精度を高めるために使用緩和アルゴリズムを含むスケルトンプログラムの形態、でフル機能の例を含んでいます。このドキュメントのスケルトンプログラム及びその他の説明は特定の実装に適用されますが、それらは、必要な機能を実装することができる唯一の方法として意図されていません。付録Aの内容は非しています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
normative examples designed to illustrate the protocol&#39;s operation and are not a requirement for a conforming implementation. While the NTPv3 symmetric key authentication scheme described in this document has been carried over from NTPv3, the Autokey public key authentication scheme new to NTPv4 is described in [RFC5906].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プロトコルの動作を説明するように設計規範的な例は、適合実装のための要件ではありません。この文書で説明NTPv3対称鍵認証方式は、NTPv3から引き継がれてきたが、NTPv4に新しいのAutokey公開鍵認証方式は、[RFC5906]に記述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NTP protocol includes modes of operation described in Section 2 using data types described in Section 6 and data structures described in Section 7. The implementation model described in Section 5 is based on a threaded, multi-process architecture, although other architectures could be used as well. The on-wire protocol described in Section 8 is based on a returnable-time design that depends only on measured clock offsets, but does not require reliable message delivery. Reliable message delivery such as TCP [RFC0793] can actually make the delivered NTP packet less reliable since retries would increase the delay value and other errors. The synchronization subnet is a self-organizing, hierarchical, master-slave network with synchronization paths determined by a shortest-path spanning tree and defined metric. While multiple masters (primary servers) may exist, there is no requirement for an election protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPプロトコルは、他のアーキテクチャを使用することができるが、セクション7に記載項5に記載の実装モデルは、ねじ、マルチプロセスアーキテクチャに基づいて、セクション6で説明したデータタイプおよびデータ構造を使用して、セクション2で説明した動作のモードを含みます同じように。セクション8に記載のオンワイヤプロトコルのみ測定クロックオフセットに依存するが、信頼性の高いメッセージ配信を必要としない返却時の設計に基づいています。リトライが遅延値やその他のエラーを増加させるため、このようなTCP [RFC0793]のように信頼性の高いメッセージ配信が実際に配信NTPパケットが少なく信頼性を高めることができます。同期サブネットは最短パススパニングツリーによって決定され、メトリック定義同期パスを有する自己組織化、階層、マスタースレーブネットワークです。複数のマスター（プライマリサーバ）が存在するかもしれないが、選挙プロトコルの必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document includes material from [ref9], which contains flow charts and equations unsuited for RFC format. There is much additional information in [ref7], including an extensive technical analysis and performance assessment of the protocol and algorithms in this document. The reference implementation is available at www.ntp.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、RFC形式には不適当フローチャート及び方程式が含ま[ref9]、から材料を含みます。この文書に記載されているプロトコルとアルゴリズムの豊富なテクニカル分析と性能評価を含む[ref7]で多くの追加情報は、あります。リファレンス実装はwww.ntp.orgで入手可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The remainder of this document contains numerous variables and mathematical expressions. Some variables take the form of Greek characters, which are spelled out by their full case-sensitive name. For example, DELTA refers to the uppercase Greek character, while delta refers to the lowercase character. Furthermore, subscripts are denoted with &#39;_&#39;; for example, theta_i refers to the lowercase Greek character theta with subscript i, or phonetically theta sub i. In this document, all time values are in seconds (s), and all frequencies will be specified as fractional frequency offsets (FFOs) (pure number). It is often convenient to express these FFOs in parts per million (ppm).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの残りの部分は、多くの変数と数式が含まれています。いくつかの変数は、その完全大文字と小文字を区別した名前で綴られているギリシャ文字の形をとります。デルタは、小文字の文字を参照しながら、例えば、DELTAは、大文字のギリシャ文字を指します。さらに、添字は「_」で表されています。例えば、theta_iは添字I、または音声的シータサブIと小文字のギリシャ文字のシータを指します。本書では、すべての時間値は秒（s）であり、そしてすべての周波数は、分数周波数オフセット（FFOs）（純粋番号）として指定されます。百万分率（ppm）でこれらのFFOsを表現するために便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。要件表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はあります[RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Modes of Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
操作の2モード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An NTP implementation operates as a primary server, secondary server, or client. A primary server is synchronized to a reference clock directly traceable to UTC (e.g., GPS, Galileo, etc.). A client synchronizes to one or more upstream servers, but does not provide synchronization to dependent clients. A secondary server has one or more upstream servers and one or more downstream servers or clients. All servers and clients who are fully NTPv4-compliant MUST implement the entire suite of algorithms described in this document. In order to maintain stability in large NTP subnets, secondary servers SHOULD be fully NTPv4-compliant. Alternative algorithms MAY be used, but their output MUST be identical to the algorithms described in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPの実装では、プライマリサーバ、セカンダリサーバ、またはクライアントとして動作します。プライマリ・サーバがUTC（例えば、GPS、ガリレオ、等）に直接トレーサブル基準クロックに同期されます。クライアントは、1つまたは複数のアップストリームサーバーと同期しますが、依存型クライアントに同期を提供していません。セカンダリサーバは、1つまたは複数のアップストリームサーバーと1つまたは複数のダウンストリームサーバーまたはクライアントを持っています。完全NTPv4に準拠しているすべてのサーバとクライアントは、この文書で説明したアルゴリズムのスイート全体を実装しなければなりません。大NTPサブネット内の安定性を維持するために、セカンダリサーバが完全にNTPv4準拠であるべきです。代替的なアルゴリズムを使用することができるが、それらの出力は、本明細書に記載されたアルゴリズムと同一でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Protocol Modes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.プロトコルモード
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are three NTP protocol variants: symmetric, client/server, and broadcast. Each is associated with an association mode (a description of the relationship between two NTP speakers) as shown in Figure 1. In addition, persistent associations are mobilized upon startup and are never demobilized. Ephemeral associations are mobilized upon the arrival of a packet and are demobilized upon error or timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対称型、クライアント/サーバー、およびブロードキャスト：3つのNTPプロトコルのバリアントがあります。また、図1に示すように各々が関連付けモード（二NTPスピーカとの間の関係の記述）に関連付けられている、永続的な関連付けは、起動時に動員され、復員されることはありません。エフェメラル団体は、パケットの到着時に動員され、エラーやタイムアウト時に復員しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          +-------------------+-------------------+------------------+
          |  Association Mode | Assoc. Mode Value | Packet Mode Value|
          +-------------------+-------------------+------------------+
          | Symmetric Active  |         1         | 1 or 2           |
          | Symmetric Passive |         2         | 1                |
          | Client            |         3         | 4                |
          | Server            |         4         | 3                |
          | Broadcast Server  |         5         | 5                |
          | Broadcast Client  |         6         | N/A              |
          +-------------------+-------------------+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 1: Association and Packet Modes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図1：協会およびパケットモード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the client/server variant, a persistent client sends packet mode 4 packets to a server, which returns packet mode 3 packets. Servers provide synchronization to one or more clients, but do not accept synchronization from them. A server can also be a reference clock driver that obtains time directly from a standard source such as a GPS receiver or telephone modem service. In this variant, clients pull synchronization from servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント/サーバーの変形例では、永続的なクライアントは、パケットモード3つのパケットを返すサーバーにパケットモード4つのパケットを送信します。サーバーは1つ以上のクライアントに同期を提供しますが、それらから同期を受け付けておりません。サーバはまた、GPS受信機、または電話モデム・サービスのような標準的な供給源から直接時間を取得し、基準クロックドライバとすることができます。この変形例では、クライアントはサーバから同期を引きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the symmetric variant, a peer operates as both a server and client using either a symmetric active or symmetric passive association. A persistent symmetric active association sends symmetric active (mode 1) packets to a symmetric active peer association. Alternatively, an ephemeral symmetric passive association can be mobilized upon the arrival of a symmetric active packet with no matching association. That association sends symmetric passive (mode 2) packets and persists until error or timeout. Peers both push and pull synchronization to and from each other. For the purposes of this document, a peer operates like a client, so references to client imply peer as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
対称的な変形例では、ピアはいずれかのアクティブ対称または対称パッシブアソシエーションを使用して、サーバとクライアントの両方として動作します。永続的対称アクティブ・アソシエーションは、対称アクティブピアアソシエーションに対称アクティブ（モード1）パケットを送信します。代替的に、エフェメラル対称パッシブアソシエーションが一致する関連対称活性パケットの到着時に動員することができます。その関連付けは、対称パッシブ（モード2）パケットを送信し、エラーまたはタイムアウトするまで持続します。ピアは、相互に及びからの同期をプッシュとプルの両方。このドキュメントの目的のために、ピアは、クライアントのように動作するので、クライアントへの言及は、同様にピアを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the broadcast variant, a persistent broadcast server association sends periodic broadcast server (mode 5) packets that can be received by multiple clients. Upon reception of a broadcast server packet without a matching association, an ephemeral broadcast client (mode 6) association is mobilized and persists until error or timeout. It is useful to provide an initial volley where the client operating in client mode exchanges several packets with the server, so as to calibrate the propagation delay and to run the Autokey security protocol, after which the client reverts to broadcast client mode. A broadcast server pushes synchronization to clients and other servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
放送変形例では、永続的な放送サーバアソシエーションは、周期的ブロードキャスト・サーバー（モード5）複数のクライアントが受信可能なパケットを送信します。マッチング・アソシエーション、エフェメラルブロードキャストクライアントなしで放送サーバパケットを受信すると（モード6）関連付けが動員され、エラーまたはタイムアウトするまで持続します。伝播遅延を校正すると、クライアントは、クライアントモードを放送するために戻り、その後のAutokeyセキュリティプロトコルを実行するように、クライアントがサーバとクライアントモード交換に複数のパケットを操作する最初のボレーを提供するのに有用です。放送サーバは、クライアントと他のサーバーとの同期をプッシュ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Loosely following the conventions established by the telephone industry, the level of each server in the hierarchy is defined by a stratum number. Primary servers are assigned stratum one; secondary servers at each lower level are assigned stratum numbers one greater than the preceding level. As the stratum number increases, its accuracy degrades depending on the particular network path and system clock stability. Mean errors, measured by synchronization distances, increase approximately in proportion to stratum numbers and measured round-trip delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゆるく電話業界によって確立された規則に従って、階層内の各サーバのレベルは、地層の数によって定義されます。プライマリサーバは、ストラタム1が割り当てられます。各下位レベルでの二次サーバーは、前のレベルより1大きい階層番号が割り当てられています。階層数が増加するにつれて、その精度は、特定のネットワークパスとシステムクロックの安定性に依存して劣化します。同期距離によって測定されたエラーを意味し、数字と測定されたラウンドトリップ遅延を地層にほぼ比例して増加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As a standard practice, timing network topology should be organized to avoid timing loops and minimize the synchronization distance. In NTP, the subnet topology is determined using a variant of the Bellman-Ford distributed routing algorithm, which computes the shortest-path spanning tree rooted on the primary servers. As a result of this design, the algorithm automatically reorganizes the subnet, so as to produce the most accurate and reliable time, even when there are failures in the timing network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
標準プラクティスとして、タイミングネットワークトポロジは、タイミングループを回避し、同期距離を最小化するために組織されなければなりません。 NTPでは、サブネットトポロジーは、一次サーバーに根ざし最短パススパニングツリーを計算するベルマン・フォード分散ルーティングアルゴリズムの変形を使用して決定されます。タイミングネットワークの障害があっても、最も正確で信頼性の高い時間を生成するように、この設計の結果として、アルゴリズムは自動的に、サブネットを再編成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Dynamic Server Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1。 Dynamic Serverのディスカバリー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two special associations, manycast client and manycast server, which provide a dynamic server discovery function. There are two types of manycast client associations: persistent and ephemeral. The persistent manycast client sends client (mode 3) packets to a designated IPv4 or IPv6 broadcast or multicast group address. Designated manycast servers within range of the time-to-live (TTL) field in the packet header listen for packets with that address. If a server is suitable for synchronization, it returns an ordinary server (mode 4) packet using the client&#39;s unicast address. Upon receiving this packet, the client mobilizes an ephemeral client (mode 3) association. The ephemeral client association persists until error or timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
動的なサーバー検出機能を提供する2つの特殊な団体、メニーキャストクライアントとメニーキャストサーバは、あります。持続的かつ短命：メニーキャストクライアントのアソシエーションの2種類があります。永続的なメニーキャストクライアントは、クライアント（モード3）指定されたIPv4またはIPv6ブロードキャストまたはマルチキャストグループアドレスにパケットを送信します。パケットヘッダの生存時間（TTL）フィールドの範囲内で指定メニーキャストサーバは、そのアドレスを持つパケットを待ち受けます。サーバーが同期に適している場合、それは、クライアントのユニキャストアドレスを使用して、通常のサーバ（モード4）パケットを返します。このパケットを受信すると、クライアントは、エフェメラルクライアント（モード3）アソシエーションを動員します。短命クライアントアソシエーションは、エラーまたはタイムアウトするまで持続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A manycast client continues sending packets to search for a minimum number of associations. It starts with a TTL equal to one and continuously adding one to it until the minimum number of associations is made or when the TTL reaches a maximum value. If the TTL reaches its maximum value and yet not enough associations are mobilized, the client stops transmission for a time-out period to clear all associations, and then repeats the search cycle. If a minimum number of associations has been mobilized, then the client starts transmitting one packet per time-out period to maintain the associations. Field constraints limit the minimum value to 1 and the maximum to 255. These limits may be tuned for individual application needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メニーキャストクライアントは、協会の最小数を検索するためのパケットを送信し続けます。これは、1に等しいTTLで始まり、関連の最小数がなさ又はTTLが最大値に達したときにされるまで連続的に1を加えます。 TTLは、その最大値に達すると、まだ十分な団体が動員されていない場合は、クライアントはすべての関連付けをクリアするには、タイムアウト期間の送信を停止した後、検索サイクルを繰り返します。団体の最小数が動員されている場合、クライアントは関連付けを維持するために、タイムアウト時間ごとに1つのパケットの送信を開始します。フィールド制約は、これらの制限は、個々のアプリケーションのニーズに合わせて調整することができる255に1最小値と最大値を制限します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ephemeral associations compete among themselves. As new ephemeral associations are mobilized, the client runs the mitigation algorithms described in Sections 10 and 11.2 for the best candidates out of the population, the remaining ephemeral associations are timed out and demobilized. In this way, the population includes only the best candidates that have most recently responded with an NTP packet to discipline the system clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
はかない団体は、自分たちの中で競います。新しい一時的な関連が動員されると、クライアントはセクション10および人口のうち、最良の候補者のための11.2で説明緩和アルゴリズムを実行し、残りのはかない団体がタイムアウトして復員しています。このように、人口が最も最近のシステムクロックを訓練するNTPパケットで応答しているだけで最適な候補を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A number of technical terms are defined in this section. A timescale is a frame of reference where time is expressed as the value of a monotonically increasing binary counter with an indefinite number of bits. It counts in seconds and fractions of a second, when a decimal point is employed. The Coordinated Universal Time (UTC) timescale is defined by ITU-R TF.460 [ITU-R_TF.460]. Under the auspices of the Metre Convention of 1865, in 1975 the CGPM [CGPM] strongly endorsed the use of UTC as the basis for civil time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
専門用語の数は、このセクションで定義されています。タイムスケールは、時間がビットの不定数の単調増加バイナリカウンタの値として表現される基準フレームです。小数点が使用される場合には、秒、秒の小数でカウントします。協定世界時（UTC）タイムスケールは、ITU-R TF.460 [ITU-R_TF.460]によって定義されます。 1865年のメートル条約の後援のもと、1975年にCGPMは[CGPM]強く常用時の基礎としてUTCを使用することを承認しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Coordinated Universal Time (UTC) timescale represents mean solar time as disseminated by national standards laboratories. The system time is represented by the system clock maintained by the hardware and operating system. The goal of the NTP algorithms is to minimize both the time difference and frequency difference between UTC and the system clock. When these differences have been reduced below nominal tolerances, the system clock is said to be synchronized to UTC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
協定世界時（UTC）タイムスケールは、国家規格研究所によって広めとして平均太陽時を表します。システム時間は、ハードウェアとオペレーティングシステムにより維持されるシステムクロックによって表されます。 NTPアルゴリズムの目標は、UTCとシステムクロックとの間の時間差と周波数差の両方を最小限に抑えることです。これらの違いは、公称公差以下に減少されている場合は、システムクロックがUTCに同期させることが言われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The date of an event is the UTC time at which the event takes place. Dates are ephemeral values designated with uppercase T. Running time is another timescale that is coincident to the synchronization function of the NTP program.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
イベントの日付は、イベントが起こるUTC時間です。日付は大文字のT.は時間を実行すると、指定はかない値であり、NTPプログラムの同期機能に一致する別のタイムスケールです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A timestamp T(t) represents either the UTC date or time offset from UTC at running time t. Which meaning is intended should be clear from the context. Let T(t) be the time offset, R(t) the frequency offset, and D(t) the aging rate (first derivative of R(t) with respect to t). Then, if T(t_0) is the UTC time offset determined at t = t_0, the UTC time offset at time t is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプT（t）は時間tの実行でUTCからのオフセットUTCの日付または時刻のいずれかを表します。文脈から明らかなはずであることを意図している意味は。 T（t）は、R（t）は周波数オフセット、及びD（t）がエージングレート（tに対するR（t）の一次導関数）オフセット時間とします。 T（T_0）は、T = T_0で決定されたオフセットUTC時間である場合、時刻tにおけるオフセットUTC時間であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T(t) = T(t_0) + R(t_0)(t-t_0) + 1/2 * D(t_0)(t-t_0)^2 + e,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T（T）= T（T_0）+ R（T_0）（T-T_0）+ 1/2 * D（T_0）（T-T_0）^ 2 + E、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where e is a stochastic error term discussed later in this document. While the D(t) term is important when characterizing precision oscillators, it is ordinarily neglected for computer oscillators. In this document, all time values are in seconds (s) and all frequency values are in seconds-per-second (s/s). It is sometimes convenient to express frequency offsets in parts-per-million (ppm), where 1 ppm is equal to 10^(-6) s/s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、eは、このドキュメントで後述する確率的誤差項です。高精度発振器を特徴付ける際にD（T）項が重要であるが、それは通常、コンピュータ発振器のために無視されます。本書では、すべての時間値は、秒（s）であり、すべての周波数値は秒毎秒（S / S）です。 （ -  6）S / Sには、1 ppmで10 ^に等しいパーツ・パー・ミリオン（ppm）で周波数オフセットを表現するために、時には便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is important in computer timekeeping applications to assess the performance of the timekeeping function. The NTP performance model includes four statistics that are updated each time a client makes a measurement with a server. The offset (theta) represents the maximum-likelihood time offset of the server clock relative to the system clock. The delay (delta) represents the round-trip delay between the client and server. The dispersion (epsilon) represents the maximum error inherent in the measurement. It increases at a rate equal to the maximum disciplined system clock frequency tolerance (PHI), typically 15 ppm. The jitter (psi) is defined as the root-mean-square (RMS) average of the most recent offset differences, and it represents the nominal error in estimating the offset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
計時機能の性能を評価するために、コンピュータの計時用途で重要です。 NTPのパフォーマンスモデルは、クライアントがサーバーとの測定を行うたびに更新されている4つの統計情報が含まれています。オフセット（シータ）は、システムクロックに対するサーバのクロックの相対オフセット最尤時間を表します。遅延（デルタ）は、クライアントとサーバ間の往復遅延を表します。分散（イプシロン）は、測定に固有の最大誤差を表します。これは、最大規律システムクロック周波数公差（PHI）、典型的には15ppmに等しい速度で増加します。ジッタ（PSI）は、最新のオフセットの差異の二乗平均平方根（RMS）の平均として定義され、それがオフセットの推定に名目上のエラーを表しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the theta, delta, epsilon, and psi statistics represent measurements of the system clock relative to each server clock separately, the NTP protocol includes mechanisms to combine the statistics of several servers to more accurately discipline and calibrate the system clock. The system offset (THETA) represents the maximum-likelihood offset estimate for the server population. The system jitter (PSI) represents the nominal error in estimating the system offset. The delta and epsilon statistics are accumulated at each stratum level from the reference clock to produce the root delay (DELTA) and root dispersion (EPSILON) statistics. The synchronization distance (LAMBDA) equal to EPSILON + DELTA / 2 represents the maximum error due to all causes. The detailed formulations of these statistics are given in Section 11.2. They are available to the dependent applications in order to assess the performance of the synchronization function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シータ、デルタ、イプシロン、およびPSI統計が個別サーバクロックにシステムクロックの相対的測定値を表して、NTPプロトコルは、より正確に規律とシステムクロックを較正するために複数のサーバーの統計を結合する機構を含みます。 （THETA）オフセットシステムは、サーバ集団について最尤オフセット推定値を表します。システムジッタ（PSI）はオフセット推定システムにおける公称誤差を表します。デルタ及びイプシロン統計は、ルート遅延（DELTA）、ルート分散（EPSILON）の統計情報を生成する基準クロックから各階層レベルで蓄積されます。 EPSILON + DELTA / 2に等しい同期距離（LAMBDA）は、すべての原因による最大誤差を表します。これらの統計の詳細な製剤は、セクション11.2に記載されています。彼らは、同期機能の性能を評価するために依存するアプリケーションに利用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Implementation Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.実装モデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 2 shows the architecture of a typical, multi-threaded implementation. It includes two processes dedicated to each server, a peer process to receive messages from the server or reference clock, and a poll process to transmit messages to the server or reference clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図2は、典型的なマルチスレッド実装のアーキテクチャを示しています。これは、各サーバ、サーバまたは基準クロックからメッセージを受信するピアプロセス、およびサーバまたは基準クロックにメッセージを送信するポーリング処理に専用の2つのプロセスを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   .....................................................................
   . Remote   .   Peer/Poll  .              System          .  Clock   .
   . Servers  .   Processes  .              Process         .Discipline.
   .          .              .                              . Process  .
   .+--------+. +-----------+. +------------+               .          .
   .|        |-&gt;|           |. |            |               .          .
   .|Server 1|  |Peer/Poll 1|-&gt;|            |               .          .
   .|        |&lt;-|           |. |            |               .          .
   .+--------+. +-----------+. |            |               .          .
   .          .       ^      . |            |               .          .
   .          .       |      . |            |               .          .
   .+--------+. +-----------+. |            |  +-----------+.          .
   .|        |-&gt;|           |. | Selection  |-&gt;|           |. +------+ .
   .|Server 2|  |Peer/Poll 2|-&gt;|    and     |  | Combine   |-&gt;| Loop | .
   .|        |&lt;-|           |. | Cluster    |  | Algorithm |. |Filter| .
   .+--------+. +-----------+. | Algorithms |-&gt;|           |. +------+ .
   .          .       ^      . |            |  +-----------+.    |     .
   .          .       |      . |            |               .    |     .
   .+--------+. +-----------+. |            |               .    |     .
   .|        |-&gt;|           |. |            |               .    |     .
   .|Server 3|  |Peer/Poll 3|-&gt;|            |               .    |     .
   .|        |&lt;-|           |. |            |               .    |     .
   .+--------+. +-----------+. +------------+               .    |     .
   ....................^.........................................|......
                       |                                    .    V     .
                       |                                    . +-----+  .
                       +--------------------------------------| VFO |  .
                                                            . +-----+  .
                                                            .  Clock   .
                                                            .  Adjust  .
                                                            .  Process .
                                                            ............
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 2: Implementation Model
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図2：実装モデル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
These processes operate on a common data structure, called an association, which contains the statistics described above along with various other data described in Section 9. A client sends packets to one or more servers and then processes returned packets when they are received. The server interchanges source and destination addresses and ports, overwrites certain fields in the packet and returns it immediately (in the client/server mode) or at some time later (in the symmetric modes). As each NTP message is received, the offset theta between the peer clock and the system clock is computed along with the associated statistics delta, epsilon, and psi.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのプロセスは、クライアントが1つまたは複数のサーバーにパケットを送信し、それを受信したときに返されたパケットを処理セクション9に記載されている種々の他のデータと一緒に、上記の統計情報が含まれている関連付けを、と呼ばれる、共通のデータ構造を操作します。サーバは、後に（対称モードで）、送信元アドレスと宛先アドレスとポートを入れ替えるパケット内の特定のフィールドを上書きし、すぐにそれを返す（クライアント/サーバー・モードの場合）またはいくつかの時点で。各NTPメッセージが受信されるように、ピア・クロックとシステムクロックとの間のオフセットシータは、関連する統計デルタ、イプシロン、およびPSIと共に計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The system process includes the selection, cluster, and combine algorithms that mitigate among the various servers and reference clocks to determine the most accurate and reliable candidates to synchronize the system clock. The selection algorithm uses Byzantine fault detection principles to discard the presumably incorrect candidates called &#34;falsetickers&#34; from the incident population, leaving only good candidates called &#34;truechimers&#34;. A truechimer is a clock that maintains timekeeping accuracy to a previously published and trusted standard, while a falseticker is a clock that shows misleading or inconsistent time. The cluster algorithm uses statistical principles to find the most accurate set of truechimers. The combine algorithm computes the final clock offset by statistically averaging the surviving truechimers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
システムプロセスは、クラスタの選択を含む、システムクロックを同期させるために最も正確で信頼性の高い候補者を決定するために、さまざまなサーバーや基準クロックの間で緩和するアルゴリズムを組み合わせています。選択アルゴリズムは、「truechimers」と呼ばれる唯一の良い候補を残し、事件の集団から「falsetickers」と呼ばれる、おそらく間違った候補を破棄するビザンチン故障検出の原則を使用しています。 truechimerはfalsetickerが誤解を招くか、一貫性のない時間を示したクロックである一方で、以前に公開され、信頼された規格に計時精度を維持したクロックです。クラスタ化アルゴリズムはtruechimersの最も正確なセットを見つけるために、統計的原則を使用しています。結合アルゴリズムは、統計学的に生存truechimersを平均することによって最終的なオフセットクロックを計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The clock discipline process is a system process that controls the time and frequency of the system clock, here represented as a variable frequency oscillator (VFO). Timestamps struck from the VFO close the feedback loop that maintains the system clock time. Associated with the clock discipline process is the clock-adjust process, which runs once each second to inject a computed time offset and maintain constant frequency. The RMS average of past time offset differences represents the nominal error or system clock jitter. The RMS average of past frequency offset differences represents the oscillator frequency stability or frequency wander. These terms are given precise interpretation in Section 11.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロック規律プロセスは、ここでは可変周波数発振器（VFO）として表され、システム・クロックの時間と周波数を制御するシステムプロセスです。 VFOから打たれたタイムスタンプは、システムクロックの時間を維持し、フィードバックループを閉じます。クロック規律プロセスに関連付けられたオフセット計算時間を注入し、一定の周波数を維持するために、一度各秒を実行するクロック調整方法です。過去の時間のRMS平均は違いを公称オフセットエラーまたはシステム・クロック・ジッタを表します。過去周波数オフセット差のRMSの平均値は、発振器の周波数安定度や周波数ワンダーを表します。これらの用語は、11.3節で正確な解釈が与えられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A client sends messages to each server with a poll interval of 2^tau seconds, as determined by the poll exponent tau. In NTPv4, tau ranges from 4 (16 s) to 17 (36 h). The value of tau is determined by the clock discipline algorithm to match the loop-time constant T_c = 2^tau. In client/server mode, the server responds immediately; however, in symmetric modes, each of two peers manages tau as a function of current system offset and system jitter, so they may not agree with the same value. It is important that the dynamic behavior of the clock discipline algorithm be carefully controlled in order to maintain stability in the NTP subnet at large. This requires that the peers agree on a common tau equal to the minimum poll exponent of both peers. The NTP protocol includes provisions to properly negotiate this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントは、ポーリング指数タウによって決定されるように、2 ^タウ秒のポーリング間隔で各サーバーにメッセージを送信します。 NTPv4では、タウは、4（16秒）から17（36時間）の範囲です。タウの値は、ループ時定数T_C = 2 ^タウと一致するようにクロック規律アルゴリズムによって決定されます。クライアント/サーバモードでは、サーバーはすぐに応答します。しかし、対称モードでは、2つのピアの各々は、現在のオフセットシステムおよびシステム・ジッタの関数としてのタウを管理するので、それらは同じ値と一致しない可能性があります。クロックの規律アルゴリズムの動的挙動を注意深く大でNTPサブネット内の安定性を維持するために制御されることが重要です。これは、ピアが、両方のピアの最小ポーリング指数に等しい共通タウに同意することが必要です。 NTPプロトコルが適切にこの値を交渉する条項が含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The implementation model includes some means to set and adjust the system clock. The operating system is assumed to provide two functions: one to set the time directly, for example, the Unix settimeofday() function, and another to adjust the time in small increments advancing or retarding the time by a designated amount, for example, the Unix adjtime() function. In this and following references, parentheses following a name indicate reference to a function rather than a simple variable. In the intended design the clock discipline process uses the adjtime() function if the adjustment is less than a designated threshold, and the settimeofday() function if above the threshold. The manner in which this is done and the value of the threshold as described in Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装モデルは、システムクロックを設定し、調整するためのいくつかの手段を含みます。オペレーティングシステムは、二つの機能を提供するために仮定される：一つは、直接時間を設定するために、例えば、Unixのsettimeofday（）関数は、別のは、例えば、前進または指定量だけ時間を遅らせる少しずつ時間を調整するために、 Unixのadjtime（）関数。このおよび以下の参考文献では、名前の後に括弧は、関数ではなく、単純な変数への参照を示しています。閾値を超える場合に調整が指定閾値未満であり、settimeofday（）関数の場合に意図した設計にクロック規律プロセスはadjtime（）関数を使用します。これが行われている方法とセクション10で説明したように、閾値の値。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Data Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.データ型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All NTP time values are represented in twos-complement format, with bits numbered in big-endian (as described in Appendix A of [RFC0791]) fashion from zero starting at the left, or high-order, position. There are three NTP time formats, a 128-bit date format, a 64-bit timestamp format, and a 32-bit short format, as shown in Figure 3. The 128-bit date format is used where sufficient storage and word size are available. It includes a 64-bit signed seconds field spanning 584 billion years and a 64-bit fraction field resolving .05 attosecond (i.e., 0.5e-18). For convenience in mapping between formats, the seconds field is divided into a 32-bit Era Number field and a 32-bit Era Offset field. Eras cannot be produced by NTP directly, nor is there need to do so. When necessary, they can be derived from external means, such as the filesystem or dedicated hardware.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
左、または上位位置でゼロスタートからファッション（[RFC0791]の付録Aに記載されているように）、すべてのNTPタイム値は、ビッグエンディアンで番号ビットで、2の補数形式で表現されています。十分な記憶及びワードサイズである場合、128ビットの日付フォーマットが使用され、図3に示すように、3つのNTPタイムフォーマット、128ビットの日付形式、64ビットのタイムスタンプ形式、及び32ビットの短い形式は、あります利用可能。それは64ビットの584億年に及ぶ秒フィールドと0.05アト秒の解決64ビットの小数フィールドを締結含む（すなわち、0.5E-18）。フォーマット間のマッピングの便宜上、秒フィールドは32ビット時代番号フィールドと、32ビットの時代オ​​フセットフィールドに分割されています。時代は直接NTPによって製造することができない、またそうすることが必要です。必要な場合、それらは、ファイルシステム又は専用ハードウェアなどの外部手段、から誘導することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Seconds              |           Fraction            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP Short Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPショートフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Seconds                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                            Fraction                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP Timestamp Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPタイムスタンプ形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Era Number                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Era Offset                          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                           Fraction                            |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP Date Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP日付フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 3: NTP Time Formats
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図3：NTP時刻の書式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 64-bit timestamp format is used in packet headers and other places with limited word size. It includes a 32-bit unsigned seconds field spanning 136 years and a 32-bit fraction field resolving 232 picoseconds. The 32-bit short format is used in delay and dispersion header fields where the full resolution and range of the other formats are not justified. It includes a 16-bit unsigned seconds field and a 16-bit fraction field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
64ビットのタイムスタンプ形式は、パケットヘッダと、限られたワードサイズの他の場所で使用されています。これは、136年に及ぶ32ビットの符号なし秒フィールドと232ピコ秒を解決する32ビットの小数フィールドを含みます。 32ビットのショートフォーマットは、他の形式のフル解像度及び範囲は正当化されない遅延及び分散ヘッダーフィールドで使用されています。これは、16ビットの符号なし秒フィールドと16ビットの小数フィールドを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the date and timestamp formats, the prime epoch, or base date of era 0, is 0 h 1 January 1900 UTC, when all bits are zero. It should be noted that strictly speaking, UTC did not exist prior to 1 January 1972, but it is convenient to assume it has existed for all eternity, even if all knowledge of historic leap seconds has been lost. Dates are relative to the prime epoch; values greater than zero represent times after that date; values less than zero represent times before it. Note that the Era Offset field of the date format and the Seconds field of the timestamp format have the same interpretation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのビットがゼロであるときに、日付およびタイムスタンプ形式で、プライムエポック、又は時代0の基準日は、0時間1900年1月1日UTCです。厳密に言えば、UTCの前1へ1972年1月に存在していなかったが、それは歴史的なうるう秒のすべての知識が失われた場合でも、すべての永遠のために存在していると仮定すると便利であることに留意すべきです。日付はプライムエポックに対して相対的です。ゼロより大きいが、その日の後の時間を表す値。値がゼロ未満、その前に時間を表しています。日付フォーマットの時代オ​​フセットフィールドおよびタイムスタンプ形式の秒フィールドが同じ解釈を持っていることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Timestamps are unsigned values, and operations on them produce a result in the same or adjacent eras. Era 0 includes dates from the prime epoch to some time in 2036, when the timestamp field wraps around and the base date for era 1 is established. In either format, a value of zero is a special case representing unknown or unsynchronized time. Figure 4 shows a number of historic NTP dates together with their corresponding Modified Julian Day (MJD), NTP era, and NTP timestamp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイムスタンプは、符号なしの値であり、それらの操作は、同じ又は隣接する時代に結果を生成します。時代0は、タイムスタンプフィールドがラップアラウンドし、時代の1のための基準日が確立されると、2036年のある時点までの素数エポックからの日付を含んでいます。どちらの形式では、ゼロの値が不明または非同期時間を表す特殊なケースです。図4は、歴史的なNTPの数は、それらに対応する修正ユリウス日（MJD）、NTPの時代、およびNTPタイムスタンプと一緒に日付を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------+------------+-----+---------------+------------------+
   | Date        | MJD        | NTP | NTP Timestamp | Epoch            |
   |             |            | Era | Era Offset    |                  |
   +-------------+------------+-----+---------------+------------------+
   | 1 Jan -4712 | -2,400,001 | -49 | 1,795,583,104 | 1st day Julian   |
   | 1 Jan -1    | -679,306   | -14 | 139,775,744   | 2 BCE            |
   | 1 Jan 0     | -678,491   | -14 | 171,311,744   | 1 BCE            |
   | 1 Jan 1     | -678,575   | -14 | 202,939,144   | 1 CE             |
   | 4 Oct 1582  | -100,851   | -3  | 2,873,647,488 | Last day Julian  |
   | 15 Oct 1582 | -100,840   | -3  | 2,874,597,888 | First day        |
   |             |            |     |               | Gregorian        |
   | 31 Dec 1899 | 15019      | -1  | 4,294,880,896 | Last day NTP Era |
   |             |            |     |               | -1               |
   | 1 Jan 1900  | 15020      | 0   | 0             | First day NTP    |
   |             |            |     |               | Era 0            |
   | 1 Jan 1970  | 40,587     | 0   | 2,208,988,800 | First day UNIX   |
   | 1 Jan 1972  | 41,317     | 0   | 2,272,060,800 | First day UTC    |
   | 31 Dec 1999 | 51,543     | 0   | 3,155,587,200 | Last day 20th    |
   |             |            |     |               | Century          |
   | 8 Feb 2036  | 64,731     | 1   | 63,104        | First day NTP    |
   |             |            |     |               | Era 1            |
   +-------------+------------+-----+---------------+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 4: Interesting Historic NTP Dates
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図4：興味深い歴史NTP日付
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let p be the number of significant bits in the second fraction. The clock resolution is defined as 2^(-p), in seconds. In order to minimize bias and help make timestamps unpredictable to an intruder, the non-significant bits should be set to an unbiased random bit string. The clock precision is defined as the running time to read the system clock, in seconds. Note that the precision defined in this way can be larger or smaller than the resolution. The term rho, representing the precision used in the protocol, is the larger of the two.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pは第二画分の有効ビット数とします。秒で、 - （p）のクロックの分解能は2 ^のように定義されます。バイアスを最小限にし、侵入者に予測不可能なタイムスタンプを作るのを助けるために、非上位ビットが公平なランダムなビット列に設定する必要があります。クロックの精度は秒単位で、システムクロックを読み取るために実行している時間として定義されます。このように定義された精度が解像度よりも大きくても小さくすることができることに留意されたいです。プロトコルで使用される精度を表す用語ローは、2つの大きい方です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The only arithmetic operation permitted on dates and timestamps is twos-complement subtraction, yielding a 127-bit or 63-bit signed result. It is critical that the first-order differences between two dates preserve the full 128-bit precision and the first-order differences between two timestamps preserve the full 64-bit precision. However, the differences are ordinarily small compared to the seconds span, so they can be converted to floating double format for further processing and without compromising the precision.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
日付とタイムスタンプに許可のみ演算は、127ビットまたは63ビットの符号付きの結果が得られ、2の補数の減算です。 2つの日付の間の一次差がフル128ビット精度を維持することが重要であり、2つのタイムスタンプの間の一次違いは、完全な64ビットの精度を維持します。しかし、違いは秒スパンに比べて通常小さいので、それらは、さらなる処理のためおよび精度を損なうことなく、浮動二重フォーマットに変換することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is important to note that twos-complement arithmetic does not distinguish between signed and unsigned values (although comparisons can take sign into account); only the conditional branch instructions do. Thus, although the distinction is made between signed dates and unsigned timestamps, they are processed the same way. A perceived hazard with 64-bit timestamp calculations spanning an era, such as is possible in 2036, might result in over-run. In point of fact, if the client is set within 68 years of the server before the protocol is started, correct values are obtained even if the client and server are in adjacent eras.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
なお、（比較がアカウントにログイン取ることができるが）2の補数演算は符号付きおよび符号なしの値を区別しないことに留意することが重要です。唯一の条件分岐命令を行います。区別が署名の日付と符号なしのタイムスタンプとの間で行われているがこのように、彼らは同じように処理されます。時代にまたがる64ビットのタイムスタンプの計算と認識される危険性は、2036年に可能であるような、オーバーランが発生する場合があります。プロトコルが開始される前に、クライアントがサーバーの68年以内に設定されている場合は、クライアントとサーバは、隣接する時代にあっても実際は、正しい値が得られます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some time values are represented in exponent format, including the precision, time constant, and poll interval. These are in 8-bit signed integer format in log2 (log base 2) seconds. The only arithmetic operations permitted on them are increment and decrement. For the purpose of this document and to simplify the presentation, a reference to one of these variables by name means the exponentiated value, e.g., the poll interval is 1024 s, while reference by name and exponent means the actual value, e.g., the poll exponent is 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの時間の値は、精度、時定数、およびポーリング間隔を含む、指数形式で表されています。これらはLOG2の8ビット符号付き整数形式である秒間（ベース2対数）。その上で許可のみ算術演算はインクリメントとデクリメントされています。このドキュメントの目的のために、プレゼンテーションを簡単にするために、名前でこれらの変数の1を参照するには例えば、指数化値を意味名前と指数による参照は、実際の値、例えば、投票を意味し、ポーリング間隔は、1024秒です指数は10です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To convert system time in any format to NTP date and timestamp formats requires that the number of seconds s from the prime epoch to the system time be determined. To determine the integer era and timestamp given s,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPの日付とタイムスタンプのフォーマットに任意の形式でシステム時刻を変換するには、システム時間にプライムエポックからの秒数sが決定されている必要があります。 S指定された整数時代とタイムスタンプを決定するために、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
era = s / 2^(32) and timestamp = s - era * 2^(32),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
時代= S / 2 ^（32）と、タイムスタンプ= S  - 時代* 2 ^（32）、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
which works for positive and negative dates. To determine s given the era and timestamp,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは正と負の日付のために動作します。時代とタイムスタンプ与えられたのを確認するには、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
s = era * 2^(32) + timestamp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
S =時代* 2 ^（32）+タイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Converting between NTP and system time can be a little messy, and is beyond the scope of this document. Note that the number of days in era 0 is one more than the number of days in most other eras, and this won&#39;t happen again until the year 2400 in era 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPとシステム時間との間で変換すると、少し厄介なこと、およびこのドキュメントの範囲を超えていることができます。時代0の日数は、他のほとんどの時代の日数よりも1つ多くあり、これは時代の3年2400年まで再び起こらないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the description of state variables to follow, explicit reference to integer type implies a 32-bit unsigned integer. This simplifies bounds checks, since only the upper limit needs to be defined. Without explicit reference, the default type is 64-bit floating double. Exceptions will be noted as necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
従うべき状態変数の説明では、整数型への明示的な参照は、32ビット符号なし整数を意味しています。唯一の上限を定義する必要があるので、これは、境界チェックを簡素化します。明示的な参照がなければ、デフォルトのタイプは、64ビット浮動二重です。例外は、必要に応じて注目されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Data Structures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.データ構造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NTP state machines are defined in the following sections. State variables are separated into classes according to their function in packet headers, peer and poll processes, the system process, and the clock discipline process. Packet variables represent the NTP header values in transmitted and received packets. Peer and poll variables represent the contents of the association for each server separately. System variables represent the state of the server as seen by its dependent clients. Clock discipline variables represent the internal workings of the clock discipline algorithm. An example is described in Appendix A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPのステートマシンは、次のセクションで定義されています。状態変数は、パケットヘッダ、ピアと投票プロセス、システムプロセス、およびクロック規律プロセスにおけるその機能に応じてクラス分けされています。パケット変数は、送信と受信パケットにおけるNTPのヘッダ値を表します。ピアと投票変数は個別に各サーバーの関連付けの内容を表しています。その依存型クライアントで見られるようなシステム変数は、サーバの状態を表しています。時計の規律変数は、クロック規律アルゴリズムの内部動作を表しています。例は、付録Aに記載されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Structure Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。構造規則
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to distinguish between different variables of the same name but used in different processes, the naming convention summarized in Figure 5 is adopted. A receive packet variable v is a member of the packet structure r with fully qualified name r.v. In a similar manner, x.v is a transmit packet variable, p.v is a peer variable, s.v is a system variable, and c.v is a clock discipline variable. There is a set of peer variables for each association; there is only one set of system and clock variables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じ名前の異なる変数間の区別が、異なるプロセスで使用するために、図5にまとめた命名規則が採用されています。受信パケット変数vは、完全修飾名r.v.のパケット構造体Rのメンバーであります同様に、x.vはs.vは、システム変数であり、c.vクロック規律変数であり、送信パケット変数は、p.vピア変数です。各団体のピア変数のセットがあります。システムクロックの変数のセットは1つだけです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   +------+---------------------------------+
                   | Name | Description                     |
                   +------+---------------------------------+
                   | r.   | receive packet header variable  |
                   | x.   | transmit packet header variable |
                   | p.   | peer/poll variable              |
                   | s.   | system variable                 |
                   | c.   | clock discipline variable       |
                   +------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 5: Prefix Conventions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図5：プレフィックスの表記
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Global Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。グローバルパラメータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the variable classes, a number of global parameters are defined in this document, including those shown with values in Figure 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
変数のクラスに加えて、グローバルパラメータの数は、図6内の値で示されるものを含め、本文書で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            +-----------+-------+----------------------------------+
            | Name      | Value | Description                      |
            +-----------+-------+----------------------------------+
            | PORT      | 123   | NTP port number                  |
            | VERSION   | 4     | NTP version number                   |
            | TOLERANCE | 15e-6 | frequency tolerance PHI (s/s)    |
            | MINPOLL   | 4     | minimum poll exponent (16 s)     |
            | MAXPOLL   | 17    | maximum poll exponent (36 h)     |
            | MAXDISP   | 16    | maximum dispersion (16 s)        |
            | MINDISP   | .005  | minimum dispersion increment (s) |
            | MAXDIST   | 1     | distance threshold (1 s)         |
            | MAXSTRAT  | 16    | maximum stratum number           |
            +-----------+-------+----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 6: Global Parameters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図6：グローバルパラメータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While these are the only global parameters needed for interoperability, a larger collection is necessary in any implementation. Appendix A.1.1 contains those used by the skeleton for the mitigation algorithms, clock discipline algorithm, and related implementation-dependent functions. Some of these parameter values are cast in stone, like the NTP port number assigned by the IANA and the version number assigned NTPv4 itself. Others, like the frequency tolerance (also called PHI), involve an assumption about the worst-case behavior of a system clock once synchronized and then allowed to drift when its sources have become unreachable. The minimum and maximum parameters define the limits of state variables as described in later sections of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらは、相互運用性のために必要な唯一のグローバルパラメータですが、大きなコレクションは、どのような実装に必要です。付録A.1.1は、緩和アルゴリズムのスケルトン、クロック規律アルゴリズム、および関連する実装依存の関数で使用されるものが含まれています。これらのパラメータ値のいくつかは、IANAによって割り当てられたNTPポート番号とNTPv4自身に割り当てられたバージョン番号のように、石で鋳造されています。 （PHIも呼ばれる）周波数公差のような他のものは、システムクロックの最悪の場合の挙動一度同期して、そのソースが到達不能になったときにドリフトを許可についての仮定を伴います。この文書の後のセクションで説明したように最小値と最大値のパラメータは、状態変数の限界を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While shown with fixed values in this document, some implementations may make them variables adjustable by configuration commands. For instance, the reference implementation computes the value of PRECISION as log2 of the minimum time in several iterations to read the system clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントでは固定値で示されているが、いくつかの実装では、コンフィギュレーションコマンドによって、これらの変数は、調整可能なことがあります。例えば、リファレンス実装は、システムクロックを読み取るためのいくつかの反復における最小時間のLOG2としてPRECISIONの値を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Packet Header Variables
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。パケットヘッダ変数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The most important state variables from an external point of view are the packet header variables described in Figure 7 and below. The NTP packet header consists of an integral number of 32-bit (4 octet) words in network byte order. The packet format consists of three components: the header itself, one or more optional extension fields, and an optional message authentication code (MAC). The header component is identical to the NTPv3 header and previous versions. The optional extension fields are used by the Autokey public key cryptographic algorithms described in [RFC5906]. The optional MAC is used by both Autokey and the symmetric key cryptographic algorithm described in this RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ビューの外部の点から最も重要な状態変数は、図7および以下に記載のパケットヘッダ変数です。 NTPパケットのヘッダーは、ネットワークバイト順に、32ビット（4オクテット）、ワードの整数から成ります。パケットフォーマットは、3つの成分からなる：ヘッダ自体、1つ以上の任意の拡張フィールド、およびオプションのメッセージ認証コード（MAC）。ヘッダ成分はNTPv3ヘッダと以前のバージョンと同じです。オプションの拡張フィールドは、[RFC5906]に記載のオートキー公開キー暗号化アルゴリズムで使用されます。オプションのMACは、オートキーこのRFCに記載の対称鍵暗号化アルゴリズムの両方で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               +-----------+------------+-----------------------+
               | Name      | Formula    | Description           |
               +-----------+------------+-----------------------+
               | leap      | leap       | leap indicator (LI)   |
               | version   | version    | version number (VN)   |
               | mode      | mode       | mode                  |
               | stratum   | stratum    | stratum               |
               | poll      | poll       | poll exponent         |
               | precision | rho        | precision exponent    |
               | rootdelay | delta_r    | root delay            |
               | rootdisp  | epsilon_r  | root dispersion       |
               | refid     | refid      | reference ID          |
               | reftime   | reftime    | reference timestamp   |
               | org       | T1         | origin timestamp      |
               | rec       | T2         | receive timestamp     |
               | xmt       | T3         | transmit timestamp    |
               | dst       | T4         | destination timestamp |
               | keyid     | keyid      | key ID                |
               | dgst      | dgst       | message digest        |
               +-----------+------------+-----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 7: Packet Header Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図7：パケットヘッダ変数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NTP packet is a UDP datagram [RFC0768]. Some fields use multiple words and others are packed in smaller fields within a word. The NTP packet header shown in Figure 8 has 12 words followed by optional extension fields and finally an optional message authentication code (MAC) consisting of the Key Identifier field and Message Digest field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPパケットはUDPデータグラム[RFC0768]です。一部のフィールドは、複数の単語を使用し、他はワード内の小さなフィールドにパックされています。図8に示されているNTPパケットヘッダは、オプションの拡張フィールドとキー識別子フィールドおよびメッセージダイジェストフィールドからなる最終的に任意のメッセージ認証コード（MAC）、続いて12個のワードを有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |LI | VN  |Mode |    Stratum     |     Poll      |  Precision   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Root Delay                            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Root Dispersion                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Reference ID                         |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                     Reference Timestamp (64)                  +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                      Origin Timestamp (64)                    +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                      Receive Timestamp (64)                   +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      +                      Transmit Timestamp (64)                  +
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      .                                                               .
      .                    Extension Field 1 (variable)               .
      .                                                               .
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      .                                                               .
      .                    Extension Field 2 (variable)               .
      .                                                               .
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Key Identifier                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                            dgst (128)                         |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 8: Packet Header Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図8：パケットヘッダー形式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The extension fields are used to add optional capabilities, for example, the Autokey security protocol [RFC5906]. The extension field format is presented in order for the packet to be parsed without the knowledge of the extension field functions. The MAC is used by both Autokey and the symmetric key authentication scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張フィールドは、例えば、オプション機能を追加するために使用され、オートキーセキュリティプロトコル[RFC5906]。拡張フィールドのフォーマットは、拡張フィールド関数の知識なしに解析されるべきパケットのために提示されます。 MACは、自動キーと対称鍵認証方式の両方で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A list of the packet header variables is shown in Figure 7 and described in detail below. Except for a minor variation when using the IPv6 address family, these fields are backwards compatible with NTPv3. The packet header fields apply to both transmitted packets (x prefix) and received packets (r prefix). In Figure 8, the size of some multiple-word fields is shown in bits if not the default 32 bits. The basic header extends from the beginning of the packet to the end of the Transmit Timestamp field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットヘッダ変数のリストは、図7に示し、以下に詳細に記載されています。 IPv6アドレスファミリを使用した場合、マイナーバリエーションを除いて、これらのフィールドは、NTPv3との下位互換性があります。パケットヘッダフィールドは、両方の送信されたパケット（Xプレフィックス）と受信パケット（Rプレフィックス）に適用されます。図8に、いくつかの複数のワードフィールドのサイズはビットでない場合、デフォルトは32ビットで示されています。基本ヘッダは、送信タイムスタンプフィールドの終わりに、パケットの先頭から延びています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The fields and associated packet variables (in parentheses) are interpreted as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように（括弧内）フィールドと関連するパケット変数が解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LI Leap Indicator (leap): 2-bit integer warning of an impending leap second to be inserted or deleted in the last minute of the current month with values defined in Figure 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LIリープインジケータ（LEAP）：図9に定義された値と現在の月の直前に挿入または削除する切迫うるう秒の2ビット整数警告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +-------+----------------------------------------+
           | Value | Meaning                                |
           +-------+----------------------------------------+
           | 0     | no warning                             |
           | 1     | last minute of the day has 61 seconds  |
           | 2     | last minute of the day has 59 seconds  |
           | 3     | unknown (clock unsynchronized)         |
           +-------+----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 9: Leap Indicator
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図9：リープインジケータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
VN Version Number (version): 3-bit integer representing the NTP version number, currently 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VNバージョン番号（バージョン）：現在4 NTPバージョン番号を表す3ビットの整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mode (mode): 3-bit integer representing the mode, with values defined in Figure 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モード（モード）モードを示す3ビットの整数、図10に定義された値を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      +-------+--------------------------+
                      | Value | Meaning                  |
                      +-------+--------------------------+
                      | 0     | reserved                 |
                      | 1     | symmetric active         |
                      | 2     | symmetric passive        |
                      | 3     | client                   |
                      | 4     | server                   |
                      | 5     | broadcast                |
                      | 6     | NTP control message      |
                      | 7     | reserved for private use |
                      +-------+--------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 10: Association Modes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図10：アソシエーションモード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Stratum (stratum): 8-bit integer representing the stratum, with values defined in Figure 11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
階層（階層）：階層を表す8ビットの整数で、図11に定義された値を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +--------+-----------------------------------------------------+
        | Value  | Meaning                                             |
        +--------+-----------------------------------------------------+
        | 0      | unspecified or invalid                              |
        | 1      | primary server (e.g., equipped with a GPS receiver) |
        | 2-15   | secondary server (via NTP)                          |
        | 16     | unsynchronized                                      |
        | 17-255 | reserved                                            |
        +--------+-----------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 11: Packet Stratum
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図11：パケットのStratum
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is customary to map the stratum value 0 in received packets to MAXSTRAT (16) in the peer variable p.stratum and to map p.stratum values of MAXSTRAT or greater to 0 in transmitted packets. This allows reference clocks, which normally appear at stratum 0, to be conveniently mitigated using the same clock selection algorithms used for external sources (see Appendix A.5.5.1 for an example).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピア変数p.stratumにMAXSTRAT（16）に受信したパケット内の階層値0をマッピングし、送信されたパケットでは0にMAXSTRAT以上のp.stratum値をマッピングすることが通例です。これは、通常、階層0に現れる便利外部ソース（例えば付録A.5.5.1を参照）に使用したのと同じクロック選択アルゴリズムを使用して軽減する基準クロックを、可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Poll: 8-bit signed integer representing the maximum interval between successive messages, in log2 seconds. Suggested default limits for minimum and maximum poll intervals are 6 and 10, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
投票：LOG2秒で連続メッセージ間の最大間隔を表す8ビットの符号付き整数。最小および最大のポーリング間隔の推奨デフォルト限界は、それぞれ、6および10です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Precision: 8-bit signed integer representing the precision of the system clock, in log2 seconds. For instance, a value of -18 corresponds to a precision of about one microsecond. The precision can be determined when the service first starts up as the minimum time of several iterations to read the system clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
精度：LOG2秒のシステムクロックの精度を表す8ビットの符号付き整数。例えば、-18の値は、約1マイクロ秒の精度に対応します。サービスが最初にシステムクロックを読み取るために数回の反復の最小時刻として起動したときの精度を決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Root Delay (rootdelay): Total round-trip delay to the reference clock, in NTP short format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルート遅延（にrootdelay）：NTPの短い形式のリファレンスクロックへの総ラウンドトリップ遅延、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Root Dispersion (rootdisp): Total dispersion to the reference clock, in NTP short format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルート分散液（rootdisp）：NTP短い形式で基準クロックに全分散、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Reference ID (refid): 32-bit code identifying the particular server or reference clock. The interpretation depends on the value in the stratum field. For packet stratum 0 (unspecified or invalid), this is a four-character ASCII [RFC1345] string, called the &#34;kiss code&#34;, used for debugging and monitoring purposes. For stratum 1 (reference clock), this is a four-octet, left-justified, zero-padded ASCII string assigned to the reference clock. The authoritative list of Reference Identifiers is maintained by IANA; however, any string beginning with the ASCII character &#34;X&#34; is reserved for unregistered experimentation and development. The identifiers in Figure 12 have been used as ASCII identifiers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照ID（REFID）：特定のサーバまたは基準クロックを識別する32ビットのコード。解釈は、地層のフィールドの値に依存します。 （未指定または無効な）パケットの階層0の場合、これは4文字のASCII [RFC1345]の文字列で、デバッグや監視の目的のために使用される「キス・コード」と呼ばれます。階層1（基準クロック）の場合、これは、基準クロックに割り当てられた4オクテット、左寄せ、ゼロパディングされたASCII文字列です。リファレンス識別子の権威リストはIANAによって維持されています。しかし、ASCII文字「X」で始まる任意の文字列が登録されていない実験や開発のために予約されています。図12の識別子はASCII識別子として使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +------+----------------------------------------------------------+
     | ID   | Clock Source                                             |
     +------+----------------------------------------------------------+
     | GOES | Geosynchronous Orbit Environment Satellite               |
     | GPS  | Global Position System                                   |
     | GAL  | Galileo Positioning System                               |
     | PPS  | Generic pulse-per-second                                 |
     | IRIG | Inter-Range Instrumentation Group                        |
     | WWVB | LF Radio WWVB Ft. Collins, CO 60 kHz                     |
     | DCF  | LF Radio DCF77 Mainflingen, DE 77.5 kHz                  |
     | HBG  | LF Radio HBG Prangins, HB 75 kHz                         |
     | MSF  | LF Radio MSF Anthorn, UK 60 kHz                          |
     | JJY  | LF Radio JJY Fukushima, JP 40 kHz, Saga, JP 60 kHz       |
     | LORC | MF Radio LORAN C station, 100 kHz                        |
     | TDF  | MF Radio Allouis, FR 162 kHz                             |
     | CHU  | HF Radio CHU Ottawa, Ontario                             |
     | WWV  | HF Radio WWV Ft. Collins, CO                             |
     | WWVH | HF Radio WWVH Kauai, HI                                  |
     | NIST | NIST telephone modem                                     |
     | ACTS | NIST telephone modem                                     |
     | USNO | USNO telephone modem                                     |
     | PTB  | European telephone modem                                 |
     +------+----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 12: Reference Identifiers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図12：参照識別子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Above stratum 1 (secondary servers and clients): this is the reference identifier of the server and can be used to detect timing loops. If using the IPv4 address family, the identifier is the four-octet IPv4 address. If using the IPv6 address family, it is the first four octets of the MD5 hash of the IPv6 address. Note that, when using the IPv6 address family on an NTPv4 server with a NTPv3 client, the Reference Identifier field appears to be a random value and a timing loop might not be detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
階層1の上方（二次サーバーとクライアント）：これは、サーバーの参照識別子であり、タイミングループを検出することができます。 IPv4アドレスファミリを使用している場合、識別子は4オクテットのIPv4アドレスです。 IPv6アドレスファミリを使用している場合、それは、IPv6アドレスのMD5ハッシュの最初の4つのオクテットです。 NTPv3クライアントとNTPv4サーバー上でIPv6アドレスファミリを使用した場合、参照識別子フィールドは、ランダムな値とタイミングループが検出されないことがありますように見える、ということに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Reference Timestamp: Time when the system clock was last set or corrected, in NTP timestamp format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参考タイムスタンプ：システムクロックがNTPタイムスタンプ形式で、最後に設定または修正された時刻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Origin Timestamp (org): Time at the client when the request departed for the server, in NTP timestamp format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
原産地タイムスタンプ（ORG）：要求がNTPタイムスタンプ形式で、サーバー用に出発し、クライアントの時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Receive Timestamp (rec): Time at the server when the request arrived from the client, in NTP timestamp format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストがNTPタイムスタンプ形式で、クライアントから到着したときに、サーバーでタイム：タイムスタンプ（REC）を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transmit Timestamp (xmt): Time at the server when the response left for the client, in NTP timestamp format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答がNTPタイムスタンプ形式で、クライアントのために残されたときに、サーバーでタイム：タイムスタンプ（XMT）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Destination Timestamp (dst): Time at the client when the reply arrived from the server, in NTP timestamp format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目的地のタイムスタンプ（DST）：応答がNTPタイムスタンプ形式で、サーバから到着したクライアントでの時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note: The Destination Timestamp field is not included as a header field; it is determined upon arrival of the packet and made available in the packet buffer data structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
注：宛先タイムスタンプフィールドは、ヘッダフィールドとして含まれていません。それは、パケットの到着時に決定され、パケットバッファデータ構造に利用可能にされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the NTP has access to the physical layer, then the timestamps are associated with the beginning of the symbol after the start of frame. Otherwise, implementations should attempt to associate the timestamp to the earliest accessible point in the frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPは、物理層へのアクセス権を持っている場合は、タイムスタンプは、フレームの開始後のシンボルの始まりと関連しています。それ以外の場合、実装はフレーム内で最も古いアクセスポイントにタイムスタンプを関連付けるために試みるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The MAC consists of the Key Identifier followed by the Message Digest. The message digest, or cryptosum, is calculated as in [RFC1321] over all NTP-header and optional extension fields, but not the MAC itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MACは、メッセージダイジェストに続くキー識別子で構成されています。メッセージダイジェスト、又はcryptosumは、すべてのNTPヘッダーとオプションの拡張フィールド上[RFC1321]はなく、MAC自体のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Extension Field n: See Section 7.5 for a description of the format of this field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張フィールドN：このフィールドのフォーマットの説明については、セクション7.5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Key Identifier (keyid): 32-bit unsigned integer used by the client and server to designate a secret 128-bit MD5 key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鍵識別子（鍵ID）：シークレット128ビットのMD5キーを指定するために、クライアントとサーバによって使用される32ビットの符号なし整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Message Digest (digest): 128-bit MD5 hash computed over the key followed by the NTP packet header and extensions fields (but not the Key Identifier or Message Digest fields).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージダイジェスト（ダイジェスト）：NTPパケットのヘッダーと拡張フィールド（ただし、キー識別子またはメッセージダイジェストフィールド）が続くキーにわたって計算128ビットのMD5ハッシュ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It should be noted that the MAC computation used here differs from those defined in [RFC1305] and [RFC4330] but is consistent with how existing implementations generate a MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
なお、ここで使用されるMAC計算は[RFC1305]及び[RFC4330]で定義されたものとは異なるが、MACを生成する方法既存の実装と一致していることに留意すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. The Kiss-o&#39;-Death Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4。キス-O&#39;-死パケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the Stratum field is 0, which implies unspecified or invalid, the Reference Identifier field can be used to convey messages useful for status reporting and access control. These are called Kiss-o&#39;-Death (KoD) packets and the ASCII messages they convey are called kiss codes. The KoD packets got their name because an early use was to tell clients to stop sending packets that violate server access controls. The kiss codes can provide useful information for an intelligent client, either NTPv4 or SNTPv4. Kiss codes are encoded in four-character ASCII strings that are left justified and zero filled. The strings are designed for character displays and log files. A list of the currently defined kiss codes is given in Figure 13. Recipients of kiss codes MUST inspect them and, in the following cases, take these actions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
階層フィールドが指定されていないか、または無効意味0である場合、参照識別子フィールドには、状況報告とアクセス制御のための有益なメッセージを伝えるために使用することができます。これらは、キス-O&#39;-死（KOD）パケットと、彼らはキス・コードと呼ばれてい伝えるASCIIメッセージと呼ばれています。初期の使用は、サーバーのアクセス制御に違反するパケットの送信を停止するようにクライアントを伝えることだったので、KODパケットは、その名前を得ました。キス・コードは、インテリジェントなクライアントのためにNTPv4またはSNTPv4のいずれかを有用な情報を提供することができます。キスコードは左寄せとゼロが満たされている4文字のASCII文字列でエンコードされています。文字列は、文字が表示され、ログファイル用に設計されています。現在定義されてキスコードのリストは、キス・コードの13受信者がそれらを検査し、次の場合には、これらのアクションを取る必要があり、図に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
a. For kiss codes DENY and RSTR, the client MUST demobilize any associations to that server and stop sending packets to that server;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A。キスコードはDENYとRSTRの場合、クライアントはそのサーバーに何らかの関連をdemobilizeし、そのサーバーへのパケットの送信を停止しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
b. For kiss code RATE, the client MUST immediately reduce its polling interval to that server and continue to reduce it each time it receives a RATE kiss code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B。キスの符号化率の場合、クライアントはすぐにそのサーバーへのポーリング間隔を短縮し、それにそれがRATEキスコードを受け取り、それぞれの時間を短縮し続けなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
c. Kiss codes beginning with the ASCII character &#34;X&#34; are for unregistered experimentation and development and MUST be ignored if not recognized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C。 ASCII文字「X」で始まるキスコードが未登録の実験と開発のためのものであると認識されていない場合は無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
d. Other than the above conditions, KoD packets have no protocol significance and are discarded after inspection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D。上記の条件以外に、KODパケットには、プロトコルの意味を持っていないし、検査後に廃棄されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------+------------------------------------------------------------+
   | Code |                           Meaning                          |
   +------+------------------------------------------------------------+
   | ACST | The association belongs to a unicast server.               |
   | AUTH | Server authentication failed.                              |
   | AUTO | Autokey sequence failed.                                   |
   | BCST | The association belongs to a broadcast server.             |
   | CRYP | Cryptographic authentication or identification failed.     |
   | DENY | Access denied by remote server.                            |
   | DROP | Lost peer in symmetric mode.                               |
   | RSTR | Access denied due to local policy.                         |
   | INIT | The association has not yet synchronized for the first     |
   |      | time.                                                      |
   | MCST | The association belongs to a dynamically discovered server.|
   | NKEY | No key found. Either the key was never installed or is     |
   |      | not trusted.                                               |
   | RATE | Rate exceeded. The server has temporarily denied access    |
   |      | because the client exceeded the rate threshold.            |
   | RMOT | Alteration of association from a remote host running       |
   |      | ntpdc.                                                     |
   | STEP | A step change in system time has occurred, but the         |
   |      | association has not yet resynchronized.                    |
   +------+------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 13: Kiss Codes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図13：キスコード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Receive Timestamp and the Transmit Timestamp (set by the server) are undefined when in a KoD packet and MUST NOT be relied upon to have valid values and MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信タイムスタンプと（サーバーによって設定された）送信タイムスタンプときKODパケットで定義されていないと有効な値を持つように依拠してはならないと捨てなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. NTP Extension Field Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5。 NTP拡張フィールドのフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In NTPv4, one or more extension fields can be inserted after the header and before the MAC, which is always present when an extension field is present. Other than defining the field format, this document makes no use of the field contents. An extension field contains a request or response message in the format shown in Figure 14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPv4では、一つ以上の拡張フィールドは、ヘッダの後と拡張フィールドが存在するときは常に存在しているMAC、前に挿入することができます。フィールド形式を定義する以外に、このドキュメントでは、フィールドの内容を使用しません。拡張フィールドは、図14に示すフォーマットで要求または応答メッセージを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Field Type           |            Length             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      .                                                               .
      .                            Value                              .
      .                                                               .
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       Padding (as needed)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 14: Extension Field Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図14：拡張フィールドのフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All extension fields are zero-padded to a word (four octets) boundary. The Field Type field is specific to the defined function and is not elaborated here. While the minimum field length containing required fields is four words (16 octets), a maximum field length remains to be established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての拡張フィールドは、ワード（4つのオクテット）の境界までゼロが追加されます。フィールドタイプフィールドが定義された関数に固有のものであり、ここでは詳述されていません。必須フィールドを含む最小のフィールド長は4つのワード（16オクテット）であるが、最大フィールド長は、確立されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Length field is a 16-bit unsigned integer that indicates the length of the entire extension field in octets, including the Padding field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Lengthフィールドは、パディングフィールドを含むオクテット全体拡張フィールドの長さを示す16ビットの符号なし整数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. On-Wire Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.オンワイヤプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The heart of the NTP on-wire protocol is the core mechanism that exchanges time values between servers, peers, and clients. It is inherently resistant to lost or duplicate packets. Data integrity is provided by the IP and UDP checksums. No flow control or retransmission facilities are provided or necessary. The protocol uses timestamps, which are either extracted from packet headers or struck from the system clock upon the arrival or departure of a packet. Timestamps are precision data and should be restruck in the case of link-level retransmission and corrected for the time to compute a MAC in transmit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP上のワイヤプロトコルの心臓は、サーバ、ピア、およびクライアントの間の時間値を交換コア機構です。これは、紛失したり、重複したパケットに対して本質的に耐性があります。データの整合性は、IPおよびUDPチェックサムによって提供されます。フロー制御や再送施設が設けられていないか、必要に応じています。プロトコルは、いずれかのパケットヘッダから抽出された又はパケットの到着または出発時のシステムクロックから打たれるタイムスタンプを使用します。タイムスタンプは、精度データであり、リンクレベル再送信の場合にrestruck及び送信にMACを計算する時間について補正されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP messages make use of two different communication modes, one-to-one and one-to-many, commonly referred to as unicast and broadcast. For the purposes of this document, the term broadcast is interpreted as any available one-to-many mechanism. For IPv4, this equates to either IPv4 broadcast or IPv4 multicast. For IPv6, this equates to IPv6 multicast. For this purpose, IANA has allocated the IPv4 multicast address 224.0.1.1 and the IPv6 multicast address ending :101, with the prefix determined by scoping rules. Any other non-allocated multicast address may also be used in addition to these allocated multicast addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPメッセージは、一般的に、ユニキャストとブロードキャストと呼ばれる2つの異なる通信モード、1対1および1対多、を利用します。本文書の目的のために、用語放送は、任意の利用可能な1対多数の機構として解釈されます。 IPv4の場合、これは、IPv4ブロードキャストまたはIPv4マルチキャストのいずれかに相当します。 IPv6の場合、これは、IPv6マルチキャストに相当します。ルールスコープによって決定されるプレフィックスで、101：この目的のために、IANAは、IPv4マルチキャストアドレス224.0.1.1と終了IPv6マルチキャストアドレスを割り当てました。他の非割り当てられたマルチキャストアドレスは、これらの割り当てられたマルチキャストアドレスに加えて使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The on-wire protocol uses four timestamps numbered t1 through t4 and three state variables org, rec, and xmt, as shown in Figure 15. This figure shows the most general case where each of two peers, A and B, independently measure the offset and delay relative to the other. For purposes of illustration, the packet timestamps are shown in lowercase, while the state variables are shown in uppercase. The state variables are copied from the packet timestamps upon arrival or departure of a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オンワイヤプロトコルは、4つのタイムスタンプT4を介してT1の番号三個の状態変数は、組織、REC、およびXMTを使用して、図15に示すように、この図は、2つのピア、A及びBの各々は、独立してオフセットを測定する最も一般的な場合を示していますそして他方に対して遅らせます。状態変数は大文字で示されているが、例示の目的のために、パケットのタイムスタンプは、小文字で示されています。状態変数は、パケットの到着や出発時にパケットのタイムスタンプからコピーされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             t2            t3           t6            t7
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t1   |   |   t3    |   |    t5   |
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t2   |   |   t4    |   |    t6   |  Packet
        +---------+   +---------+   +---------+   +---------+ Timestamps
        |   t1    |   |t3=clock |   |   t5    |   |t7=clock |
        +---------+   +---------+   +---------+   +---------+
        |t2=clock |                 |t6=clock |
        +---------+                 +---------+
                                                               Peer B
        +---------+   +---------+   +---------+   +---------+
   org  |   T1    |   |    T1   |   | t5&lt;&gt;T1? |   |    T5   |
        +---------+   +---------+   +---------+   +---------+   State
   rec  |   T2    |   |    T2   |   |   T6    |   |    T6   | Variables
        +---------+   +---------+   +---------+   +---------+
   xmt  |    0    |   |    T3   |   |  t3=T3? |   |    T7   |
        +---------+   +---------+   +---------+   +---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  t2      t3                 t6          t7
        ---------------------------------------------------------
                 /\         \                 /\            \
                 /           \                /              \
                /             \              /                \
               /               \/           /                 \/
        ---------------------------------------------------------
             t1                t4         t5                  t8
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
            t1            t4            t5             t8
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t1   |   |   t3    |   |    t5   |
        +---------+   +---------+   +---------+   +---------+
        |    0    |   |    t2   |   |   t4    |   |    t6   |  Packet
        +---------+   +---------+   +---------+   +---------+ Timestamps
        |t1=clock |   |    t3   |   |t5=clock |   |    t7   |
        +---------+   +---------+   +---------+   +---------+
                      |t4=clock |                 |t8=clock |
                      +---------+                 +---------+
                                                               Peer A
        +---------+   +---------+   +---------+   +---------+
   org  |    0    |   |  t3&lt;&gt;0? |   |   T3    |   | t7&lt;&gt;T3? |
        +---------+   +---------+   +---------+   +---------+   State
   rec  |    0    |   |    T4   |   |   T4    |   |    T8   | Variables
        +---------+   +---------+   +---------+   +---------+
   xmt  |   T1    |   |  t1=T1? |   |   T5    |   |  t5=T5? |
        +---------+   +---------+   +---------+   +---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 15: On-Wire Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図15：オンワイヤプロトコル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the figure, the first packet transmitted by A contains only the origin timestamp t1, which is then copied to T1. B receives the packet at t2 and copies t1 to T1 and the receive timestamp t2 to T2. At this time or some time later at t3, B sends a packet to A containing t1 and t2 and the transmit timestamp t3. All three timestamps are copied to the corresponding state variables. A receives the packet at t4 containing the three timestamps t1, t2, and t3 and the destination timestamp t4. These four timestamps are used to compute the offset and delay of B relative to A, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同図において、Aによって送信された最初のパケットは、その後、T1にコピーされるだけ原点タイムスタンプT1を含んでいます。 Bは、T1にT2およびコピーt1でパケットを受信し、T2にタイムスタンプT2を受け取ります。この時点以降t3である時点で、Bを含有するT1とT2と送信タイムスタンプT3にパケットを送信します。すべての3つのタイムスタンプは、対応する状態変数にコピーされます。 Aは、三のタイムスタンプT1、T2、およびT3および宛先タイムスタンプT4を含むt4でパケットを受信します。後述のようにこれら四つのタイムスタンプは、AとBの相対的なオフセットと遅延を計算するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Before the xmt and org state variables are updated, two sanity checks are performed in order to protect against duplicate, bogus, or replayed packets. In the exchange above, a packet is duplicate or replay if the transmit timestamp t3 in the packet matches the org state variable T3. A packet is bogus if the origin timestamp t1 in the packet does not match the xmt state variable T1. In either of these cases, the state variables are updated, then the packet is discarded. To protect against replay of the last transmitted packet, the xmt state variable is set to zero immediately after a successful bogus check.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
XMTと組織の状態変数が更新される前に、2つの健全性チェックは偽の重複、またはリプレイパケットから保護するために実行されています。上記交換において、パケットは、パケットに送信タイムスタンプT3が組織状態変数T3に一致する場合に複製または再生です。パケットの原点タイムスタンプT1がXMT状態変数T1と一致しない場合、パケットは偽です。いずれの場合も、状態変数が更新され、そのパケットは破棄されます。最後に送信したパケットのリプレイから保護するために、XMT状態変数はすぐに成功した偽のチェック後にゼロに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The four most recent timestamps, T1 through T4, are used to compute the offset of B relative to A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4つの最も最近のタイムスタンプ、T4を介してT1は、AとBの相対的なオフセットを計算するために使用されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
theta = T(B) - T(A) = 1/2 * [(T2-T1) + (T3-T4)]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シータ= T（B） -  T（A）= 1/2 * [（T2-T1）+（T3-T4）]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
and the round-trip delay
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そして、ラウンドトリップ遅延
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
delta = T(ABA) = (T4-T1) - (T3-T2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デルタ= T（ABA）=（PM-T1） - （T2、TS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the quantities within parentheses are computed from 64-bit unsigned timestamps and result in signed values with 63 significant bits plus sign. These values can represent dates from 68 years in the past to 68 years in the future. However, the offset and delay are computed as sums and differences of these values, which contain 62 significant bits and two sign bits, so they can represent unambiguous values from 34 years in the past to 34 years in the future. In other words, the time of the client must be set within 34 years of the server before the service is started. This is a fundamental limitation with 64-bit integer arithmetic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
カッコ内の量は、64ビット符号なしタイムスタンプから計算されることに注意してくださいと63の最下位ビットプラス記号で署名された値になります。これらの値は、将来的には68年に過去68年からの日付を表すことができます。しかし、オフセット遅延は合計62の最下位ビット二つ符号ビットを含むこれらの値の差として計算されるので、それらは将来の34年に過去34年から明確な値を表すことができます。サービスが開始される前に、言い換えれば、クライアントの時間は、サーバーの34年以内に設定する必要があります。これは、64ビットの整数演算と基本的な制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In implementations where floating double arithmetic is available, the first-order differences can be converted to floating double and the second-order sums and differences computed in that arithmetic. Since the second-order terms are typically very small relative to the timestamp magnitudes, there is no loss in significance, yet the unambiguous range is restored from 34 years to 68 years.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
二重算術フローティング利用可能であるインプリメンテーションでは、一次違いは、演算で計算され、二重及び二次和及び差をフローティングに変換することができます。 2次項は、典型的には、タイムスタンプの大きさに比べて非常に小さいので、そこに有意に損失がなく、まだ明確な範囲は、68年に34歳から復元されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some scenarios where the initial frequency offset of the client is relatively large and the actual propagation time small, it is possible for the delay computation to become negative. For instance, if the frequency difference is 100 ppm and the interval T4-T1 is 64 s, the apparent delay is -6.4 ms. Since negative values are misleading in subsequent computations, the value of delta should be clamped not less than s.rho, where s.rho is the system precision described in Section 11.1, expressed in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
遅延計算が負になることのために、クライアントの初期周波数オフセットが比較的大きいと実際の伝播時間小さいいくつかのシナリオでは、それが可能です。周波数差が100ppmであり、間隔T4-T1が64秒であれば、例えば、見かけの遅延は-6.4ミリ秒です。負の値は、後続の計算に誤解されているので、デルタの値はs.rhoは、セクション11.1に記載されたシステムの精度でs.rho、以上でクランプされるべきであり、秒単位で表さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The discussion above assumes the most general case where two symmetric peers independently measure the offsets and delays between them. In the case of a stateless server, the protocol can be simplified. A stateless server copies T3 and T4 from the client packet to T1 and T2 of the server packet and tacks on the transmit timestamp T3 before sending it to the client. Additional details for filling in the remaining protocol fields are given in a Section 9 and following sections and in the appendix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の議論は、二つの対称ピアが独立して、それらの間のオフセットや遅延を測定する最も一般的なケースを想定しています。ステートレス・サーバの場合には、プロトコルを簡略化することができます。クライアントに送信する前に、送信タイムスタンプT3上のクライアントパケットからサーバーパケットや鋲のT1およびT2にステートレスサーバーコピーのT3とT4。残りのプロトコルフィールドに記入するための更なる詳細は、セクション9と、次のセクションおよび付録に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the on-wire protocol as described resists replay of a server response packet. However, it does not resist replay of the client request packet, which would result in a server reply packet with new values of T2 and T3 and result in incorrect offset and delay. This vulnerability can be avoided by setting the xmt state variable to zero after computing the offset and delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
記載されているように、ワイヤプロトコルは、サーバ応答パケットの再生に抵抗することに留意されたいです。しかし、それはオフセットと遅延T2、T3の新しい値で、サーバ応答パケットが発生し、間違ったことになるクライアントの要求パケットの再生に抵抗はありません。この脆弱性は、オフセットと遅延を計算した後にゼロにXMT状態変数を設定することによって回避することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Peer Process
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.ピアプロセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The process descriptions to follow include a listing of the important state variables followed by an overview of the process operations implemented as routines. Frequent reference is made to the skeleton in the appendix. The skeleton includes C-language fragments that describe the functions in more detail. It includes the parameters, variables, and declarations necessary for a conforming NTPv4 implementation. However, many additional variables and routines may be necessary in a working implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フォローするプロセス記述は、ルーチンとして実装プロセス動作の概要に続いて重要な状態変数のリストが含まれます。頻繁に参照が付録の骨格に行われます。骨格は、より詳細に機能を記述するC言語のフラグメントを含みます。これは、準拠NTPv4の実装に必要なパラメータ、変数、および宣言を含んでいます。しかし、多くの追加の変数とルーチンは、作業実施に必要な場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The peer process is called upon arrival of a server or peer packet. It runs the on-wire protocol to determine the clock offset and round-trip delay and computes statistics used by the system and poll processes. Peer variables are instantiated in the association data structure when the structure is initialized and updated by arriving packets. There is a peer process, poll process, and association process for each server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピアプロセスは、サーバーまたはピアパケットの到着時に呼ばれています。これは、クロック・オフセットと往復遅延時間を決定するためにワイヤプロトコルを実行し、システムおよび投票プロセスで使用される統計量を計算します。構造は、パケット到着によって初期化し、更新されたときにピア変数は、関連データ構造でインスタンス化されています。各サーバーのピアプロセス、投票プロセス、および関連するプロセスがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Peer Process Variables
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1。ピアプロセス変数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figures 16, 17, 18, and 19 summarize the common names, formula names, and a short description of the peer variables. The common names and formula names are interchangeable; formula names are intended to increase readability of equations in this specification. Unless noted otherwise, all peer variables have assumed prefix p.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
16、17、18、及び19の共通名、公式名、及びピア変数の簡単な説明を要約する図。一般的な名前と式名は交換可能です。式名はこの仕様で数式の可読性を高めることを意図しています。特に断りのない限り、すべてのピアの変数は、接頭辞pを想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                 +---------+----------+-----------------------+
                 | Name    | Formula  | Description           |
                 +---------+----------+-----------------------+
                 | srcaddr | srcaddr  | source address        |
                 | srcport | srcport  | source port           |
                 | dstaddr | dstaddr  | destination address   |
                 | dstport | destport | destination port      |
                 | keyid   | keyid    | key identifier key ID |
                 +---------+----------+-----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 16: Peer Process Configuration Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図16：ピアプロセスの構成変数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                +-----------+------------+---------------------+
                | Name      | Formula    | Description         |
                +-----------+------------+---------------------+
                | leap      | leap       | leap indicator      |
                | version   | version    | version number      |
                | mode      | mode       | mode                |
                | stratum   | stratum    | stratum             |
                | ppoll     | ppoll      | peer poll exponent  |
                | rootdelay | delta_r    | root delay          |
                | rootdisp  | epsilon_r  | root dispersion     |
                | refid     | refid      | reference ID        |
                | reftime   | reftime    | reference timestamp |
                +-----------+------------+---------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 17: Peer Process Packet Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図17：ピアプロセスパケット変数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     +------+---------+--------------------+
                     | Name | Formula | Description        |
                     +------+---------+--------------------+
                     | org  | T1      | origin timestamp   |
                     | rec  | T2      | receive timestamp  |
                     | xmt  | T3      | transmit timestamp |
                     | t    | t       | packet time        |
                     +------+---------+--------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 18: Peer Process Timestamp Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図18：ピアプロセスのタイムスタンプ変数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     +--------+---------+-----------------+
                     | Name   | Formula | Description     |
                     +--------+---------+-----------------+
                     | offset | theta   | clock offset    |
                     | delay  | delta   | round-trip delay|
                     | disp   | epsilon | dispersion      |
                     | jitter | psi     | jitter          |
                     | filter | filter  | clock filter    |
                     | tp     | t_p     | filter time     |
                     +--------+---------+-----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 19: Peer Process Statistics Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図19：ピアプロセスの統計変数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following configuration variables are normally initialized when the association is mobilized, either from a configuration file or upon the arrival of the first packet for an unknown association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連付けが動員されたときに、以下の構成変数は、通常、構成ファイルからまたは未知の関連についての最初のパケットの到着時にいずれか、初期化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
srcaddr: IP address of the remote server or reference clock. This becomes the destination IP address in packets sent from this association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SRCADDR：リモートサーバーまたは参照クロックのIPアドレス。これは、この関連付けから送信されたパケットの宛先IPアドレスになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
srcport: UDP port number of the server or reference clock. This becomes the destination port number in packets sent from this association. When operating in symmetric modes (1 and 2), this field must contain the NTP port number PORT (123) assigned by the IANA. In other modes, it can contain any number consistent with local policy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
srcport：サーバまたはリファレンスクロックのUDPポート番号。これは、この関連付けから送信されたパケットの宛先ポート番号になります。対称モード（1及び2）で動作している場合、このフィールドは、IANAによって割り当てられたNTPポート番号のポート（123）を含んでいなければなりません。他のモードでは、ローカルの方針と整合任意の数を含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dstaddr: IP address of the client. This becomes the source IP address in packets sent from this association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DSTADDR：クライアントのIPアドレス。これは、この協会から送られたパケットの送信元IPアドレスになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dstport: UDP port number of the client, ordinarily the NTP port number PORT (123) assigned by the IANA. This becomes the source port number in packets sent from this association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DstPortの：IANAによって割り当てられたクライアントのUDPポート番号、通常NTPポート番号PORT（123）。これは、この関連付けから送信されたパケットの送信元ポート番号になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
keyid: Symmetric key ID for the 128-bit MD5 key used to generate and verify the MAC. The client and server or peer can use different values, but they must map to the same key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
鍵ID：生成してMACを検証するために使用される128ビットのMD5鍵の対称鍵ID。クライアントとサーバまたはピアが異なる値を使用することができますが、彼らは同じキーにマップする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The variables defined in Figure 17 are updated from the packet header as each packet arrives. They are interpreted in the same way as the packet variables of the same names. It is convenient for later processing to convert the NTP short format packet values r.rootdelay and r.rootdisp to floating doubles as peer variables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各パケットが到着するように、図17に定義された変数は、パケットヘッダから更新されます。彼らは、同じ名前のパケット変数と同じように解釈されます。後の処理は、ピア変数としてフローティング倍にNTP短い形式パケット値r.rootdelayとr.rootdispを変換することが便利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The variables defined in Figure 18 include the timestamps exchanged by the on-wire protocol in Section 8. The t variable is the seconds counter c.t associated with these values. The c.t variable is maintained by the clock-adjust process described in Section 12. It
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図18に定義された変数は、T変数は、これらの値に関連付けられた秒カウンタc.tあるセクション8内にワイヤプロトコルによって交換されるタイムスタンプを含みます。 c.t変数はセクション12のそれに記載のクロック調整プロセスによって維持されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
counts the seconds since the service was started. The variables defined in Figure 19 include the statistics computed by the clock_filter() routine described in Section 10. The tp variable is the seconds counter associated with these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サービスが開始されてからの秒をカウントします。図19に定義された変数は、TP変数は、これらの値に関連付けられた秒カウンタである項10に記載clock_filter（）ルーチンによって計算された統計を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Peer Process Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2。ピアプロセス操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The receive routine defines the process flow upon the arrival of a packet. An example is described by the receive() routine in Appendix A.5.1. There is no specific method required for access control, although it is recommended that implementations include such a scheme, which is similar to many others now in widespread use. The access() routine in Appendix A.5.4 describes a method of implementing access restrictions using an access control list (ACL). Format checks require correct field length and alignment, acceptable version number (1-4), and correct extension field syntax, if present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信ルーチンは、パケットの到着時の処理の流れを定義します。例は、付録A.5.1で受信（）ルーチンによって記載されています。実装が広く使用されている今、多くの人に似ているようなスキームを含むことをお勧めしますが、アクセス制御のために必要な具体的な方法は、ありません。付録A.5.4でのアクセス（）ルーチンは、アクセス制御リスト（ACL）を使用してアクセス制限を実現する方法について説明します。存在する場合に、フォーマットチェックは、許容されるバージョン番号（1-4）、および正しい拡張子フィールド構文を正しいフィールド長と位置合わせを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is no specific requirement for authentication; however, if authentication is implemented, then the MD5-keyed hash algorithm described in [RFC1321] must be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証に関する特別な要件はありません。認証が実装されている場合は、次に、[RFC1321]に記載のMD5-鍵付きハッシュアルゴリズムがサポートされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Next, the association table is searched for matching source address and source port, for example, using the find_assoc() routine in Appendix A.5.1. Figure 20 is a dispatch table where the columns correspond to the packet mode and rows correspond to the association mode. The intersection of the association and packet modes dispatches processing to one of the following steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次に、対応テーブルは、例えば、送信元アドレスおよび送信元ポートに一致find_assoc付録A.5.1で（）ルーチンを使用して検索されます。図20は、列がパケットモードに対応し、行が関連付けモードに対応するディスパッチ・テーブルです。アソシエーションとパケットモードの交点は、以下の工程のいずれかに処理をディスパッチします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           +------------------+---------------------------------------+
           |                  |              Packet Mode              |
           +------------------+-------+-------+-------+-------+-------+
           | Association Mode |   1   |   2   |   3   |   4   |   5   |
           +------------------+-------+-------+-------+-------+-------+
           | No Association 0 | NEWPS | DSCRD | FXMIT | MANY  | NEWBC |
           | Symm. Active   1 | PROC  | PROC  | DSCRD | DSCRD | DSCRD |
           | Symm. Passive  2 | PROC  | ERR   | DSCRD | DSCRD | DSCRD |
           | Client         3 | DSCRD | DSCRD | DSCRD | PROC  | DSCRD |
           | Server         4 | DSCRD | DSCRD | DSCRD | DSCRD | DSCRD |
           | Broadcast      5 | DSCRD | DSCRD | DSCRD | DSCRD | DSCRD |
           | Bcast Client   6 | DSCRD | DSCRD | DSCRD | DSCRD | PROC  |
           +------------------+-------+-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 20: Peer Dispatch Table
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図20：ピアディスパッチテーブル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
DSCRD. This indicates a non-fatal violation of protocol as the result of a programming error, long-delayed packet, or replayed packet. The peer process discards the packet and exits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
廃棄数。これは、プログラミング・エラー、長い遅延パケット、又は再生パケットの結果としてのプロトコルの非致命的な違反を示しています。ピアプロセスは、パケットと終了を破棄します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ERR. This indicates a fatal violation of protocol as the result of a programming error, long-delayed packet, or replayed packet. The peer process discards the packet, demobilizes the symmetric passive association, and exits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ERR。これは、プログラミング・エラー、長い遅延パケット、又は再生パケットの結果としてのプロトコルの致命的な違反を示します。ピアプロセスは、パケットを破棄し、対称パッシブアソシエーション、及び終了をdemobilizes。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FXMIT. This indicates a client (mode 3) packet matching no association (mode 0). If the destination address is not a broadcast address, the server constructs a server (mode 4) packet and returns it to the client without retaining state. The server packet header is constructed. An example is described by the fast_xmit() routine in Appendix A.5.3. The packet header is assembled from the receive packet and system variables as shown in Figure 21. If the s.rootdelay and s.rootdisp system variables are stored in floating double, they must be converted to NTP short format first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FXMIT。これは、クライアント（モード3）パケットは関連が一致しない（モード0）を示します。宛先アドレスがブロードキャストアドレスでない場合、サーバは、サーバ（モード4）パケットを構築し、状態を保持することなく、それをクライアントに返します。サーバ・パケット・ヘッダが構成されています。例は、付録A.5.3でfast_xmit（）ルーチンによって記載されています。 s.rootdelayとs.rootdispシステム変数は、二重フローティングに格納され、それらは最初NTP短いフォーマットに変換する必要がある場合、図21に示すように、パケットヘッダを受信パケットとシステム変数から組み立てられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   +-----------------------------------+
                   | Packet Variable --&gt;   Variable    |
                   +-----------------------------------+
                   | r.leap        --&gt;     p.leap      |
                   | r.mode        --&gt;     p.mode      |
                   | r.stratum     --&gt;     p.stratum   |
                   | r.poll        --&gt;     p.ppoll     |
                   | r.rootdelay   --&gt;     p.rootdelay |
                   | r.rootdisp    --&gt;     p.rootdisp  |
                   | r.refid       --&gt;     p.refid     |
                   | r.reftime     --&gt;     p.reftime   |
                   | r.keyid       --&gt;     p.keyid     |
                   +-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 21: Receive Packet Header
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図21：パケットヘッダを受信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that, if authentication fails, the server returns a special message called a crypto-NAK. This message includes the normal NTP header data shown in Figure 8, but with a MAC consisting of four octets of zeros. The client MAY accept or reject the data in the message. After these actions, the peer process exits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証が失敗した場合、サーバは暗号NAKと呼ばれる特別なメッセージを返す、ということに注意してください。このメッセージは、図8に示す通常NTPヘッダデータを含むが、MACとゼロの4つのオクテットからなります。クライアントは、メッセージ内のデータを受け入れるか拒否するかもしれません。これらのアクションの後、ピア・プロセスが終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the destination address is a multicast address, the sender is operating in manycast client mode. If the packet is valid and the server stratum is less than the client stratum, the server sends an ordinary server (mode 4) packet, but one which uses its unicast destination address. A crypto-NAK is not sent if authentication fails. After these actions, the peer process exits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
宛先アドレスがマルチキャストアドレスである場合、送信者は、メニーキャストクライアントモードで動作しています。パケットが有効であり、サーバ階層がクライアントの地層よりも小さい場合、サーバは通常のサーバ（モード4）パケットを送信しますが、そのユニキャスト宛先アドレスを使用しています1。認証が失敗した場合に暗号NAKが送信されません。これらのアクションの後、ピア・プロセスが終了します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
MANY: This indicates a server (mode 4) packet matching no association. Ordinarily, this can happen only as the result of a manycast server reply to a previously sent multicast client packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
MANY：これは何の関連付けに一致しないサーバ（モード4）パケットを示しています。通常、これは唯一以前に送信されたマルチキャストクライアントパケットにメニーキャストサーバの応答の結果として発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the packet is valid, an ordinary client (mode 3) association is mobilized and operation continues as if the association was mobilized by the configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットが有効である場合は、通常のクライアント（モード3）関連付けが動員され、関連付けが設定ファイルで動員されたかのように動作を継続します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NEWBC. This indicates a broadcast (mode 5) packet matching no association. The client mobilizes either a client (mode 3) or broadcast client (mode 6) association. Examples are shown in the mobilize() and clear() routines in Appendix A.2. Then, the packet is validated and the peer variables initialized. An example is provided by the packet() routine in Appendix A.5.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NEWBC。これは、ブロードキャスト（モード5）パケットは関連と一致しないことを示します。クライアントは、クライアント（モード3）またはブロードキャストクライアント（モード6）会合のいずれかを動員します。例は、付録A.2に動員（）及びクリア（）ルーチンで示されています。その後、パケットが確認され、ピア変数が初期化されます。例は、付録A.5.1.1におけるパケット（）ルーチンによって提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the implementation supports no additional security or calibration functions, the association mode is set to broadcast client (mode 6) and the peer process exits. Implementations supporting public key authentication MAY run the Autokey or equivalent security protocol. Implementations SHOULD set the association mode to 3 and run a short client/server exchange to determine the propagation delay. Following the exchange, the association mode is set to 6 and the peer process continues in listen-only mode. Note the distinction between a mode-6 packet, which is reserved for the NTP monitor and control functions, and a mode-6 association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装が追加のセキュリティやキャリブレーション機能をサポートしていない場合は、アソシエーションモードは、クライアント（モード6）とピア・プロセスが終了をブロードキャストするように設定されています。公開鍵認証をサポートする実装は、自動キーまたは同等のセキュリティプロトコルを実行することができます。実装は、伝播遅延を決定するために3にアソシエーションモードを設定し、短いクライアント/サーバ交換を実行する必要があります。交換後、アソシエーションモードが6に設定され、ピア・プロセスがリッスンのみのモードで継続します。 NTPモニタおよび制御機能のために予約されているモード6パケット、及びモード-6関連の区別に注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NEWPS. This indicates a symmetric active (mode 1) packet matching no association. The client mobilizes a symmetric passive (mode 2) association. An example is shown in the mobilize() and clear() routines in Appendix A.2. Processing continues in the PROC section below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NEWPS。これは何の関連付けに一致しない対称アクティブ（モード1）パケットを示しています。クライアントは、対称パッシブ（モード2）アソシエーションを動員します。例は付録A.2に動員（）及びクリア（）ルーチンで示されています。処理は、以下のPROCセクションで続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PROC. This indicates a packet matching an existing association. The packet timestamps are carefully checked to avoid invalid, duplicate, or bogus packets. Additional checks are summarized in Figure 22. Note that all packets, including a crypto-NAK, are considered valid only if they survive these tests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PROC。これは、既存の関連付けに一致パケットを示しています。パケットのタイムスタンプは、慎重に、無効避けるため、複製、または偽のパケットをチェックしています。追加のチェックは暗号NAKを含むすべてのパケットが、彼らはこれらのテストを生き残る場合にのみ有効と見なされていることを、図22注意に要約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +--------------------------+----------------------------------------+
   | Packet Type              | Description                            |
   +--------------------------+----------------------------------------+
   | 1 duplicate packet       | The packet is at best an old duplicate |
   |                          | or at worst a replay by a hacker.      |
   |                          | This can happen in symmetric modes if  |
   |                          | the poll intervals are uneven.         |
   | 2 bogus packet           |                                        |
   | 3 invalid                | One or more timestamp fields are       |
   |                          | invalid. This normally happens in      |
   |                          | symmetric modes when one peer sends    |
   |                          | the first packet to the other and      |
   |                          | before the other has received its      |
   |                          | first reply.                           |
   | 4 access denied          | The access controls have blacklisted   |
   |                          | the source.                            |
   | 5 authentication failure | The cryptographic message digest does  |
   |                          | not match the MAC.                     |
   | 6 unsynchronized         | The server is not synchronized to a    |
   |                          | valid source.                          |
   | 7 bad header data        | One or more header fields are invalid. |
   +--------------------------+----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 22: Packet Error Checks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図22：パケットエラーチェック
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Processing continues by copying the packet variables to the peer variables as shown in Figure 21. An example is described by the packet() routine in Appendix A.5.1.1. The receive() routine implements tests 1-5 in Figure 22; the packet() routine implements tests 6-7. If errors are found, the packet is discarded and the peer process exits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例は付録A.5.1.1にパケット（）ルーチンによって記載されている図21に示すような処理は、ピア変数へパケット変数をコピーすることによって継続します。受信（）ルーチンを実装は、図22の1-5テスト。パケット（）ルーチンが実装は6-7をテストします。エラーが発見された場合、パケットは破棄され、ピア・プロセスが終了しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The on-wire protocol calculates the clock offset theta and round-trip delay delta from the four most recent timestamps as described in Section 8. While it is, in principle, possible to do all calculations except the first-order timestamp differences in fixed-point arithmetic, it is much easier to convert the first-order differences to floating doubles and do the remaining calculations in that arithmetic, and this will be assumed in the following description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上のワイヤプロトコルは、固定で一次タイムスタンプの違いを除き、すべての計算を行うことが可能、それはですが、セクション8に記載されたクロックは、原則的には、4つの最も最近のタイムスタンプからシータと往復遅延デルタオフセット計算します小数点演算は、フローティング倍に第一階差分を変換し、その演算の残りの計算を行うことがはるかに容易であり、これは、以下の説明において想定されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Next, the 8-bit p.reach shift register in the poll process described in Section 13 is used to determine whether the server is reachable and the data are fresh. The register is shifted left by one bit when a packet is sent and the rightmost bit is set to zero. As valid packets arrive, the rightmost bit is set to one. If the register contains any nonzero bits, the server is considered reachable; otherwise, it is unreachable. Since the peer poll interval might have changed since the last packet, the host poll interval is reviewed. An example is provided by the poll_update() routine in Appendix A.5.7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次に、第13章に記載ポーリングプロセスにおいて8ビットp.reachシフトレジスタは、サーバが到達可能であり、データが新鮮であるかどうかを決定するために使用されます。パケットが送信されたときにレジスタが1ビット左シフトされ、右端のビットはゼロに設定されています。有効なパケットが到着すると、右端のビットが1に設定されています。レジスタは0（ゼロ）以外のビットが含まれている場合は、サーバが到達可能と考えられています。そうでない場合は、それが到達不能です。ピアポーリング間隔は、最後のパケット以降に変更された可能性があるため、ホストのポーリング間隔が見直されています。例は、付録A.5.7.2にpoll_update（）ルーチンによって提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The dispersion statistic epsilon(t) represents the maximum error due to the frequency tolerance and time since the last packet was sent. It is initialized
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後のパケットが送信されたので、分散統計イプシロン（t）は周波数公差および時間による最大誤差を表します。これは、初期化されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
epsilon(t_0) = r.rho + s.rho + PHI * (T4-T1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
イプシロン（T_0）= r.rho s.rho + + PH *（T4-T1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
when the measurement is made at t_0 according to the seconds counter. Here, r.rho is the packet precision described in Section 7.3 and s.rho is the system precision described in Section 11.1, both expressed in seconds. These terms are necessary to account for the uncertainty in reading the system clock in both the server and the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
測定は、秒カウンタに応じT_0で行われたとき。ここで、r.rhoは7.3節とs.rhoで説明したパケットの精度は11.1、秒単位で表さ両方に記載されているシステムの精度です。これらの用語は、サーバーとクライアントの両方でシステムクロックを読んで不確実性を考慮する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The dispersion then grows at constant rate PHI; in other words, at time t, epsilon(t) = epsilon(t_0) + PHI * (t-t_0). With the default value PHI = 15 ppm, this amounts to about 1.3 s per day. With this understanding, the argument t will be dropped and the dispersion represented simply as epsilon. The remaining statistics are computed by the clock filter algorithm described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次に、分散液を一定の速度で成長PHI;換言すれば、時刻tにおける、イプシロン（T）=イプシロン（T_0）+ PHI *（T-T_0）。デフォルト値PHIが15 ppmのを=で、これは、1日あたり約1.3秒になります。このような理解では、引数tは廃棄され、分散は単にイプシロンとして表現しました。残りの統計は、次のセクションで説明したクロックフィルタアルゴリズムによって計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Clock Filter Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.クロックフィルタアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The clock filter algorithm is part of the peer process. It grooms the stream of on-wire data to select the samples most likely to represent accurate time. The algorithm produces the variables shown in Figure 19, including the offset (theta), delay (delta), dispersion (epsilon), jitter (psi), and time of arrival (t). These data are used by the mitigation algorithms to determine the best and final offset used to discipline the system clock. They are also used to determine the server health and whether it is suitable for synchronization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロックフィルタアルゴリズムは、ピアプロセスの一部です。これは、正確な時刻を表現する可能性が最も高いサンプルを選択するために、上の線データのストリームを新郎。アルゴリズムは、オフセット（シータ）、遅延（デルタ）、分散（イプシロン）、ジッタ（PSI）、および到着（t）の時間を含む、図19に示す変数を生成します。これらのデータは、システムクロックを統制するために使用オフセット最善と最終的に判断するために緩和アルゴリズムによって使用されています。彼らはまた、サーバーの状態を決定するために使用され、それが同期のために適しているかどうか。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The clock filter algorithm saves the most recent sample tuples (theta, delta, epsilon, t) in the filter structure, which functions as an 8-stage shift register. The tuples are saved in the order that packets arrive. Here, t is the packet time of arrival according to the seconds counter and should not be confused with the peer variable tp.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロックフィルタアルゴリズムは、8段のシフトレジスタとして機能するフィルタ構造に最新のサンプルタプル（シータ、デルタ、イプシロン、t）を保存します。タプルは、パケットが到着順に保存されます。ここで、tは秒カウンタに応じて、到着のパケット時間であり、ピア変数TPと混同してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following scheme is used to ensure sufficient samples are in the filter and that old stale data are discarded. Initially, the tuples of all stages are set to the dummy tuple (0, MAXDISP, MAXDISP, 0). As valid packets arrive, tuples are shifted into the filter causing old tuples to be discarded, so eventually only valid tuples remain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のスキームは、十分なサンプルがフィルタにあり、古い古いデータは破棄されていることを確認するために使用されます。最初に、すべてのステージのタプルはダミータプル（0、MAXDISP、MAXDISP、0）に設定されています。有効なパケットが到着すると、タプルは古いタプルを破棄させるフィルタ内にシフトされているので、最終的には唯一の有効なタプルが残っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the three low-order bits of the reach register are zero, indicating three poll intervals have expired with no valid packets received, the poll process calls the clock filter algorithm with a dummy tuple just as if the tuple had arrived from the network. If this persists for eight poll intervals, the register returns to the initial condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リーチレジスタの下位3ビットが3つのポーリング間隔を示し、ゼロの場合、有効なパケットを受信して​​いないと有効期限が切れている、ポーリングプロセスは、タプルがネットワークから到着したかのようにダミーのタプルとクロックフィルタアルゴリズムを呼び出します。これは、8つのポーリング間隔のために解決しない場合は、レジスタが初期状態に戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the next step, the shift register stages are copied to a temporary list and the list sorted by increasing delta. Let i index the stages starting with the lowest delta. If the first tuple epoch t_0 is not later than the last valid sample epoch tp, the routine exits without affecting the current peer variables. Otherwise, let epsilon_i be the dispersion of the ith entry, then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のステップでは、シフトレジスタのステージは一時リストとデルタを増加させることにより、ソートされたリストにコピーされます。私は、インデックスのステージが最低デルタで始まるましょう。最初のタプルエポックT_0は後で最後の有効なサンプルエポックTPよりもされていない場合、現在のピア変数に影響を与えることなく、ルーチンは終了します。それ以外の場合は、その後、epsilon_iは、i番目のエントリの分散も聞かせて
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     i=n-1
                     ---     epsilon_i
      epsilon =       \     ----------
                      /        (i+1)
                     ---     2
                     i=0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
is the peer dispersion p.disp. Note the overload of epsilon, whether input to the clock filter or output, the meaning should be clear from context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ピア分散p.dispです。クロックフィルタや出力への入力は、意味が文脈から明らかであるかどうか、イプシロンの過負荷に注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The observer should note (a) if all stages contain the dummy tuple with dispersion MAXDISP, the computed dispersion is a little less than 16 s, (b) each time a valid tuple is shifted into the register, the dispersion drops by a little less than half, depending on the valid tuples dispersion, and (c) after the fourth valid packet the dispersion is usually a little less than 1 s, which is the assumed value of the MAXDIST parameter used by the selection algorithm to determine whether or not the peer variables are acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
観察者は、（b）は、有効なタプルがレジスタにシフトされるたびに、分散が少し低下する、全ての段階は分散MAXDISPダミータプルを含む場合（a）に示すように、計算された分散は16秒弱であることに注意すべきですか否かを決定するために選択アルゴリズムによって使用されるMAXDISTパラメータの想定値である分散液は、通常、1秒よりも少し小さい第四の有効なパケット、後に有効なタプルの分散に応じて、半分以上、および（c）ピア変数が許容されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let the first stage offset in the sorted list be theta_0; then, for the other stages in any order, the jitter is the RMS average
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ソートされたリストにオフセット第一段階はtheta_0とします。その後、任意の順序で他のステージのために、ジッタは、RMSの平均であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                          +-----                 -----+^1/2
                          |  n-1                      |
                          |  ---                      |
                  1       |  \                     2  |
      psi   =  -------- * |  /    (theta_0-theta_j)   |
                (n-1)     |  ---                      |
                          |  j=1                      |
                          +-----                 -----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where n is the number of valid tuples in the filter (n &gt; 1). In order to ensure consistency and avoid divide exceptions in other computations, the psi is bounded from below by the system precision s.rho expressed in seconds. While not in general considered a major factor in ranking server quality, jitter is a valuable indicator of fundamental timekeeping performance and network congestion state. Of particular importance to the mitigation algorithms is the peer synchronization distance, which is computed from the delay and dispersion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Nはフィルタの有効なタプルの数（N&gt; 1）です。一貫性を確保し、他の計算で除算例外を回避するために、PSIは、秒単位で表さシステム精密s.rhoによって下方から制限されます。一般的には、サーバーの質をランク付けする大きな要因と考えられていないが、ジッタは、基本的な計時性能とネットワークの輻輳状態の貴重な指標です。緩和アルゴリズムに特に重要なの遅延及び分散から計算され、ピア同期距離、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
lambda = (delta / 2) + epsilon.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ラムダ=（デルタ/ 2）+イプシロン。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that epsilon and therefore lambda increase at rate PHI. The lambda is not a state variable, since lambda is recalculated at each use. It is a component of the root synchronization distance used by the mitigation algorithms as a metric to evaluate the quality of time available from each server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
率PHIでそのイプシロンので、ラムダ増加に注意してください。ラムダは、各用途に再計算されるので、ラムダは、状態変数ではありません。これは、各サーバから利用可能な時間の品質を評価する指標として緩和アルゴリズムによって使用されるルート同期距離の成分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is important to note that, unlike NTPv3, NTPv4 associations do not show a timeout condition by setting the stratum to 16 and leap indicator to 3. The association variables retain the values determined upon arrival of the last packet. In NTPv4, lambda increases with time, so eventually the synchronization distance exceeds the distance threshold MAXDIST, in which case the association is considered unfit for synchronization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPv3とは異なり、NTPv4団体が関連変数は、最後のパケットの到着時に決定された値を保持3に16の地層とうるうインジケータを設定することにより、タイムアウト条件を示さない、ということに注意することが重要です。 NTPv4では、ラムダは、時間と共に増加するので、最終的に同期距離は、関連付けが、同期のために不適当であると考えられる場合には距離閾値MAXDISTを超えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example implementation of the clock filter algorithm is shown in the clock_filter() routine of Appendix A.5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロックフィルタアルゴリズムの実装例は、付録A.5.2のclock_filter（）ルーチンに示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. System Process
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.システムプロセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As each new sample (theta, delta, epsilon, jitter, t) is produced by the clock filter algorithm, all peer processes are scanned by the mitigation algorithms consisting of the selection, cluster, combine, and clock discipline algorithms in the system process. The selection algorithm scans all associations and casts off the falsetickers, which have demonstrably incorrect time, leaving the truechimers as result. In a series of rounds, the cluster algorithm discards the association statistically furthest from the centroid until a specified minimum number of survivors remain. The combine algorithm produces the best and final statistics on a weighted average basis. The final offset is passed to the clock discipline algorithm to steer the system clock to the correct time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロックフィルタアルゴリズムにより生成される各新しいサンプル（シータ、デルタ、イプシロン、ジッタ、t）として、すべてのピアプロセスがシステムプロセスでの選択、クラスタ、結合、およびクロック規律アルゴリズムからなる緩和アルゴリズムによって走査されます。選択アルゴリズムは、結果としてtruechimersを残して、すべての関連付けをスキャンし、明らかに間違った時間を持ってfalsetickersを、オフにキャストします。生存者の指定された最小数が残るまでのラウンドのシリーズでは、クラスタ化アルゴリズムは、統計学的に遠い重心からアソシエーションを破棄する。組み合わせアルゴリズムは、加重平均ベースで最高と最終統計情報を生成します。オフセットは、最終的には正しい時刻にシステムクロックを操縦するためにクロック規律アルゴリズムに渡されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The cluster algorithm selects one of the survivors as the system peer. The associated statistics (theta, delta, epsilon, jitter, t) are used to construct the system variables inherited by dependent servers and clients and made available to other applications running on the same machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クラスタ化アルゴリズムは、システムのピアとして生存者のいずれかを選択します。関連する統計（シータ、デルタ、イプシロン、ジッタ、t）は従属サーバとクライアントによって継承され、同じマシン上で実行されている他のアプリケーションが利用できるようにシステム変数を構築するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. System Process Variables
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1。システムプロセス変数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 23 summarizes the common names, formula names, and a short description of each system variable. Unless noted otherwise, all variables have assumed prefix s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図23は、共通の名前、式名、および各システム変数の簡単な説明をまとめたものです。特に断りのない限り、すべての変数は、接頭辞の前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                +-----------+------------+------------------------+
                | Name      | Formula    | Description            |
                +-----------+------------+------------------------+
                | t         | t          | update time            |
                | p         | p          | system peer identifier |
                | leap      | leap       | leap indicator         |
                | stratum   | stratum    | stratum                |
                | precision | rho        | precision              |
                | offset    | THETA      | combined offset        |
                | jitter    | PSI        | combined jitter        |
                | rootdelay | DELTA      | root delay             |
                | rootdisp  | EPSILON    | root dispersion        |
                | v         | v          | survivor list          |
                | refid     | refid      | reference ID           |
                | reftime   | reftime    | reference time         |
                | NMIN      | 3          | minimum survivors      |
                | CMIN      | 1          | minimum candidates     |
                +-----------+------------+------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 23: System Process Variables
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図23：システムのプロセス変数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Except for the t, p, offset, and jitter variables and the NMIN and CMIN constants, the variables have the same format and interpretation as the peer variables of the same name. The NMIN and CMIN parameters are used by the selection and cluster algorithms described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T、P、オフセット、およびジッタ変数とNMINとCMIN定数を除いて、変数は、同じ名前のピア変数と同じ形式と解釈を持っています。 NMIN及びCMINパラメータは、次のセクションで説明した選択し、クラスタアルゴリズムによって使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The t variable is the seconds counter at the time of the last update. An example is shown by the clock_update() routine in Appendix A.5.5.4. The p variable is the system peer identifier determined by the cluster() routine in Section 11.2.2. The precision variable has the same format as the packet variable of the same name. The precision is defined as the larger of the resolution and time to read the clock, in log2 units. For instance, the precision of a mains-frequency clock incrementing at 60 Hz is 16 ms, even when the system clock hardware representation is to the nanosecond.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T変数は、最後の更新時の秒カウンタです。例は、付録A.5.5.4にclock_update（）ルーチンによって示されています。 p変数は、セクション11.2.2クラスタ（）ルーチンによって決定システムピア識別子です。精度変数は、同じ名前のパケット変数と同じフォーマットを有します。精度はLOG2単位で、解像度の大きいクロックを読み取るための時間として定義されます。例えば、60Hzでインクリメント電源周波数のクロックの精度は、システムクロックハードウェア表現はナノ秒である場合であっても、16ミリ秒です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The offset and jitter variables are determined by the combine algorithm in Section 11.2.3. These values represent the best and final offset and jitter used to discipline the system clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オフセットとジッタの変数は、11.2.3項で結合アルゴリズムによって決定されます。これらの値は、システムクロックを統制するために使用最善かつ最終オフセットとジッタを表します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Initially, all variables are cleared to zero, then the leap is set to 3 (unsynchronized) and stratum is set to MAXSTRAT (16). Remember that MAXSTRAT is mapped to zero in the transmitted packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初は、すべての変数がゼロにクリアされ、その後、飛躍を3（非同期の）に設定され、地層はMAXSTRAT（16）に設定されています。 MAXSTRATが送信パケット内で0にマッピングされていることを覚えておいてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. System Process Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2。システムプロセスの操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 24 summarizes the system process operations performed by the clock select routine. The selection algorithm described in Section 11.2.1 produces a majority clique of presumed correct candidates (truechimers) based on agreement principles. The cluster algorithm described in Section 11.2.2 discards outliers to produce the most accurate survivors. The combine algorithm described in Section 11.2.3 provides the best and final offset for the clock discipline algorithm. An example is described in Appendix A.5.5.6. If the selection algorithm cannot produce a majority clique, or if it cannot produce at least CMIN survivors, the system process exits without disciplining the system clock. If successful, the cluster algorithm selects the statistically best candidate as the system peer and its variables are inherited as the system variables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図24は、クロック選択ルーチンによって実行されるシステムの処理動作をまとめたものです。 11.2.1項に記載した選択アルゴリズムは、契約の原則に基づいて推定正しい候補（truechimers）の多数決クリークを生成します。 11.2.2項で説明したクラスタアルゴリズムは、最も正確な生存者を生成するために外れ値を破棄します。 11.2.3項で説明組み合わせたアルゴリズムは、クロック規律アルゴリズムのオフセット最高と最終を提供します。例は、付録A.5.5.6に記述されています。選択アルゴリズムは、過半数のクリークを生成することができない、またはそれは、少なくともCMIN生存者を生み出すことができない場合は、システム・プロセスは、システムクロックを懲戒せずに終了した場合。成功した場合は、クラスタ化アルゴリズムは、システムのピアとして、統計的に最良の候補を選択し、その変数がシステム変数として継承されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                          +-----------------+
                          | clock_select()  |
                          +-----------------+
   ................................|...........
   .                               V          .
   .      yes +---------+ +-----------------+ .
   .       +--| accept? | | scan candidates | .
   .       |  +---------+ |                 | .
   .       V        no |  |                 | .
   .  +---------+      |  |                 | .
   .  | add peer|      |  |                 | .
   .  +----------      |  |                 | .
   .       |           V  |                 | .
   .       +----------&gt;--&gt;|                 | .
   .                      |                 | .
   . Selection Algorithm  +-----------------+ .
   .................................|..........
                                    V
                       no +-------------------+
            +-------------|     survivors?    |
            |             +-------------------+
            |                       | yes
            |                       V
            |             +-------------------+
            |             | Cluster Algorithm |
            |             +-------------------+
            |                       |
            |                       V
            V         yes +-------------------+
            |&lt;------------|     n &lt; CMIN?     |
            |             +-------------------+
            V                       |
     +-----------------+            V no
     |   s.p = NULL    |  +-------------------+
     +-----------------+  |   s.p = v_0.p     |
            |             +-------------------+
            V                       |
     +-----------------+            V
     | return (UNSYNC) |  +-------------------+
     +-----------------+  |   return (SYNC)   |
                          +-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 24: Clock Select Routine
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図24：クロック選択ルーチン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1. Selection Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.1。選択アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the selection and cluster algorithms are described separately, but combined in the code skeleton. The selection algorithm operates to find an intersection interval containing a majority clique of truechimers using Byzantine agreement principles originally proposed by Marzullo [ref6], but modified to improve accuracy. An overview of the algorithm is given below and described in the first half of the clock_select() routine in Appendix A.5.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択およびクラスタアルゴリズムは別々に説明したが、コード骨格に結合されることに留意されたいです。選択アルゴリズムは、もともとMarzullo [ref6]によって提案されたが、精度を改善するために改変ビザンチン合意原理を用いてtruechimersの大部分のクリークを含む交差点間隔を検索するように動作します。アルゴリズムの概要は下記付録A.5.5.1にclock_select（）ルーチンの前半に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First, those servers that are unusable according to the rules of the protocol are detected and discarded as shown by the accept() routine in Appendix A.5.5.3. Next, a set of tuples (p, type, edge) is generated for the remaining candidates. Here, p is the association identifier and type identifies the upper (+1), middle (0), and lower (-1) endpoints of a correctness interval centered on theta for that candidate. This results in three tuples, lowpoint (p, -1, theta - lambda), midpoint (p, 0, theta), and highpoint (p, +1, theta + lambda), where lambda is the root synchronization distance. An example of this calculation is shown by the rootdist() routine in Appendix A.5.1.1. The steps of the algorithm are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A.5.5.3に受け入れる（）ルーチンによって示すように、まず、プロトコルの規則に従って使用できないこれらのサーバが検出され、廃棄されます。次に、タプル（P型、エッジ）のセットは、残りの候補について生成されます。ここで、pは、アソシエーション識別子とタイプは、上部（+1）、中央（0）、及び下部（-1）その候補についてシータを中心に正確間隔のエンドポイントを識別しています。ラムダルート同期距離である - （ラムダP、-1、シータ）、中間点（P、0、シータ）、及びHIGHPOINT（P、+1、シータ+ラムダ）、これは、3つのタプル、lowpointもたらします。この計算の例は、付録A.5.1.1にrootdist（）ルーチンによって示されています。アルゴリズムのステップは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. For each of m associations, place three tuples as defined above on the candidate list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mアソシエーションのそれぞれについて1候補リストに上で定義した通り、3つのタプルを配置します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Sort the tuples on the list by the edge component. Order the lowpoint, midpoint, and highpoint of these intervals from lowest to highest. Set the number of falsetickers f = 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.エッジ成分によってリスト上のタプルをソート。 lowpoint、中間点、最低から最高へのこれらの間隔のHIGHPOINTを注文します。 F = 0 falsetickersの数を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. Set the number of midpoints d = 0. Set c = 0. Scan from lowest endpoint to highest. Add one to c for every lowpoint, subtract one for every highpoint, add one to d for every midpoint. If c &gt;= m - f, stop; set l = current lowpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
中間点の数を設定3.最低エンドポイントから最高へ= 0集合C = 0スキャン日間。 、すべてのHIGHPOINTのための1つを引く、すべてのlowpoint用のCに1を追加し、すべての中間点のためにDに1を追加します。 C&gt; = Mであれば - 停止、F。集合L =電流lowpoint。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Set c = 0. Scan from highest endpoint to lowest. Add one to c for every highpoint, subtract one for every lowpoint, add one to d for every midpoint. If c &gt;= m - f, stop; set u = current highpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最高のエンドポイントから最低に= 0のスキャン4.セットC。 、すべてのlowpointのための1つを引く、すべてのHIGHPOINTのためにCに1を追加し、すべての中間点のためにDに1を追加します。 C&gt; = Mであれば - 停止、F。 U =現在のHIGHPOINTを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. Is d = f and l &lt; u? If yes, then follow step 5A; else, follow step 5B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5. D = Fとl &lt;uのですか？ yesの場合、ステップ5Aに従ってください。他に、ステップ5Bに従ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5A. Success: the intersection interval is [l, u].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図5（a）。成功：交差点間隔が[L、U]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5B. Add one to f. Is f &lt; (m / 2)? If yes, then go to step 3 again. If no, then go to step 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図5（b）。 Fに1を追加します。 F &lt;（M / 2）ですか？ yesの場合は、再度手順3に進みます。いいえ場合は、手順6に進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. Failure; a majority clique could not be found. There are no suitable candidates to discipline the system clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6.失敗;大半のクリークが見つかりませんでした。システムクロックを訓練するために何の適切な候補がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The algorithm is described in detail in Appendix A.5.5.1. Note that it starts with the assumption that there are no falsetickers (f = 0) and attempts to find a non-empty intersection interval containing the midpoints of all correct servers, i.e., truechimers. If a non-empty interval cannot be found, it increases the number of assumed falsetickers by one and tries again. If a non-empty interval is found and the number of falsetickers is less than the number of truechimers, a majority clique has been found and the midpoint of each truechimer (theta) represents the candidates available to the cluster algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アルゴリズムは付録A.5.5.1に詳細に記載されています。それはfalsetickers（F = 0）が存在しないという仮定から始まり、すべての適切なサーバ、すなわち、truechimersの中点を含む非空交差間隔を見つけようとすることに注意してください。空でない間隔が見つからない場合、これは、1つが想定falsetickersの数を増加させ、再度試みます。空でない間隔が見つかり、falsetickers数がtruechimersの数未満である場合、多数決クリークが見出され、各truechimer（シータ）の中点は、クラスタ化アルゴリズムに利用可能な候補を表しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a majority clique is not found, or if the number of truechimers is less than CMIN, there are insufficient candidates to discipline the system clock. CMIN defines the minimum number of servers consistent with the correctness requirements. Suspicious operators would set CMIN to ensure multiple redundant servers are available for the algorithms to mitigate properly. However, for historic reasons the default value for CMIN is one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
過半数のクリークが見つからない場合truechimersの数がCMINよりも小さい場合、または、システムクロックを訓練するのに十分な候補があります。 CMINは正当性要件に合致サーバーの最小数を定義します。不審な演算子は、アルゴリズムが適切に軽減するために、複数の冗長サーバが利用可能であることを確認するためにCMINを設定します。しかし、歴史的な理由でCMINのデフォルト値は1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2. Cluster Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.2。クラスタアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The candidates of the majority clique are placed on the survivor list v in the form of tuples (p, theta_p, psi_p, lambda_p), where p is an association identifier, theta_p, psi_p, and stratum_p the current offset, jitter and stratum of association p, respectively, and lambda_p is a merit factor equal to stratum_p * MAXDIST + lambda, where lambda is the root synchronization distance for association p. The list is processed by the cluster algorithm below. An example is shown by the second half of the clock_select() algorithm in Appendix A.5.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多数クリークの候補は、pは、アソシエーション識別子、theta_p、psi_pあるタプルの形式（P、theta_p、psi_p、lambda_p）で生存者リストV上に配置され、かつ関連の現在のオフセット、ジッタ及び地層をstratum_pれますpは、それぞれ、及びlambda_pは*ラムダが関連付けPのルート同期距離でMAXDIST +ラムダを、stratum_pに等しいメリット係数です。リストは以下のクラスタ化アルゴリズムによって処理されます。例は、付録A.5.5.1にclock_selectの後半（）アルゴリズムによって示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Let (p, theta_p, psi_p, lambda_p) represent a survivor candidate.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.レッツ（P、theta_p、psi_p、lambda_pは）生存者候補を表しています。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. Sort the candidates by increasing lambda_p. Let n be the number of candidates and NMIN the minimum required number of survivors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. lambda_pを増やすことで候補を並べ替えます。 n個の候補者とNMIN生存者の最低限必要な数の数とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. For each candidate, compute the selection jitter psi_s:
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
各候補について前記選択ジッタpsi_sを計算します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +-----                       -----+^1/2
             |        n-1                      |
             |        ---                      |
             |   1    \                     2  |
     psi_s = | ---- * /  (theta_s - theta_j)   |
             |  n-1   ---                      |
             |        j=1                      |
             +-----                       -----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Select psi_max as the candidate with maximum psi_s.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.最大psi_sと候補としてpsi_maxを選択します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Select psi_min as the candidate with minimum psi_p.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.最小psi_pと候補としてpsi_minを選択します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. Is psi_max &lt; psi_min or n &lt;= NMIN? If yes, follow step 6A; otherwise, follow step 6B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6. psi_max &lt;psi_minあるいはn &lt;= NMINですか？そうならば、ステップ6Aに従ってください。そうでなければ、ステップ6Bに従います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6A. Done. The remaining candidates on the survivor list are ranked in the order of preference. The first entry on the list represents the system peer; its variables are used later to update the system variables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6A。完了。遺族リストの残りの候補は優先順にランク付けされています。リストの最初のエントリは、システムピアを表します。その変数は、システム変数を更新するために、後で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6B. Delete the outlier candidate with psi_max; reduce n by one and go back to step 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6B。 psi_maxで外れ値候補を削除します。 1でのnを軽減し、ステップ3に戻ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The algorithm operates in a series of rounds where each round discards the statistical outlier with maximum selection jitter psi_s. However, if psi_s is less than the minimum peer jitter psi_p, no improvement is possible by discarding outliers. This and the minimum number of survivors represent the terminating conditions of the algorithm. Upon termination, the final value of psi_max is saved as the system selection jitter PSI_s for use later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アルゴリズムは、各ラウンドは最大選択ジッタpsi_sと統計外れ値を破棄ラウンド一連の動作します。 psi_sが最小ピアジッタpsi_p未満である場合は、改善は外れ値を捨てることにより可能ではありません。これと生存の最小数は、アルゴリズムの終了条件を表します。終了時に、psi_maxの最終的な値は、後の使用のためのシステム選択ジッタPSI_sとして保存されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3. Combine Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2.3。アルゴリズムを組み合わせます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The clock combine route processes the remaining survivors to produce the best and final data for the clock discipline algorithm. The routine processes peer offset and jitter statistics to produce the combined system offset THETA and system peer jitter PSI_p, where each server statistic is weighted by the reciprocal of the root synchronization distance and the result normalized. An example is shown by the clock_combine() routine in Appendix A.5.5.5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロックはクロック規律アルゴリズムのための最高の、最終的なデータを生成するために、残りの生存ルートプロセスを兼ね備えています。ルーチン処理はオフセットと組み合わせるシステムを生成するジッタの統計情報は、各サーバの統計がルート同期距離の逆数と正規化された結果によって重み付けされ、THETA、システムピアジッタPSI_pを、オフセットピア。例は、付録A.5.5.5にclock_combine（）ルーチンによって示されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The combined THETA is passed to the clock update routine. The first candidate on the survivor list is nominated as the system peer with identifier p. The system peer jitter PSI_p is a component of the system jitter PSI. It is used along with the selection jitter PSI_s to produce the system jitter:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
組み合わせTHETAはクロック更新ルーチンに渡されます。生存者リスト上の最初の候補識別子pのシステムのピアとして指名されます。システムピアジッタPSI_pシステムジッタPSIの構成要素です。システムのジッタを生成するために選択ジッタPSI_sと一緒に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSI = [(PSI_s)^2 + (PSI_p)^2]^1/2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PSI = [（PSI_s）^ 2 +（PSI_p）^ 2] ^ 1/2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each time an update is received from the system peer, the clock update routine is called. By rule, an update is discarded if its time of arrival p.t is not strictly later than the last update used s.t. The labels IGNOR, PANIC, ADJ, and STEP refer to return codes from the local clock routine described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
更新は、システムピアから受信されるたびに、クロック更新ルーチンが呼び出されます。到着p.tのその時が最後の更新に使用S。T.より後の厳密でない場合は、ルールにより、更新が破棄されますラベルIGNOR、PANIC、ADJ、ステップは次のセクションで説明したローカルクロックルーチンからコードを返すように参照します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
IGNORE means the update has been ignored as an outlier. PANIC means the offset is greater than the panic threshold PANICT (1000 s) and SHOULD cause the program to exit with a diagnostic message to the system log. STEP means the offset is less than the panic threshold, but greater than the step threshold STEPT (125 ms). In this case, the clock is stepped to the correct offset, but since this means all peer data have been invalidated, all associations MUST be reset and the client begins as at initial start.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
更新が外れ値として無視されてきた手段を無視します。 PANICオフセットがパニック閾値PANICT（1000秒）よりも大きくなると、プログラムは、システムログに診断メッセージを表示して終了させるべきであることを意味します。 STEPオフセットを意味するパニック閾値よりも小さいが、ステップしきい値STEPT（125ミリ秒）よりも大きいです。この場合、クロックが正しいオフセットに踏まれるが、これは、データが無効化されているすべてのピアを意味するので、すべての関連付けをリセットする必要があり、クライアントは、初期起動時のように開始されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ADJ means the offset is less than the step threshold and thus a valid update. In this case, the system variables are updated from the peer variables as shown in Figure 25.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ADJは、オフセットステップの閾値未満ので、有効なアップデートであることを意味します。図25に示すように、この場合には、システム変数は、ピア変数から更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                  +-------------------------------------------+
                  | System Variable &lt;-- System Peer Variable  |        |
                  +-------------------------------------------+
                  | s.leap      &lt;-- p.leap                    |
                  | s.stratum   &lt;-- p.stratum + 1             |
                  | s.offset    &lt;-- THETA                     |
                  | s.jitter    &lt;-- PSI                       |
                  | s.rootdelay &lt;-- p.delta_r + delta         |
                  | s.rootdisp  &lt;-- p.epsilon_r + p.epsilon + |
                  |                 p.psi + PHI * (s.t - p.t) |
                  |                 + |THETA|                 |
                  | s.refid     &lt;-- p.refid                   |
                  | s.reftime   &lt;-- p.reftime                 |
                  | s.t         &lt;-- p.t                       |
                  +-------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 25: System Variables Update
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図25：システム変数を更新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is an important detail not shown. The dispersion increment (p.epsilon + p.psi + PHI * (s.t - p.t) + |THETA|) is bounded from below by MINDISP. In subnets with very fast processors and networks and very small delay and dispersion this forces a monotone-definite increase in s.rootdisp (EPSILON), which avoids loops between peers operating at the same stratum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
示されていない重要なディテールがあります。分散増分（p.epsilon + p.psi + PHI *（s.t  -  p.t）+ | THETA |）はMINDISPによって下から囲まれています。非常に高速なプロセッサとネットワークと非常に小さい遅延及び分散のサブネットでは、これは、同じ階層で動作するピア間のループを回避s.rootdispにおける単調定値増加（EPSILON）を、強制します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The system variables are available to dependent application programs as nominal performance statistics. The system offset THETA is the clock offset relative to the available synchronization sources. The system jitter PSI is an estimate of the error in determining this value, elsewhere called the expected error. The root delay DELTA is the total round-trip delay relative to the primary server. The root dispersion EPSILON is the dispersion accumulated over the network from the primary server. Finally, the root synchronization distance is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
システム変数は、名目上のパフォーマンス統計などに依存するアプリケーションプログラムにご利用いただけます。システムは、THETAは、利用可能な同期ソースに対してオフセットクロックオフセット。システムジッタPSIは、他の場所で予想されるエラーと呼ばれる、この値を決定する際の誤差の推定値です。ルート遅延DELTAは、プライマリサーバに対して、合計往復遅延です。ルート分散EPSILONは、プライマリサーバからネットワーク経由で累積分散です。最後に、ルート同期距離は次のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
LAMBDA = EPSILON + DELTA / 2,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LAMBDA = EPSILON + DELTA / 2、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
which represents the maximum error due all causes and is designated the root synchronization distance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その最大誤差によるすべての原因を表し、ルート同期距離が指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of the clock update routine is provided in Appendix A.5.5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロック更新ルーチンの一例は、付録A.5.5.4で提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Clock Discipline Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3。時計調教アルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NTPv4 clock discipline algorithm, shortened to discipline in the following, functions as a combination of two quite philosophically different feedback control systems. In a phase-locked loop (PLL) design, periodic phase updates at update intervals mu seconds are used directly to minimize the time error and indirectly the frequency error. In a frequency-locked loop (FLL) design, periodic frequency updates at intervals mu are used directly to minimize the frequency error and indirectly the time error. As shown in [ref7], a PLL usually works better when network jitter dominates, while an FLL works better when oscillator wander dominates. This section contains an outline of how the NTPv4 design works. An in-depth discussion of the design principles is provided in [ref7], which also includes a performance analysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下では規律に短縮NTPv4クロック規律アルゴリズム、二つ全く哲学の異なるフィードバック制御システムの組み合わせとして機能します。位相ロックループ（PLL）の設計では、更新間隔で周期的な位相更新ミュー秒時刻誤差および間接的周波数誤差を最小化するために直接使用されます。周波数ロックループ（FLL）の設計では、間隔ミューで周期的周波数の更新は、周波数誤差及び間接的時間誤差を最小化するために直接使用されます。 【ref7]に示すように、ネットワーク・ジッタが支配的と発振器ワンダーが支配するときFLLは良好に動作しながら、PLLは通常、良好に動作します。このセクションでは、NTPv4のデザインがどのように動作するかの概要が含まれています。設計原理の詳細な議論は、パフォーマンス分析を含む、[ref7]で提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The discipline is implemented as the feedback control system shown in Figure 26. The variable theta_r represents the combine algorithm offset (reference phase) and theta_c the VFO offset (control phase). Each update produces a signal V_d representing the instantaneous phase difference theta_r - theta_c. The clock filter for each server functions as a tapped delay line, with the output taken at the tap selected by the clock filter algorithm. The selection, cluster, and combine algorithms combine the data from multiple filters to produce the signal V_s. The loop filter, with impulse response F(t), produces the signal V_c, which controls the VFO frequency omega_c and thus the integral of the phase theta_c which closes the loop. The V_c signal is generated by the clock-adjust process in Section 12. The detailed equations that implement these functions are best presented in the routines of Appendices A.5.5.6 and A.5.6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
規律は、図26に可変theta_rを示したフィードバック制御系として実現される結合アルゴリズムが（基準位相）オフセットとtheta_c VFOは、（制御相）のオフセットを表します。 theta_c  - 各アップデートは、瞬時位相差theta_rを示す信号V_Dを生成します。クロックフィルタアルゴリズムにより選択されたタップで撮影された出力を有するタップ付き遅延線として、各サーバ機能用のクロックフィルタ。選択、クラスタ、及び組み合わせアルゴリズムは、信号V_Sを生成する複数のフィルタからのデータを組み合わせます。インパルス応答F（t）を有するループフィルタは、このようにVFO周波数omega_cとループを閉じる相の積分theta_cを制御信号V_Cを生成します。 V_C信号部12にこれらの機能を実装する詳細な式は最高の付録のA.5.5.6及びA.5.6.1のルーチンに提示されているクロック調整処理によって生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                theta_r + +---------\        +----------------+
            NTP ---------&gt;|  Phase   \  V_d  |                | V_s
                theta_c - | Detector  ------&gt;|  Clock Filter  |----+
                +--------&gt;|          /       |                |    |
                |         +---------/        +----------------+    |
                |                                                  |
              -----                                                |
             /     \                                               |
             | VFO |                                               |
             \     /                                               |
              -----    .......................................     |
                ^      .            Loop Filter              .     |
                |      . +---------+   x  +-------------+    .     |
                | V_c  . |         |&lt;-----|             |    .     |
                +------.-|  Clock  |   y  | Phase/Freq  |&lt;---------+
                       . | Adjust  |&lt;-----| Prediction  |    .
                       . |         |      |             |    .
                       . +---------+      +-------------+    .
                       .......................................
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 26: Clock Discipline Feedback Loop
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図26：クロック調教フィードバックループ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ordinarily, the pseudo-linear feedback loop described above operates to discipline the system clock. However, there are cases where a non-linear algorithm offers considerable improvement. One case is when the discipline starts without knowledge of the intrinsic clock frequency. The pseudo-linear loop takes several hours to develop an accurate measurement and during most of that time the poll interval cannot be increased. The non-linear loop described below does this in 15 minutes. Another case is when occasional bursts of large jitter are present due to congested network links. The state machine described below resists error bursts lasting less than 15 minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
通常、上述した擬似線形フィードバックループは、システムクロックを訓練するように動作します。しかし、非線形アルゴリズムは、かなりの改善を提供する場合があります。規律は、固有のクロック周波数の知識がなくても起動時に一つのケースがあります。疑似リニアループは、正確な測定を開発するのに数時間かかり、その時間のほとんどの間、ポーリング間隔を大きくすることができません。下記の非線形ループは15分でこれを行います。大きなジッタの時折のバーストが原因混雑したネットワークリンクに存在するときに別のケースです。以下のステートマシンは、15分未満の持続エラーバーストに抵抗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 27 contains a summary of the variables and parameters including the variable (lowercase) or parameter (uppercase) name, formula name, and short description. Unless noted otherwise, all variables have assumed prefix c. The variables t, tc, state, hyster, and count are integers; the remaining variables are floating doubles. The function of each will be explained in the algorithm descriptions below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図27は、可変（小文字）またはパラメータ（大文字）名、式名、および短い説明を含む変数およびパラメータの概要を含んでいます。特に断りのない限り、すべての変数は、接頭辞Cを想定しています。変数T、TC、状態、HYSTER、カウントは整数です。残りの変数はダブルスを浮遊しています。それぞれの機能は、以下のアルゴリズムの記述に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                +--------+------------+--------------------------+
                | Name   | Formula    | Description              |
                +--------+------------+--------------------------+
                | t      | timer      | seconds counter          |
                | offset | theta      | combined offset          |
                | resid  | theta_r    | residual offset          |
                | freq   | phi        | clock frequency          |
                | jitter | psi        | clock offset jitter      |
                | wander | omega      | clock frequency wander   |
                | tc     | tau        | time constant (log2)     |
                | state  | state      | state                    |
                | adj    | adj        | frequency adjustment     |
                | hyster | hyster     | hysteresis counter       |
                | STEPT  | 125        | step threshold (.125 s)  |
                | WATCH  | 900        | stepout thresh(s)        |
                | PANICT | 1000       | panic threshold (1000 s) |
                | LIMIT  | 30         | hysteresis limit         |
                | PGATE  | 4          | hysteresis gate          |
                | TC     | 16         | time constant scale      |
                | AVG    | 8          | averaging constant       |
                +--------+------------+--------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 27: Clock Discipline Variables and Parameters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図27：クロック変数とパラメータを規律
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The process terminates immediately if the offset is greater than the panic threshold PANICT (1000 s). The state transition function is described by the rstclock() function in Appendix A.5.5.7. Figure 28 shows the state transition function used by this routine. It has four columns showing, respectively, the state name, predicate and action if the offset theta is less than the step threshold, the predicate and actions otherwise, and finally some comments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
オフセットパニック閾値PANICT（1000秒）よりも大きければ処理は直ちに終了します。状態遷移関数は、付録A.5.5.7にrstclock（）関数によって記述されます。図28は、このルーチンによって使用される状態遷移関数を示します。オフセットシータはステップ閾値を、そうでない場合は、述語とアクション、そして最終的にいくつかのコメントよりも小さい場合には、4つの列をそれぞれ示す、状態名、述語とアクションを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      +-------+---------------------+-------------------+--------------+
      | State | theta &lt; STEP        | theta &gt; STEP      | Comments     |
      +-------+---------------------+-------------------+--------------+
      | NSET  | -&gt;FREQ              | -&gt;FREQ            | no frequency |
      |       | adjust time         | step time         | file         |
      +-------+---------------------+-------------------+--------------+
      | FSET  | -&gt;SYNC              | -&gt;SYNC            | frequency    |
      |       | adjust time         | step time         | file         |
      +-------+---------------------+-------------------+--------------+
      | SPIK  | -&gt;SYNC              | if &lt; 900 s -&gt;SPIK | outlier      |
      |       | adjust freq         | else -&gt;SYNC       | detected     |
      |       | adjust time         | step freq         |              |
      |       |                     | step time         |              |
      +-------+---------------------+-------------------+--------------+
      | FREQ  | if &lt; 900 s -&gt;FREQ   | if &lt; 900 s -&gt;FREQ | initial      |
      |       | else -&gt;SYNC         | else -&gt;SYNC       | frequency    |
      |       | step freq           | step freq         |              |
      |       | adjust time         | adjust time       |              |
      +-------+---------------------+-------------------+--------------+
      | SYNC  | -&gt;SYNC              | if &lt; 900 s -&gt;SPIK | normal       |
      |       | adjust freq         | else -&gt;SYNC       | operation    |
      |       | adjust time         | step freq         |              |
      |       |                     | step time         |              |
      +-------+---------------------+-------------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 28: State Transition Function
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図28：状態遷移関数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the table entries, the next state is identified by the arrow -&gt; with the actions listed below. Actions such as adjust time and adjust frequency are implemented by the PLL/FLL feedback loop in the local_clock() routine. A step clock action is implemented by setting the clock directly, but this is done only after the stepout threshold WATCH (900 s) when the offset is more than the step threshold STEPT (.125 s). This resists clock steps under conditions of extreme network congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アクションは以下のとおりで&gt;  - テーブルエントリでは、次の状態を矢印で識別されます。そのような時間を調整し、調整周波数のアクションはlocal_clock（）ルーチンにおけるPLL / FLL帰還ループによって実現されます。ステップクロックアクションは、直接クロックを設定することにより実現されるが、これは唯一stepout閾値WATCHステップしきい値STEPT（0.125秒）以上であるオフセット（900秒）後に行われます。これは極端なネットワークの輻輳の条件でクロックステップに抵抗します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The jitter (psi) and wander (omega) statistics are computed using an exponential average with weight factor AVG. The time constant exponent (tau) is determined by comparing psi with the magnitude of the current offset theta. If the offset is greater than PGATE (4) times the clock jitter, the hysteresis counter hyster is reduced by two; otherwise, it is increased by one. If hyster increases to the upper limit LIMIT (30), tau is increased by one; if it decreases to the lower limit -LIMIT (-30), tau is decreased by one. Normally, tau hovers near MAXPOLL, but quickly decreases if a temperature spike causes a frequency surge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジッタ（PSI）およびワンダーは（オメガ）統計は、重み係数AVGとの指数平均を用いて計算されます。時定数指数（タウ）は、現在のオフセット、θの大きさにPSIを比較することによって決定されます。オフセット（4）倍のクロックジッタPGATEより大きい場合、ヒステリシスカウンタHYSTERは2で低減されます。それ以外の場合は、1つ増加しています。 HYSTERが上限LIMIT（30）に上昇した場合、タウは1だけ増加されます。それは下限-LIMIT（-30）に減少すれば、タウは1だけ減少されます。通常、タウはMAXPOLL近くに置いたが、温度スパイクは、周波数サージが発生した場合に迅速に減少します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Clock-Adjust Process
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.時計調整プロセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The actual clock-adjust process runs at one-second intervals to add the frequency correction and a fixed percentage of the residual offset theta_r. The theta_r is, in effect, the exponential decay of the theta value produced by the loop filter at each update. The TC parameter scales the time constant to match the poll interval for convenience. Note that the dispersion EPSILON increases by PHI at each second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際のクロック調整プロセスは、周波数補正及び残留オフセットtheta_rの一定の割合を追加するために、1秒間隔で実行されます。 theta_rは、実質的に、シータ値の指数関数的減衰は、各更新のループフィルタにより生成されます。 TCパラメータは便宜的にポーリング間隔に合わせて、一定の時間をスケーリングします。各第二にPHIによる分散イプシロン増加することに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The clock-adjust process includes a timer interrupt facility driving the seconds counter c.t. It begins at zero when the service starts and increments once each second. At each interrupt, the clock_adjust() routine is called to incorporate the clock discipline time and frequency adjustments, then the associations are scanned to determine if the seconds counter equals or exceeds the p.next state variable defined in the next section. If so, the poll process is called to send a packet and compute the next p.next value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロック調整プロセスは、秒カウンタc.t.を駆動するタイマ割り込み機能を含みこれは、各秒後にゼロ時にサービスが開始され、増分で始まります。各割り込みに、clock_adjust（）ルーチンは、次いで、関連付けが秒カウンタは、次のセクションで定義p.next状態変数と等しい又は超えるか否かを決定するためにスキャンされ、クロック規律時間及び周波数の調整を組み込むために呼び出されます。その場合は、ポーリングプロセスがパケットを送信し、次のp.next値を計算するために呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An example of the clock-adjust process is shown by the clock_adjust() routine in Appendix A.5.6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クロック調整プロセスの例は、付録A.5.6.1にclock_adjust（）ルーチンによって示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Poll Process
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.ポーリングプロセス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each association supports a poll process that runs at regular intervals to construct and send packets in symmetric, client, and broadcast server associations. It runs continuously, whether or not servers are reachable in order to manage the clock filter and reach register.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各協会は、構築し、対称、クライアントにパケットを送信し、サーバーの関連付けを放送するために定期的に実行されるポーリングプロセスをサポートしています。これは、サーバがクロックフィルタを管理し、登録に到達するために到達可能であるかどうかにかかわらず、継続的に実行されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Poll Process Variables
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1。ポーリングプロセス変数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 29 summarizes the common names, formula names, and a short description of the poll process variables (lowercase) and parameters (uppercase). Unless noted otherwise, all variables have assumed prefix p.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図29は、一般名、式名、ポーリングプロセス変数（小文字）およびパラメータ（大文字）の簡単な説明をまとめたものです。特に断りのない限り、すべての変数は、接頭辞pを想定しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   +---------+---------+--------------------+
                   | Name    | Formula | Description        |
                   +---------+---------+--------------------+
                   | hpoll   | hpoll   | host poll exponent |
                   | last    | last    | last poll time     |
                   | next    | next    | next poll time     |
                   | reach   | reach   | reach register     |
                   | unreach | unreach | unreach counter    |
                   | UNREACH | 24      | unreach limit      |
                   | BCOUNT  | 8       | burst count        |
                   | BURST   | flag    | burst enable       |
                   | IBURST  | flag    | iburst enable      |
                   +---------+---------+--------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 29: Poll Process Variables and Parameters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図29：投票プロセス変数とパラメータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The poll process variables are allocated in the association data structure along with the peer process variables. The following is a detailed description of the variables. The parameters will be called out in the following text.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポーリングプロセス変数は、ピアプロセス変数とともに関連データ構造に割り当てられています。以下は、変数の詳細な説明です。パラメータは、次のテキストで呼び出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
hpoll: signed integer representing the poll exponent, in log2 seconds
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
hpoll：LOG2秒でポーリング指数を表す符号付き整数、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
last: integer representing the seconds counter when the most recent packet was sent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後：最新のパケットが送信されたとき、秒カウンタを表す整数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
next: integer representing the seconds counter when the next packet is to be sent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次：次のパケットが送信されるとき、秒カウンタを表す整数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
reach: 8-bit integer shift register shared by the peer and poll processes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
到達：8ビット整数シフトピアによって共有レジスタと投票プロセスを
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
unreach: integer representing the number of seconds the server has been unreachable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNREACH：秒数を表す整数でサーバが到達不能になっています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Poll Process Operations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2。ポーリングプロセス操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described previously, once each second the clock-adjust process is called. This routine calls the poll routine for each association in turn. If the time for the next poll message is greater than the seconds counter, the routine returns immediately. Symmetric (modes 1, 2), client (mode 3), and broadcast server (mode 5) associations routinely send packets. A broadcast client (mode 6) association runs the routine to update the reach and unreach variables, but does not send packets. The poll process calls the transmit process to send a packet. If in a burst (burst &gt; 0), nothing further is done except call the poll update routine to set the next poll interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前述のように、一旦各第2のクロック・調整処理が呼び出されます。このルーチンは、順番に各組合のポーリングルーチンを呼び出します。次のポーリングメッセージの時間は、秒カウンタ、すぐにリターンするよりも大きい場合。対称（モード1、2）、クライアント（モード3）、およびブロードキャストサーバ（モード5）協会が定期パケットを送信します。ブロードキャストクライアント（モード6）の関連はリーチとUNREACH変数を更新するためのルーチンを実行しますが、パケットを送信しません。ポーリングプロセスは、パケットを送信するための送信プロセスを呼び出します。 （&gt; 0バースト）バーストで、何もさらに次のポーリング間隔を設定するには、ポーリング更新ルーチンを呼び出すことを除いて行われていない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If not in a burst, the reach variable is shifted left by one bit, with zero replacing the rightmost bit. If the server has not been heard for the last three poll intervals, the clock filter routine is called to increase the dispersion. An example is shown in Appendix A.5.7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バーストでない場合、リーチ変数はゼロ右端のビットを交換すると、1ビット左シフトされます。サーバーは、最後の三つのポーリング間隔のために聞かれていない場合は、クロック・フィルタ・ルーチンは、分散性を向上させるために呼び出されます。例は、付録A.5.7.3に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the BURST flag is lit and the server is reachable and a valid source of synchronization is available, the client sends a burst of BCOUNT (8) packets at each poll interval. The interval between packets in the burst is two seconds. This is useful to accurately measure jitter with long poll intervals. If the IBURST flag is lit and this is the first packet sent when the server has been unreachable, the client sends a burst. This is useful to quickly reduce the synchronization distance below the distance threshold and synchronize the clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
BURSTフラグが点灯し、サーバが到達可能であり、同期の有効なソースが利用可能である場合、クライアントは各ポーリング間隔でBCOUNT（8）パケットのバーストを送信します。バースト内のパケット間の間隔は2秒です。これは、正確に長いポーリング間隔でジッタを測定するのに便利です。 IBURSTフラグが点灯し、これは、サーバが到達不能になっていたときに送信された最初のパケットである場合、クライアントは、バーストを送信します。これはすぐに距離閾値以下の同期距離を短くし、クロックを同期させることに有用です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the P_MANY flag is lit in the p.flags word of the association, this is a manycast client association. Manycast client associations send client mode packets to designated multicast group addresses at MINPOLL intervals. The association starts out with a TTL of 1. If by the time of the next poll there are fewer than MINCLOCK servers have been mobilized, the ttl is increased by one. If the ttl reaches the limit TTLMAX, without finding MINCLOCK servers, the poll interval increases until reaching BEACON, when it starts over from the beginning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
P_MANYフラグが協会のp.flagsワードに点灯している場合、これはメニーキャストクライアントのアソシエーションです。メニーキャストクライアントのアソシエーションはのminpoll間隔で指定されたマルチキャストグループアドレスにクライアントモードのパケットを送信します。協会が動員されているMINCLOCKサーバよりも少ない場合、次のポーリングの時間によって1のTTLで始まり、TTLは1ずつ増加されます。 TTLは、それは最初から開始したときに、BEACONに到達するまでMINCLOCKサーバー、ポーリング間隔の増加を見つけることなく、制限TTLMAXに達した場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The poll() routine includes a feature that backs off the poll interval if the server becomes unreachable. If reach is nonzero, the server is reachable and unreach is set to zero; otherwise, unreach is incremented by one for each poll to the maximum UNREACH. Thereafter for each poll hpoll is increased by one, which doubles the poll interval up to the maximum MAXPOLL determined by the poll_update() routine. When the server again becomes reachable, unreach is set to zero, hpoll is reset to the tc system variable, and operation resumes normally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
世論調査（）ルーチンは、サーバが到達不能になった場合にポーリング間隔をバックオフ機能が含まれています。リーチはゼロでない場合、サーバが到達可能であるとUNREACHはゼロに設定されています。そうでない場合、UNREACH最大UNREACH各ポーリングのために1だけインクリメントされます。その後、各ポーリングhpollためpoll_update（）ルーチンによって決定される最大MAXPOLLまでポーリング間隔を倍増れ、1だけ増加されます。サーバが再び到達可能になったとき、UNREACHがゼロに設定され、hpollはTCシステム変数にリセットされ、動作が正常に再開されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A packet is sent by the transmit process. Some header values are copied from the peer variables left by a previous packet and others from the system variables. Figure 30 shows which values are copied to each header field. In those implementations, using floating double data types for root delay and root dispersion, these must be converted to NTP short format. All other fields are either copied intact from peer and system variables or struck as a timestamp from the system clock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
パケットは、送信工程によって送信されます。いくつかのヘッダの値は、システム変数からの前のパケットと他の人が左ピア変数からコピーされます。値は各ヘッダフィールドにコピーされている図30を図。これらの実装では、ルート遅延、ルート分散をフローティングダブルデータタイプを使用して、これらは、NTP短い形式に変換されなければなりません。他のすべてのフィールドには、いずれかのピアとシステム変数からそのままコピーしたり、システムクロックからのタイムスタンプとして打たれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   +-----------------------------------+
                   | Packet Variable &lt;--   Variable    |
                   +-----------------------------------+
                   | x.leap        &lt;--     s.leap      |
                   | x.version     &lt;--     s.version   |
                   | x.mode        &lt;--     s.mode      |
                   | x.stratum     &lt;--     s.stratum   |
                   | x.poll        &lt;--     s.poll      |
                   | x.precision   &lt;--     s.precision |
                   | x.rootdelay   &lt;--     s.rootdelay |
                   | x.rootdisp    &lt;--     s.rootdisp  |
                   | x.refid       &lt;--     s.refid     |
                   | x.reftime     &lt;--     s.reftime   |
                   | x.org         &lt;--     p.xmt       |
                   | x.rec         &lt;--     p.dst       |
                   | x.xmt         &lt;--     clock       |
                   | x.keyid       &lt;--     p.keyid     |
                   | x.digest      &lt;--     md5 digest  |
                   +-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 30: xmit_packet Packet Header
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図30：xmit_packetパケットヘッダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The poll update routine is called when a valid packet is received and immediately after a poll message has been sent. If in a burst, the poll interval is fixed at 2 s; otherwise, the host poll exponent hpoll is set to the minimum of ppoll from the last packet received and hpoll from the poll routine, but not less than MINPOLL or greater than MAXPOLL. Thus, the clock discipline can be oversampled but not undersampled. This is necessary to preserve subnet dynamic behavior and protect against protocol errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
有効なパケットを受信すると、ポーリングメッセージが送信された直後際ポーリング更新ルーチンが呼び出されます。バーストであれば、ポーリング間隔は2秒に固定されます。最後のパケットが受信され、ポーリングルーチンからhpollが、MAXPOLL以上のminpoll未満以上​​からそうでない場合は、ホストのポーリング指数hpollはPPOLLの最小値に設定されています。このように、クロックの規律は、オーバーサンプリングされたが、アンダーませんすることができます。これは、サブネット動的挙動を維持し、プロトコル・エラーから保護する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The poll exponent is converted to an interval, which, when added to the last poll time variable, determines the value of the next poll time variable. Finally, the last poll time variable is set to the current seconds counter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポーリング指数が最後のポーリング時間変数に加え、間隔、に変換され、次のポーリング時間変数の値を決定します。最後に、最後のポーリング時間変数は、現在の秒カウンタに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Simple Network Time Protocol (SNTP)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.簡易ネットワークタイムプロトコル（SNTP）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Primary servers and clients complying with a subset of NTP, called the Simple Network Time Protocol (SNTPv4) [RFC4330], do not need to implement the mitigation algorithms described in Section 9 and following sections. SNTP is intended for primary servers equipped with a single reference clock, as well as for clients with a single upstream server and no dependent clients. The fully developed NTPv4 implementation is intended for secondary servers with multiple upstream servers and multiple downstream servers or clients. Other than these considerations, NTP and SNTP servers and clients are completely interoperable and can be intermixed in NTP subnets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPのサブセットに準拠プライマリサーバーとクライアントは、簡易ネットワークタイムプロトコル（SNTPv4）[RFC4330]を呼ばれ、セクション9と、次のセクションで説明緩和アルゴリズムを実装する必要はありません。 SNTPは、単一の基準クロックを搭載したプライマリサーバのための、ならびに単一のアップストリームサーバーおよび無依存型クライアントとクライアントのために意図されます。完全に開発NTPv4の実装は、複数のアップストリームサーバーと複数のダウンストリームサーバーまたはクライアントとセカンダリサーバを対象としています。これらの考慮事項以外に、NTPとSNTPサーバとクライアントは、完全に相互運用可能であり、NTPサブネットに混在することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An SNTP primary server implementing the on-wire protocol described in Section 8 has no upstream servers except a single reference clock. In principle, it is indistinguishable from an NTP primary server that has the mitigation algorithms and therefore capable of mitigating between multiple reference clocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション8に記載のオンワイヤプロトコルを実装SNTPプライマリサーバは、単一の基準クロック以外に、上流のサーバを有していません。原理的には、複数の基準クロックとの間に緩和することができる、従って緩和アルゴリズムとを有するNTPプライマリサーバと区別がつきません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon receiving a client request, an SNTP primary server constructs and sends the reply packet as described in Figure 31. Note that the dispersion field in the packet header must be updated as described in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアント要求を受信すると、SNTPプライマリサーバ構築及び図31（注）に記載されるように第5節で説明したように、パケットヘッダ内の分散フィールドが更新されなければならないことを応答パケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                   +-----------------------------------+
                   | Packet Variable &lt;--   Variable    |
                   +-----------------------------------+
                   | x.leap        &lt;--     s.leap      |
                   | x.version     &lt;--     r.version   |
                   | x.mode        &lt;--     4           |
                   | x.stratum     &lt;--     s.stratum   |
                   | x.poll        &lt;--     r.poll      |
                   | x.precision   &lt;--     s.precision |
                   | x.rootdelay   &lt;--     s.rootdelay |
                   | x.rootdisp    &lt;--     s.rootdisp  |
                   | x.refid       &lt;--     s.refid     |
                   | x.reftime     &lt;--     s.reftime   |
                   | x.org         &lt;--     r.xmt       |
                   | x.rec         &lt;--     r.dst       |
                   | x.xmt         &lt;--     clock       |
                   | x.keyid       &lt;--     r.keyid     |
                   | x.digest      &lt;--     md5 digest  |
                   +-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 31: fast_xmit Packet Header
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図31：fast_xmitパケットヘッダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An SNTP client implementing the on-wire protocol has a single server and no dependent clients. It can operate with any subset of the NTP on-wire protocol, the simplest approach using only the transmit timestamp of the server packet and ignoring all other fields. However, the additional complexity to implement the full on-wire protocol is minimal so that a full implementation is encouraged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上のワイヤプロトコルを実装SNTPクライアントは、単一のサーバと無依存型クライアントを持っています。これは、NTP上のワイヤプロトコル、サーバのパケットのみ送信タイムスタンプを使用して、他のすべてのフィールドを無視する最も簡単な方法の任意のサブセットで動作することができます。完全な実装を奨励するようしかし、完全にワイヤプロトコルを実装するために追加の複雑さは最小です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP security requirements are even more stringent than most other distributed services. First, the operation of the authentication mechanism and the time synchronization mechanism are inextricably intertwined. Reliable time synchronization requires cryptographic keys that are valid only over a designated time interval; but, time intervals can be enforced only when participating servers and clients are reliably synchronized to UTC. In addition, the NTP subnet is hierarchical by nature, so time and trust flow from the primary servers at the root through secondary servers to the clients at the leaves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPのセキュリティ要件は、さらに厳しい他のほとんどの分散サービスよりも。まず、認証機構との時刻同期機構の動作が密接に絡み合っています。信頼性の高い時刻同期は、指定された時間間隔で有効な暗号鍵​​が必要です。しかし、時間間隔は、参加サーバとクライアントが確実にUTCに同期しているときにのみ適用できます。また、NTPサブネットは、本質的に階層的であるため、葉のクライアントへのセカンダリサーバ経由ルートに、プライマリサーバからの時間と信頼流れ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An NTP client can claim to have authentic time to dependent applications only if all servers on the path to the primary servers are authenticated. In NTP each server authenticates the next lower stratum servers and authenticates by induction the lowest stratum (primary) servers. It is important to note that authentication in the context of NTP does not necessarily imply the time is correct. An NTP client mobilizes a number of concurrent associations with different servers and uses a crafted agreement algorithm to pluck truechimers from the population possibly including falsetickers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPクライアントは、プライマリサーバへのパス上のすべてのサーバーが認証されている場合にのみ依存するアプリケーションへの本格的な時間を持っていると主張することができます。 NTPでは、各サーバーは、次の下位階層サーバを認証し、誘導により最低の地層（プライマリ）サーバを認証します。 NTPの文脈では、認証が必ずしも時刻が正しい意味するものではありません注意することが重要です。 NTPクライアントは異なるサーバで同時アソシエーション数を動員し、おそらくfalsetickersを含む集団からtruechimersを摘み取るために細工された合意アルゴリズムを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NTP specification assumes that the goal of the intruder is to inject false time values, disrupt the protocol, or clog the network, servers, or clients with spurious packets that exhaust resources and deny service to legitimate applications. There are a number of defense mechanisms already built in the NTP architecture, protocol, and algorithms. The on-wire timestamp exchange scheme is inherently resistant to spoofing, packet-loss, and replay attacks. The engineered clock filter, selection and clustering algorithms are designed to defend against evil cliques of Byzantine traitors. While not necessarily designed to defeat determined intruders, these algorithms and accompanying sanity checks have functioned well over the years to deflect improperly operating but presumably friendly scenarios. However, these mechanisms do not securely identify and authenticate servers to clients. Without specific further protection, an intruder can inject any or all of the following attacks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTP仕様は、侵入者の目的は、虚偽の時間値を注入プロトコルを妨害する、または排気リソーススプリアスパケットをネットワーク、サーバ、またはクライアントを詰まらせ、正当なアプリケーションにサービスを拒否していることを前提としています。すでにNTPアーキテクチャ、プロトコル、およびアルゴリズムに組み込まれた防御機構の数があります。上の線のタイムスタンプ交換方式はスプーフィング、パケット損失、およびリプレイ攻撃に対して本質的に耐性があります。エンジニアリングクロックフィルタ、選択とクラスタリングアルゴリズムはビザンチン裏切り者の悪クリークを防御するために設計されています。必ずしも決定した侵入者を倒すために設計されていないが、これらのアルゴリズムおよび添付の健全性チェックが正しく動作しますが、おそらく友好的なシナリオを偏向させるために長年にわたってうまく機能しています。しかし、これらのメカニズムは、しっかりと、クライアントにサーバーを識別し、認証しません。特定のさらなる保護がなければ、侵入者は、次の攻撃のいずれかまたは全てを注入することができます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. An intruder can intercept and archive packets forever, as well as all the public values ever generated and transmitted over the net.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.侵入者は、傍受したアーカイブパケット永遠に、だけでなく、すべての公共の値は、これまでに生成され、ネット上で送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. An intruder can generate packets faster than the server, network or client can process them, especially if they require expensive cryptographic computations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2.侵入者は、彼らは高価な暗号計算が必要な場合は特に、ネットワークまたはクライアントがそれらを処理することができ、より高速なサーバー以外のパケットを生成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. In a wiretap attack, the intruder can intercept, modify, and replay a packet. However, it cannot permanently prevent onward transmission of the original packet; that is, it cannot break the wire, only tell lies and congest it. Generally, the modified packet cannot arrive at the victim before the original packet, nor does it have the server private keys or identity parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
盗聴攻撃で3、侵入者は、傍受、変更、およびパケットを再生することができます。しかし、それは永久以降、元のパケットの送信を防ぐことはできません。つまり、それはワイヤーを破ることができない、唯一の嘘を言うと、それを混雑。一般的に、変更されたパケットは、元のパケットの前に犠牲者に到着することができない、またそれは、サーバの秘密鍵またはIDパラメータを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. In a middleman or masquerade attack, the intruder is positioned between the server and client, so it can intercept, modify and replay a packet and prevent onward transmission of the original packet. However, the middleman does not have the server private keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは、傍受変更し、パケットを再生し、元のパケットの以降の送信を防止することができるように仲介4.又は攻撃をマスカレードは、侵入者は、サーバとクライアントとの間に配置されます。しかし、仲介サーバ秘密鍵を持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NTP security model assumes the following possible limitations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NTPのセキュリティモデルは、以下の可能性の限界を前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1. The running times for public key algorithms are relatively long and highly variable. In general, the performance of the time synchronization function is badly degraded if these algorithms must be used for every NTP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1.公開鍵アルゴリズムの実行している時間が比較的長く、非常に可変です。これらのアルゴリズムは、すべてのNTPパケットのために使用されなければならない場合には、一般的には、時刻同期機能の性能がひどく劣化しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2. In some modes of operation, it is not feasible for a server to retain state variables for every client. It is however feasible to regenerated them for a client upon arrival of a packet from that client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サーバはすべてのクライアントのために状態変数を保持するための動作のいくつかのモード2.、それは現実的ではありません。そのクライアントからのパケットの到着時にクライアントのためにそれらを再生成することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3. The lifetime of cryptographic values must be enforced, which requires a reliable system clock. However, the sources that synchronize the system clock must be trusted. This circular interdependence of the timekeeping and authentication functions requires special handling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3.暗号値の寿命は、信頼性の高いシステム・クロックを必要とする、実施されなければなりません。しかし、システムクロックを同期させるソースが信頼されている必要があります。計時および認証機能のこの円形相互依存関係は、特別な処理が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4. Client security functions must involve only public values transmitted over the net. Private values must never be disclosed beyond the machine on which they were created, except in the case of a special trusted agent (TA) assigned for this purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.クライアントのセキュリティ機能は、ネットを介して送信のみ公開値を伴う必要があります。プライベートの値は、この目的のために割り当てられた特別な信頼できるエージェント（TA）の場合を除き、それらが作成されたマシンを超えて開示してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unlike the Secure Shell (SSH) security model, where the client must be securely authenticated to the server, in NTP the server must be securely authenticated to the client. In SSH, each different interface address can be bound to a different name, as returned by a reverse-DNS query. In this design, separate public/private key pairs may be required for each interface address with a distinct name. A perceived advantage of this design is that the security compartment can be different for each interface. This allows a firewall, for instance, to require some interfaces to authenticate the client and others not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
クライアントがサーバーにしっかりと認証されなければならないのSecure Shell（SSH）セキュリティモデルとは異なり、NTPにサーバが安全にクライアントに認証される必要があります。逆DNSクエリによって返されるSSHでは、それぞれ異なるインターフェイスアドレスは、別の名前にバインドすることができます。この設計では、独立した公開鍵/秘密鍵のペアは、異なる名前を持つ各インターフェイスアドレスが必要な場合があります。この設計の知覚される利点は、セキュリティ区画は各インターフェイスのために異なることができることです。これは、ファイアウォールが、例えば、クライアントではなく、他を認証するためにいくつかのインタフェースを必要とすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of NTP as specified herein, NTP broadcast clients are vulnerable to disruption by misbehaving or hostile SNTP or NTP broadcast servers elsewhere in the Internet. Such disruption can be minimized by several approaches. Filtering can be employed to limit the access of NTP clients to known or trusted NTP broadcast servers. Such filtering will prevent malicious traffic from reaching the NTP clients. Cryptographic authentication at the client will only allow timing information from properly signed NTP messages to be utilized in synchronizing its clock. Higher levels of authentication may be gained by the use of the Autokey mechanism [RFC5906].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここ指定されているNTPの場合は、NTPブロードキャストクライアントは、他の場所で、インターネットでのSNTPまたはNTPブロードキャストサーバをふらちな事か、敵対的なことで混乱に対して脆弱です。このような混乱は、いくつかのアプローチによって最小限に抑えることができます。フィルタリングは、既知または信頼できるNTPブロードキャストサーバへのNTPクライアントのアクセスを制限するために使用することができます。このようなフィルタリングは、NTPクライアントに到達する悪意のあるトラフィックを防ぐことができます。クライアントの暗号化認証はそのクロックを同期させる際に利用される適切に署名NTPメッセージからタイミング情報をできるようになります。認証の高いレベルは、オートキー機構[RFC5906]を使用することによって得ることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 8 describes a potential security concern with the replay of client requests. Following the recommendations in that section provides protection against such attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第8章では、クライアントの要求のリプレイとの潜在的なセキュリティ上の懸念を示しています。そのセクションの推奨事項に従うことで、このような攻撃に対する保護を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It should be noted that this specification is describing an existing implementation. While the security shortfalls of the MD5 algorithm are well-known, its use in the NTP specification is consistent with widescale deployment in the Internet community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この仕様は、既存の実装を記述していることに留意すべきです。 MD5アルゴリズムのセキュリティ不足がよく知られているが、NTPの仕様での使用は、インターネットコミュニティでwidescale展開と一致しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
UDP/TCP Port 123 was previously assigned by IANA for this protocol. The IANA has assigned the IPv4 multicast group address 224.0.1.1 and the IPv6 multicast address ending :101 for NTP. This document introduces NTP extension fields allowing for the development of future extensions to the protocol, where a particular extension is to be identified by the Field Type sub-field within the extension field. IANA has established and will maintain a registry for Extension Field Types associated with this protocol, populating this registry with no initial entries. As future needs arise, new Extension Field Types may be defined. Following the policies outlined in [RFC5226], new values are to be defined by IETF Review.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UDP / TCPポート123は、以前、このプロトコルのためにIANAによって割り当てられました。 NTPのために101：IANAは、IPv4マルチキャストグループアドレス224.0.1.1と終了IPv6マルチキャストアドレスが割り当てられています。この文書は、特定の拡張は、拡張フィールド内のフィールドタイプサブフィールドによって識別されるプロトコルへの将来の拡張の開発を可能にするNTPの拡張フィールドを導入します。 IANAは確立しているといない初期のエントリでこのレジストリを移入、このプロトコルに関連した拡張フィールドタイプのレジストリを維持します。将来のニーズが発生したように、新しい拡張フィールドタイプを定義することができます。 [RFC5226]に概説された方針に続いて、新しい値はIETFレビューにより定義されることになっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IANA has created a new registry for NTP Reference Identifier codes. This includes the current codes defined in Section 7.3, and may be extended on a First-Come-First-Serve (FCFS) basis. The format of the registry is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、NTPリファレンス識別子コードのための新しいレジストリを作成しました。これはセクション7.3で定義されている現在のコードを含み、先着-ファーストサーブ（FCFS）に基づいて拡張されてもよいです。レジストリの形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     +------+----------------------------------------------------------+
     | ID   | Clock Source                                             |
     +------+----------------------------------------------------------+
     | GOES | Geosynchronous Orbit Environment Satellite               |
     | GPS  | Global Position System                                   |
     | ...  | ...                                                      |
     +------+----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 32: Reference Identifier Codes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図32：参照IDコード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IANA has created a new registry for NTP Kiss-o&#39;-Death codes. This includes the current codes defined in Section 7.4, and may be extended on a FCFS basis. The format of the registry is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IANAは、NTPキス-O&#39;-死のコードのための新しいレジストリを作成しました。これはセクション7.4で定義されている現在のコードを含む、とFCFSベースで拡張することができます。レジストリの形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------+------------------------------------------------------------+
   | Code |                           Meaning                          |
   +------+------------------------------------------------------------+
   | ACST | The association belongs to a unicast server.               |
   | AUTH | Server authentication failed.                              |
   | ...  | ...                                                        |
   +------+------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Figure 33: Kiss Codes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
図33：キス・コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For both Reference Identifiers and Kiss-o&#39;-Death codes, IANA is requested to never assign a code beginning with the character &#34;X&#34;, as this is reserved for experimentation and development.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、実験や開発のために予約されているように参照識別子とキス-O&#39;-死コードの両方のために、IANAは、文字「X」で始まるコードを割り当てることがないように要求されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The editors would like to thank Karen O&#39;Donoghue, Brian Haberman, Greg Dowd, Mark Elliot, Harlan Stenn, Yaakov Stein, Stewart Bryant, and Danny Mayer for technical reviews and specific text contributions to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
編集者は、技術的なレビューと、この文書に特定のテキストの貢献のためにカレンO&#39;Donoghue、ブライアンハーバーマン、グレッグ・ダウド、マーク・エリオット、ハーランStenn、Yaakovのスタイン、スチュワートブライアント、そしてダニー・メイヤーに感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0768] Postel, J., &#34;User Datagram Protocol&#34;, STD 6, RFC 768, August 1980.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0768]ポステル、J.、 &#34;ユーザ・データグラム・プロトコル&#34;、STD 6、RFC 768、1980年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0791] Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0791]ポステル、J.、 &#34;インターネットプロトコル&#34;、STD 5、RFC 791、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC0793]ポステル、J.、 &#34;伝送制御プロトコル&#34;、STD 7、RFC 793、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1321] Rivest, R., &#34;The MD5 Message-Digest Algorithm&#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1321]のRivest、R.、 &#34;MD5メッセージダイジェストアルゴリズム&#34;、RFC 1321、1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[CGPM] Bureau International des Poids et Mesures, &#34;Comptes Rendus de la 15e CGPM&#34;, 1976.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[GFCM]国際度量衡局、1976年「第15回GFCMのレンダリングアカウント」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ITU-R_TF.460] International Telecommunications Union, &#34;ITU-R TF.460 Standard-frequency and time-signal emissions&#34;, February 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ITU-R_TF.460]国際電気通信連合、 &#34;ITU-R TF.460標準周波数および時間信号の排出量&#34;、2002年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1305] Mills, D., &#34;Network Time Protocol (Version 3) Specification, Implementation and Analysis&#34;, RFC 1305, March 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1305]ミルズ、D.、 &#34;ネットワーク時間プロトコル（バージョン3）仕様、実装と分析&#34;、RFC 1305、1992年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1345] Simonsen, K., &#34;Character Mnemonics and Character Sets&#34;, RFC 1345, June 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC1345]シモンセン、K.、 &#34;文字ニーモニックと文字セット&#34;、RFC 1345、1992年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4330] Mills, D., &#34;Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI&#34;, RFC 4330, January 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC4330]ミルズ、D.、 &#34;IPv4、IPv6、およびOSIのため簡易ネットワークタイムプロトコル（SNTP）バージョン4&#34;、RFC 4330、2006年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5226] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5226] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 5226、2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5906] Haberman, B., Ed. and D. Mills, &#34;Network Time Protocol Version 4: Autokey Specification&#34;, RFC 5906, June 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RFC5906]ハーバーマン、B.、エド。そして、D.ミルズ、 &#34;ネットワークタイムプロトコルバージョン4：自動キー仕様&#34;、RFC 5906、2010年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ref6] Marzullo and S. Owicki, &#34;Maintaining the time in a distributed system&#34;, ACM Operating Systems Review 19, July 1985.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;分散システムにおける時刻の更新&#34; [ref6] Marzullo及びS. Owicki、ACMオペレーティングシステムレビュー19、1985年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ref7] Mills, D.L., &#34;Computer Network Time Synchronization - the Network Time Protocol&#34;, CRC Press, 304 pp, 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ref7]ミルズ、D.L.、 &#34;コンピュータネットワーク時刻同期 - ネットワークタイムプロトコル&#34;、CRCプレス、304頁、2006年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ref9] Mills, D.L., Electrical and Computer Engineering Technical Report 06-6-1, NDSS, June 2006, &#34;Network Time Protocol Version 4 Reference and Implementation Guide&#34;, 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ref9]ミルズ、D.L.、電気およびコンピュータ工学技術報告書06-6-1、NDSS、2006年6月、「ネットワークタイムプロトコルバージョン4リファレンスと実装ガイド」、2006。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. Code Skeleton
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A.コードスケルトン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix is intended to describe the protocol and algorithms of an implementation in a general way using what is called a code skeleton program. This consists of a set of definitions, structures, and code fragments that illustrate the protocol operations without the complexities of an actual implementation of the protocol. This program is not an executable and is not designed to run in the ordinary sense.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録では、コードスケルトンプログラムと呼ばれるものを使用して、一般的な方法で実装のプロトコルとアルゴリズムを記述することを意図しています。これは、定義、構造、及びプロトコルの実際の実装の複雑させずにプロトコル動作を示すコードフラグメントの集合から成ります。このプログラムは、実行可能ではなく、通常の意味で実行するように設計されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Most of the features of the reference implementation are included here, with the following exceptions: there are no provisions for reference clocks or public key (Autokey) cryptography. There is no huff-n&#39;-puff filter, anti-clockhop hysteresis, or monitoring provisions. Many of the values that can be tinkered in the reference implementation are assumed constants here. There are only minimal provisions for the kiss-o&#39;-death packet and no responding code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リファレンス実装の機能のほとんどは、次の例外を除いて、ここに含まれています：基準クロックまたは公開キー（自動キー）暗号についての規定はありません。何ムッ-N&#39;-パフフィルタ、アンチclockhopヒステリシス、またはモニタリングの規定はありません。リファレンス実装でティンカー製のできる値の多くは、ここで定数を想定しています。キス-O&#39;-死パケットと無応答コードのための最小限の規定があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The program is not intended to be fast or compact, just to demonstrate the algorithms with sufficient fidelity to understand how they work. The code skeleton consists of eight segments, a header segment included by each of the other segments, plus a code segment for the main program, kernel I/O and system clock interfaces, and peer, system, clock_adjust, and poll processes. These are presented in order below along with definitions and variables specific to each process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プログラムは、高速またはコンパクトにちょうど彼らがどのように機能するかを理解するために十分な忠実度でアルゴリズムを証明するものではありません。コードスケルトンは、8つのセグメント、他のセグメントの各々によって含まれるヘッダセグメント、プラスメインプログラム、カーネルI / Oとシステムクロックインタフェース、及びピア、システム、clock_adjust、及びポーリング処理のためのコード・セグメントから成ります。これらは、以下の各プロセスに固有の定義と変数と一緒に順に提示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1. Global Definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1。グローバル定義
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.1. Definitions, Constants, Parameters
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.1。定義、定数、パラメータ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#include &lt;math.h&gt;               /* avoids complaints about sqrt() */
#include &lt;sys/time.h&gt;           /* for gettimeofday() and friends */
#include &lt;stdlib.h&gt;             /* for malloc() and friends */
#include &lt;string.h&gt;             /* for memset() */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Data types
 *
 * This program assumes the int data type is 32 bits and the long data
 * type is 64 bits.  The native data type used in most calculations is
 * floating double.  The data types used in some packet header fields
 * require conversion to and from this representation.  Some header
 * fields involve partitioning an octet, here represented by individual
 * octets.
 *
 * The 64-bit NTP timestamp format used in timestamp calculations is
 * unsigned seconds and fraction with the decimal point to the left of
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 * bit 32.  The only operation permitted with these values is
 * subtraction, yielding a signed 31-bit difference.  The 32-bit NTP
 * short format used in delay and dispersion calculations is seconds and
 * fraction with the decimal point to the left of bit 16.  The only
 * operations permitted with these values are addition and
 * multiplication by a constant.
 *
 * The IPv4 address is 32 bits, while the IPv6 address is 128 bits.  The
 * message digest field is 128 bits as constructed by the MD5 algorithm.
 * The precision and poll interval fields are signed log2 seconds.
 */
typedef unsigned long long tstamp;   /* NTP timestamp format */
typedef unsigned int tdist;     /* NTP short format */
typedef unsigned long ipaddr;   /* IPv4 or IPv6 address */
typedef unsigned long digest;   /* md5 digest */
typedef signed char s_char;     /* precision and poll interval (log2) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Timestamp conversion macroni
 */
#define FRIC        65536.                  /* 2^16 as a double */
#define D2FP(r)     ((tdist)((r) * FRIC))   /* NTP short */
#define FP2D(r)     ((double)(r) / FRIC)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define FRAC       4294967296.             /* 2^32 as a double */
#define D2LFP(a)   ((tstamp)((a) * FRAC))  /* NTP timestamp */
#define LFP2D(a)   ((double)(a) / FRAC)
#define U2LFP(a)   (((unsigned long long) \
                       ((a).tv_sec + JAN_1970) &lt;&lt; 32) + \
                       (unsigned long long) \
                       ((a).tv_usec / 1e6 * FRAC))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Arithmetic conversions
 */
#define LOG2D(a)        ((a) &lt; 0 ? 1. / (1L &lt;&lt; -(a)) : \
                            1L &lt;&lt; (a))          /* poll, etc. */
#define SQUARE(x)       (x * x)
#define SQRT(x)         (sqrt(x))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Global constants.  Some of these might be converted to variables
 * that can be tinkered by configuration or computed on-the-fly.  For
 * instance, the reference implementation computes PRECISION on-the-fly
 * and provides performance tuning for the defines marked with % below.
 */
#define VERSION         4       /* version number */
#define MINDISP         .01     /* % minimum dispersion (s) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define MAXDISP         16      /* maximum dispersion (s) */
#define MAXDIST         1       /* % distance threshold (s) */
#define NOSYNC          0x3     /* leap unsync */
#define MAXSTRAT        16      /* maximum stratum (infinity metric) */
#define MINPOLL         6       /* % minimum poll interval (64 s)*/
#define MAXPOLL         17      /* % maximum poll interval (36.4 h) */
#define MINCLOCK        3       /* minimum manycast survivors */
#define MAXCLOCK        10      /* maximum manycast candidates */
#define TTLMAX          8       /* max ttl manycast */
#define BEACON          15      /* max interval between beacons */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
#define PHI             15e-6   /* % frequency tolerance (15 ppm) */
#define NSTAGE          8       /* clock register stages */
#define NMAX            50      /* maximum number of peers */
#define NSANE           1       /* % minimum intersection survivors */
#define NMIN            3       /* % minimum cluster survivors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Global return values
 */
#define TRUE            1       /* boolean true */
#define FALSE           0       /* boolean false */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Local clock process return codes
 */
#define IGNORE          0       /* ignore */
#define SLEW            1       /* slew adjustment */
#define STEP            2       /* step adjustment */
#define PANIC           3       /* panic - no adjustment */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * System flags
 */
#define S_FLAGS         0       /* any system flags */
#define S_BCSTENAB      0x1     /* enable broadcast client */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Peer flags
 */
#define P_FLAGS         0       /* any peer flags */
#define P_EPHEM         0x01    /* association is ephemeral */
#define P_BURST         0x02    /* burst enable */
#define P_IBURST        0x04    /* intial burst enable */
#define P_NOTRUST       0x08    /* authenticated access */
#define P_NOPEER        0x10    /* authenticated mobilization */
#define P_MANY          0x20    /* manycast client */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Authentication codes
 */
#define A_NONE          0       /* no authentication */
#define A_OK            1       /* authentication OK */
#define A_ERROR         2       /* authentication error */
#define A_CRYPTO        3       /* crypto-NAK */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Association state codes
 */
#define X_INIT          0       /* initialization */
#define X_STALE         1       /* timeout */
#define X_STEP          2       /* time step */
#define X_ERROR         3       /* authentication error */
#define X_CRYPTO        4       /* crypto-NAK received */
#define X_NKEY          5       /* untrusted key */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Protocol mode definitions
 */
#define M_RSVD          0       /* reserved */
#define M_SACT          1       /* symmetric active */
#define M_PASV          2       /* symmetric passive */
#define M_CLNT          3       /* client */
#define M_SERV          4       /* server */
#define M_BCST          5       /* broadcast server */
#define M_BCLN          6       /* broadcast client */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Clock state definitions
 */
#define NSET            0       /* clock never set */
#define FSET            1       /* frequency set from file */
#define SPIK            2       /* spike detected */
#define FREQ            3       /* frequency mode */
#define SYNC            4       /* clock synchronized */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define min(a, b) ((a) &lt; (b) ? (a) : (b)) #define max(a, b) ((a) &lt; (b) ? (b) : (a))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
#define分（A、B）（（A）&lt;（B）（A）：（B））の#define MAX（A、B）（（A）&lt;（B）（B）：（A））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.2. Packet Data Structures
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.2。パケットデータ構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * The receive and transmit packets may contain an optional message
 * authentication code (MAC) consisting of a key identifier (keyid) and
 * message digest (mac in the receive structure and dgst in the transmit
 * structure).  NTPv4 supports optional extension fields that
 * are inserted after the header and before the MAC, but these are
 * not described here.
 *
 * Receive packet
 *
 * Note the dst timestamp is not part of the packet itself.  It is
 * captured upon arrival and returned in the receive buffer along with
 * the buffer length and data.  Note that some of the char fields are
 * packed in the actual header, but the details are omitted here.
 */
struct r {
        ipaddr  srcaddr;        /* source (remote) address */
        ipaddr  dstaddr;        /* destination (local) address */
        char    version;        /* version number */
        char    leap;           /* leap indicator */
        char    mode;           /* mode */
        char    stratum;        /* stratum */
        char    poll;           /* poll interval */
        s_char  precision;      /* precision */
        tdist   rootdelay;      /* root delay */
        tdist   rootdisp;       /* root dispersion */
        char    refid;          /* reference ID */
        tstamp  reftime;        /* reference time */
        tstamp  org;            /* origin timestamp */
        tstamp  rec;            /* receive timestamp */
        tstamp  xmt;            /* transmit timestamp */
        int     keyid;          /* key ID */
        digest  mac;            /* message digest */
        tstamp  dst;            /* destination timestamp */
} r;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Transmit packet
 */
struct x {
        ipaddr  dstaddr;        /* source (local) address */
        ipaddr  srcaddr;        /* destination (remote) address */
        char    version;        /* version number */
        char    leap;           /* leap indicator */
        char    mode;           /* mode */
        char    stratum;        /* stratum */ char    poll;           /* poll interval */
        s_char  precision;      /* precision */
        tdist   rootdelay;      /* root delay */
        tdist   rootdisp;       /* root dispersion */
        char    refid;          /* reference ID */
        tstamp  reftime;        /* reference time */
        tstamp  org;            /* origin timestamp */
        tstamp  rec;            /* receive timestamp */
        tstamp  xmt;            /* transmit timestamp */
        int     keyid;          /* key ID */
        digest  dgst;           /* message digest */
} x;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.3. Association Data Structures
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.3。協会のデータ構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Filter stage structure.  Note the t member in this and other
    * structures refers to process time, not real time.  Process time
    * increments by one second for every elapsed second of real time.
    */
   struct f {
           tstamp  t;              /* update time */
           double  offset;         /* clock ofset */
           double  delay;          /* roundtrip delay */
           double  disp;           /* dispersion */
   } f;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Association structure.  This is shared between the peer process
    * and poll process.
    */
   struct p {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*
            * Variables set by configuration
            */
           ipaddr  srcaddr;        /* source (remote) address */
           ipaddr  dstaddr;        /* destination (local) address */
           char    version;        /* version number */
           char    hmode;          /* host mode */
           int     keyid;          /* key identifier */
           int     flags;          /* option flags */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*
            * Variables set by received packet
            */
           char    leap;           /* leap indicator */
           char    pmode;          /* peer mode */ char    stratum;        /* stratum */
           char    ppoll;          /* peer poll interval */
           double  rootdelay;      /* root delay */
           double  rootdisp;       /* root dispersion */
           char    refid;          /* reference ID */
           tstamp  reftime;        /* reference time */
   #define begin_clear org         /* beginning of clear area */
           tstamp  org;            /* originate timestamp */
           tstamp  rec;            /* receive timestamp */
           tstamp  xmt;            /* transmit timestamp */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*
            * Computed data
            */
           double  t;              /* update time */
           struct f f[NSTAGE];     /* clock filter */
           double  offset;         /* peer offset */
           double  delay;          /* peer delay */
           double  disp;           /* peer dispersion */
           double  jitter;         /* RMS jitter */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           /*
            * Poll process variables
            */
           char    hpoll;          /* host poll interval */
           int     burst;          /* burst counter */
           int     reach;          /* reach register */
           int     ttl;            /* ttl (manycast) */
   #define end_clear unreach       /* end of clear area */
           int     unreach;        /* unreach counter */
           int     outdate;        /* last poll time */
           int     nextdate;       /* next poll time */
   } p;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.4. System Data Structures
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.4。システムデータ構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Chime list.  This is used by the intersection algorithm.
    */
   struct m {                      /* m is for Marzullo */
           struct p *p;            /* peer structure pointer */
           int     type;           /* high +1, mid 0, low -1 */
           double  edge;           /* correctness interval edge */
   } m;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Survivor list.  This is used by the clustering algorithm.
    */
   struct v {
           struct p *p;            /* peer structure pointer */
           double  metric;         /* sort metric */
   } v;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * System structure
    */
   struct s {
           tstamp  t;              /* update time */
           char    leap;           /* leap indicator */
           char    stratum;        /* stratum */
           char    poll;           /* poll interval */
           char    precision;      /* precision */
           double  rootdelay;      /* root delay */
           double  rootdisp;       /* root dispersion */
           char    refid;          /* reference ID */
           tstamp  reftime;        /* reference time */
           struct m m[NMAX];       /* chime list */
           struct v v[NMAX];       /* survivor list */
           struct p *p;            /* association ID */
           double  offset;         /* combined offset */
           double  jitter;         /* combined jitter */
           int     flags;          /* option flags */
           int     n;              /* number of survivors */
   } s;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.5. Local Clock Data Structures
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.5。ローカルクロックデータ構造
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Local clock structure
    */
   struct c {
           tstamp  t;              /* update time */
           int     state;          /* current state */
           double  offset;         /* current offset */
           double  last;           /* previous offset */
           int     count;          /* jiggle counter */
           double  freq;           /* frequency */
           double  jitter;         /* RMS jitter */
           double  wander;         /* RMS wander */
   } c;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.6. Function Prototypes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1.6。関数プロトタイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Peer process
   */
  void    receive(struct r *);    /* receive packet */
  void    packet(struct p *, struct r *); /* process packet */
  void    clock_filter(struct p *, double, double, double); /* filter */
  double  root_dist(struct p *);  /* calculate root distance */
  int     fit(struct p *);        /* determine fitness of server */
  void    clear(struct p *, int); /* clear association */
  int     access(struct r *);     /* determine access restrictions */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * System process
   */
  int     main();                 /* main program */
  void    clock_select();         /* find the best clocks */
  void    clock_update(struct p *); /* update the system clock */
  void    clock_combine();        /* combine the offsets */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Local clock process
   */
  int     local_clock(struct p *, double); /* clock discipline */
  void    rstclock(int, double, double); /* clock state transition */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Clock adjust process
   */
  void    clock_adjust();         /* one-second timer process */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Poll process
   */
  void    poll(struct p *);               /* poll process */
  void    poll_update(struct p *, int); /* update the poll interval */
  void    peer_xmit(struct p *);  /* transmit a packet */
  void    fast_xmit(struct r *, int, int); /* transmit a reply packet */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Utility routines
   */
  digest  md5(int);               /* generate a message digest */
  struct p *mobilize(ipaddr, ipaddr, int, int, int, int); /* mobilize */
  struct p *find_assoc(struct r *); /* search the association table */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * Kernel interface
   */
  struct r *recv_packet();        /* wait for packet */
  void    xmit_packet(struct x *); /* send packet */
  void    step_time(double);      /* step time */
  void    adjust_time(double);    /* adjust (slew) time */
  tstamp  get_time();             /* read time */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.2. Main Program and Utility Routines
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.2。メインプログラムとユーティリティルーチン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Definitions
 */
#define PRECISION       -18     /* precision (log2 s)  */
#define IPADDR          0       /* any IP address */
#define MODE            0       /* any NTP mode */
#define KEYID           0       /* any key identifier */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * main() - main program
 */
int
main()
{
        struct p *p;            /* peer structure pointer */
        struct r *r;            /* receive packet pointer */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Read command line options and initialize system variables.
         * The reference implementation measures the precision specific
         * to each machine by measuring the clock increments to read the
         * system clock.
         */
        memset(&amp;s, sizeof(s), 0);
        s.leap = NOSYNC;
        s.stratum = MAXSTRAT;
        s.poll = MINPOLL;
        s.precision = PRECISION;
        s.p = NULL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Initialize local clock variables
         */
        memset(&amp;c, sizeof(c), 0);
        if (/* frequency file */ 0) {
                c.freq = /* freq */ 0;
                rstclock(FSET, 0, 0);
        } else {
                rstclock(NSET, 0, 0);
        }
        c.jitter = LOG2D(s.precision);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Read the configuration file and mobilize persistent
         * associations with specified addresses, version, mode, key ID,
         * and flags.
         */
        while (/* mobilize configurated associations */ 0) {
                p = mobilize(IPADDR, IPADDR, VERSION, MODE, KEYID,
                    P_FLAGS);
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Start the system timer, which ticks once per second.  Then,
         * read packets as they arrive, strike receive timestamp, and
         * call the receive() routine.
         */
        while (0) {
                r = recv_packet();
                r-&gt;dst = get_time();
                receive(r);
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return(0); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リターン（0）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * mobilize() - mobilize and initialize an association
 */
struct p
*mobilize(
        ipaddr  srcaddr,        /* IP source address */
        ipaddr  dstaddr,        /* IP destination address */
        int     version,        /* version */
        int     mode,           /* host mode */
        int     keyid,          /* key identifier */
        int     flags           /* peer flags */
        )
{
        struct p *p;            /* peer process pointer */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Allocate and initialize association memory
         */
        p = malloc(sizeof(struct p));
        p-&gt;srcaddr = srcaddr;
        p-&gt;dstaddr = dstaddr;
        p-&gt;version = version;
        p-&gt;hmode = mode;
        p-&gt;keyid = keyid;
        p-&gt;hpoll = MINPOLL;
        clear(p, X_INIT);
        p-&gt;flags = flags;
        return (p);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * find_assoc() - find a matching association
 */
struct p                        /* peer structure pointer or NULL */
*find_assoc(
        struct r *r             /* receive packet pointer */
        )
{
        struct p *p;            /* dummy peer structure pointer */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Search association table for matching source
         * address, source port and mode.
         */
        while (/* all associations */ 0) {
                if (r-&gt;srcaddr == p-&gt;srcaddr &amp;&amp; r-&gt;mode == p-&gt;hmode)
                        return(p);
        } return (NULL);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * md5() - compute message digest
 */
digest
md5(
       int     keyid           /* key identifier */
       )
{
       /*
        * Compute a keyed cryptographic message digest.  The key
        * identifier is associated with a key in the local key cache.
        * The key is prepended to the packet header and extension fields
        * and the result hashed by the MD5 algorithm as described in
        * RFC 1321.  Return a MAC consisting of the 32-bit key ID
        * concatenated with the 128-bit digest.
        */
       return (/* MD5 digest */ 0);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.3. Kernel Input/Output Interface
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.3。カーネルの入力/出力インタフェース
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Kernel interface to transmit and receive packets.  Details are
    * deliberately vague and depend on the operating system.
    *
    * recv_packet - receive packet from network
    */
   struct r                        /* receive packet pointer*/
   *recv_packet() {
           return (/* receive packet r */ 0);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * xmit_packet - transmit packet to network
    */
   void
   xmit_packet(
           struct x *x             /* transmit packet pointer */
           )
   {
           /* send packet x */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4. Kernel System Clock Interface
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4。カーネルのシステムクロックインタフェース
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * System clock utility functions
 *
 * There are three time formats: native (Unix), NTP, and floating
 * double.  The get_time() routine returns the time in NTP long format.
 * The Unix routines expect arguments as a structure of two signed
 * 32-bit words in seconds and microseconds (timeval) or nanoseconds
 * (timespec).  The step_time() and adjust_time() routines expect signed
 * arguments in floating double.  The simplified code shown here is for
 * illustration only and has not been verified.
 */
#define JAN_1970        2208988800UL /* 1970 - 1900 in seconds */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * get_time - read system time and convert to NTP format
 */
tstamp
get_time()
{
        struct timeval unix_time;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * There are only two calls on this routine in the program.  One
         * when a packet arrives from the network and the other when a
         * packet is placed on the send queue.  Call the kernel time of
         * day routine (such as gettimeofday()) and convert to NTP
         * format.
         */
        gettimeofday(&amp;unix_time, NULL);
        return (U2LFP(unix_time));
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * step_time() - step system time to given offset value
 */
void
step_time(
        double  offset          /* clock offset */
        )
{
        struct timeval unix_time;
        tstamp  ntp_time;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Convert from double to native format (signed) and add to the
         * current time.  Note the addition is done in native format to
         * avoid overflow or loss of precision.
         */
        gettimeofday(&amp;unix_time, NULL);
        ntp_time = D2LFP(offset) + U2LFP(unix_time);
        unix_time.tv_sec = ntp_time &gt;&gt; 32;
        unix_time.tv_usec = (long)(((ntp_time - unix_time.tv_sec) &lt;&lt;
            32) / FRAC * 1e6);
        settimeofday(&amp;unix_time, NULL);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * adjust_time() - slew system clock to given offset value
 */
void
adjust_time(
        double  offset          /* clock offset */
        )
{
        struct timeval unix_time;
        tstamp  ntp_time;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Convert from double to native format (signed) and add to the
         * current time.
         */
        ntp_time = D2LFP(offset);
        unix_time.tv_sec = ntp_time &gt;&gt; 32;
        unix_time.tv_usec = (long)(((ntp_time - unix_time.tv_sec) &lt;&lt;
            32) / FRAC * 1e6);
        adjtime(&amp;unix_time, NULL);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5. Peer Process
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5。ピアプロセス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * A crypto-NAK packet includes the NTP header followed by a MAC
    * consisting only of the key identifier with value zero.  It tells
    * the receiver that a prior request could not be properly
    * authenticated, but the NTP header fields are correct.
    *
    * A kiss-o&#39;-death packet is an NTP header with leap 0x3 (NOSYNC) and
    * stratum 16 (MAXSTRAT).  It tells the receiver that something
    * drastic has happened, as revealed by the kiss code in the refid
    * field.  The NTP header fields may or may not be correct.
    */
   /*
    * Peer process parameters and constants
    */
   #define SGATE           3       /* spike gate (clock filter */
   #define BDELAY          .004    /* broadcast delay (s) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Dispatch codes
    */
   #define ERR             -1      /* error */
   #define DSCRD           0       /* discard packet */
   #define PROC            1       /* process packet */
   #define BCST            2       /* broadcast packet */
   #define FXMIT           3       /* client packet */
   #define MANY            4       /* manycast packet */
   #define NEWPS           5       /* new symmetric passive client */
   #define NEWBC           6       /* new broadcast client */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Dispatch matrix
    *              active  passv  client server bcast */
   int table[7][5] = {
   /* nopeer  */   { NEWPS, DSCRD, FXMIT, MANY, NEWBC },
   /* active  */   { PROC,  PROC,  DSCRD, DSCRD, DSCRD },
   /* passv   */   { PROC,  ERR,   DSCRD, DSCRD, DSCRD },
   /* client  */   { DSCRD, DSCRD, DSCRD, PROC,  DSCRD },
   /* server  */   { DSCRD, DSCRD, DSCRD, DSCRD, DSCRD },
   /* bcast   */   { DSCRD, DSCRD, DSCRD, DSCRD, DSCRD },
   /* bclient */   { DSCRD, DSCRD, DSCRD, DSCRD, PROC}
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Miscellaneous macroni
    *
    * This macro defines the authentication state.  If x is 0,
    * authentication is optional; otherwise, it is required.
    */
   #define AUTH(x, y)      ((x) ? (y) == A_OK : (y) == A_OK || \
                               (y) == A_NONE)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * These are used by the clear() routine
    */
   #define BEGIN_CLEAR(p)  ((char *)&amp;((p)-&gt;begin_clear))
   #define END_CLEAR(p)    ((char *)&amp;((p)-&gt;end_clear))
   #define LEN_CLEAR       (END_CLEAR((struct p *)0) - \
                               BEGIN_CLEAR((struct p *)0))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.1. receive()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.1。受信（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * receive() - receive packet and decode modes
 */
void
receive(
        struct r *r             /* receive packet pointer */
        )
{
        struct p *p;            /* peer structure pointer */
        int     auth;           /* authentication code */
        int     has_mac;        /* size of MAC */
        int     synch;          /* synchronized switch */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Check access control lists.  The intent here is to implement
         * a whitelist of those IP addresses specifically accepted
         * and/or a blacklist of those IP addresses specifically
         * rejected.  There could be different lists for authenticated
         * clients and unauthenticated clients.
         */
        if (!access(r))
                return;                 /* access denied */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * The version must not be in the future.  Format checks include
         * packet length, MAC length and extension field lengths, if
         * present.
         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        if (r-&gt;version &gt; VERSION /* or format error */)
                return;                 /* format error */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Authentication is conditioned by two switches that can be
         * specified on a per-client basis.
         *
         * P_NOPEER     do not mobilize an association unless
         *              authenticated.
         * P_NOTRUST    do not allow access unless authenticated
         *              (implies P_NOPEER).
         *
         * There are four outcomes:
         *
         * A_NONE       the packet has no MAC.
         * A_OK         the packet has a MAC and authentication
         *               succeeds.
         * A_ERROR      the packet has a MAC and authentication fails.
         * A_CRYPTO     crypto-NAK.  The MAC has four octets only.
         *
         * Note: The AUTH (x, y) macro is used to filter outcomes.  If x
         * is zero, acceptable outcomes of y are NONE and OK.  If x is
         * one, the only acceptable outcome of y is OK.
         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        has_mac = /* length of MAC field */ 0;
        if (has_mac == 0) {
                auth = A_NONE;          /* not required */
        } else if (has_mac == 4) {
                auth = A_CRYPTO;       /* crypto-NAK */
        } else {
                if (r-&gt;mac != md5(r-&gt;keyid))
                        auth = A_ERROR; /* auth error */
                else
                        auth = A_OK;    /* auth OK */
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Find association and dispatch code.  If there is no
         * association to match, the value of p-&gt;hmode is assumed NULL.
         */
        p = find_assoc(r);
        switch(table[(unsigned int)(p-&gt;hmode)][(unsigned int)(r-&gt;mode)])
        {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Client packet and no association.  Send server reply without
         * saving state.
         */
        case FXMIT:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * If unicast destination address, send server packet.
                 * If authentication fails, send a crypto-NAK packet.
                 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /* not multicast dstaddr */
                if (0) {
                        if (AUTH(p-&gt;flags &amp; P_NOTRUST, auth))
                                fast_xmit(r, M_SERV, auth);
                        else if (auth == A_ERROR)
                                fast_xmit(r, M_SERV, A_CRYPTO);
                        return;         /* M_SERV packet sent */
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * This must be manycast.  Do not respond if we are not
                 * synchronized or if our stratum is above the
                 * manycaster.
                 */
                if (s.leap == NOSYNC || s.stratum &gt; r-&gt;stratum)
                        return;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * Respond only if authentication is OK.  Note that the
                 * unicast address is used, not the multicast.
                 */
                if (AUTH(p-&gt;flags &amp; P_NOTRUST, auth))
                        fast_xmit(r, M_SERV, auth);
                return;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * New manycast client ephemeral association.  It is mobilized
         * in the same version as in the packet.  If authentication
         * fails, ignore the packet.  Verify the server packet by
         * comparing the r-&gt;org timestamp in the packet with the p-&gt;xmt
         * timestamp in the multicast client association.  If they
         * match, the server packet is authentic.  Details omitted.
         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        case MANY:
                if (!AUTH(p-&gt;flags &amp; (P_NOTRUST | P_NOPEER), auth))
                        return;         /* authentication error */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                p = mobilize(r-&gt;srcaddr, r-&gt;dstaddr, r-&gt;version, M_CLNT,
                    r-&gt;keyid, P_EPHEM);
                break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       /*
        * New symmetric passive association.  It is mobilized in the
        * same version as in the packet.  If authentication fails,
        * send a crypto-NAK packet.  If restrict no-moblize, send a
        * symmetric active packet instead.
        */
        case NEWPS:
                if (!AUTH(p-&gt;flags &amp; P_NOTRUST, auth)) {
                        if (auth == A_ERROR)
                                fast_xmit(r, M_SACT, A_CRYPTO);
                        return;         /* crypto-NAK packet sent */
                }
                if (!AUTH(p-&gt;flags &amp; P_NOPEER, auth)) {
                        fast_xmit(r, M_SACT, auth);
                        return;         /* M_SACT packet sent */
                }
                p = mobilize(r-&gt;srcaddr, r-&gt;dstaddr, r-&gt;version, M_PASV,
                    r-&gt;keyid, P_EPHEM);
                break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * New broadcast client association.  It is mobilized in the
         * same version as in the packet.  If authentication fails,
         * ignore the packet.  Note this code does not support the
         * initial volley feature in the reference implementation.
         */
        case NEWBC:
                if (!AUTH(p-&gt;flags &amp; (P_NOTRUST | P_NOPEER), auth))
                        return;         /* authentication error */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                if (!(s.flags &amp; S_BCSTENAB))
                        return;         /* broadcast not enabled */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                p = mobilize(r-&gt;srcaddr, r-&gt;dstaddr, r-&gt;version, M_BCLN,
                    r-&gt;keyid, P_EPHEM);
                break;                  /* processing continues */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Process packet.  Placeholdler only.
         */
        case PROC:
                break;                  /* processing continues */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Invalid mode combination.  We get here only in case of
         * ephemeral associations, so the correct action is simply to
         * toss it.
         */
        case ERR:
                clear(p, X_ERROR);
                return;                 /* invalid mode combination */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * No match; just discard the packet.
         */
        case DSCRD:
                return;                 /* orphan abandoned */
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Next comes a rigorous schedule of timestamp checking.  If the
         * transmit timestamp is zero, the server is horribly broken.
         */
        if (r-&gt;xmt == 0)
                return;                 /* invalid timestamp */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * If the transmit timestamp duplicates a previous one, the
         * packet is a replay.
         */
        if (r-&gt;xmt == p-&gt;xmt)
                return;                 /* duplicate packet */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * If this is a broadcast mode packet, skip further checking.
         * If the origin timestamp is zero, the sender has not yet heard
         * from us.  Otherwise, if the origin timestamp does not match
         * the transmit timestamp, the packet is bogus.
         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        synch = TRUE;
        if (r-&gt;mode != M_BCST) {
                if (r-&gt;org == 0)
                        synch = FALSE;  /* unsynchronized */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                else if (r-&gt;org != p-&gt;xmt)
                        synch = FALSE;  /* bogus packet */
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Update the origin and destination timestamps.  If
         * unsynchronized or bogus, abandon ship.
         */
        p-&gt;org = r-&gt;xmt;
        p-&gt;rec = r-&gt;dst;
        if (!synch)
                return;                 /* unsynch */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * The timestamps are valid and the receive packet matches the
         * last one sent.  If the packet is a crypto-NAK, the server
         * might have just changed keys.  We demobilize the association
         * and wait for better times.
         */
        if (auth == A_CRYPTO) {
                clear(p, X_CRYPTO);
                return;                 /* crypto-NAK */
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * If the association is authenticated, the key ID is nonzero
         * and received packets must be authenticated.  This is designed
         * to avoid a bait-and-switch attack, which was possible in past
         * versions.
         */
        if (!AUTH(p-&gt;keyid || (p-&gt;flags &amp; P_NOTRUST), auth))
                return;                 /* bad auth */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Everything possible has been done to validate the timestamps
         * and prevent bad guys from disrupting the protocol or
         * injecting bogus data.  Earn some revenue.
         */
        packet(p, r);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.1.1. packet()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.1.1。パケット（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * packet() - process packet and compute offset, delay, and
 * dispersion.
 */
void
packet(
        struct p *p,            /* peer structure pointer */
        struct r *r             /* receive packet pointer */
        )
{
        double  offset;         /* sample offsset */
        double  delay;          /* sample delay */
        double  disp;           /* sample dispersion */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * By golly the packet is valid.  Light up the remaining header
         * fields.  Note that we map stratum 0 (unspecified) to MAXSTRAT
         * to make stratum comparisons simpler and to provide a natural
         * interface for radio clock drivers that operate for
         *  convenience at stratum 0.
         */
        p-&gt;leap = r-&gt;leap;
        if (r-&gt;stratum == 0)
                p-&gt;stratum = MAXSTRAT;
        else
                p-&gt;stratum = r-&gt;stratum;
        p-&gt;pmode = r-&gt;mode;
        p-&gt;ppoll = r-&gt;poll;
        p-&gt;rootdelay = FP2D(r-&gt;rootdelay);
        p-&gt;rootdisp = FP2D(r-&gt;rootdisp);
        p-&gt;refid = r-&gt;refid;
        p-&gt;reftime = r-&gt;reftime;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Verify the server is synchronized with valid stratum and
         * reference time not later than the transmit time.
         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        if (p-&gt;leap == NOSYNC || p-&gt;stratum &gt;= MAXSTRAT)
                return;                 /* unsynchronized */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Verify valid root distance.
         */
        if (r-&gt;rootdelay / 2 + r-&gt;rootdisp &gt;= MAXDISP || p-&gt;reftime &gt;
            r-&gt;xmt)
                return;                 /* invalid header values */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        poll_update(p, p-&gt;hpoll);
        p-&gt;reach |= 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Calculate offset, delay and dispersion, then pass to the
         * clock filter.  Note carefully the implied processing.  The
         * first-order difference is done directly in 64-bit arithmetic,
         * then the result is converted to floating double.  All further
         * processing is in floating-double arithmetic with rounding
         * done by the hardware.  This is necessary in order to avoid
         * overflow and preserve precision.
         *
         * The delay calculation is a special case.  In cases where the
         * server and client clocks are running at different rates and
         * with very fast networks, the delay can appear negative.  In
         * order to avoid violating the Principle of Least Astonishment,
         * the delay is clamped not less than the system precision.
         */
        if (p-&gt;pmode == M_BCST) {
                offset = LFP2D(r-&gt;xmt - r-&gt;dst);
                delay = BDELAY;
                disp = LOG2D(r-&gt;precision) + LOG2D(s.precision) + PHI *
                    2 * BDELAY;
        } else {
                offset = (LFP2D(r-&gt;rec - r-&gt;org) + LFP2D(r-&gt;dst -
                    r-&gt;xmt)) / 2;
                delay = max(LFP2D(r-&gt;dst - r-&gt;org) - LFP2D(r-&gt;rec -
                    r-&gt;xmt), LOG2D(s.precision));
                disp = LOG2D(r-&gt;precision) + LOG2D(s.precision) + PHI *
                    LFP2D(r-&gt;dst - r-&gt;org);
        }
        clock_filter(p, offset, delay, disp);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.2. clock_filter()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.2。 clock_filter（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * clock_filter(p, offset, delay, dispersion) - select the best from the
 * latest eight delay/offset samples.
 */
void
clock_filter(
        struct p *p,            /* peer structure pointer */
        double  offset,         /* clock offset */
        double  delay,          /* roundtrip delay */
        double  disp            /* dispersion */
        )
{
        struct f f[NSTAGE];     /* sorted list */
        double  dtemp;
        int     i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * The clock filter contents consist of eight tuples (offset,
         * delay, dispersion, time).  Shift each tuple to the left,
         * discarding the leftmost one.  As each tuple is shifted,
         * increase the dispersion since the last filter update.  At the
         * same time, copy each tuple to a temporary list.  After this,
         * place the (offset, delay, disp, time) in the vacated
         * rightmost tuple.
         */
        for (i = 1; i &lt; NSTAGE; i++) {
                p-&gt;f[i] = p-&gt;f[i - 1];
                p-&gt;f[i].disp += PHI * (c.t - p-&gt;t);
                f[i] = p-&gt;f[i];
        }
        p-&gt;f[0].t = c.t;
        p-&gt;f[0].offset = offset;
        p-&gt;f[0].delay = delay;
        p-&gt;f[0].disp = disp;
        f[0] = p-&gt;f[0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Sort the temporary list of tuples by increasing f[].delay.
         * The first entry on the sorted list represents the best
         * sample, but it might be old.
         */
        dtemp = p-&gt;offset;
        p-&gt;offset = f[0].offset;
        p-&gt;delay = f[0].delay;
        for (i = 0; i &lt; NSTAGE; i++) {
                p-&gt;disp += f[i].disp / (2 ^ (i + 1));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                p-&gt;jitter += SQUARE(f[i].offset - f[0].offset);
        }
        p-&gt;jitter = max(SQRT(p-&gt;jitter), LOG2D(s.precision));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Prime directive: use a sample only once and never a sample
         * older than the latest one, but anything goes before first
         * synchronized.
         */
        if (f[0].t - p-&gt;t &lt;= 0 &amp;&amp; s.leap != NOSYNC)
                return;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Popcorn spike suppressor.  Compare the difference between the
         * last and current offsets to the current jitter.  If greater
         * than SGATE (3) and if the interval since the last offset is
         * less than twice the system poll interval, dump the spike.
         * Otherwise, and if not in a burst, shake out the truechimers.
         */
        if (fabs(p-&gt;offset - dtemp) &gt; SGATE * p-&gt;jitter &amp;&amp; (f[0].t -
            p-&gt;t) &lt; 2 * s.poll)
                return;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        p-&gt;t = f[0].t;
        if (p-&gt;burst == 0)
                clock_select();
        return;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * fit() - test if association p is acceptable for synchronization
 */
int
fit(
        struct p *p             /* peer structure pointer */
        )
{
        /*
         * A stratum error occurs if (1) the server has never been
         * synchronized, (2) the server stratum is invalid.
         */
        if (p-&gt;leap == NOSYNC || p-&gt;stratum &gt;= MAXSTRAT)
                return (FALSE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * A distance error occurs if the root distance exceeds the
         * distance threshold plus an increment equal to one poll
         * interval.
         */
        if (root_dist(p) &gt; MAXDIST + PHI * LOG2D(s.poll))
                return (FALSE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * A loop error occurs if the remote peer is synchronized to the
         * local peer or the remote peer is synchronized to the current
         * system peer.  Note this is the behavior for IPv4; for IPv6
         * the MD5 hash is used instead.
         */
        if (p-&gt;refid == p-&gt;dstaddr || p-&gt;refid == s.refid)
                return (FALSE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * An unreachable error occurs if the server is unreachable.
         */
        if (p-&gt;reach == 0)
                return (FALSE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return (TRUE); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（TRUE）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * clear() - reinitialize for persistent association, demobilize
 * for ephemeral association.
 */
void
clear(
        struct p *p,            /* peer structure pointer */
        int     kiss            /* kiss code */
        )
{
        int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * The first thing to do is return all resources to the bank.
         * Typical resources are not detailed here, but they include
         * dynamically allocated structures for keys, certificates, etc.
         * If an ephemeral association and not initialization, return
         * the association memory as well.
         */
        /* return resources */
        if (s.p == p)
                s.p = NULL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        if (kiss != X_INIT &amp;&amp; (p-&gt;flags &amp; P_EPHEM)) {
                free(p);
                return;
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Initialize the association fields for general reset.
         */
        memset(BEGIN_CLEAR(p), LEN_CLEAR, 0);
        p-&gt;leap = NOSYNC;
        p-&gt;stratum = MAXSTRAT;
        p-&gt;ppoll = MAXPOLL;
        p-&gt;hpoll = MINPOLL;
        p-&gt;disp = MAXDISP;
        p-&gt;jitter = LOG2D(s.precision);
        p-&gt;refid = kiss;
        for (i = 0; i &lt; NSTAGE; i++)
                p-&gt;f[i].disp = MAXDISP;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Randomize the first poll just in case thousands of broadcast
         * clients have just been stirred up after a long absence of the
         * broadcast server.
         */
        p-&gt;outdate = p-&gt;t = c.t;
        p-&gt;nextdate = p-&gt;outdate + (random() &amp; ((1 &lt;&lt; MINPOLL) - 1));
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.3. fast_xmit()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.3。 fast_xmit（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * fast_xmit() - transmit a reply packet for receive packet r
 */
void
fast_xmit(
        struct r *r,            /* receive packet pointer */
        int     mode,           /* association mode */
        int     auth            /* authentication code */
        )
{
        struct x x;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Initialize header and transmit timestamp.  Note that the
         * transmit version is copied from the receive version.  This is
         * for backward compatibility.
         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        x.version = r-&gt;version;
        x.srcaddr = r-&gt;dstaddr;
        x.dstaddr = r-&gt;srcaddr;
        x.leap = s.leap;
        x.mode = mode;
        if (s.stratum == MAXSTRAT)
                x.stratum = 0;
        else
                x.stratum = s.stratum;
        x.poll = r-&gt;poll;
        x.precision = s.precision;
        x.rootdelay = D2FP(s.rootdelay);
        x.rootdisp = D2FP(s.rootdisp);
        x.refid = s.refid;
        x.reftime = s.reftime;
        x.org = r-&gt;xmt;
        x.rec = r-&gt;dst;
        x.xmt = get_time();
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * If the authentication code is A.NONE, include only the
         * header; if A.CRYPTO, send a crypto-NAK; if A.OK, send a valid
         * MAC.  Use the key ID in the received packet and the key in
         * the local key cache.
         */
        if (auth != A_NONE) {
                if (auth == A_CRYPTO) {
                        x.keyid = 0;
                } else {
                        x.keyid = r-&gt;keyid;
                        x.dgst = md5(x.keyid);
                }
        }
        xmit_packet(&amp;x);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.4. access()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.4。アクセス（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 /*
  * access() - determine access restrictions
  */
 int
 access(
         struct r *r             /* receive packet pointer */
         )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 {
         /*
          * The access control list is an ordered set of tuples
          * consisting of an address, mask, and restrict word containing
          * defined bits.  The list is searched for the first match on
          * the source address (r-&gt;srcaddr) and the associated restrict
          * word is returned.
          */
         return (/* access bits */ 0);
 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5. System Process
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5。システムプロセス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.1. clock_select()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.1。 clock_select（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * clock_select() - find the best clocks
 */
void
clock_select() {
       struct p *p, *osys;     /* peer structure pointers */
       double  low, high;      /* correctness interval extents */
       int     allow, found, chime; /* used by intersection algorithm */
       int     n, i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * We first cull the falsetickers from the server population,
         * leaving only the truechimers.  The correctness interval for
         * association p is the interval from offset - root_dist() to
         * offset + root_dist().  The object of the game is to find a
         * majority clique; that is, an intersection of correctness
         * intervals numbering more than half the server population.
         *
         * First, construct the chime list of tuples (p, type, edge) as
         * shown below, then sort the list by edge from lowest to
         * highest.
         */
        osys = s.p;
        s.p = NULL;
        n = 0;
        while (fit(p)) {
                s.m[n].p = p;
                s.m[n].type = +1;
                s.m[n].edge = p-&gt;offset + root_dist(p);
                n++;
                s.m[n].p = p;
                s.m[n].type = 0;
                s.m[n].edge = p-&gt;offset;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                n++;
                s.m[n].p = p;
                s.m[n].type = -1;
                s.m[n].edge = p-&gt;offset - root_dist(p);
                n++;
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Find the largest contiguous intersection of correctness
         * intervals.  Allow is the number of allowed falsetickers;
         * found is the number of midpoints.  Note that the edge values
         * are limited to the range +-(2 ^ 30) &lt; +-2e9 by the timestamp
         * calculations.
         */
        low = 2e9; high = -2e9;
        for (allow = 0; 2 * allow &lt; n; allow++) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * Scan the chime list from lowest to highest to find
                 * the lower endpoint.
                 */
                found = 0;
                chime = 0;
                for (i = 0; i &lt; n; i++) {
                        chime -= s.m[i].type;
                        if (chime &gt;= n - found) {
                                low = s.m[i].edge;
                                break;
                        }
                        if (s.m[i].type == 0)
                                found++;
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * Scan the chime list from highest to lowest to find
                 * the upper endpoint.
                 */
                chime = 0;
                for (i = n - 1; i &gt;= 0; i--) {
                        chime += s.m[i].type;
                        if (chime &gt;= n - found) {
                                high = s.m[i].edge;
                                break;
                        }
                        if (s.m[i].type == 0)
                                found++;
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * If the number of midpoints is greater than the number
                 * of allowed falsetickers, the intersection contains at
                 * least one truechimer with no midpoint.  If so,
                 * increment the number of allowed falsetickers and go
                 * around again.  If not and the intersection is
                 * non-empty, declare success.
                 */
                if (found &gt; allow)
                        continue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 if (high &gt; low) break; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（高&gt;低）ブレークであれば、 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Clustering algorithm.  Construct a list of survivors (p,
         * metric) from the chime list, where metric is dominated first
         * by stratum and then by root distance.  All other things being
         * equal, this is the order of preference.
         */
        s.n = 0;
        for (i = 0; i &lt; n; i++) {
                if (s.m[i].edge &lt; low || s.m[i].edge &gt; high)
                        continue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                p = s.m[i].p;
                s.v[n].p = p;
                s.v[n].metric = MAXDIST * p-&gt;stratum + root_dist(p);
                s.n++;
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * There must be at least NSANE survivors to satisfy the
         * correctness assertions.  Ordinarily, the Byzantine criteria
         * require four survivors, but for the demonstration here, one
         * is acceptable.
         */
        if (s.n &lt; NSANE)
                return;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * For each association p in turn, calculate the selection
         * jitter p-&gt;sjitter as the square root of the sum of squares
         * (p-&gt;offset - q-&gt;offset) over all q associations.  The idea is
         * to repeatedly discard the survivor with maximum selection
         * jitter until a termination condition is met.
         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        while (1) {
                struct p *p, *q, *qmax; /* peer structure pointers */
                double  max, min, dtemp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                max = -2e9; min = 2e9;
                for (i = 0; i &lt; s.n; i++) {
                        p = s.v[i].p;
                        if (p-&gt;jitter &lt; min)
                                min = p-&gt;jitter;
                        dtemp = 0;
                        for (j = 0; j &lt; n; j++) {
                                q = s.v[j].p;
                                dtemp += SQUARE(p-&gt;offset - q-&gt;offset);
                        }
                        dtemp = SQRT(dtemp);
                        if (dtemp &gt; max) {
                                max = dtemp;
                                qmax = q;
                        }
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * If the maximum selection jitter is less than the
                 * minimum peer jitter, then tossing out more survivors
                 * will not lower the minimum peer jitter, so we might
                 * as well stop.  To make sure a few survivors are left
                 * for the clustering algorithm to chew on, we also stop
                 * if the number of survivors is less than or equal to
                 * NMIN (3).
                 */
                if (max &lt; min || n &lt;= NMIN)
                        break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * Delete survivor qmax from the list and go around
                 * again.
                 */
                s.n--;
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Pick the best clock.  If the old system peer is on the list
         * and at the same stratum as the first survivor on the list,
         * then don&#39;t do a clock hop.  Otherwise, select the first
         * survivor on the list as the new system peer.
         */
        if (osys-&gt;stratum == s.v[0].p-&gt;stratum)
                s.p = osys;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        else
                s.p = s.v[0].p;
        clock_update(s.p);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.2. root_dist()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.2。 root_dist（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * root_dist() - calculate root distance
 */
double
root_dist(
        struct p *p             /* peer structure pointer */
        )
{
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * The root synchronization distance is the maximum error due to
         * all causes of the local clock relative to the primary server.
         * It is defined as half the total delay plus total dispersion
         * plus peer jitter.
         */
        return (max(MINDISP, p-&gt;rootdelay + p-&gt;delay) / 2 +
            p-&gt;rootdisp + p-&gt;disp + PHI * (c.t - p-&gt;t) + p-&gt;jitter);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.3. accept()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.3。受け入れます（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * accept() - test if association p is acceptable for synchronization
 */
int
accept(
        struct p *p             /* peer structure pointer */
        )
{
        /*
         * A stratum error occurs if (1) the server has never been
         * synchronized, (2) the server stratum is invalid.
         */
        if (p-&gt;leap == NOSYNC || p-&gt;stratum &gt;= MAXSTRAT)
                return (FALSE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * A distance error occurs if the root distance exceeds the
         * distance threshold plus an increment equal to one poll
         * interval.
         */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
if (root_dist(p) &gt; MAXDIST + PHI * LOG2D(s.poll)) return (FALSE);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
もし（root_dist（P）&gt; MAXDIST + PHI * LOG2D（s.poll））リターン（FALSE）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * A loop error occurs if the remote peer is synchronized to the
         * local peer or the remote peer is synchronized to the current
         * system peer.  Note this is the behavior for IPv4; for IPv6
         * the MD5 hash is used instead.
         */
        if (p-&gt;refid == p-&gt;dstaddr || p-&gt;refid == s.refid)
                return (FALSE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * An unreachable error occurs if the server is unreachable.
         */
        if (p-&gt;reach == 0)
                return (FALSE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 return (TRUE); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（TRUE）を返します。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.4. clock_update()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.4。 clock_update（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * clock_update() - update the system clock
 */
void
clock_update(
        struct p *p             /* peer structure pointer */
        )
{
        double dtemp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * If this is an old update, for instance, as the result of a
         * system peer change, avoid it.  We never use an old sample or
         * the same sample twice.
         */
        if (s.t &gt;= p-&gt;t)
                return;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Combine the survivor offsets and update the system clock; the
         * local_clock() routine will tell us the good or bad news.
         */
        s.t = p-&gt;t;
        clock_combine();
        switch (local_clock(p, s.offset)) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * The offset is too large and probably bogus.  Complain to the
         * system log and order the operator to set the clock manually
         * within PANIC range.  The reference implementation includes a
         * command line option to disable this check and to change the
         * panic threshold from the default 1000 s as required.
         */
        case PANIC:
                exit (0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * The offset is more than the step threshold (0.125 s by
         * default).  After a step, all associations now have
         * inconsistent time values, so they are reset and started
         * fresh.  The step threshold can be changed in the reference
         * implementation in order to lessen the chance the clock might
         * be stepped backwards.  However, there may be serious
         * consequences, as noted in the white papers at the NTP project
         * site.
         */
        case STEP:
                while (/* all associations */ 0)
                        clear(p, X_STEP);
                s.stratum = MAXSTRAT;
                s.poll = MINPOLL;
                break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * The offset was less than the step threshold, which is the
         * normal case.  Update the system variables from the peer
         * variables.  The lower clamp on the dispersion increase is to
         * avoid timing loops and clockhopping when highly precise
         * sources are in play.  The clamp can be changed from the
         * default .01 s in the reference implementation.
         */
        case SLEW:
                s.leap = p-&gt;leap;
                s.stratum = p-&gt;stratum + 1;
                s.refid = p-&gt;refid;
                s.reftime = p-&gt;reftime;
                s.rootdelay = p-&gt;rootdelay + p-&gt;delay;
                dtemp = SQRT(SQUARE(p-&gt;jitter) + SQUARE(s.jitter));
                dtemp += max(p-&gt;disp + PHI * (c.t - p-&gt;t) +
                    fabs(p-&gt;offset), MINDISP);
                s.rootdisp = p-&gt;rootdisp + dtemp;
                break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Some samples are discarded while, for instance, a direct
         * frequency measurement is being made.
         */
        case IGNORE:
                break;
        }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.5. clock_combine()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.5。 clock_combine（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * clock_combine() - combine offsets
 */
void
clock_combine()
{
        struct p *p;            /* peer structure pointer */
        double x, y, z, w;
        int     i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Combine the offsets of the clustering algorithm survivors
         * using a weighted average with weight determined by the root
         * distance.  Compute the selection jitter as the weighted RMS
         * difference between the first survivor and the remaining
         * survivors.  In some cases, the inherent clock jitter can be
         * reduced by not using this algorithm, especially when frequent
         * clockhopping is involved.  The reference implementation can
         * be configured to avoid this algorithm by designating a
         * preferred peer.
         */
        y = z = w = 0;
        for (i = 0; s.v[i].p != NULL; i++) {
                p = s.v[i].p;
                x = root_dist(p);
                y += 1 / x;
                z += p-&gt;offset / x;
                w += SQUARE(p-&gt;offset - s.v[0].p-&gt;offset) / x;
        }
        s.offset = z / y;
        s.jitter = SQRT(w / y);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.6. local_clock()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.6。 local_clock（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * Clock discipline parameters and constants
 */
#define STEPT           .128    /* step threshold (s) */
#define WATCH           900     /* stepout threshold (s) */
#define PANICT          1000    /* panic threshold (s) */
#define PLL             65536   /* PLL loop gain */
#define FLL             MAXPOLL + 1 /* FLL loop gain */
#define AVG             4       /* parameter averaging constant */
#define ALLAN           1500    /* compromise Allan intercept (s) */
#define LIMIT           30      /* poll-adjust threshold */
#define MAXFREQ         500e-6  /* frequency tolerance (500 ppm) */
#define PGATE           4       /* poll-adjust gate */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * local_clock() - discipline the local clock
 */
int                             /* return code */
local_clock(
        struct p *p,            /* peer structure pointer */
        double  offset          /* clock offset from combine() */
        )
{
        int     state;          /* clock discipline state */
        double  freq;           /* frequency */
        double  mu;             /* interval since last update */
        int     rval;
        double  etemp, dtemp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * If the offset is too large, give up and go home.
         */
        if (fabs(offset) &gt; PANICT)
                return (PANIC);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Clock state machine transition function.  This is where the
         * action is and defines how the system reacts to large time
         * and frequency errors.  There are two main regimes: when the
         * offset exceeds the step threshold and when it does not.
         */
        rval = SLEW;
        mu = p-&gt;t - s.t;
        freq = 0;
        if (fabs(offset) &gt; STEPT) {
                switch (c.state) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * In S_SYNC state, we ignore the first outlier and
                 * switch to S_SPIK state.
                 */
                case SYNC:
                        state = SPIK;
                        return (rval);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * In S_FREQ state, we ignore outliers and inliers.  At
                 * the first outlier after the stepout threshold,
                 * compute the apparent frequency correction and step
                 * the time.
                 */
                case FREQ:
                        if (mu &lt; WATCH)
                                return (IGNORE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        freq = (offset - c.offset) / mu;
                        /* fall through to S_SPIK */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * In S_SPIK state, we ignore succeeding outliers until
                 * either an inlier is found or the stepout threshold is
                 * exceeded.
                 */
                case SPIK:
                        if (mu &lt; WATCH)
                                return (IGNORE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        /* fall through to default */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * We get here by default in S_NSET and S_FSET states
                 * and from above in S_FREQ state.  Step the time and
                 * clamp down the poll interval.
                 *
                 * In S_NSET state, an initial frequency correction is
                 * not available, usually because the frequency file has
                 * not yet been written.  Since the time is outside the
                 * capture range, the clock is stepped.  The frequency
                 * will be set directly following the stepout interval.
                 *
                 * In S_FSET state, the initial frequency has been set
                 * from the frequency file.  Since the time is outside
                 * the capture range, the clock is stepped immediately,
                 * rather than after the stepout interval.  Guys get
                 * nervous if it takes 17 minutes to set the clock for
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 * the first time. * * In S_SPIK state, the stepout threshold has expired * and the phase is still above the step threshold. * Note that a single spike greater than the step * threshold is always suppressed, even at the longer * poll intervals. */ default:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
* 初めて。 * S_SPIK状態では、stepout閾値は*有効期限が切れていると位相はステップ閾値より依然としてあります。 *ステップ*閾値よりも大きい単一スパイクはいつもより長く*ポーリング間隔で、抑制されていることに注意してください。 */ デフォルト：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        /*
                         * This is the kernel set time function, usually
                         * implemented by the Unix settimeofday() system
                         * call.
                         */
                        step_time(offset);
                        c.count = 0;
                        s.poll = MINPOLL;
                        rval = STEP;
                        if (state == NSET) {
                                rstclock(FREQ, p-&gt;t, 0);
                                return (rval);
                        }
                        break;
                }
                rstclock(SYNC, p-&gt;t, 0);
        } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * Compute the clock jitter as the RMS of exponentially
                 * weighted offset differences.  This is used by the
                 * poll-adjust code.
                 */
                etemp = SQUARE(c.jitter);
                dtemp = SQUARE(max(fabs(offset - c.last),
                    LOG2D(s.precision)));
                c.jitter = SQRT(etemp + (dtemp - etemp) / AVG);
                switch (c.state) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * In S_NSET state, this is the first update received
                 * and the frequency has not been initialized.  The
                 * first thing to do is directly measure the oscillator
                 * frequency.
                 */
                case NSET:
                        rstclock(FREQ, p-&gt;t, offset);
                        return (IGNORE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * In S_FSET state, this is the first update and the
                 * frequency has been initialized.  Adjust the phase,
                 * but don&#39;t adjust the frequency until the next update.
                 */
                case FSET:
                        rstclock(SYNC, p-&gt;t, offset);
                        break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * In S_FREQ state, ignore updates until the stepout
                 * threshold.  After that, correct the phase and
                 * frequency and switch to S_SYNC state.
                 */
                case FREQ:
                        if (c.t - s.t &lt; WATCH)
                                return (IGNORE);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        freq = (offset - c.offset) / mu;
                        break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * We get here by default in S_SYNC and S_SPIK states.
                 * Here we compute the frequency update due to PLL and
                 * FLL contributions.
                 */
                default:
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        /*
                         * The FLL and PLL frequency gain constants
                         * depending on the poll interval and Allan
                         * intercept.  The FLL is not used below one
                         * half the Allan intercept.  Above that the
                         * loop gain increases in steps to 1 / AVG.
                         */
                        if (LOG2D(s.poll) &gt; ALLAN / 2) {
                                etemp = FLL - s.poll;
                                if (etemp &lt; AVG)
                                        etemp = AVG;
                                freq += (offset - c.offset) / (max(mu,
                                    ALLAN) * etemp);
                        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        /*
                         * For the PLL the integration interval
                         * (numerator) is the minimum of the update
                         * interval and poll interval.  This allows
                         * oversampling, but not undersampling.
                         */
                        etemp = min(mu, LOG2D(s.poll));
                        dtemp = 4 * PLL * LOG2D(s.poll);
                        freq += offset * etemp / (dtemp * dtemp);
                        rstclock(SYNC, p-&gt;t, offset);
                        break;
                }
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Calculate the new frequency and frequency stability (wander).
         * Compute the clock wander as the RMS of exponentially weighted
         * frequency differences.  This is not used directly, but can,
         * along with the jitter, be a highly useful monitoring and
         * debugging tool.
         */
        freq += c.freq;
        c.freq = max(min(MAXFREQ, freq), -MAXFREQ);
        etemp = SQUARE(c.wander);
        dtemp = SQUARE(freq);
        c.wander = SQRT(etemp + (dtemp - etemp) / AVG);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Here we adjust the poll interval by comparing the current
         * offset with the clock jitter.  If the offset is less than the
         * clock jitter times a constant, then the averaging interval is
         * increased; otherwise, it is decreased.  A bit of hysteresis
         * helps calm the dance.  Works best using burst mode.
         */
        if (fabs(c.offset) &lt; PGATE * c.jitter) {
                c.count += s.poll;
                if (c.count &gt; LIMIT) {
                        c.count = LIMIT;
                        if (s.poll &lt; MAXPOLL) {
                                c.count = 0;
                                s.poll++;
                        }
                }
        } else {
                c.count -= s.poll &lt;&lt; 1;
                if (c.count &lt; -LIMIT) {
                        c.count = -LIMIT;
                        if (s.poll &gt; MINPOLL) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                c.count = 0;
                                s.poll--;
                        }
                }
        }
        return (rval);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.7. rstclock()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.5.7。 rstclock（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
  /*
   * rstclock() - clock state machine
   */
  void
  rstclock(
          int     state,          /* new state */
          double  offset,         /* new offset */
          double  t               /* new update time */
          )
  {
          /*
           * Enter new state and set state variables.  Note, we use the
           * time of the last clock filter sample, which must be earlier
           * than the current time.
           */
          c.state = state;
          c.last = c.offset = offset;
          s.t = t;
  }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.6. Clock Adjust Process
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.6。時計のプロセスを調整
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.6.1. clock_adjust()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.6.1。 clock_adjust（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
 /*
  * clock_adjust() - runs at one-second intervals
  */
 void
 clock_adjust() {
         double  dtemp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /*
          * Update the process time c.t.  Also increase the dispersion
          * since the last update.  In contrast to NTPv3, NTPv4 does not
          * declare unsynchronized after one day, since the dispersion
          * threshold serves this function.  When the dispersion exceeds
          * MAXDIST (1 s), the server is considered unfit for
          * synchronization.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          */
         c.t++;
         s.rootdisp += PHI;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /*
          * Implement the phase and frequency adjustments.  The gain
          * factor (denominator) is not allowed to increase beyond the
          * Allan intercept.  It doesn&#39;t make sense to average phase
          * noise beyond this point and it helps to damp residual offset
          * at the longer poll intervals.
          */
         dtemp = c.offset / (PLL * min(LOG2D(s.poll), ALLAN));
         c.offset -= dtemp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /*
          * This is the kernel adjust time function, usually implemented
          * by the Unix adjtime() system call.
          */
         adjust_time(c.freq + dtemp);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /*
          * Peer timer.  Call the poll() routine when the poll timer
          * expires.
          */
         while (/* all associations */ 0) {
                 struct p *p;    /* dummy peer structure pointer */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 if (c.t &gt;= p-&gt;nextdate) poll(p); }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IF（c.t&gt; = P-&gt; nextdate）ポール（P）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         /*
          * Once per hour, write the clock frequency to a file.
          */
         /*
          * if (c.t % 3600 == 3599)
          *   write c.freq to file
          */
 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.7. Poll Process
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.7。投票プロセス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   /*
    * Poll process parameters and constants
    */
   #define UNREACH         12      /* unreach counter threshold */
   #define BCOUNT          8       /* packets in a burst */
   #define BTIME           2       /* burst interval (s) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.7.1. poll()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.7.1。世論調査（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * poll() - determine when to send a packet for association p-&gt;
 */
void
poll(
        struct p *p             /* peer structure pointer */
        )
{
        int     hpoll;
        int     oreach;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * This routine is called when the current time c.t catches up
         * to the next poll time p-&gt;nextdate.  The value p-&gt;outdate is
         * the last time this routine was executed.  The poll_update()
         * routine determines the next execution time p-&gt;nextdate.
         *
         * If broadcasting, just do it, but only if we are synchronized.
         */
        hpoll = p-&gt;hpoll;
        if (p-&gt;hmode == M_BCST) {
                p-&gt;outdate = c.t;
                if (s.p != NULL)
                        peer_xmit(p);
                poll_update(p, hpoll);
                return;
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * If manycasting, start with ttl = 1.  The ttl is increased by
         * one for each poll until MAXCLOCK servers have been found or
         * ttl reaches TTLMAX.  If reaching MAXCLOCK, stop polling until
         * the number of servers falls below MINCLOCK, then start all
         * over.
         */
        if (p-&gt;hmode == M_CLNT &amp;&amp; p-&gt;flags &amp; P_MANY) {
                p-&gt;outdate = c.t;
                if (p-&gt;unreach &gt; BEACON) {
                        p-&gt;unreach = 0;
                        p-&gt;ttl = 1;
                        peer_xmit(p);
                } else if (s.n &lt; MINCLOCK) {
                        if (p-&gt;ttl &lt; TTLMAX)
                                p-&gt;ttl++;
                        peer_xmit(p);
                } p-&gt;unreach++;
                poll_update(p, hpoll);
                return;
        }
        if (p-&gt;burst == 0) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * We are not in a burst.  Shift the reachability
                 * register to the left.  Hopefully, some time before
                 * the next poll a packet will arrive and set the
                 * rightmost bit.
                 */
                oreach = p-&gt;reach;
                p-&gt;outdate = c.t;
                p-&gt;reach = p-&gt;reach &lt;&lt; 1;
                if (!(p-&gt;reach &amp; 0x7))
                        clock_filter(p, 0, 0, MAXDISP);
                if (!p-&gt;reach) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        /*
                         * The server is unreachable, so bump the
                         * unreach counter.  If the unreach threshold
                         * has been reached, double the poll interval
                         * to minimize wasted network traffic.  Send a
                         * burst only if enabled and the unreach
                         * threshold has not been reached.
                         */
                        if (p-&gt;flags &amp; P_IBURST &amp;&amp; p-&gt;unreach == 0) {
                                p-&gt;burst = BCOUNT;
                        } else if (p-&gt;unreach &lt; UNREACH)
                                p-&gt;unreach++;
                        else
                                hpoll++;
                        p-&gt;unreach++;
                } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        /*
                         * The server is reachable.  Set the poll
                         * interval to the system poll interval.  Send a
                         * burst only if enabled and the peer is fit.
                         */
                        p-&gt;unreach = 0;
                        hpoll = s.poll;
                        if (p-&gt;flags &amp; P_BURST &amp;&amp; fit(p))
                                p-&gt;burst = BCOUNT;
                }
        } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * If in a burst, count it down.  When the reply comes
                 * back the clock_filter() routine will call
                 * clock_select() to process the results of the burst.
                 */
                p-&gt;burst--;
        }
        /*
         * Do not transmit if in broadcast client mode.
         */
        if (p-&gt;hmode != M_BCLN)
                peer_xmit(p);
        poll_update(p, hpoll);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.7.2. poll_update()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.7.2。 poll_update（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * poll_update() - update the poll interval for association p
 *
 * Note: This routine is called by both the packet() and poll() routine.
 * Since the packet() routine is executed when a network packet arrives
 * and the poll() routine is executed as the result of timeout, a
 * potential race can occur, possibly causing an incorrect interval for
 * the next poll.  This is considered so unlikely as to be negligible.
 */
void
poll_update(
        struct p *p,            /* peer structure pointer */
        int     poll            /* poll interval (log2 s) */
        )
{
        /*
         * This routine is called by both the poll() and packet()
         * routines to determine the next poll time.  If within a burst
         * the poll interval is two seconds.  Otherwise, it is the
         * minimum of the host poll interval and peer poll interval, but
         * not greater than MAXPOLL and not less than MINPOLL.  The
         * design ensures that a longer interval can be preempted by a
         * shorter one if required for rapid response.
         */
        p-&gt;hpoll = max(min(MAXPOLL, poll), MINPOLL);
        if (p-&gt;burst &gt; 0) {
                if (p-&gt;nextdate != c.t)
                        return;
                else
                        p-&gt;nextdate += BTIME;
        } else {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                /*
                 * While not shown here, the reference implementation
                 * randomizes the poll interval by a small factor.
                 */
                p-&gt;nextdate = p-&gt;outdate + (1 &lt;&lt; max(min(p-&gt;ppoll,
                    p-&gt;hpoll), MINPOLL));
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * It might happen that the due time has already passed.  If so,
         * make it one second in the future.
         */
        if (p-&gt;nextdate &lt;= c.t)
                p-&gt;nextdate = c.t + 1;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.7.3. peer_xmit()
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5.7.3。 peer_xmit（）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
/*
 * transmit() - transmit a packet for association p
 */
void
peer_xmit(
        struct p *p             /* peer structure pointer */
        )
{
        struct x x;             /* transmit packet */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * Initialize header and transmit timestamp
         */
        x.srcaddr = p-&gt;dstaddr;
        x.dstaddr = p-&gt;srcaddr;
        x.leap = s.leap;
        x.version = p-&gt;version;
        x.mode = p-&gt;hmode;
        if (s.stratum == MAXSTRAT)
                x.stratum = 0;
        else
                x.stratum = s.stratum;
        x.poll = p-&gt;hpoll;
        x.precision = s.precision;
        x.rootdelay = D2FP(s.rootdelay);
        x.rootdisp = D2FP(s.rootdisp);
        x.refid = s.refid;
        x.reftime = s.reftime;
        x.org = p-&gt;org;
        x.rec = p-&gt;rec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        x.xmt = get_time();
        p-&gt;xmt = x.xmt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        /*
         * If the key ID is nonzero, send a valid MAC using the key ID
         * of the association and the key in the local key cache.  If
         * something breaks, like a missing trusted key, don&#39;t send the
         * packet; just reset the association and stop until the problem
         * is fixed.
         */
        if (p-&gt;keyid)
                if (/* p-&gt;keyid invalid */ 0) {
                        clear(p, X_NKEY);
                        return;
                }
                x.dgst = md5(p-&gt;keyid);
        xmit_packet(&amp;x);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Dr. David L. Mills University of Delaware Newark, DE 19716 US
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
デラウェア州ニューアーク、DE 19716米国のデビッドL.ミルズ大学
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 302 831 8247 EMail: mills@udel.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 302 831 8247 Eメール：mills@udel.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jim Martin (editor) Internet Systems Consortium 950 Charter Street Redwood City, CA 94063 US
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジム・マーティン（エディタ）インターネットシステムコンソーシアム950憲章通りカリフォルニア州レッドウッドシティー94063米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 650 423 1378 EMail: jrmii@isc.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 650 423 1378 Eメール：jrmii@isc.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Jack Burbank The Johns Hopkins University Applied Physics Laboratory 11100 Johns Hopkins Road Laurel, MD 20723-6099 US
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジャック・バーバンクザ・ジョンズホプキンス大学応用物理研究所11100ジョンズホプキンスロードローレル、MD 20723から6099米
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 443 778 7127 EMail: jack.burbank@jhuapl.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 443 778 7127 Eメール：jack.burbank@jhuapl.edu
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
William Kasch The Johns Hopkins University Applied Physics Laboratory 11100 Johns Hopkins Road Laurel, MD 20723-6099 US
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ウィリアムKaschザ・ジョンズホプキンス大学応用物理研究所11100ジョンズホプキンスロードローレル、MD 20723から6099米
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +1 443 778 7463 EMail: william.kasch@jhuapl.edu
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+1 443 778 7463 Eメール：william.kasch@jhuapl.edu
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
