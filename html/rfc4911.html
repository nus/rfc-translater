<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 4911 - Encoding Instructions for the Robust XML Encoding Rules (RXER) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4911</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 4911 - Encoding Instructions for the Robust XML Encoding Rules (RXER) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc4911">
              https://tools.ietf.org/html/rfc4911
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 4911 - 堅牢なXMLの符号化規則の符号化手順（RXER）</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                            S. Legg
Request for Comments: 4911                                       eB2Bcom
Category: Experimental                                         July 2007
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     Encoding Instructions for the
                    Robust XML Encoding Rules (RXER)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモはインターネットコミュニティのためにExperimentalプロトコルを定義します。それはどんな種類のインターネット標準を指定しません。改善のための議論や提案が要求されています。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The IETF Trust (2007).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）IETFトラスト（2007）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines encoding instructions that may be used in an Abstract Syntax Notation One (ASN.1) specification to alter how ASN.1 values are encoded by the Robust XML Encoding Rules (RXER) and Canonical Robust XML Encoding Rules (CRXER), for example, to encode a component of an ASN.1 value as an Extensible Markup Language (XML) attribute rather than as a child element. Some of these encoding instructions also affect how an ASN.1 specification is translated into an Abstract Syntax Notation X (ASN.X) specification. Encoding instructions that allow an ASN.1 specification to reference definitions in other XML schema languages are also defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、ASN.1値がために、堅牢なXMLエンコーディング規則（RXER）と正規ロバストXMLエンコーディング規則（CRXER）によってコードされている方法を変更する抽象構文記法1（ASN.1）仕様で使用することができる符号化命令を定義します拡張マークアップ言語（XML）属性ではなく、子要素としてとしてASN.1値の成分を符号化する例。これらの符号化手順の一部は、ASN.1仕様は抽象構文記法X（ASN.X）仕様に変換される方法に影響します。 ASN.1仕様が他のXMLスキーマ言語の定義を参照することを可能にする符号化命令も定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................3
   2. Conventions .....................................................3
   3. Definitions .....................................................4
   4. Notation for RXER Encoding Instructions .........................4
   5. Component Encoding Instructions .................................6
   6. Reference Encoding Instructions .................................8
   7. Expanded Names of Components ...................................10
   8. The ATTRIBUTE Encoding Instruction .............................11
   9. The ATTRIBUTE-REF Encoding Instruction .........................12
   10. The COMPONENT-REF Encoding Instruction ........................13
   11. The ELEMENT-REF Encoding Instruction ..........................16
   12. The LIST Encoding Instruction .................................17
   13. The NAME Encoding Instruction .................................19
   14. The REF-AS-ELEMENT Encoding Instruction .......................19
   15. The REF-AS-TYPE Encoding Instruction ..........................20
   16. The SCHEMA-IDENTITY Encoding Instruction ......................22
   17. The SIMPLE-CONTENT Encoding Instruction .......................22
   18. The TARGET-NAMESPACE Encoding Instruction .....................23
   19. The TYPE-AS-VERSION Encoding Instruction ......................24
   20. The TYPE-REF Encoding Instruction .............................25
   21. The UNION Encoding Instruction ................................26
   22. The VALUES Encoding Instruction ...............................27
   23. Insertion Encoding Instructions ...............................29
   24. The VERSION-INDICATOR Encoding Instruction ....................32
   25. The GROUP Encoding Instruction ................................34
      25.1. Unambiguous Encodings ....................................36
           25.1.1. Grammar Construction ..............................37
           25.1.2. Unique Component Attribution ......................47
           25.1.3. Deterministic Grammars ............................52
           25.1.4. Attributes in Unknown Extensions ..................54
   26. Security Considerations .......................................56
   27. References ....................................................56
      27.1. Normative References .....................................56
      27.2. Informative References ...................................57
   Appendix A. GROUP Encoding Instruction Examples ...................58
   Appendix B. Insertion Encoding Instruction Examples ...............74
   Appendix C. Extension and Versioning Examples .....................87
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document defines encoding instructions [X.680-1] that may be used in an Abstract Syntax Notation One (ASN.1) [X.680] specification to alter how ASN.1 values are encoded by the Robust XML Encoding Rules (RXER) [RXER] and Canonical Robust XML Encoding Rules (CRXER) [RXER], for example, to encode a component of an ASN.1 value as an Extensible Markup Language (XML) [XML10] attribute rather than as a child element. Some of these encoding instructions also affect how an ASN.1 specification is translated into an Abstract Syntax Notation X (ASN.X) specification [ASN.X].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、ASN.1値はロバストXMLエンコーディング規則によってコードされている方法を変更する抽象構文記法1（ASN.1）[X.680]明細書で使用され得る符号化命令[X.680-1（RXERを定義します）[RXER]と正規ロバストXMLエンコーディング規則（CRXER）RXER]、例えば、拡張マークアップ言語（XML）[XML10]の属性としてではなく、子要素としてASN.1値の成分を符号化します。これらの符号化手順の一部はまた、ASN.1仕様は抽象構文記法X（ASN.X）仕様[ASN.X]に変換される方法に影響を与えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document also defines encoding instructions that allow an ASN.1 specification to incorporate the definitions of types, elements, and attributes in specifications written in other XML schema languages. References to XML Schema [XSD1] types, elements, and attributes, RELAX NG [RNG] named patterns and elements, and XML document type definition (DTD) [XML10] element types are supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書はまた、他のXMLスキーマ言語で書かれた仕様でエンコードASN.1仕様は、タイプ、要素の定義を組み込むことが可能命令、および属性を定義します。 XMLスキーマ[XSD1]種類、要素および属性への参照は、NG [RNG]指定パターンと要素、およびXML文書型定義（DTD）[XML10]の要素タイプがサポートされているがRELAX。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In most cases, the effect of an encoding instruction is only briefly mentioned in this document. The precise effects of these encoding instructions are described fully in the specifications for RXER [RXER] and ASN.X [ASN.X], at the points where they apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ほとんどの場合、符号化命令の効果は、短時間だけ、この文書に記載されています。これらの符号化手順の正確な効果は、それらが適用点で、RXER [RXER]とASN.X [ASN.X]の仕様に完全に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34; and &#34;MAY&#34; in this document are to be interpreted as described in BCP 14, RFC 2119 [BCP14]. The key word &#34;OPTIONAL&#34; is exclusively used with its ASN.1 meaning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
キーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、 &#34;SHALL&#34;、 &#34;SHOULD&#34; &#34;ないもの&#34;、 &#34;推奨&#34; &#34;NOTべきだ&#34; と、この文書で説明するように解釈されるべきであり、 &#34;MAY&#34; BCP 14、RFC 2119 [BCP14]。キーワード「OPTIONAL」は、もっぱらそのASN.1の意味で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Throughout this document &#34;type&#34; shall be taken to mean an ASN.1 type, and &#34;value&#34; shall be taken to mean an ASN.1 abstract value, unless qualified otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの「タイプ」を通して、ASN.1タイプを意味するものと、そうでない場合は資格がない限り、「値」は、ASN.1抽象値を意味するものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A reference to an ASN.1 production [X.680] (e.g., Type, NamedType) is a reference to text in an ASN.1 specification corresponding to that production. Throughout this document, &#34;component&#34; is synonymous with NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1の製造[X.680]（例えば、タイプ、NamedType）への言及は、その生産に対応するASN.1仕様でテキストへの参照です。本書では、「成分」NamedTypeと同義です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document uses the namespace prefix &#34;xsi:&#34; to stand for the namespace name [XMLNS10] &#34;http://www.w3.org/2001/XMLSchema-instance&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、名前空間接頭辞「XSIを」使用する名前空間名[XMLNS10]「http://www.w3.org/2001/XMLSchema-instance」放置します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example ASN.1 definitions in this document are assumed to be defined in an ASN.1 module with a TagDefault of &#34;AUTOMATIC TAGS&#34; and an EncodingReferenceDefault [X.680-1] of &#34;RXER INSTRUCTIONS&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書の例ASN.1定義は、「自動タグ」のTagDefault及び[X.680-1「RXER命令」のEncodingReferenceDefaultとASN.1モジュールで定義されているものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following definition of base type is used in specifying a number of encoding instructions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基本型の以下の定義は、符号化命令の数を指定する際に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (base type): If a type, T, is a constrained type, then the base type of T is the base type of the type that is constrained; else if T is a prefixed type, then the base type of T is the base type of the type that is prefixed; else if T is a type notation that references or denotes another type (i.e., DefinedType, ObjectClassFieldType, SelectionType, TypeFromObject, or ValueSetFromObjects), then the base type of T is the base type of the type that is referenced or denoted; otherwise, the base type of T is T itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（基本型）、Tは、拘束型で入力すると、次に、Tの基本型が制約される型の基本型です。他Tがプレフィックスタイプである場合、Tの基本型は、前置されたタイプの基本型です。他Tは別のタイプ（すなわち、DefinedType、ObjectClassFieldType、のSelectionType、TypeFromObject、又はValueSetFromObjects）である参照またはタイプ表記である場合、Tの基本型は、参照または示されているタイプの基本型です。そうでない場合は、Tの基本型は、T自体です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: A tagged type is a special case of a prefixed type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：タグ付けされたタイプは、前置タイプの特殊なケースです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Notation for RXER Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
RXERエンコーディング手順4.表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The grammar of ASN.1 permits the application of encoding instructions [X.680-1], through type prefixes and encoding control sections, that modify how abstract values are encoded by nominated encoding rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1の文法は、抽象値が指名符号化規則により符号化される方法を変更、タイププレフィックスと、符号化制御部を介して、[X.680-1]エンコード命令の適用を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The generic notation for type prefixes and encoding control sections is defined by the ASN.1 basic notation [X.680] [X.680-1], and includes an encoding reference to identify the specific encoding rules that are affected by the encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイププレフィックスと、符号化制御部のための一般的な表記法はASN.1基本的な表記法[X.680] [X.680-1]によって定義され、符号化命令によって影響される特定の符号化ルールを識別するための符号化基準を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The encoding reference that identifies the Robust XML Encoding rules is literally RXER. An RXER encoding instruction applies equally to both RXER and CRXER encodings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ロバストXMLエンコーディングルールを識別する符号化参照は、文字通りRXERあります。 RXERエンコード命令はRXERとCRXERエンコーディングの両方に等しく適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The specific notation for an encoding instruction for a specific set of encoding rules is left to the specification of those encoding rules. Consequently, this companion document to the RXER specification [RXER] defines the notation for RXER encoding instructions. Specifically, it elaborates the EncodingInstruction and EncodingInstructionAssignmentList placeholder productions of the ASN.1 basic notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
符号化ルールの特定のセットのエンコード命令の特定の表記法は、それらの符号化規則の仕様に任されています。したがって、RXER仕様[RXER]この仲間ドキュメントはRXERエンコード命令の表記法を定義します。具体的には、ASN.1基本的な表記法のEncodingInstructionとEncodingInstructionAssignmentListプレースホルダ生産を詳述します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the context of the RXER encoding reference, the EncodingInstruction production is defined as follows, using the conventions of the ASN.1 basic notation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RXER符号化基準の文脈において、EncodingInstruction生産はASN.1基本的な表記法の規則を使用して、以下のように定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      EncodingInstruction ::=
          AttributeInstruction |
          AttributeRefInstruction |
          ComponentRefInstruction |
          ElementRefInstruction |
          GroupInstruction |
          InsertionsInstruction |
          ListInstruction |
          NameInstruction |
          RefAsElementInstruction |
          RefAsTypeInstruction |
          SimpleContentInstruction |
          TypeAsVersionInstruction |
          TypeRefInstruction |
          UnionInstruction |
          ValuesInstruction |
          VersionIndicatorInstruction
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the context of the RXER encoding reference, the EncodingInstructionAssignmentList production (which only appears in an encoding control section) is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにRXER符号化基準の文脈において、（のみ符号化制御部に表示される）EncodingInstructionAssignmentList生産が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      EncodingInstructionAssignmentList ::=
          SchemaIdentityInstruction ?
          TargetNamespaceInstruction ?
          TopLevelComponents ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      TopLevelComponents ::= TopLevelComponent TopLevelComponents ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      TopLevelComponent ::= &#34;COMPONENT&#34; NamedType
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (top-level NamedType): A NamedType is a top-level NamedType (equivalently, a top-level component) if and only if it is the NamedType in a TopLevelComponent. A NamedType nested within the Type of the NamedType of a TopLevelComponent is not itself a top-level NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（最上位NamedType）：NamedTypeがあれば最上位NamedType（等価的に、最上位レベルのコンポーネント）であり、それはTopLevelComponentにNamedType場合のみ。 TopLevelComponentのNamedTypeのタイプ内にネストNamedTypeは、トップレベルNamedType自体はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Specification writers should note that non-trivial types defined within a top-level NamedType will not be visible to ASN.1 tools that do not understand RXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：仕様の作家は、トップレベルのNamedType内で定義された非自明なタイプはRXERを理解していないASN.1ツールに表示されないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although a top-level NamedType only appears in an RXER encoding control section, the default encoding reference for the module [X.680-1] still applies when parsing a top-level NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トップレベルNamedTypeのみRXER符号化制御部に表示されているが、トップレベルのNamedTypeを解析するときに、モジュール[X.680-1]のデフォルトの符号化基準が適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each top-level NamedType within a module SHALL have a distinct identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
モジュール内の各トップレベルNamedTypeは異なる識別子を有するものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NamedType production is defined by the ASN.1 basic notation. The other productions are described in subsequent sections and make use of the following productions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NamedType生産はASN.1基本的な表記法によって定義されます。他の作品は、後続のセクションで説明すると、次の作品を利用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      NCNameValue ::= Value
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      AnyURIValue ::= Value
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      QNameValue ::= Value
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      NameValue ::= Value
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Value production is defined by the ASN.1 basic notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
値生成はASN.1基本的な表記法によって定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The governing type for the Value in an NCNameValue is the NCName type from the AdditionalBasicDefinitions module [RXER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NCNameValueにおける値の支配型が[RXER] AdditionalBasicDefinitionsモジュールからNCNameで型です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The governing type for the Value in an AnyURIValue is the AnyURI type from the AdditionalBasicDefinitions module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AnyURIValueにおける値の支配型がAdditionalBasicDefinitionsモジュールからanyURIのタイプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The governing type for the Value in a QNameValue is the QName type from the AdditionalBasicDefinitions module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
QNameValueでの価値のための統治タイプはAdditionalBasicDefinitionsモジュールからのQNameタイプです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The governing type for the Value in a NameValue is the Name type from the AdditionalBasicDefinitions module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NameValueでの価値のための統治タイプはAdditionalBasicDefinitionsモジュールから名前型です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Value in an NCNameValue, AnyURIValue, QNameValue, or NameValue SHALL NOT be a DummyReference [X.683] and SHALL NOT textually contain a nested DummyReference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NCNameValue、AnyURIValue、QNameValue、またはのNameValueの値は[X.683] DummyReferenceてはならないとネストされたテキストでDummyReferenceを含んではなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Thus, encoding instructions are not permitted to be parameterized in any way. This restriction will become important if a future specification for ASN.X explicitly represents parameterized definitions and parameterized references instead of expanding out parameterized references as in the current specification. A parameterized definition could not be directly translated into ASN.X if it contained encoding instructions that were not fully specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：したがって、符号化命令は、どのような方法でパラメータ化することは許可されていません。 ASN.Xの将来の仕様が明示的にパラメータ化定義し、代わりに現在の仕様のようにパラメータ化の参照を拡大するパラメータ化の参照を表す場合、この制限は重要になります。それは完全に指定されていないエンコーディング命令が含まれている場合、パラメータ化定義は直接ASN.Xに翻訳することができませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Component Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.成分符号化手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Certain of the RXER encoding instructions are categorized as component encoding instructions. The component encoding instructions are the ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, NAME, REF-AS-ELEMENT, SIMPLE-CONTENT, TYPE-AS-VERSION, and VERSION-INDICATOR encoding instructions (whose notations are described respectively by AttributeInstruction, AttributeRefInstruction, ComponentRefInstruction, GroupInstruction,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RXER符号化命令の特定の成分の符号化命令として分類されます。成分符号化命令、属性、属性REF、COMPONENT-REF、GROUP、ELEMENT-REF、NAME、REF-AS-ELEMENT、SIMPLE-CONTENT、TYPE-AS-VERSION、およびその表記しているバージョンインジケータ符号化命令（ありますAttributeInstruction、AttributeRefInstruction、ComponentRefInstruction、GroupInstruction、によってそれぞれ説明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ElementRefInstruction, NameInstruction, RefAsElementInstruction, SimpleContentInstruction, TypeAsVersionInstruction, and VersionIndicatorInstruction).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ElementRefInstruction、NameInstruction、RefAsElementInstruction、SimpleContentInstruction、TypeAsVersionInstruction、およびVersionIndicatorInstruction）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in the EncodingPrefixedType for a component encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
成分符号化命令のEncodingPrefixedTypeにおけるタイプのいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) the Type in a NamedType, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）NamedTypeを入力し、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) the Type in an EncodingPrefixedType in a PrefixedType in a BuiltinType in a Type that is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）上記（1）〜（4）のいずれかのタイプでBuiltinTypeでPrefixedTypeでEncodingPrefixedTypeでタイプ、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) the Type in an TaggedType in a PrefixedType in a BuiltinType in a Type that is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）上記（1）〜（4）のいずれかのタイプでBuiltinTypeでPrefixedTypeでTaggedTypeでタイプ、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) the Type in a ConstrainedType (excluding a TypeWithConstraint) in a Type that is one of (1) to (4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）上記（1）〜（4）のいずれかのタイプで（TypeWithConstraint除く）ConstrainedTypeにおけるタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: The effect of this condition is to force the component encoding instructions to be textually within the NamedType to which they apply. Only case (2) can be true on the first iteration as the Type belongs to an EncodingPrefixedType; however, any of (1) to (4) can be true on subsequent iterations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
余談：この条件の効果は、それらが適用されるNamedType内のテキストであること成分符号化命令を強制することです。唯一のケースは、（2）タイプEncodingPrefixedTypeに属しているように、第1の反復で真であることができます。しかし、（1）のいずれかは、（4）その後の反復で真であることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Case (4) is not permitted when the encoding instruction is the ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, or REF-AS-ELEMENT encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）場合は、符号化命令がATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF、またはREF-AS-ELEMENT符号化命令である場合に許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NamedType in case (1) is said to be &#34;subject to&#34; the component encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）場合NamedTypeは成分符号化命令「対象」であると言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A top-level NamedType SHALL NOT be subject to an ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, or SIMPLE-CONTENT encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トップレベルNamedTypeはATTRIBUTE-REF、COMPONENT-REF、GROUP、ELEMENT-REF、REF-AS-ELEMENT、または単純コンテンツエンコード命令を受けてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: This condition does not preclude these encoding instructions being used on a nested NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：この条件は、ネストされたNamedTypeで使用されているこれらのエンコード命令を排除するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A NamedType SHALL NOT be subject to two or more component encoding instructions of the same kind, e.g., a NamedType is not permitted to be subject to two NAME encoding instructions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NamedTypeは、同じ種類の2つの以上の成分符号化指示の対象とされるべきではない、例えば、NamedTypeは、2つの名前の符号化手順を受けることを許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, and TYPE-AS-VERSION encoding instructions are mutually exclusive. The NAME, ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, and REF-AS-ELEMENT encoding instructions are mutually exclusive. A NamedType SHALL NOT be subject to two or more encoding instructions that are mutually exclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ATTRIBUTE、ATTRIBUTE-REF、COMPONENT-REF、GROUP、ELEMENT-REF、REF-AS-ELEMENT、SIMPLE-CONTENT、およびTYPE-AS-VERSION符号化命令は相互に排他的です。 NAME属性-REF、COMPONENT-REF、ELEMENT-REF、及びREF-AS-要素符号化命令は、相互に排他的です。 NamedTypeは相互に排他的である二つ以上の符号化指示の対象とされるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A SelectionType [X.680] SHALL NOT be used to select the Type from a NamedType that is subject to an ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF or REF-AS-ELEMENT encoding instruction. The other component encoding instructions are not inherited by the type denoted by a SelectionType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SelectionTypeは[X.680] ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF又はREF-AS-要素符号化指示の対象となるNamedTypeからタイプを選択するために使用してはなりません。他の成分符号化命令はのSelectionTypeで示されるタイプによって継承されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (attribute component): An attribute component is a NamedType that is subject to an ATTRIBUTE or ATTRIBUTE-REF encoding instruction, or subject to a COMPONENT-REF encoding instruction that references a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（属性成分）：属性コンポーネントは、属性コード命令の対象となる最上位NamedTypeを参照部品REF符号化命令に属性または属性REF符号化命令、又は被験体であるNamedTypeあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (element component): An element component is a NamedType that is not subject to an ATTRIBUTE, ATTRIBUTE-REF, GROUP, or SIMPLE-CONTENT encoding instruction, and not subject to a COMPONENT-REF encoding instruction that references a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（元素成分）：元素成分がトップレベルNamedTypeを参照部品REF符号化命令を受け、ATTRIBUTE-REF、GROUP、または単純コンテンツエンコード命令ATTRIBUTEを受けないNamedTypeではなく、その属性の符号化命令を受けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: A NamedType subject to a GROUP or SIMPLE-CONTENT encoding instruction is neither an attribute component nor an element component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：グループにNamedType対象または単純コンテンツエンコード命令は、属性コンポーネントNOR素子部品でもありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Reference Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.参考エンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Certain of the RXER encoding instructions are categorized as reference encoding instructions. The reference encoding instructions are the ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, and TYPE-REF encoding instructions (whose notations are described respectively by AttributeRefInstruction, ComponentRefInstruction, ElementRefInstruction, RefAsElementInstruction, RefAsTypeInstruction, and TypeRefInstruction). These encoding instructions (except COMPONENT-REF) allow an ASN.1 specification to incorporate the definitions of types, elements, and attributes in specifications written in other XML schema languages, through implied constraints on the markup that may appear in values of the Markup ASN.1 type from the AdditionalBasicDefinitions module [RXER] (for ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, and TYPE-REF) or the UTF8String type (for ATTRIBUTE-REF). References to XML Schema [XSD1] types, elements, and attributes, RELAX NG [RNG] named patterns and elements, and XML document type definition (DTD) [XML10] element types are supported. References to ASN.1 types and top-level components are also permitted. The COMPONENT-REF encoding instruction provides a more direct method of referencing a top-level component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RXER符号化命令の特定は、基準符号化命令として分類されます。基準符号化命令は、ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF、REF-AS-ELEMENT、REF-AS-TYPEと表記AttributeRefInstruction、ComponentRefInstructionによってそれぞれ記載されているTYPE-REF符号化命令（ElementRefInstruction、RefAsElementInstructionあります、RefAsTypeInstruction、およびTypeRefInstruction）。 （COMPONENT-REFを除く）これらの符号化命令はASN.1仕様がタイプ、要素の定義を組み込むことができるように、そして、マークアップASNの値に現れるマークアップに暗黙の制約を介して他のXMLスキーマ言語で書かれた仕様の属性AdditionalBasicDefinitionsモジュール[RXER（ELEMENT-REFは、REF-AS-ELEMENT、REF-AS-TYPE、及びTYPE-REF）又は（ATTRIBUTE-REF用）UTF8Stringを型から0.1型。 XMLスキーマ[XSD1]種類、要素および属性への参照は、NG [RNG]指定パターンと要素、およびXML文書型定義（DTD）[XML10]の要素タイプがサポートされているがRELAX。 ASN.1タイプとトップレベルのコンポーネントへの参照も許可されています。 COMPONENT-REF符号化命令は、トップレベル・コンポーネントを参照するより直接的な方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in the EncodingPrefixedType for an ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, or TYPE-REF encoding instruction SHALL be either: (1) a ReferencedType that is a DefinedType that is a typereference (not a DummyReference) or ExternalTypeReference that references the Markup ASN.1 type from the AdditionalBasicDefinitions module [RXER], or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ELEMENT-REF用EncodingPrefixedTypeを入力し、REF-AS-ELEMENT、REF-AS-TYPE、またはTYPE-REF符号化命令のいずれかでなければならない：typereference（ないDummyReferenceあるDefinedTypeである（1）ReferencedType ）または[RXER] AdditionalBasicDefinitionsモジュールからのマークアップASN.1タイプを参照し、またはExternalTypeReference
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (3), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）TaggedType中タイプの一つであるTaggedTypeがPrefixedTypeであるBuiltinType（1）〜（3）、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (3) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）EncodingPrefixedTypeにおけるタイプ（1）〜（3）のいずれかEncodingPrefixedType基準符号化命令が含まれていないEncodingPrefixedTypeでEncodingPrefixあるPrefixedTypeあるBuiltinType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Case (3) and similar cases for the ATTRIBUTE-REF and COMPONENT-REF encoding instructions have the effect of making the reference encoding instructions mutually exclusive as well as singly occurring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：ATTRIBUTE-REFおよびコンポーネントREF符号化命令のケース（3）と同様のケースが相互に排他的な参照符号指示を行うだけでなく、単独で発生する効果を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With respect to the REF-AS-TYPE and TYPE-REF encoding instructions, the DefinedType in case (1) is said to be &#34;subject to&#34; the encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
REF-AS-TYPEとTYPE-REF符号化命令に対して、場合DefinedTypeは、（1）符号化命令「対象」であると言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The restrictions on the Type in the EncodingPrefixedType for an ATTRIBUTE-REF encoding instruction are specified in Section 9. The restrictions on the Type in the EncodingPrefixedType for a COMPONENT-REF encoding instruction are specified in Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ATTRIBUTE-REFエンコーディング命令のEncodingPrefixedTypeを入力上の制限がCOMPONENT-REFエンコーディング命令のEncodingPrefixedTypeを入力上の制限は、セクション10で指定されている第9節で指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The reference encoding instructions make use of a common production defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照のエンコード命令は、次のように定義された共通の生産を利用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      RefParameters ::= ContextParameter ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ContextParameter ::= &#34;CONTEXT&#34; AnyURIValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A RefParameters instance provides extra information about a reference to a definition. A ContextParameter is used when a reference is ambiguous, i.e., refers to definitions in more than one schema document or external DTD subset. This situation would occur, for example, when importing types with the same name from independently developed XML Schemas defined without a target namespace [XSD1]. When used in conjunction with a reference to an element type in an external DTD subset, the AnyURIValue in the ContextParameter is the system identifier (a Uniform Resource Identifier or URI [URI]) of the external DTD subset; otherwise, the AnyURIValue is a URI that indicates the intended schema document, either an XML Schema specification, a RELAX NG specification, or an ASN.1 or ASN.X specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RefParametersインスタンスが定義への参照に関する追加情報を提供します。基準が曖昧である場合ContextParameterが使用され、すなわち、複数のスキーマ文書または外部DTDサブセットの定義を指します。ターゲット名前空間[XSD1]なしで定義された独立して開発されたXMLスキーマから同じ名前を持つ型をインポートするときにこのような状況は、例えば、発生するであろう。外部DTDサブセット内の要素の型への参照と併せて使用される場合、ContextParameterでAnyURIValue外部DTDサブセットのシステム識別子（ユニフォームリソース識別子又はURI [URI]）です。そうでない場合、AnyURIValueは、意図スキーマ文書を示すURIは、いずれかのXMLスキーマ仕様、RELAX NG仕様、またはASN.1またはASN.X仕様です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Expanded Names of Components
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
コンポーネントの7.拡張名
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each NamedType has an associated expanded name [XMLNS10], determined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各NamedTypeは、以下のように決定関連する拡張名[XMLNS10]を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) if the NamedType is subject to a NAME encoding instruction, then the local name of the expanded name is the character string specified by the NCNameValue of the NAME encoding instruction,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NamedTypeがNAME符号化命令の対象である場合（1）、次いで、拡張名のローカル名は、NAME符号化命令のNCNameValueによって指定された文字列であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) else if the NamedType is subject to a COMPONENT-REF encoding instruction, then the expanded name is the same as the expanded name of the referenced top-level NamedType,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）他NamedTypeコンポーネント-REF符号化命令の対象である場合、拡張名は、参照最上位NamedTypeの拡張名と同じです
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) else if the NamedType is subject to an ATTRIBUTE-REF or ELEMENT-REF encoding instruction, then the namespace name of the expanded name is equal to the namespace-name component of the QNameValue of the encoding instruction, and the local name is equal to the local-name component of the QNameValue,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）他NamedTypeは-REF属性または要素-REF符号化命令の対象である場合、拡張名の名前空間名は、符号化命令のQNameValueの名前空間名コンポーネントに等しく、ローカル名でありますQNameValueのローカル名の成分に等しいです、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) else if the NamedType is subject to a REF-AS-ELEMENT encoding instruction, then the local name of the expanded name is the LocalPart [XMLNS10] of the qualified name specified by the NameValue of the encoding instruction,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）他NamedTypeは、REF-AS-要素符号化命令の対象である場合、拡張名のローカル名は、LocalPartは[XMLNS10】符号化命令のNameValueによって指定された修飾された名前のあります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(5) otherwise, the local name of the expanded name is the identifier of the NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（5）それ以外の場合は、拡張名のローカル名はNamedTypeの識別子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In cases (1) and (5), if the NamedType is a top-level NamedType and the module containing the NamedType has a TARGET-NAMESPACE encoding instruction, then the namespace name of the expanded name is the character string specified by the AnyURIValue of the TARGET-NAMESPACE encoding instruction; otherwise, the namespace name has no value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（1）と（5）、NamedTypeがトップレベルNamedTypeあり、NamedTypeを含むモジュールは、ターゲット名前空間符号化命令を有し、次に展開名の名前空間名のAnyURIValueによって指定された文字列である場合TARGET名前空間符号化命令。それ以外の場合は、名前空間名には値がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Thus, the TARGET-NAMESPACE encoding instruction applies to a top-level NamedType but not to any other NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
余談：このように、ターゲット名前空間符号化命令は、トップレベルNamedTypeにではなく、他NamedTypeに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In case (4), if the encoding instruction contains a Namespace, then the namespace name of the expanded name is the character string specified by the AnyURIValue of the Namespace; otherwise, the namespace name has no value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
符号化命令は名前空間が含まれている場合、ケース（4）において、次に展開名の名前空間名は、名前空間のAnyURIValueによって指定された文字列です。それ以外の場合は、名前空間名には値がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The expanded names for the attribute components of a CHOICE, SEQUENCE, or SET type MUST be distinct. The expanded names for the components of a CHOICE, SEQUENCE, or SET type that are not attribute components MUST be distinct. These tests are applied after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE、SEQUENCE、またはSET型の属性コンポーネントの拡張名は別個でなければなりません。部品属性されていないCHOICE、SEQUENCE、またはセットタイプのコンポーネントの拡張名は別個でなければなりません。これらの試験は、X.680で指定された変換、条項24.4 [X.680]の構成要素の後に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Two components of the same CHOICE, SEQUENCE, or SET type may have the same expanded name if one of them is an attribute component and the other is not. Note that the &#34;not&#34; case includes components that are subject to a GROUP or SIMPLE-CONTENT encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：そのうちの一つが、属性コンポーネントである場合、同じCHOICE、SEQUENCE、またはSET型の2つのコンポーネントは、同じ拡張名を有していてもよく、他ではありません。 「ない」場合は、基または単純コンテンツエンコード命令の対象である構成要素を含むことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The expanded name of a top-level NamedType subject to an ATTRIBUTE encoding instruction MUST be distinct from the expanded name of every other top-level NamedType subject to an ATTRIBUTE encoding instruction in the same module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トップレベルNamedType対象の拡張名に属性符号化命令が同じモジュールに命令をコード属性に他のすべてのトップレベルNamedType対象の拡張名異なるものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The expanded name of a top-level NamedType not subject to an ATTRIBUTE encoding instruction MUST be distinct from the expanded name of every other top-level NamedType not subject to an ATTRIBUTE encoding instruction in the same module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ATTRIBUTE符号化命令を受けない最上位NamedTypeの拡張名は、同じモジュール内の属性の符号化命令を受けない他のすべてのトップレベルNamedTypeの拡張名異なるものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Two top-level components may have the same expanded name if one of them is an attribute component and the other is not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：そのうちの一つが、属性コンポーネントである場合、2つのトップレベルのコンポーネントは、同じ拡張名を有していてもよく、他ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. The ATTRIBUTE Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. ATTRIBUTEエンコーディング命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ATTRIBUTE encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an XML attribute instead of as a child element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
命令を符号化する属性は、それがXML属性として代わりの子要素として適用される成分の値を符号化するためにRXERエンコーダを引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for an ATTRIBUTE encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように命令を符号化する属性の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      AttributeInstruction ::= &#34;ATTRIBUTE&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The base type of the type of a NamedType that is subject to an ATTRIBUTE encoding instruction SHALL NOT be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ATTRIBUTE符号化指示の対象となるNamedTypeの種類の基本型があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a CHOICE, SET, or SET OF type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）CHOICE、SET、またはタイプのセット、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）[RXER（すなわち、QNameのが許可されている）AdditionalBasicDefinitionsモジュールからのQNameタイプを定義以外のSEQUENCEタイプ、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）SequenceOfTypeリスト符号化命令を受けないタイプのシーケンス、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) an open type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）オープンタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      PersonalDetails ::= SEQUENCE {
          firstName   [ATTRIBUTE] UTF8String,
          middleName  [ATTRIBUTE] UTF8String,
          surname     [ATTRIBUTE] UTF8String
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. The ATTRIBUTE-REF Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. ATTRIBUTE-REFエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ATTRIBUTE-REF encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an XML attribute instead of as a child element, where the attribute&#39;s name is a qualified name of the attribute declaration referenced by the encoding instruction. In addition, the ATTRIBUTE-REF encoding instruction causes values of the UTF8String type to be restricted to conform to the type of the attribute declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ATTRIBUTE-REF符号化命令は、XML属性として代わりの属性の名前は、符号化命令によって参照される属性宣言の修飾名であり、子要素として、それが適用される成分の値を符号化するためにRXERエンコーダを引き起こします。また、属性REF符号化命令はUTF8Stringを型の値は、属性宣言のタイプに適合するように制限されるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for an ATTRIBUTE-REF encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように属性REF符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      AttributeRefInstruction ::=
          &#34;ATTRIBUTE-REF&#34; QNameValue RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taken together, the QNameValue and the ContextParameter in the RefParameters (if present) MUST reference an XML Schema attribute declaration or a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一緒になって、QNameValueとRefParametersでContextParameter（存在する場合）XMLスキーマ属性の宣言または属性コード命令の対象となる最上位NamedTypeを参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The type of a referenced XML Schema attribute declaration SHALL NOT be, either directly or by derivation, the XML Schema type QName, NOTATION, ENTITY, ENTITIES, or anySimpleType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照XMLスキーマ属性の宣言のタイプが直接または導出することにより、してはならない、XMLスキーマQName型、表記ENTITY、ENTITIES、又はanySimpleTypeの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Values of these types require information from the context of the attribute for interpretation. Because an ATTRIBUTE-REF encoding instruction is restricted to prefixing the ASN.1 UTF8String type, there is no mechanism to capture such context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：これらの型の値は、解釈のための属性の文脈からの情報を必要としています。 ATTRIBUTE-REF符号化命令はASN.1のUTF8Stringをタイププレフィックスに制限されるので、そのようなコンテキストをキャプチャするメカニズムはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The type of a referenced top-level NamedType SHALL NOT be, either directly or by subtyping, the QName type from the AdditionalBasicDefinitions module [RXER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照トップレベルNamedTypeのタイプは、[RXER]、直接またはサブタイピングによって、AdditionalBasicDefinitionsモジュールからのQNameの形であってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in the EncodingPrefixedType for an ATTRIBUTE-REF encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ATTRIBUTE-REF符号化命令のEncodingPrefixedTypeにおけるタイプのいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) the UTF8String type, or (2) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (3), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）UTF8Stringを型、またはTaggedTypeにおけるタイプ（1）〜（3）のいずれかであるTaggedType PrefixedType（2）BuiltinTypeを、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (3) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）EncodingPrefixedTypeにおけるタイプ（1）〜（3）のいずれかEncodingPrefixedType基準符号化命令が含まれていないEncodingPrefixedTypeでEncodingPrefixあるPrefixedTypeあるBuiltinType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The identifier of a NamedType subject to an ATTRIBUTE-REF encoding instruction does not contribute to the name of attributes in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the local name of the referenced attribute declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ATTRIBUTE-REFエンコーディング命令にNamedType対象の識別子がRXERエンコーディング内の属性の名前には寄与しません。一貫性のために、識別子は、可能な場合、参照される属性宣言のローカル名と同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. The COMPONENT-REF Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.部品REFエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ASN.1 basic notation does not have a concept of a top-level NamedType and therefore does not have a mechanism to reference a top-level NamedType. The COMPONENT-REF encoding instruction provides a way to specify that a NamedType within a combining type definition is equivalent to a referenced top-level NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1基本的な表記法は、トップレベルNamedTypeの概念を持たないので、トップレベルのNamedTypeを参照する機構を有していません。 COMPONENT-REF符号化命令は、結合型定義内NamedTypeが参照最上位NamedTypeと同等であることを指定する方法を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a COMPONENT-REF encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように部品REF符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ComponentRefInstruction ::= &#34;COMPONENT-REF&#34; ComponentReference
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ComponentReference ::=
          InternalComponentReference |
          ExternalComponentReference
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      InternalComponentReference ::= identifier FromModule ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      FromModule ::= &#34;FROM&#34; GlobalModuleReference
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ExternalComponentReference ::= modulereference &#34;.&#34; identifier
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The GlobalModuleReference production is defined by the ASN.1 basic notation [X.680]. If the GlobalModuleReference is absent from an InternalComponentReference, then the identifier MUST be the identifier of a top-level NamedType in the same module. If the GlobalModuleReference is present in an InternalComponentReference, then the identifier MUST be the identifier of a top-level NamedType in the referenced module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
GlobalModuleReference生産はASN.1基本的な表記法[X.680]で定義されます。 GlobalModuleReferenceはInternalComponentReferenceから存在しない場合、識別子は、同じモジュール内の最上位NamedTypeの識別子でなければなりません。 GlobalModuleReferenceはInternalComponentReferenceに存在する場合、識別子は、参照モジュール内の最上位NamedTypeの識別子でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The modulereference in an ExternalComponentReference is used in the same way as a modulereference in an ExternalTypeReference. The identifier in an ExternalComponentReference MUST be the identifier of a top-level NamedType in the referenced module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ExternalComponentReferenceでmodulereferenceはExternalTypeReferenceでmodulereferenceと同様に使用されています。 ExternalComponentReference内の識別子は、参照モジュール内の最上位NamedTypeの識別子でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in the EncodingPrefixedType for a COMPONENT-REF encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれかでなければならないCOMPONENT-REFエンコーディング命令のEncodingPrefixedTypeを入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a ReferencedType that is a DefinedType that is a typereference (not a DummyReference) or an ExternalTypeReference, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）typereference（ないDummyReference）またはExternalTypeReferenceあるDefinedTypeあるReferencedType、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a BuiltinType or ReferencedType that is one of the productions in Table 1 in Section 5 of the specification for RXER [RXER], or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）RXERの仕様のセクション5において、表1におけるプロダクションの一つであるタイプまたは参照タイプ[RXER]内蔵、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）TaggedType中タイプの一つであるTaggedTypeがPrefixedTypeであるBuiltinType（1）〜（4）、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (4) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）EncodingPrefixedTypeにおけるタイプ（1）〜（4）のいずれかEncodingPrefixedType基準符号化命令が含まれていないEncodingPrefixedTypeでEncodingPrefixあるPrefixedTypeあるBuiltinType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The restrictions on the use of RXER encoding instructions are such that no other RXER encoding instruction is permitted within a NamedType if the NamedType is subject to a COMPONENT-REF encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RXER符号化命令の使用上の制約がNamedTypeコンポーネント-REF符号化命令の対象である場合、他のRXERエンコード命令がNamedType内で許可されていないようなものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in the top-level NamedType referenced by the COMPONENT-REF encoding instruction MUST be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPONENT-REF符号化命令によって参照される最上位NamedTypeにおけるタイプのいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(a) if the preceding case (1) is used, a ReferencedType that is a DefinedType that is a typereference or ExternalTypeReference that references the same type as the DefinedType in case (1), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（a）は前述のケース（1）が使用される場合、場合DefinedTypeと同じタイプ（1）を参照typereference又はExternalTypeReferenceあるDefinedTypeあるReferencedType、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) if the preceding case (2) is used, a BuiltinType or ReferencedType that is the same as the BuiltinType or ReferencedType in case (2), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（B）前述のケース（2）が使用される場合、BuiltinType又はReferencedType（2）場合BuiltinType又はReferencedTypeと同じである、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(c) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (a) to (c), and the EncodingPrefix in the EncodingPrefixedType contains an RXER encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（C）EncodingPrefixedTypeにおけるタイプ（a）〜（c）の一つであり、EncodingPrefixedTypeでEncodingPrefixがRXERエンコード命令を含む。EncodingPrefixedTypeあるPrefixedTypeあるBuiltinType
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In principle, the COMPONENT-REF encoding instruction creates a notional NamedType where the expanded name is that of the referenced top-level NamedType and the Type in case (1) or (2) is substituted by the Type of the referenced top-level NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
原理的には、部品REF符号化命令は、拡張名が概念的NamedTypeを作成参照最上位NamedTypeとケースで入力（1）又は（2）参照トップレベルNamedTypeの種類によって置換されていると。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In practice, it is sufficient for non-RXER encoders and decoders to use the original NamedType rather than the notional NamedType because the Type in case (1) or (2) can only differ from the Type of the referenced top-level NamedType by having fewer RXER encoding instructions, and RXER encoding instructions are ignored by non-RXER encoders and decoders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際には、ケース内にタイプするので、元のNamedTypeなく概念的NamedTypeを使用する非RXERエンコーダおよびデコーダのために十分である（1）又は（2）のみを有するで参照最上位NamedTypeのタイプと異なっていてもよいです少ないRXERエンコーディング命令、およびRXERエンコーディング命令が非RXERエンコーダとデコーダによって無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although any prefixes for the Type in case (1) or (2) would be bypassed, it is sufficient for RXER encoders and decoders to use the referenced top-level NamedType instead of the notional NamedType because these prefixes cannot be RXER encoding instructions (except, of course, for the COMPONENT-REF encoding instruction) and can have no effect on an RXER encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケースを入力するための任意のプレフィックスが（1）又は（2）バイパスされるであろう、これらのプレフィックスがRXERエンコード命令をすることができないので除い（名目NamedTypeの代わりに参照されるトップレベルNamedTypeを使用するRXERエンコーダおよびデコーダのために十分ですもちろん、部品REF符号化命令のため）とRXERエンコードに影響を与えないことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Modules ::= SEQUENCE OF
          module [COMPONENT-REF module
                     FROM AbstractSyntaxNotation-X
                         { 1 3 6 1 4 1 21472 1 0 1 }]
                     ModuleDefinition
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the &#34;module&#34; top-level NamedType in the AbstractSyntaxNotation-X module is defined like so:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AbstractSyntaxNotation-Xモジュールで「モジュール」トップレベルNamedTypeはそうのように定義されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPONENT module ModuleDefinition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
部品モジュールのModuleDefinitionは
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ASN.X translation of the SEQUENCE OF type definition provides a more natural representation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
型定義のシーケンスのASN.X翻訳は、より自然な表現を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;namedType xmlns:asnx=&#34;urn:ietf:params:xml:ns:asnx&#34; name=&#34;Modules&#34;&gt; &lt;sequenceOf&gt; &lt;element ref=&#34;asnx:module&#34;/&gt; &lt;/sequenceOf&gt; &lt;/namedType&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;namedTypeのxmlns：asnx = &#34;URN：IETF：paramsは：XML：NS：asnx&#34; NAME = &#34;モジュール&#34;&gt; &lt;sequenceOf&gt; &lt;要素REF = &#34;asnx：モジュール&#34; /&gt; &lt;/ sequenceOf&gt; &lt;/ namedType&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: The &lt;namedType&gt; element in ASN.X corresponds to a TypeAssignment, not a NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：ASN.Xにおける&lt;namedType&gt;要素はTypeAssignment、ないNamedTypeに相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The identifier of a NamedType subject to a COMPONENT-REF encoding instruction does not contribute to an RXER encoding. For the sake of consistency with other encoding rules, the identifier SHOULD be the same as the identifier in the ComponentRefInstruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
COMPONENT-REF符号化命令にNamedType対象の識別子がRXER符号化には寄与しません。他の符号化規則との整合のために、識別子はComponentRefInstruction内の識別子と同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. The ELEMENT-REF Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. ELEMENT-REFエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ELEMENT-REF encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an element where the element&#39;s name is a qualified name of the element declaration referenced by the encoding instruction. In addition, the ELEMENT-REF encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the type of the element declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ELEMENT-REF符号化命令は、それが要素の名前は、符号化命令によって参照される要素宣言の修飾名であり、素子として適用される成分の値を符号化するためにRXERエンコーダを引き起こします。また、ELEMENT-REF符号化命令は、マークアップASN.1タイプの値は、要素宣言のタイプに適合するように制限されるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for an ELEMENT-REF encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにELEMENT-REF符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ElementRefInstruction ::= &#34;ELEMENT-REF&#34; QNameValue RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taken together, the QNameValue and the ContextParameter in the RefParameters (if present) MUST reference an XML Schema element declaration, a RELAX NG element definition, or a top-level NamedType that is not subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一緒になって、QNameValueとRefParametersでContextParameter（存在する場合）XMLスキーマ要素宣言、RELAX NG要素定義、またはATTRIBUTEコード命令を受けない最上位NamedTypeを参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A referenced XML Schema element declaration MUST NOT have a type that requires the presence of values for the XML Schema ENTITY or ENTITIES types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照XMLスキーマ要素宣言は、XMLスキーマエンティティまたはエンティティタイプの値の存在を必要とするタイプを有してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Entity declarations are not supported by CRXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：エンティティ宣言はCRXERによってサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      AnySchema ::= CHOICE {
          module   [ELEMENT-REF {
                       namespace-name
                           &#34;urn:ietf:params:xml:ns:asnx&#34;,
                       local-name &#34;module&#34; }]
                   Markup,
          schema   [ELEMENT-REF {
                       namespace-name
                           &#34;http://www.w3.org/2001/XMLSchema&#34;,
                       local-name &#34;schema&#34; }]
                   Markup,
          grammar  [ELEMENT-REF {
                       namespace-name
                           &#34;http://relaxng.org/ns/structure/1.0&#34;,
                       local-name &#34;grammar&#34; }]
                   Markup
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ASN.X translation of the choice type definition provides a more natural representation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択型定義のASN.X翻訳は、より自然な表現を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;namedType xmlns:asnx=&#34;urn:ietf:params:xml:ns:asnx&#34; xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:rng=&#34;http://relaxng.org/ns/structure/1.0&#34; name=&#34;AnySchema&#34;&gt; &lt;choice&gt; &lt;element ref=&#34;asnx:module&#34; embedded=&#34;true&#34;/&gt; &lt;element ref=&#34;xs:schema&#34; embedded=&#34;true&#34;/&gt; &lt;element ref=&#34;rng:grammar&#34; embedded=&#34;true&#34;/&gt; &lt;/choice&gt; &lt;/namedType&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;namedTypeのxmlns：asnx = &#34;壷：IETF：のparams：XML：NS：asnx&#34; のxmlns：XS = &#34;http://www.w3.org/2001/XMLSchema&#34; のxmlns：RNG = &#34;http://relaxng.org /ns/structure/1.0&#34; 名前= &#34;ANYSCHEMA&#34;&gt; &lt;選択&gt; &lt;要素REF = &#34;asnx：モジュール&#34; 埋め込まれた= &#34;true&#34; を/&gt; &lt;要素REF = &#34;XS：スキーマ&#34; 埋め込まれた= &#34;true&#34; を/&gt; &lt;要素REF =：埋め込まれた &#34;RNG文法&#34; = &#34;真&#34; /&gt; &lt;/選択&gt; &lt;/ namedType&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The identifier of a NamedType subject to an ELEMENT-REF encoding instruction does not contribute to the name of an element in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the local name of the referenced element declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ELEMENT-REF符号化命令にNamedType対象の識別子がRXER符号化における要素の名前に寄与しません。一貫性のために、識別子は、可能な場合、参照される要素宣言のローカル名と同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. The LIST Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. LISTエンコーディング命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The LIST encoding instruction causes an RXER encoder to encode a value of a SEQUENCE OF type as a white-space-separated list of the component values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LISTエンコード命令は、成分値の空白で区切られたリストとしてタイプのシーケンスの値を符号化するためにRXERエンコーダを引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a LIST encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにLIST符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ListInstruction ::= &#34;LIST&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in an EncodingPrefixedType for a LIST encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれかでなければならないLISTエンコーディング命令のEncodingPrefixedTypeを入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a BuiltinType that is a SequenceOfType of the &#34;SEQUENCE OF NamedType&#34; form, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）形態 &#34;NamedType OF SEQUENCE&#34; のSequenceOfTypeあるBuiltinType、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a ConstrainedType that is a TypeWithConstraint of the &#34;SEQUENCE Constraint OF NamedType&#34; form or &#34;SEQUENCE SizeConstraint OF NamedType&#34; form, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）「NamedType一連の制約」のTypeWithConstraintあるConstrainedTypeを形成または「配列SizeConstraint NamedType OF」形、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (5), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）ConstrainedType中タイプの一つである制約を有するタイプではない制約タイプ（1）〜（5）、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (5), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）TaggedType中タイプの一つであるTaggedTypeがPrefixedTypeであるBuiltinType（1）〜（5）、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(5) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（5）EncodingPrefixedTypeにおけるタイプ（1）〜（5）のいずれかであるEncodingPrefixedType PrefixedTypeあるBuiltinType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The effect of this condition is to force the LIST encoding instruction to be textually co-located with the SequenceOfType or TypeWithConstraint to which it applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この条件の効果はテキストで、それが適用されるSequenceOfType又はTypeWithConstraintと同じ場所に配置されるLISTエンコード命令を強制することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: This makes it clear to a reader that the encoding instruction applies to every use of the type no matter how it might be referenced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：これは、符号化命令は関係なく、それが参照されるかもしれない方法のタイプのすべての使用に適用されていない読者にはそれが明確になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SequenceOfType in case (1) and the TypeWithConstraint in case (2) are said to be &#34;subject to&#34; the LIST encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（1）にSequenceOfType及び（2）の場合にTypeWithConstraintがリスト符号化命令「対象」であると言われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A SequenceOfType or TypeWithConstraint SHALL NOT be subject to more than one LIST encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SequenceOfTypeまたはTypeWithConstraintは、複数のリストエンコードの指示を受けてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The base type of the component type of a SequenceOfType or TypeWithConstraint that is subject to a LIST encoding instruction MUST be one of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LIST符号化指示の対象となるSequenceOfType又はTypeWithConstraintのコンポーネントタイプのベース型は、以下のいずれかである必要があります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) the BOOLEAN, INTEGER, ENUMERATED, REAL, OBJECT IDENTIFIER, RELATIVE-OID, GeneralizedTime, or UTCTime type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）BOOLEAN、INTEGER列挙、REAL、オブジェクト識別子、相対OID、GeneralizedTimeの、またはUTC時刻型、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) the NCName, AnyURI, Name, or QName type from the AdditionalBasicDefinitions module [RXER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）AdditionalBasicDefinitionsモジュールからNCNameで、anyURIの、名前、またはQNameのタイプを[RXER]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: While it would be feasible to allow the component type to also be any character string type that is constrained such that all its abstract values have a length greater than zero and none of its abstract values contain any white space characters, testing whether this condition is satisfied can be quite involved. For the sake of simplicity, only certain immediately useful constrained UTF8String types, which are known to be suitable, are permitted (i.e., NCName, AnyURI, and Name).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：コンポーネントのタイプも、そのすべての抽象値がゼロより大きい長さを有し、その抽象値のどれもが、この状態かどうかをテストし、任意の空白文字を含まないように制約されている任意の文字列型であることを許可することが可能であろうが非常に関与することができ満足しています。簡略化のために、適切であることが知られている唯一の特定の即時有用制約UTF8Stringをタイプは、許可されている（すなわち、NCNameで、anyURIの、および名前）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NamedType in a SequenceOfType or TypeWithConstraint that is subject to a LIST encoding instruction MUST NOT be subject to an ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, or TYPE-AS-VERSION encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
LIST符号化指示の対象となるSequenceOfType又はTypeWithConstraintでNamedType属性の対象であってはなりませんATTRIBUTE-REF、COMPONENT-REF、GROUP、ELEMENT-REF、REF-AS-ELEMENT、SIMPLE-CONTENT、又はタイプ - AS-VERSIONエンコーディング命令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      UpdateTimes ::= [LIST] SEQUENCE OF updateTime GeneralizedTime
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. The NAME Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13名のエンコーディング命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NAME encoding instruction causes an RXER encoder to use a nominated character string instead of a component&#39;s identifier wherever that identifier would otherwise appear in the encoding (e.g., as an element or attribute name).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NAMEエンコード命令は、その識別子がそうでなければ（例えば、要素として、又は属性名）符号化に現れるどこ代わりにコンポーネントの識別子の指名文字列を使用するRXERエンコーダを引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a NAME encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにNAME符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      NameInstruction ::= &#34;NAME&#34; &#34;AS&#34;? NCNameValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE { foo-att [ATTRIBUTE] [NAME AS &#34;Foo&#34;] INTEGER, foo-elem [NAME &#34;Foo&#34;] INTEGER }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE {FOO-ATT [ATTRIBUTE] INTEGER、FOO-ELEM [NAME &#34;foo&#34; という] INTEGER [ &#34;foo&#34; というAS NAME]}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. The REF-AS-ELEMENT Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. REF-AS-ELEMENTエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The REF-AS-ELEMENT encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an element where the element&#39;s name is the name of the external DTD subset element type declaration referenced by the encoding instruction. In addition, the REF-AS-ELEMENT encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the content and attributes permitted by that element type declaration and its associated attribute-list declarations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
REF-AS-要素符号化命令は、それが要素の名前は、符号化命令によって参照される外部DTDサブセットの要素型宣言の名前である要素として適用される成分の値を符号化するためにRXERエンコーダを引き起こします。また、REF-AS-要素符号化命令は、マークアップASN.1タイプの値がその要素型宣言とそれに関連する属性リスト宣言で許可されたコンテンツと属性に適合するように制限されるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a REF-AS-ELEMENT encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにREF-AS-要素符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      RefAsElementInstruction ::=
          &#34;REF-AS-ELEMENT&#34; NameValue Namespace ? RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Namespace ::= &#34;NAMESPACE&#34; AnyURIValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taken together, the NameValue and the ContextParameter in the RefParameters (if present) MUST reference an element type declaration in an external DTD subset that is conformant with Namespaces in XML 1.0 [XMLNS10].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まとめると、のNameValueおよびRefParametersでContextParameter（存在する場合）はXML 1.0 [XMLNS10]における名前空間に準拠した外部DTDサブセット内の要素型宣言を参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Namespace is present if and only if the Name of the referenced element type declaration conforms to a PrefixedName (a QName) [XMLNS10], in which case the Namespace specifies the namespace name to be associated with the Prefix of the PrefixedName.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名前空間が存在する場合、参照要素型宣言の名前は、名前空間がPrefixedNameのプレフィックスに関連付けられる名前空間名を指定した場合にPrefixedName（QNameの）XMLNS10]に準拠している場合のみ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The referenced element type declaration MUST NOT require the presence of attributes of type ENTITY or ENTITIES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照される要素型宣言は、ENTITY型やENTITIESの属性が存在することを要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Entity declarations are not supported by CRXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：エンティティ宣言はCRXERによってサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose that the following external DTD subset has been defined with a system identifier of &#34;http://www.example.com/inventory&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下、外部DTDサブセットは「http://www.example.com/inventory」のシステム識別子と定義されていると仮定する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;?xml version=&#39;1.0&#39;?&gt; &lt;!ELEMENT product EMPTY&gt; &lt;!ATTLIST product name CDATA #IMPLIED partNumber CDATA #REQUIRED quantity CDATA #REQUIRED &gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;？xmlのバージョン= &#39;1.0&#39;？&gt; &lt;！ELEMENT製品EMPTY&gt; &lt;！ATTLIST製品名CDATA #IMPLIED partNumberもCDATA #REQUIRED量CDATA #REQUIRED&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The product element type declaration can be referenced as an element in an ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
製品要素型宣言はASN.1型定義の要素として参照することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE { product [REF-AS-ELEMENT &#34;product&#34; CONTEXT &#34;http://www.example.com/inventory&#34;] Markup }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE {産物[REF-AS-ELEMENT &#34;製品&#34; CONTEXT &#34;http://www.example.com/inventory&#34;]マークアップ}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is the ASN.X translation of this ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでは、このASN.1型定義のASN.X変換は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;type&gt; &lt;choice&gt; &lt;element elementType=&#34;product&#34; context=&#34;http://www.example.com/inventory&#34;/&gt; &lt;/choice&gt; &lt;/type&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;タイプ&gt; &lt;選択&gt; &lt;要素をelementType = &#34;製品&#34; コンテキスト= &#34;http://www.example.com/inventory&#34; /&gt; &lt;/選択&gt; &lt;/入力&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The identifier of a NamedType subject to a REF-AS-ELEMENT encoding instruction does not contribute to the name of an element in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the Name of the referenced element type declaration (or the LocalPart if the Name conforms to a PrefixedName).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
REF-AS-要素符号化命令にNamedType対象の識別子がRXER符号化における要素の名前に寄与しません。一貫性のために、識別子は、可能な場合、参照される要素型宣言（または名前PrefixedNameに準拠している場合LocalPartは）の名前と同じでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. The REF-AS-TYPE Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. REF-AS-TYPEのエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The REF-AS-TYPE encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the content and attributes permitted by a nominated element type declaration and its associated attribute-list declarations in an external DTD subset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
REF-AS型の符号化命令は、マークアップASN.1タイプの値は指名要素型宣言と外部DTDサブセット内のその関連属性リスト宣言で許可されたコンテンツと属性に適合するように制限されるようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a REF-AS-TYPE encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにREF-AS型の符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      RefAsTypeInstruction ::= &#34;REF-AS-TYPE&#34; NameValue RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taken together, the NameValue and the ContextParameter of the RefParameters (if present) MUST reference an element type declaration in an external DTD subset that is conformant with Namespaces in XML 1.0 [XMLNS10].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まとめると、のNameValueおよびRefParametersのContextParameter（存在する場合）はXML 1.0 [XMLNS10]における名前空間に準拠した外部DTDサブセット内の要素型宣言を参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The referenced element type declaration MUST NOT require the presence of attributes of type ENTITY or ENTITIES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照される要素型宣言は、ENTITY型やENTITIESの属性が存在することを要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Entity declarations are not supported by CRXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：エンティティ宣言はCRXERによってサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The product element type declaration can be referenced as a type in an ASN.1 definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
製品要素型宣言はASN.1定義でタイプとして参照することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE OF inventoryItem [REF-AS-TYPE &#34;product&#34; CONTEXT &#34;http://www.example.com/inventory&#34;] Markup
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【 &#34;http://www.example.com/inventory&#34; REF-AS-TYPE &#34;製品&#34; CONTEXT] inventoryItem一連のマークアップ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is the ASN.X translation of this definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでは、この定義のASN.X変換は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;sequenceOf&gt; &lt;element name=&#34;inventoryItem&#34;&gt; &lt;type elementType=&#34;product&#34; context=&#34;http://www.example.com/inventory&#34;/&gt; &lt;/element&gt; &lt;/sequenceOf&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;sequenceOf&gt; &lt;要素名= &#34;inventoryItem&#34;&gt; &lt;タイプをelementType = &#34;製品&#34; コンテキスト= &#34;http://www.example.com/inventory&#34; /&gt; &lt;/要素&gt; &lt;/ sequenceOf&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that when an element type declaration is referenced as a type, the Name of the element type declaration does not contribute to RXER encodings. For example, child elements in the RXER encoding of values of the above SEQUENCE OF type would resemble the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要素型宣言が型として参照されるとき、要素型宣言の名前RXERエンコーディングに寄与しないことに留意されたいです。例えば、種類の上記のシーケンスの値のRXER符号化における子要素は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;inventoryItem name=&#34;hammer&#34; partNumber=&#34;1543&#34; quantity=&#34;29&#34;/&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;inventoryItem名= &#34;ハンマー&#34; partNumberも= &#34;1543&#34; 量= &#34;29&#34; /&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. The SCHEMA-IDENTITY Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. SCHEMA-IDENTITYエンコーディング命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SCHEMA-IDENTITY encoding instruction associates a unique identifier, a URI [URI], with the ASN.1 module containing the encoding instruction. This encoding instruction has no effect on an RXER encoder but does have an effect on the translation of an ASN.1 specification into an ASN.X representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SCHEMA-IDENTITY符号化命令は、符号化命令を含むASN.1モジュールと、一意の識別子、URI [URI]を関連付けます。このエンコード命令はRXERエンコーダには影響しませんが、ASN.X表現にASN.1仕様の翻訳に影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a SCHEMA-IDENTITY encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにスキーマIDENTITY符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      SchemaIdentityInstruction ::= &#34;SCHEMA-IDENTITY&#34; AnyURIValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The character string specified by the AnyURIValue of each SCHEMA-IDENTITY encoding instruction MUST be distinct. In particular, successive versions of an ASN.1 module must each have a different schema identity URI value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各スキーマIDENTITY符号化命令のAnyURIValueによって指定された文字列は別個でなければなりません。具体的には、ASN.1モジュールの連続したバージョンは、それぞれ異なるスキーマ識別URI値を有していなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. The SIMPLE-CONTENT Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. SIMPLE-コンテンツエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SIMPLE-CONTENT encoding instruction causes an RXER encoder to encode a value of a component of a SEQUENCE or SET type without encapsulation in a child element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単純コンテンツエンコード命令は、子要素にカプセル化することなく、SEQUENCEまたはSETタイプの成分の値を符号化するRXERエンコーダを引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a SIMPLE-CONTENT encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように単純コンテンツエンコード命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      SimpleContentInstruction ::= &#34;SIMPLE-CONTENT&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A NamedType subject to a SIMPLE-CONTENT encoding instruction SHALL be in a ComponentType in a ComponentTypeList in a RootComponentTypeList. At most one such NamedType of a SEQUENCE or SET type is permitted to be subject to a SIMPLE-CONTENT encoding instruction. If any component is subject to a SIMPLE-CONTENT encoding instruction, then all other components in the same SEQUENCE or SET type definition MUST be attribute components. These tests are applied after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SIMPLE-CONTENT符号化命令にNamedType対象はRootComponentTypeListでComponentTypeListにCOMPONENTTYPEでなければなりません。配列またはSET型のせいぜい一つのそのようなNamedTypeは、単純コンテンツエンコード命令を受けることを許可されています。任意成分は、単純コンテンツエンコード命令の対象である場合には、同じ配列またはSET型定義内の他のすべてのコンポーネントは、コンポーネントの属性である必要があります。これらの試験は、X.680で指定された変換、条項24.4 [X.680]の構成要素の後に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Child elements and simple content are mutually exclusive. Specification writers should note that use of the SIMPLE-CONTENT encoding instruction on a component of an extensible SEQUENCE or SET type means that all future extensions to the SEQUENCE or SET type are restricted to being attribute components with the limited set of types that are permitted for attribute components. Using an ATTRIBUTE encoding instruction instead of a SIMPLE-CONTENT encoding instruction avoids this limitation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：子要素とシンプルな内容は相互に排他的です。仕様作成者は、拡張可能な配列またはSETタイプのコンポーネントに単純コンテンツエンコード命令の使用は、配列またはSETタイプに対するすべての将来の拡張のために許可されているタイプの限定されたセットと属性のコンポーネントであることに限定されることを意味する注意してくださいコンポーネントの属性。代わりに単純コンテンツエンコード命令の属性エンコード命令を使用してこの制限を回避します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The base type of the type of a NamedType that is subject to a SIMPLE-CONTENT encoding instruction SHALL NOT be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単純コンテンツエンコード命令の対象となるNamedTypeの種類の基本型があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a SET or SET OF type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）セット又はタイプのセット、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a CHOICE type where the ChoiceType is not subject to a UNION encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）ChoiceTypeはUNION符号化命令を受けないCHOICE型、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）[RXER（すなわち、QNameのが許可されている）AdditionalBasicDefinitionsモジュールからのQNameタイプを定義以外のSEQUENCEタイプ、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）SequenceOfTypeリスト符号化命令を受けないタイプのシーケンス、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(5) an open type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（5）開放型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the type of a NamedType subject to a SIMPLE-CONTENT encoding instruction has abstract values with an empty character data translation [RXER] (i.e., an empty encoding), then the NamedType SHALL NOT be marked OPTIONAL or DEFAULT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SIMPLE-CONTENT符号化命令にNamedType対象の種類が空の文字データ変換[RXER（すなわち、空の符号化）と抽象値を持つ場合、NamedTypeはOPTIONALまたはDEFAULTマークされないもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { units [ATTRIBUTE] UTF8String, amount [SIMPLE-CONTENT] INTEGER }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {ユニット[ATTRIBUTE] UTF8Stringを、量[SIMPLE-CONTENT] INTEGER}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. The TARGET-NAMESPACE Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.ターゲット名前空間エンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TARGET-NAMESPACE encoding instruction associates an XML namespace name [XMLNS10], a URI [URI], with the type, object class, value, object, and object set references defined in the ASN.1 module containing the encoding instruction. In addition, it associates the namespace name with each top-level NamedType in the RXER encoding control section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TARGET名前空間符号化命令は、符号化命令を含むASN.1モジュールで定義された型、オブジェクトクラス、値、オブジェクト、およびオブジェクトセットの参照で、XML名前空間名[XMLNS10]、URI [URI]を関連付けます。また、RXER符号化制御部内の各トップレベルNamedTypeと名前空間名を関連付けます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a TARGET-NAMESPACE encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにTARGET名前空間符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      TargetNamespaceInstruction ::=
          &#34;TARGET-NAMESPACE&#34; AnyURIValue Prefix ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Prefix ::= &#34;PREFIX&#34; NCNameValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The AnyURIValue SHALL NOT specify an empty string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AnyURIValueは、空の文字列を指定してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (target namespace): If an ASN.1 module contains a TARGET-NAMESPACE encoding instruction, then the target namespace of the module is the character string specified by the AnyURIValue of the TARGET-NAMESPACE encoding instruction; otherwise, the target namespace of the module is said to be absent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（ターゲット名前空間）：ASN.1モジュールはTARGET-NAMESPACEエンコーディング命令が含まれている場合、モジュールのターゲット名前空間は、TARGET-NAMESPACEエンコーディング命令のAnyURIValueで指定した文字列です。そうでない場合、モジュールのターゲット名前空間が存在しないと言われています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Two or more ASN.1 modules MAY have the same non-absent target namespace if and only if the expanded names of the top-level attribute components are distinct across all those modules, the expanded names of the top-level element components are distinct across all those modules, and the defined type, object class, value, object, and object set references are distinct in their category across all those modules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トップレベルの属性要素の拡大名はすべて、これらのモジュール間で異なっている場合にのみ、トップレベルの要素部品の拡大名称は全体異なっている場合、2つの以上のASN.1モジュールは、同じ非不在のターゲット名前空間を持っているかもしれませんこれらすべてのモジュール、および定義された型、オブジェクトクラス、値、オブジェクト、およびオブジェクト・セットの参考文献はすべて、それらのモジュール間でそれらのカテゴリに区別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Prefix, if present, suggests an NCName to use as the namespace prefix in namespace declarations involving the target namespace. An RXER encoder is not obligated to use the nominated namespace prefix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プレフィックスは、存在する場合、NCNameでは、ターゲット名前空間を含む名前空間宣言で名前空間接頭辞として使用することを示唆しています。 RXERエンコーダがノミネート名前空間接頭辞を使用する義務を負いません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If there are no top-level components, then the RXER encodings produced using a module with a TARGET-NAMESPACE encoding instruction are backward compatible with the RXER encodings produced by the same module without the TARGET-NAMESPACE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ないトップレベルのコンポーネントが存在しない場合、ターゲット名前空間符号化命令でモジュールを使用して製造RXERエンコーディングは、ターゲット名前空間符号化命令なしで同じモジュールによって生成RXERエンコーディングとの後方互換性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. The TYPE-AS-VERSION Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. TYPE-AS-VERSIONエンコーディング命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TYPE-AS-VERSION encoding instruction causes an RXER encoder to include an xsi:type attribute in the encoding of a value of the component to which the encoding instruction is applied. This attribute allows an XML Schema [XSD1] validator to select, if available, the appropriate XML Schema translation for the version of the ASN.1 specification used to create the encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
符号化命令が適用された成分の値の符号化にtype属性：TYPE-ASバージョンの符号化命令はXSIを含むようにRXERエンコーダを引き起こします。この属性は、選択するためのXMLスキーマ[XSD1]バリデータ、利用可能な場合、エンコーディングを作成するために使用されるASN.1仕様のバージョンに適したXMLスキーマ変換することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Translations of an ASN.1 specification into a compatible XML Schema are expected to be slightly different across versions because of progressive extensions to the ASN.1 specification. Any incompatibilities between these translations can be accommodated if each version uses a different target namespace. The target namespace will be evident in the value of the xsi:type attribute and will cause an XML Schema validator to use the appropriate version. This mechanism also accommodates an ASN.1 type that is renamed in a later version of the ASN.1 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：互換性のあるXMLスキーマにASN.1仕様の翻訳が原因ASN.1仕様プログレッシブ拡張のバージョン間でわずかに異なることが予想されます。各バージョンは、異なるターゲット名前空間を使用している場合、これらの変換の間の任意の非互換性を収容することができます。ターゲット名前空間は、XSIの値は明らかであろう：type属性およびXML Schemaのバリデータは、適切なバージョンを使用するようになります。この機構はまた、ASN.1仕様のバージョンで名前が変更されたASN.1タイプを収容します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a TYPE-AS-VERSION encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにTYPE-ASバージョンの符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      TypeAsVersionInstruction ::= &#34;TYPE-AS-VERSION&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in a NamedType that is subject to a TYPE-AS-VERSION encoding instruction MUST be a namespace-qualified reference [RXER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TYPE-ASバージョンの符号化命令を受けるNamedTypeを入力は、名前空間で修飾参照[RXER]でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The addition of a TYPE-AS-VERSION encoding instruction does not affect the backward compatibility of RXER encodings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TYPE-AS-VERSIONエンコーディング命令の追加はRXERエンコーディングの後方互換性に影響を与えることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: In a translation of an ASN.1 specification into XML Schema, any Type in a NamedType that is subject to a TYPE-AS-VERSION encoding instruction is expected to be translated into the XML Schema anyType so that the xsi:type attribute acts as a switch to select the appropriate version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：タイプ作用属性：XSIのようにXMLスキーマanyType型に変換することが予想されるTYPE-ASバージョンの符号化指示の対象となるXMLスキーマ、NamedTypeにおける任意のタイプにASN.1仕様の訳スイッチとして適切なバージョンを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. The TYPE-REF Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20 TYPE-REFエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The TYPE-REF encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to a specific XML Schema named type, RELAX NG named pattern or an ASN.1 defined type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TYPE-REF符号化命令はNGという名前のパターン又はASN.1定義型をRELAX、タイプという名前の特定のXMLスキーマに準拠するように制限されるマークアップASN.1型の値を生じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Referencing an ASN.1 type in a TYPE-REF encoding instruction does not have the effect of imposing a requirement to preserve the Infoset [INFOSET] representation of the RXER encoding of an abstract value of the type. It is still sufficient to preserve just the abstract value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：TYPE-REF符号化命令にASN.1タイプを参照すると、型の抽象値のRXERエンコードのインフォセット[INFOSET]表現を維持するための要件を課すという効果を有していません。まだ単なる抽象的価値を維持するのに十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a TYPE-REF encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにTYPE-REF符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      TypeRefInstruction ::= &#34;TYPE-REF&#34; QNameValue RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Taken together, the QNameValue and the ContextParameter of the RefParameters (if present) MUST reference an XML Schema named type, a RELAX NG named pattern, or an ASN.1 defined type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一緒になって、QNameの値とrefパラメータのコンテキストパラメータ（存在する場合）は、タイプという名前のXMLスキーマ、RELAX NG名前パターン、またはASN.1定義された型を参照しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A referenced XML Schema type MUST NOT require the presence of values for the XML Schema ENTITY or ENTITIES types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参照されるXMLスキーマ型は、XMLスキーマENTITYまたはENTITIES種類の値の存在を要求してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Entity declarations are not supported by CRXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：エンティティ宣言はCRXERによってサポートされていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The QNameValue SHALL NOT be a direct reference to the XML Schema NOTATION type [XSD2] (i.e., the namespace name &#34;http://www.w3.org/2001/XMLSchema&#34; and local name &#34;NOTATION&#34;); however, a reference to an XML Schema type derived from the NOTATION type is permitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
QNameValueは[XSD2（すなわち、名前空間名「http://www.w3.org/2001/XMLSchema」とローカル名「NOTATION」）XMLスキーマ表記タイプを直接参照してはなりません。ただし、表記タイプに由来するXMLスキーマ・タイプへの参照が許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: This restriction is to ensure that the lexical space [XSD2] of the referenced type is actually populated with the names of notations [XSD1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
余談：この制限は、参照型の字句空間【XSD2]が実際に表記の名前[XSD1]が移入されていることを保証することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      MyDecimal ::=
          [TYPE-REF {
              namespace-name &#34;http://www.w3.org/2001/XMLSchema&#34;,
              local-name     &#34;decimal&#34; }]
          Markup
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the ASN.X translation of this ASN.1 type definition provides a more natural way to reference the XML Schema decimal type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このASN.1型定義のASN.Xの翻訳は、XMLスキーマの小数点型を参照するために、より自然な方法を提供することに注意してください：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;namedType xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34; name=&#34;MyDecimal&#34;&gt; &lt;type ref=&#34;xs:decimal&#34; embedded=&#34;true&#34;/&gt; &lt;/namedType&gt;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&lt;namedTypeのxmlns：XS = &#34;http://www.w3.org/2001/XMLSchema&#34; 名前= &#34;MyDecimal&#34;&gt; &lt;タイプREF = &#34;XS：小数点以下&#34; 組込み= &#34;真&#34; /&gt; &lt;/ namedType&gt;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. The UNION Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. UNIONエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The UNION encoding instruction causes an RXER encoder to encode the value of an alternative of a CHOICE type without encapsulation in a child element. The chosen alternative is optionally indicated with a member attribute. The optional PrecedenceList also allows a specification writer to alter the order in which an RXER decoder will consider the alternatives of the CHOICE as it determines which alternative has been used (if the actual alternative has not been specified through the member attribute).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNIONエンコード命令は、子要素にカプセル化することなく、CHOICE型の代替の値を符号化するRXERエンコーダを引き起こします。選択された代替は、必要に応じてメンバー属性で示されています。任意PrecedenceListはまた、仕様ライタは、それが（実際の代替メンバー属性を使用して指定されていない場合）に使用された別の決定としてRXERデコーダはCHOICEの代替案を検討する順序を変更することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a UNION encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにUNION符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      UnionInstruction ::= &#34;UNION&#34; AlternativesPrecedence ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      AlternativesPrecedence ::= &#34;PRECEDENCE&#34; PrecedenceList
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      PrecedenceList ::= identifier PrecedenceList ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in the EncodingPrefixedType for a UNION encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれかでなければならないUNIONエンコーディング命令のEncodingPrefixedTypeを入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a BuiltinType that is a ChoiceType, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）ChoiceTypeあるBuiltinType、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）ConstrainedType中タイプの一つである制約を有するタイプではない制約タイプ（1）〜（4）、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）TaggedType中タイプの一つであるTaggedTypeがPrefixedTypeであるBuiltinType（1）〜（4）、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）EncodingPrefixedTypeにおけるタイプ（1）〜（4）のいずれかであるEncodingPrefixedType PrefixedTypeあるBuiltinType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ChoiceType in case (1) is said to be &#34;subject to&#34; the UNION encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（1）においてChoiceTypeはUNION符号化命令「対象」であると言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The base type of the type of each alternative of a ChoiceType that is subject to a UNION encoding instruction SHALL NOT be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNION符号化指示の対象となるChoiceTypeの各代替の種類の基本型があってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a CHOICE, SET, or SET OF type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）CHOICE、SET、またはタイプのセット、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）[RXER（すなわち、QNameのが許可されている）AdditionalBasicDefinitionsモジュールからのQNameタイプを定義以外のSEQUENCEタイプ、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）SequenceOfTypeリスト符号化命令を受けないタイプのシーケンス、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) an open type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）オープンタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each identifier in the PrecedenceList MUST be the identifier of a NamedType in the ChoiceType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
PrecedenceList内の各識別子はChoiceTypeでNamedTypeの識別子でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A particular identifier SHALL NOT appear more than once in the same PrecedenceList.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特定の識別子は同じPrecedenceListで複数回表示されないものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Every NamedType in a ChoiceType that is subject to a UNION encoding instruction MUST NOT be subject to an ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, or TYPE-AS-VERSION encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
UNIONのエンコード命令の対象となるChoiceType内のすべてのNamedTypeはATTRIBUTEの対象にはならない（MUST NOT）、ATTRIBUTE-REF、COMPONENT-REF、GROUP、ELEMENT-REF、REF-AS-ELEMENT、SIMPLE-CONTENT、またはTYPE-AS- VERSIONエンコーディング命令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[UNION PRECEDENCE basicName] CHOICE { extendedName UTF8String, basicName PrintableString }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[UNION優先basicName] CHOICE {extendedName UTF8Stringを、basicNameはPrintableString}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. The VALUES Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. VALUESエンコーディング命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The VALUES encoding instruction causes an RXER encoder to use nominated names instead of the identifiers that would otherwise appear in the encoding of a value of a BIT STRING, ENUMERATED, or INTEGER type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VALUES符号化命令ではなく、そうでなければ、ビット列列挙、または整数型の値の符号化に現れる識別子の指名名を使用するRXERエンコーダを引き起こします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a VALUES encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のように値をコード命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ValuesInstruction ::=
          &#34;VALUES&#34; AllValuesMapped ? ValueMappingList ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      AllValuesMapped ::= AllCapitalized | AllUppercased
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      AllCapitalized ::= &#34;ALL&#34; &#34;CAPITALIZED&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      AllUppercased ::= &#34;ALL&#34; &#34;UPPERCASED&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ValueMappingList ::= ValueMapping ValueMappingList ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      ValueMapping ::= &#34;,&#34; identifier &#34;AS&#34; NCNameValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in the EncodingPrefixedType for a VALUES encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれかでなければならないVALUESエンコーディング命令のEncodingPrefixedTypeを入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a BuiltinType that is a BitStringType with a NamedBitList, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）NamedBitListとBitStringTypeあるBuiltinType、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a BuiltinType that is an EnumeratedType, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）EnumeratedTypeあるBuiltinType、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a BuiltinType that is an IntegerType with a NamedNumberList, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）NamedNumberListとIntegerTypeあるBuiltinType、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (6), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）ConstrainedType中タイプの一つである制約を有するタイプではない制約タイプ（1）〜（6）、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(5) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (6), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（5）TaggedTypeにおけるタイプ（1）〜（6）のいずれかであるTaggedType PrefixedTypeあるBuiltinType、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(6) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（6）EncodingPrefixedTypeにおけるタイプ（1）〜（6）のいずれかであるEncodingPrefixedType PrefixedTypeあるBuiltinType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The effect of this condition is to force the VALUES encoding instruction to be textually co-located with the type definition to which it applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この条件の効果はテキストで、それが適用される型定義と同じ場所に配置する値符号化命令を強制することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The BitStringType, EnumeratedType, or IntegerType in case (1), (2), or (3), respectively, is said to be &#34;subject to&#34; the VALUES encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それぞれBitStringType、EnumeratedType、又はIntegerType（1）の場合に、（2）又は（3）は、命令をコードVALUES &#34;対象&#34; であると言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A BitStringType, EnumeratedType, or IntegerType SHALL NOT be subject to more than one VALUES encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
BitStringType、EnumeratedType、またはIntegerTypeは、複数のVALUES符号化命令を受けてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each identifier in a ValueMapping MUST be an identifier appearing in the NamedBitList, Enumerations, or NamedNumberList, as the case may be.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合によってはValueMapping内の各識別子は、NamedBitList、列挙型、またはNamedNumberListに現れる識別子でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The identifier in a ValueMapping SHALL NOT be the same as the identifier in any other ValueMapping for the same ValueMappingList.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ValueMapping内の識別子は同じValueMappingListするための任意の他のValueMapping内の識別子と同じであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (replacement name): Each identifier in a BitStringType, EnumeratedType, or IntegerType subject to a VALUES encoding instruction has a replacement name. If there is a ValueMapping for the identifier, then the replacement name is the character string specified by the NCNameValue in the ValueMapping; else if AllCapitalized is used, then the replacement name is the identifier with the first character uppercased; else if AllUppercased is used, then the replacement name is the identifier with all its characters uppercased; otherwise, the replacement name is the identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（代替名）：VALUES符号化命令にBitStringType、EnumeratedType、又はIntegerType対象の各識別子は、代替名を有しています。識別子のValueMappingがある場合は、交換用の名前がValueMappingでNCNameValueで指定した文字列です。 AllCapitalizedが使用されている他の場合には、代替名は大文字に最初の文字と識別子です。他AllUppercasedが使用されている場合は、代替名は大文字にすべての文字を識別子です。そうでない場合は、代替名は識別子です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The replacement names for the identifiers in a BitStringType subject to a VALUES encoding instruction MUST be distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VALUES符号化命令にBitStringType対象における識別子の代替名は別個でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The replacement names for the identifiers in an EnumeratedType subject to a VALUES encoding instruction MUST be distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VALUES符号化命令にEnumeratedType対象における識別子の代替名は別個でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The replacement names for the identifiers in an IntegerType subject to a VALUES encoding instruction MUST be distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VALUES符号化命令にIntegerType対象における識別子の代替名は別個でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      Traffic-Light ::= [VALUES ALL CAPITALIZED, red AS &#34;RED&#34;]
          ENUMERATED {
              red,    -- Replacement name is RED.
              amber,  -- Replacement name is Amber.
              green   -- Replacement name is Green.
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23. Insertion Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23.挿入エンコード手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Certain of the RXER encoding instructions are categorized as insertion encoding instructions. The insertion encoding instructions are the NO-INSERTIONS, HOLLOW-INSERTIONS, SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, and MULTIFORM-INSERTIONS encoding instructions (whose notations are described respectively by NoInsertionsInstruction, HollowInsertionsInstruction, SingularInsertionsInstruction, UniformInsertionsInstruction, and MultiformInsertionsInstruction).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RXERエンコーディング命令の一部は挿入エンコードの命令として分類されます。挿入エンコード命令は、NO-挿入、中空挿入、単数-挿入、均一挿入、および（表記NoInsertionsInstruction、HollowInsertionsInstruction、SingularInsertionsInstruction、UniformInsertionsInstruction、及びMultiformInsertionsInstructionによってそれぞれ記載されている）多形、挿入符号化命令です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for the insertion encoding instructions is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のように挿入エンコード命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      InsertionsInstruction ::=
          NoInsertionsInstruction |
          HollowInsertionsInstruction |
          SingularInsertionsInstruction |
          UniformInsertionsInstruction |
          MultiformInsertionsInstruction
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      NoInsertionsInstruction ::= &#34;NO-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      HollowInsertionsInstruction ::= &#34;HOLLOW-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      SingularInsertionsInstruction ::= &#34;SINGULAR-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      UniformInsertionsInstruction ::= &#34;UNIFORM-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      MultiformInsertionsInstruction ::= &#34;MULTIFORM-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Using the GROUP encoding instruction on components with extensible types can lead to situations where an unknown extension could be associated with more than one extension insertion point. The insertion encoding instructions remove this ambiguity by limiting the form that extensions can take. That is, the insertion encoding instructions indicate what extensions can be made to an ASN.1 specification without breaking forward compatibility for RXER encodings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張可能なタイプのコンポーネントのグループ符号化命令を使用して、未知の拡張は、複数の拡張挿入ポイントに関連付けすることができる状況につながる可能性があります。挿入エンコーディング命令拡張が取ることができるという形を制限することによって、この曖昧さを取り除きます。つまり、挿入のエンコード命令は、拡張子がRXERエンコーディングのための前方互換性を壊すことなく、ASN.1仕様にすることができるものを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Forward compatibility means the ability for a decoder to successfully decode an encoding containing extensions introduced into a version of the specification that is more recent than the one used by the decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：フォワード互換性が正常に復号器によって使用されるものよりも新しい仕様のバージョンに導入された拡張機能を含む符号を復号する復号器の能力を意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the most general case, an extension to a CHOICE, SET, or SEQUENCE type will generate zero or more attributes and zero or more elements, due to the potential use of the GROUP and ATTRIBUTE encoding instructions by the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最も一般的な場合では、CHOICE、SET、または配列型への拡張が原因拡張によるグループ属性エンコード命令の潜在的な使用のために、ゼロ以上の属性及びゼロ以上の要素を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The MULTIFORM-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of one or more elements and zero or more attributes. No restriction is placed on the names of the elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
多形-挿入エンコード命令は、タイプに前方互換性の拡張によって生成RXERエンコーディングは、常に1つの以上の要素、ゼロ以上の属性で構成されることを示します。制限は、要素の名前の上に置かれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Of necessity, the names of the attributes will all be different in any given encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：必然的に、属性の名前は、すべての任意のエンコーディングに異なるものになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The UNIFORM-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of one or more elements having the same expanded name, and zero or more attributes. The expanded name shared by the elements in one particular encoding is not required to be the same as the expanded name shared by the elements in any other encoding of the extension. For example, in one encoding of the extension the elements might all be called &#34;foo&#34;, while in another encoding of the extension they might all be called &#34;bar&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
均一挿入エンコード命令は、タイプに前方互換性の拡張によって生成RXERエンコーディングが常に同じ拡張名を有する1つのまたは複数の要素、およびゼロ以上の属性で構成されることを示します。一つの特定の符号化の要素によって共有拡張名は、拡張子の任意の他の符号化の要素によって共有拡張名と同じである必要はありません。延長の別のエンコードで、彼らはすべての「バー」と呼ばれるかもしれないが例えば、拡張子の1つのエンコーディングの要素はすべて、「foo」という呼ばれるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SINGULAR-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of a single element and zero or more attributes. The name of the single element is not required to be the same in every possible encoding of the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特異挿入エンコード命令は、タイプに前方互換性の拡張によって生成RXERエンコーディングは、常に単一の要素およびゼロ以上の属性で構成されることを示します。単一要素の名前は、拡張子のすべての可能な符号化で同じである必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The HOLLOW-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of zero elements and zero or more attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
中空挿入エンコード命令は、タイプに前方互換性の拡張によって生成RXERエンコーディングは常にゼロ要素及びゼロ以上の属性で構成されることを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NO-INSERTIONS encoding instruction indicates that no forward-compatible extensions can be made to a type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NO-挿入符号化命令には前方互換性拡張が型に行われないことができることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples of forward-compatible extensions are provided in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上位互換性の拡張機能の例は、付録Cで提供されています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in the EncodingPrefixedType for an insertion encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
挿入エンコード命令のEncodingPrefixedTypeにおけるタイプのいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a BuiltinType that is a ChoiceType where the ChoiceType is not subject to a UNION encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）ChoiceTypeはUNION符号化命令を受けないChoiceTypeであるBuiltinType、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a BuiltinType that is a SequenceType or SetType, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）SequenceType又ははsetType、またはあるBuiltinType
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (5), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）ConstrainedType中タイプの一つである制約を有するタイプではない制約タイプ（1）〜（5）、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (5), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）TaggedType中タイプの一つであるTaggedTypeがPrefixedTypeであるBuiltinType（1）〜（5）、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(5) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（5）EncodingPrefixedTypeにおけるタイプ（1）〜（5）のいずれかであるEncodingPrefixedType PrefixedTypeあるBuiltinType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Case (2) is not permitted when the insertion encoding instruction is the SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, or MULTIFORM-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
挿入エンコード命令が特異-挿入、均一挿入、または多形-挿入符号化命令である場合にケース（2）が許可されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Because extensions to a SET or SEQUENCE type are serial and effectively optional, the SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, and MULTIFORM-INSERTIONS encoding instructions offer no advantage over unrestricted extensions (for a SET or SEQUENCE). For example, an optional series of singular insertions generates zero or more elements and zero or more attributes, just like an unrestricted extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：SETまたはSEQUENCEタイプの拡張は、シリアルおよび有効オプションであるので、単数-挿入、均一挿入、及び多形-挿入エンコード命令は、（SET又は配列について）無制限の拡張に対して何ら利点を提供しません。例えば、特異挿入の任意一連だけ無制限の拡張のような、ゼロまたはそれ以上の要素およびゼロ以上の属性を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in case (1) or case (2) is said to be &#34;subject to&#34; the insertion encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（1）又は場合のタイプ（2）の挿入符号化命令「対象」であると言われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Type in case (1) or case (2) MUST be extensible, either explicitly or by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（1）またはケース（2）を入力は明示的にまたはデフォルトでは、拡張可能でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Type SHALL NOT be subject to more than one insertion encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイプは、複数の挿入エンコードの指示を受けてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The insertion encoding instructions indicate what kinds of extensions can be made to a type without breaking forward compatibility, but they do not prohibit extensions that do break forward compatibility. That is, it is not an error for a type&#39;s base type to contain extensions that do not satisfy an insertion encoding instruction affecting the type. However, if any such extensions are made, then a new value SHOULD be introduced into the extensible set of permitted values for a version indicator attribute, or attributes (see Section 24), whose scope encompasses the extensions. An example is provided in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
挿入エンコーディング命令は上位互換性を壊すことなく形にすることができる拡張の種類を示しているが、彼らは休憩前方互換性を行う拡張を禁止していません。つまり、タイプに影響を与える挿入エンコードの指示を満たしていない拡張機能が含まれているために、型の基底型のエラーではない、です。このような拡張が行われている場合は、新しい値は、範囲の拡張を含むバージョンインジケータ属性、または属性の許容値（セクション24を参照）の拡張可能なセットに導入されるべきです。例は、付録Cで提供されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24. The VERSION-INDICATOR Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24. VERSION-INDICATORエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The VERSION-INDICATOR encoding instruction provides a mechanism for RXER decoders to be alerted that an encoding contains extensions that break forward compatibility (see the preceding section).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VERSIONインジケータ符号化命令は、符号化は、互換性（前のセクションを参照）を前方に破壊拡張が含まれていることを警告するRXERデコーダのための機構を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a VERSION-INDICATOR encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにVERSIONインジケータ符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      VersionIndicatorInstruction ::= &#34;VERSION-INDICATOR&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A NamedType that is subject to a VERSION-INDICATOR encoding instruction MUST also be subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VERSIONインジケータ符号化指示の対象となるNamedTypeもATTRIBUTE符号化命令に従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The type of the NamedType that is subject to the VERSION-INDICATOR encoding instruction MUST be directly or indirectly a constrained type where the set of permitted values is defined to be extensible. Each value represents a different version of the ASN.1 specification. Ordinarily, an application will set the value of a version indicator attribute to be the last of these permitted values. An application MAY set the value of the version indicator attribute to the value corresponding to an earlier version of the specification if it has not used any of the extensions added in a subsequent version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
VERSIONインジケータ符号化指示の対象となるNamedTypeのタイプは、直接的または間接的に許可される値のセットは拡張可能であると定義される拘束型である必要があります。各値はASN.1仕様の異なるバージョンを表します。通常、アプリケーションは、これらの許可された値の最後であることをバージョンインジケータ属性の値を設定します。それは、その後のバージョンで追加の拡張機能のいずれかを使用していない場合、アプリケーションは、明細書の以前のバージョンに対応する値にバージョンインジケータ属性の値を設定してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an RXER decoder encounters a value of the type that is not one of the root values or extension additions (but that is still allowed since the set of permitted values is extensible), then this indicates that the decoder is using a version of the ASN.1 specification that is not compatible with the version used to produce the encoding. In such cases, the decoder SHOULD treat the element containing the attribute as having an unknown ASN.1 type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RXERデコーダはルート値または拡張の追加の一つではない（ただし、許可された値のセットは拡張可能であるので、それがまだ許可されている）タイプの値を検出した場合、これはデコーダがASNのバージョンを使用していることを示し符号を生成するために使用されるバージョンと互換性がありません.1仕様。このような場合には、デコーダは、未知のASN.1型を有するように、属性を含む要素を扱うべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: A version indicator attribute only indicates an incompatibility with respect to RXER encodings. Other encodings are not affected because the GROUP encoding instruction does not apply to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：バージョンインジケータ属性はRXERエンコーディングに関して互換性がないことを示しています。 GROUPエンコーディング命令はそれらに適用されないので、他のエンコーディングは影響を受けません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this first example, the decoder is using an incompatible older version if the value of the version attribute in a received RXER encoding is not 1, 2, or 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この最初の例では、デコーダは、受信されたRXER符号化におけるバージョン属性の値が1でない場合、互換性のない古いバージョンを使用して、2、又は3です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { version [ATTRIBUTE] [VERSION-INDICATOR] INTEGER (1, ..., 2..3), message MessageType }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {バージョン[ATTRIBUTE] [VERSION-INDICATOR] INTEGER（1、...、2..3）、メッセージのMessageType}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this second example, the decoder is using an incompatible older version if the value of the format attribute in a received RXER encoding is not &#34;1.0&#34;, &#34;1.1&#34;, or &#34;2.0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信RXER符号化におけるformat属性の値がない「1.0」、「1.1」、または「2.0」である場合には、この第2の例では、デコーダは、互換性のない古いバージョンを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { format [ATTRIBUTE] [VERSION-INDICATOR] UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34; | &#34;2.0&#34;), message MessageType }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {フォーマット[ATTRIBUTE] [VERSION-INDICATOR] UTF8Stringを（ &#34;1.0&#34;、...、 &#34;1.1&#34; | &#34;2.0&#34;）、メッセージのMessageType}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An extensive example is provided in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
広範な例は、付録Cに設けられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is not necessary for every extensible type to have its own version indicator attribute. It would be typical for only the types of top-level element components to include a version indicator attribute, which would serve as the version indicator for all of the nested components.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての拡張可能なタイプは、独自のバージョンインジケータ属性を持っていることは必要ありません。トップレベルの要素部品の種類のみが、ネストされたコンポーネントのすべてのバージョンインジケータとして役立つバージョンインジケータ属性を含むことが典型的であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25. The GROUP Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25. GROUPエンコード命令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The GROUP encoding instruction causes an RXER encoder to encode a value of the component to which it is applied without encapsulation as an element. It allows the construction of non-trivial content models for element content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ符号化命令は、それが構成要素としてカプセル化することなく、適用された成分の値を符号化するためにRXERエンコーダを引き起こします。これは、要素の内容のための非自明な内容モデルの構築を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The notation for a GROUP encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにグループ符号化命令の表記法が定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      GroupInstruction ::= &#34;GROUP&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The base type of the type of a NamedType that is subject to a GROUP encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ符号化指示の対象となるNamedTypeの種類の基本型のいずれかでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a SEQUENCE, SET, or SET OF type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）配列、SET、またはタイプのセット、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a CHOICE type where the ChoiceType is not subject to a UNION encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）ChoiceTypeはUNION符号化命令を受けないCHOICE型、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）SequenceOfTypeリスト符号化命令を受けないタイプのシーケンス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The SEQUENCE type in case (1) SHALL NOT be the associated type for a built-in type, SHALL NOT be a type from the AdditionalBasicDefinitions module [RXER], and SHALL NOT contain a component that is subject to a SIMPLE-CONTENT encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合のシーケンスタイプ（1）内蔵型のために関連するタイプであってはならない、AdditionalBasicDefinitionsモジュール[RXER]からタイプであってはならない、と単純コンテンツエンコード命令の対象となる成分を含んではなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Thus, the CHARACTER STRING, EMBEDDED PDV, EXTERNAL, REAL, and QName types are excluded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：したがって、文字列は、組み込みPDV、EXTERNAL、REAL、およびQNameのタイプは除外されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The CHOICE type in case (2) SHALL NOT be a type from the AdditionalBasicDefinitions module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（2）内のCHOICE型はAdditionalBasicDefinitionsモジュールからのタイプであってはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Thus, the Markup type is excluded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：したがって、マークアップの種類は除外されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (visible component): Ignoring all type constraints, the visible components for a type that is directly or indirectly a combining ASN.1 type (i.e., SEQUENCE, SET, CHOICE, SEQUENCE OF, or SET OF) is the set of components of the combining type definition plus, for each NamedType (of the combining type definition) that is subject to a GROUP encoding instruction, the visible components for the type of the NamedType. The visible components are determined after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（可視成分）：すべてのタイプの制約を無視し、直接または間接的に結合ASN.1タイプ（すなわち、SEQUENCE、SET、CHOICE、一連の、または一組）であるタイプの可視コンポーネントは、構成要素のセットでありますグループ符号化命令、NamedTypeのタイプの可視コンポーネントを受ける（結合型定義の）各NamedTypeための結合型定義に加え、。可視成分は、X.680、節24.4 [X.680]で指定された変換の構成要素の後に決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: The set of visible attribute and element components for a type is the set of all the components of the type, and any nested types, that describe attributes and child elements appearing in the RXER encodings of values of the outer type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：タイプの可視属性と要素コンポーネントのセットは、属性と外型の値のRXERエンコーディングに現れる子要素について説明し、すべてのタイプの構成要素、およびネストされたタイプのセットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A GROUP encoding instruction MUST NOT be used where it would cause a NamedType to be a visible component of the type of that same NamedType (which is only possible if the type definition is recursive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはNamedTypeは（タイプ定義が再帰的である場合にのみ可能である）は同じNamedTypeのタイプの可視成分であることが原因となる場合GROUPエンコード命令を使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Components subject to a GROUP encoding instruction might be translated into a compatible XML Schema [XSD1] as group definitions. A NamedType that is visible to its own type is analogous to a circular group, which XML Schema disallows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：グループ符号化命令を受けるコンポーネントは、互換性のあるXMLスキーマ[XSD1]としてグループ定義に翻訳されるかもしれません。独自のタイプに見えるNamedTypeは、XMLスキーマが禁止円形基に類似しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 25.1 imposes additional conditions on the use of the GROUP encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション25.1は、GROUPエンコーディング命令の使用に関する追加条件を課します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In any use of the GROUP encoding instruction, there is a type, the including type, that contains the component subject to the GROUP encoding instruction, and a type, the included type, that is the base type of that component. Either type can have an extensible content model, either by directly using ASN.1 extensibility or by including through another GROUP encoding instruction some other type that is extensible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ符号化命令の使用において、タイプがあり、グループ符号化命令に構成被写体が含ま含むタイプ、およびタイプ、含まれるタイプ、すなわち、そのコンポーネントの基本型です。どちらのタイプは、直接ASN.1の拡張を使用して、または別の基の符号化命令を介して拡張可能であり、いくつかの他のタイプを含むいずれかによって、拡張可能なコンテンツ・モデルを有することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The including and included types may be defined in different ASN.1 modules, in which case the owner of the including type, i.e., the person or organization having the authority to add extensions to the including type&#39;s definition, may be different from the owner of the included type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
含め、付属のタイプは、その場合には含めタイプの所有者は、すなわち、含むタイプの定義に拡張子を追加する権限を有する個人または組織は、所有者と異なる場合があり、異なるASN.1モジュールで定義されるかもしれ含まタイプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the owner of the including type is not using the most recent version of the included type&#39;s definition, then the owner of the including type might add an extension to the including type that is valid with respect to the older version of the included type, but is later found to be invalid when the latest versions of the including and included type definitions are brought together (perhaps by a third party). Although the owner of the including type must necessarily be aware of the existence of the included type, the reverse is not necessarily true. The owner of the included type could add an extension to the included type without realizing that it invalidates someone else&#39;s including type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
含むタイプの所有者が含まタイプの定義の最新バージョンを使用していない場合は、を含むタイプの所有者は、付属のタイプの旧バージョンに対する有効であるなどの種類に拡張子を追加するかもしれませんが、後で含め、付属の型定義の最新バージョンは、（おそらく第三者によって）一緒にされたときに無効であることが判明しました。含むタイプは必ずしも含まタイプの存在を知っていなければならないの所有者が、その逆は必ずしも真ではありません。含まタイプの所有者は、それが形を含めています他の誰かを無効にすることを実現することなく含まタイプに拡張子を追加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To avoid these problems, a GROUP encoding instruction MUST NOT be used if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの問題を回避するには、GROUPのエンコード命令があれば使用してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) the included type is defined in a different module from the including type, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）付属タイプを含むタイプから別のモジュールに定義され、そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) the included type has an extensible content model, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）含まれるタイプは、拡張コンテンツモデルを有し、そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) changes to the included type are not coordinated with the owner of the including type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）を含むタイプの変更を含むタイプの所有者と協調していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Changes in the included type are coordinated with the owner of the including type if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
含まタイプの変更は、次の場合を含む型の所有者と調整されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) the owner of the included type is also the owner of the including type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）付属タイプの所有者は、以下を含むタイプの所有者でもある、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) the owner of the including type is collaborating with the owner of the included type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）を含むタイプの所有者が含まれるタイプの所有者と協力して、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) all changes will be vetted by a common third party before being approved and published.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）すべての変更が承認され、公表される前に、一般的な第三者によって吟味されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1. Unambiguous Encodings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1。明確なエンコーディング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unregulated use of the GROUP encoding instruction can easily lead to specifications in which distinct abstract values have indistinguishable RXER encodings, i.e., ambiguous encodings. This section imposes restrictions on the use of the GROUP encoding instruction to ensure that distinct abstract values have distinct RXER encodings. In addition, these restrictions ensure that an abstract value can be easily decoded in a single pass without back-tracking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ符号化命令の無秩序な使用を容易に異なる抽象値は区別できないRXERエンコーディング、すなわち、あいまいなエンコーディングを持った仕様につながる可能性があります。このセクションでは、個別の抽象値が明確なRXERエンコーディングを持っていることを保証するために、GROUPエンコーディング命令の使用に制限を課しています。加えて、これらの制限は、抽象値を簡単バックトラッキングすることなく、単一パスで復号することができることを確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An RXER decoder for an ASN.1 type can be abstracted as a recognizer for a notional language, consisting of element and attribute expanded names, where the type definition describes the grammar for that language (in fact it is a context-free grammar). The restrictions on a type definition to ensure easy, unambiguous decoding are more conveniently, completely, and simply expressed as conditions on this associated grammar. Implementations are not expected to verify type definitions exactly in the manner to be described; however, the procedure used MUST produce the same result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1タイプのRXERデコーダは、タイプ定義がその言語の文法を記述する要素と属性拡張名、（実際には、それは文脈自由文法である）からなる、概念的な言語の認識として抽象化することができます。型定義の制約が簡単、明確な復号がより便利に、完全に、単にこの関連文法上の条件のように表現されることを保証します。実装は、後述するように、正確に型定義を確認することが期待されていません。しかし、使用した手順は同じ結果を生成しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Section 25.1.1 describes the procedure for recasting as a grammar a type definition containing components subject to the GROUP encoding instruction. Sections 25.1.2 and 25.1.3 specify conditions that the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション25.1.1は、文法、グループ符号化指示の対象成分を含有する型定義を作り直すための手順を記載しています。セクション25.1.2および25.1.3は、条件を指定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
grammar must satisfy for the type definition to be valid. Section 25.1.4 describes how unrecognized attributes are accepted by the grammar for an extensible type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文法は有効であると型定義のために満たさなければなりません。セクション25.1.4は認識されていない属性は、拡張可能なタイプのための文法に受け入れられている方法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendices A and B have extensive examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録AおよびBは、広範な例を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.1. Grammar Construction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.1。文法建設
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   A grammar consists of a collection of productions.  A production has
   a left-hand side and a right-hand side (in this document, separated
   by the &#34;::=&#34; symbol).  The left-hand side (in a context-free grammar)
   is a single non-terminal symbol.  The right-hand side is a sequence
   of non-terminal and terminal symbols.  The terminal symbols are the
   lexical items of the language that the grammar describes.  One of the
   non-terminals is nominated to be the start symbol.  A valid sequence
   of terminals for the language can be generated from the grammar by
   beginning with the start symbol and repeatedly replacing any
   non-terminal with the right-hand side of one of the productions where
   that non-terminal is on the production&#39;s left-hand side.  The final
   sequence of terminals is achieved when there are no remaining
   non-terminals to replace.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: X.680 describes the ASN.1 basic notation using a context-free grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：X.680は、文脈自由文法を使用してASN.1の基本的な表記法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each NamedType has an associated primary and secondary non-terminal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各NamedTypeは、関連する一次および二次非末端を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: The secondary non-terminal for a NamedType is used when the base type of the type in the NamedType is a SEQUENCE OF type or SET OF type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：NamedTypeための非末端二はNamedTypeにおける型の基本型は、型または型のセットのシーケンスである場合に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each ExtensionAddition and ExtensionAdditionAlternative has an associated non-terminal. There is a non-terminal associated with the extension insertion point of each extensible type. There is also a primary start non-terminal (this is the start symbol) and a secondary start non-terminal. The exact nature of the non-terminals is not important, however all the non-terminals MUST be mutually distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ExtensionAdditionとExtensionAdditionAlternativeは、関連する非末端を有しています。各拡張可能型の拡張挿入点に関連付けられた非末端があります。プライマリスタート非末端（これは開始記号である）と、二次開始非終端もあります。非端末の正確な性質は重要ではない、しかし、すべての非端末が互いに異なるものでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is adequate for most of the examples in this document (though not in the most general case) for the primary non-terminal for a NamedType to be the identifier of the NamedType, for the primary start non-terminal to be S, for the non-terminals for the instances of ExtensionAddition and ExtensionAdditionAlternative to be E1, E2, E3, and so on, and for the non-terminals for the extension insertion points to be I1, I2, I3, and so on. The secondary non-terminals are labelled by appending a &#34;&#39;&#34; character to the primary non-terminal label, e.g., the primary and secondary start non-terminals are S and S&#39;, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（しない最も一般的な場合にも）NamedTypeの一次非末端NamedTypeがするための識別子のために、一次ためSであることが非終端開始それがために、このドキュメントの例の大部分に適していますExtensionAdditionとExtensionAdditionAlternativeのインスタンスの非端子はE1、E2、E3であると、等、及び拡張挿入ポイントの非端末用ようにI1、I2、I3であり、そしてします。二次非端子は「&#39;」を付加することによって標識される、それぞれ、一次非末端標識に文字を、例えば、一次および二次スタート非端子はSとSです]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Each NamedType and extension insertion point has an associated
   terminal.  There exists a terminal called the general extension
   terminal that is not associated with any specific notation.  The
   general extension terminal and the terminals for the extension
   insertion points are used to represent elements in unknown
   extensions.  The exact nature of the terminals is not important;
   however, the aforementioned terminals MUST be mutually distinct.  The
   terminals are further categorized as either element terminals or
   attribute terminals.  A terminal for a NamedType is an attribute
   terminal if its associated NamedType is an attribute component;
   otherwise, it is an element terminal.  The general extension terminal
   and the terminals for the extension insertion points are categorized
   as element terminals.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Terminals for attributes in unknown extensions are not explicitly provided in the grammar. Certain productions in the grammar are categorized as insertion point productions, and their role in accepting unknown attributes is described in Section 25.1.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
不明な拡張子の属性のための端子は、明示的文法で提供されていません。文法中の特定のプロダクションは、挿入ポイントの制作として分類され、そして未知の属性を受け入れるにおけるその役割は、セクション25.1.4に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the examples in this document, the terminal for a component other than an attribute component will be represented as the local name of the expanded name of the component enclosed in double quotes, and the terminal for an attribute component will be represented as the local name of the expanded name of the component prefixed by the &#39;@&#39; character and enclosed in double quotes. The general extension terminal will be represented as &#34;*&#34; and the terminals for the extension insertion points will be represented as &#34;*1&#34;, &#34;*2&#34;, &#34;*3&#34;, and so on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの例では、属性成分以外の成分のための端子は、二重引用符で囲まれた構成要素の拡張名のローカル名として表現され、属性コンポーネントの端子は、ローカル名として表されます「@」文字と二重引用符で囲んで始まるコンポーネントの拡張名の。一般的な内線端末は、「*」と表記され、拡張挿入点用端子はこれに「* 1」、「* 2」、「* 3」と表記し、説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The productions generated from a NamedType depend on the base type of the type of the NamedType. The productions for the start non-terminals depend on the combining type definition being tested. In either case, the procedure for generating productions takes a primary non-terminal, a secondary non-terminal (sometimes), and a type definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NamedTypeから生成された作品はNamedTypeの種類の基本タイプに依存します。スタート非端末の生産は、試験される結合型定義に依存します。いずれの場合においても、生産を生成するための手順は、一次非末端、二次（時々）非末端、および型定義をとります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The grammar is constructed beginning with the start non-terminals and the combining type definition being tested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文法は、スタート非端末とテストされている組み合わせ型定義で始まる構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A grammar is constructed after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文法は、X.680で指定された変換、条項24.4 [X.680]の構成要素の後に構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given a primary non-terminal, N, and a type where the base type is a SEQUENCE or SET type, a production is added to the grammar with N as the left-hand side. The right-hand side is constructed from an initial empty state according to the following cases considered in order: (1) If an initial RootComponentTypeList is present in the base type, then the sequence of primary non-terminals for the components nested in that RootComponentTypeList are appended to the right-hand side in the order of their definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非末端第一級N、および塩基型がSEQUENCEまたはSET型で型を与え、生産は左側としてNと文法に追加されます。右側は順に考慮される以下の場合に応じて初期の空の状態から構成されている：（1）初期RootComponentTypeListは基本型で存在する場合、コンポーネントの一次非末端の配列は、そのRootComponentTypeListにネストその定義の順に右側に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) If an ExtensionAdditions instance is present in the base type and not empty, then the non-terminal for the first ExtensionAddition nested in the ExtensionAdditions instance is appended to the right-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）ExtensionAdditionsインスタンスはベース型に存在し、空でない場合、次にExtensionAdditionsインスタンスにネスト第ExtensionAdditionための非末端は右側に追加されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) If an ExtensionAdditions instance is empty or not present in the base type, and the base type is extensible (explicitly or by default), and the base type is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the non-terminal for the extension insertion point of the base type is appended to the right-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）ExtensionAdditionsインスタンスは、ベース型で存在空かず、基本型は、（明示的またはデフォルトで）拡張可能であり、基本型は、次いで、NO-挿入または中空挿入エンコード命令を受けない場合ベース型の拡張挿入ポイントの非末端右側に追加されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) If a final RootComponentTypeList is present in the base type, then the primary non-terminals for the components nested in that RootComponentTypeList are appended to the right-hand side in the order of their definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（4）最終RootComponentTypeListはベース型に存在する場合、そのRootComponentTypeListにネストされたコンポーネントのための主要な非端末は、それらの定義のために右側に追加されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The production is an insertion point production if an ExtensionAdditions instance is empty or not present in the base type, and the base type is extensible (explicitly or by default), and the base type is not subject to a NO-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ExtensionAdditionsインスタンスが空であるか、ベース型には存在しない、および塩基型が（明示的またはデフォルトで）拡張可能であり、ベースタイプがNO-挿入エンコード命令を受けない場合に生産が挿入ポイントの生産です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a component in a ComponentTypeList (in either a RootComponentTypeList or an ExtensionAdditionGroup) is marked OPTIONAL or DEFAULT, then a production with the primary non-terminal of the component as the left-hand side and an empty right-hand side is added to the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（RootComponentTypeList又はExtensionAdditionGroupのいずれかで）ComponentTypeListコンポーネントがOPTIONALまたはDEFAULTマークされている場合、左側のような成分と空右側の一次非末端との生産が追加されています文法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a component (regardless of the ASN.1 combining type containing it) is subject to a GROUP encoding instruction, then one or more productions constructed according to the component&#39;s type are added to the grammar. Each of these productions has the primary non-terminal of the component as the left-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（かかわらず、それを含むASN.1結合型の）成分がGROUP符号化命令の対象である場合には、コンポーネントのタイプに従って構築一つ以上の生産を文法に追加されます。これら作品のそれぞれは、左側コンポーネントの一次非末端を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a component (regardless of the ASN.1 combining type containing it) is not subject to a GROUP encoding instruction, then a production is added to the grammar with the primary non-terminal of the component as the left-hand side and the terminal of the component as the right-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（かかわらず、それを含むタイプを組み合わせるASN.1の）成分がGROUP符号化命令を受けない場合には、生産が左側及び端末などのコンポーネントの一次非末端と文法に追加されます右側コンポーネントの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のASN.1型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { -- Start of initial RootComponentTypeList. one [ATTRIBUTE] UTF8String, two BOOLEAN OPTIONAL, three INTEGER -- End of initial RootComponentTypeList. }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { - 初期RootComponentTypeListのスタート。 1 [ATTRIBUTE] UTF8Stringを、任意の2つのBOOLEAN、3つのINTEGER  - 初期RootComponentTypeListの終わり。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is the grammar derived from this type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでは、この型から派生文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= one two three
         one ::= &#34;@one&#34;
         two ::= &#34;two&#34;
         two ::=
         three ::= &#34;three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each ExtensionAddition (of a SEQUENCE or SET base type), a production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAddition and the right-hand side is initially empty. If the ExtensionAddition is a ComponentType, then the primary non-terminal for the NamedType in the ComponentType is appended to the right-hand side; otherwise (an ExtensionAdditionGroup), the sequence of primary non-terminals for the components nested in the ComponentTypeList in the ExtensionAdditionGroup are appended to the right-hand side in the order of their definition. If the ExtensionAddition is followed by another ExtensionAddition, then the non-terminal for the next ExtensionAddition is appended to the right-hand side; otherwise, if the base type is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the non-terminal for the extension insertion point of the base type is appended to the right-hand side. If the ExtensionAddition is not followed by another ExtensionAddition and the base type is not subject to a NO-INSERTIONS encoding instruction, then the production is an insertion point production. If the empty sequence of terminals cannot be generated from the production (it may be necessary to wait until the grammar is otherwise complete before making this determination), then another production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAddition and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（SEQUENCEまたはSETベース型の）各ExtensionAdditionため、生産は左側がExtensionAdditionための非末端であり、右側が最初は空である文法に追加されます。 ExtensionAdditionがCOMPONENTTYPEある場合、COMPONENTTYPEでNamedTypeための非末端第一級は右側に追加されています。そうでない場合は（ExtensionAdditionGroup）、ExtensionAdditionGroupにComponentTypeListにネストされたコンポーネントのための主要な非末端の配列は、それらの定義のために右側に追加されています。 ExtensionAdditionが別ExtensionAdditionが続いている場合、次ExtensionAdditionため、非末端は右側に追加されています。そうでない場合は、基本型は、基本型の拡張挿入点に対して、非末端、NO-挿入または中空挿入エンコード命令を受けない場合は右側に追加されています。 ExtensionAdditionが他ExtensionAddition続いていないとベースタイプがNO-挿入エンコード命令を受けない場合には、生産が挿入ポイントの生産です。端末の空のシーケンスは、（文法は、この判断を行う前に、そうでなければ完了するまで待つ必要があるかもしれない）製造から生成することができない場合、別の生産は左側が非端末である文法に追加されますExtensionAdditionと右辺のために空になっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: An extension is always effectively optional since a sender may be using an earlier version of the ASN.1 specification where none, or only some, of the extensions have been defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：送信者が拡張のどれも、あるいは一部だけが、定義されていないASN.1仕様の以前のバージョンを使用することができるので、拡張子は常に効果的に任意です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: The grammar generated for ExtensionAdditions is structured to take account of the condition that an extension can only be used if all the earlier extensions are also used [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：ExtensionAdditions用に生成文法は以前のすべての拡張機能も[X.680]を使用している場合は拡張子にのみ使用することができることが条件を考慮して構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a SEQUENCE or SET base type is extensible (explicitly or by default) and is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCEまたはSETベースタイプは拡張可能であり（明示的またはデフォルトで）、次いで、NO-挿入または中空挿入エンコード命令を受けない場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）生産は、左側が基本型の拡張挿入ポイントの非末端であり、右側は、拡張のための非末端続いて一般的な内線端末である文法に追加されます挿入ポイント、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）生産は左側拡張挿入ポイントの非末端であり、右側が空の文法に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のASN.1型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { -- Start of initial RootComponentTypeList. one BOOLEAN, two INTEGER OPTIONAL, -- End of initial RootComponentTypeList. ..., -- Start of ExtensionAdditions. four INTEGER, -- First ExtensionAddition (E1). five BOOLEAN OPTIONAL, -- Second ExtensionAddition (E2). [[ -- An ExtensionAdditionGroup. six UTF8String, seven INTEGER OPTIONAL ]], -- Third ExtensionAddition (E3). -- End of ExtensionAdditions. -- The extension insertion point is here (I1). ..., -- Start of final RootComponentTypeList. three INTEGER }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { - 初期RootComponentTypeListのスタート。 1つのBOOLEAN、任意の2つのINTEGER、 - 初期RootComponentTypeListの終わり。 ...、 -  ExtensionAdditionsのスタート。 4つのINTEGER、 - まずExtensionAddition（E1）。 5 BOOLEAN OPTIONAL、 - セカンドExtensionAddition（E2）。 [[ -  ExtensionAdditionGroup。 6つのUTF8Stringを、7つのINTEGER OPTIONAL]]、 - 第三ExtensionAddition（E3）。 -  ExtensionAdditionsの終わり。 - 拡張挿入点は、ここで（I1）です。 ...、 - 最終RootComponentTypeListのスタート。 3つのINTEGER}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is the grammar derived from this type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでは、この型から派生文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= one two E1 three
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         E1 ::= four E2
         E1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         E2 ::= five E3
         E3 ::= six seven I1
         E3 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         two ::= &#34;two&#34;
         two ::=
         three ::= &#34;three&#34;
         four ::= &#34;four&#34;
         five ::= &#34;five&#34;
         five ::=
         six ::= &#34;six&#34;
         seven ::= &#34;seven&#34;
         seven ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the SEQUENCE type were subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the productions for I1 would not appear, and the first production for E3 would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCEタイプがNO-挿入または中空挿入エンコード命令を受けた場合、I1のために制作は表示されません、およびE3のための最初の製造は次のようになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         E3 ::= six seven
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given a primary non-terminal, N, and a type where the base type is a CHOICE type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プライマリ非末端、N、および塩基型がCHOICE型であるタイプ与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) A production is added to the grammar for each NamedType nested in the RootAlternativeTypeList of the base type, where the left-hand side is N and the right-hand side is the primary non-terminal for the NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）生産は、左側がNであり、右側がNamedTypeための非末端第一級である。基本型のRootAlternativeTypeListにネスト各NamedType、のための文法に追加されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) A production is added to the grammar for each ExtensionAdditionAlternative of the base type, where the left-hand side is N and the right-hand side is the non-terminal for the ExtensionAdditionAlternative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）生産は左側がNであり、右側がExtensionAdditionAlternativeための非端末である基本型の各ExtensionAdditionAlternativeための文法に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) If the base type is extensible (explicitly or by default) and the base type is not subject to an insertion encoding instruction, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）基本型は、拡張可能であり（明示的またはデフォルトで）とベース型は、次いで、挿入符号化命令を受けない場合は、次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       (a) A production is added to the grammar where the left-hand side
           is N and the right-hand side is the non-terminal for the
           extension insertion point of the base type.  This production
           is an insertion point production.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）の製造は左側が基本型の拡張挿入ポイントの非末端であり、右側は、拡張のための非末端続いて一般的な内線端末である文法に追加されます挿入口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（c）の製造は左側が基本型の拡張挿入ポイントの非末端であり、右側が空の文法に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(4) If the base type is subject to a HOLLOW-INSERTIONS encoding instruction, then a production is added to the grammar where the left-hand side is N and the right-hand side is empty. This production is an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基本型は、中空挿入エンコード命令の対象である場合（4）、次いで生産は左側がNであり、右側が空の文法に追加されます。この生産は、挿入ポイントの生産です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(5) If the base type is subject to a SINGULAR-INSERTIONS encoding instruction, then a production is added to the grammar where the left-hand side is N and the right-hand side is the general extension terminal. This production is an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基本型が特異-挿入エンコード命令の対象である場合（5）、次いで生産は左側がNであり、右側は、一般的な内線端末である文法に追加されます。この生産は、挿入ポイントの生産です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(6) If the base type is subject to a UNIFORM-INSERTIONS encoding instruction, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（6）基本型は、次に、均一挿入エンコード命令の対象である場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       (a) A production is added to the grammar where the left-hand side
           is N and the right-hand side is the general extension
           terminal.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Aside: This production is used to verify the correctness
              of an ASN.1 type definition, but would not be used in the
              implementation of an RXER decoder.  The next production
              takes precedence over it for accepting an unknown element.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) A production is added to the grammar where the left-hand side is N and the right-hand side is the terminal for the extension insertion point of the base type followed by the non-terminal for the extension insertion point. This production is an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）の製造は左側がNであり、右側は、拡張挿入ポイントの非末端続いて塩基型の拡張挿入ポイントの端子である文法に追加されます。この生産は、挿入ポイントの生産です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the terminal for the extension insertion point followed by the non-terminal for the extension insertion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（c）の製造は左側が拡張挿入ポイントの端末は非末端続いて塩基型と右側の拡張挿入ポイントの非末端れる文法に追加されます拡張挿入ポイントのため。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(d) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（d）の製造は、左側が基本型の拡張挿入ポイントの非末端であり、右側が空の文法に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(7) If the base type is subject to a MULTIFORM-INSERTIONS encoding instruction, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（7）基本型は、次に、多形-挿入エンコード命令の対象である場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       (a) A production is added to the grammar where the left-hand side
           is N and the right-hand side is the general extension
           terminal followed by the non-terminal for the extension
           insertion point of the base type.  This production is an
           insertion point production.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(b) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（b）の製造は左側が基本型の拡張挿入ポイントの非末端であり、右側は、拡張のための非末端続いて一般的な内線端末である文法に追加されます挿入口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（c）の製造は左側が基本型の拡張挿入ポイントの非末端であり、右側が空の文法に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an ExtensionAdditionAlternative is a NamedType, then a production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAdditionAlternative and the right-hand side is the primary non-terminal for the NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ExtensionAdditionAlternativeがNamedTypeであれば、生産が左側にExtensionAdditionAlternativeと右側用の非末端でNamedTypeための主要な非末端ある文法に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If an ExtensionAdditionAlternative is an ExtensionAdditionAlternativesGroup, then a production is added to the grammar for each NamedType nested in the ExtensionAdditionAlternativesGroup, where the left-hand side is the non-terminal for the ExtensionAdditionAlternative and the right-hand side is the primary non-terminal for the NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ExtensionAdditionAlternativeがExtensionAdditionAlternativesGroupである場合、生産が左側にExtensionAdditionAlternativeと右側用の非末端でExtensionAdditionAlternativesGroupにネストされた各NamedTypeための文法にするための主要な非末端で付加されますNamedType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のASN.1型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE { -- Start of RootAlternativeTypeList. one BOOLEAN, two INTEGER, -- End of RootAlternativeTypeList. ..., -- Start of ExtensionAdditionAlternatives. three INTEGER, -- First ExtensionAdditionAlternative (E1). [[ -- An ExtensionAdditionAlternativesGroup. four UTF8String, five INTEGER ]] -- Second ExtensionAdditionAlternative (E2). -- The extension insertion point is here (I1). }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE { -  RootAlternativeTypeListのスタート。 1つのBOOLEAN、2つの整数、 -  RootAlternativeTypeListの終わり。 ...、 -  ExtensionAdditionAlternativesのスタート。 3つのINTEGER、 - まずExtensionAdditionAlternative（E1）。 [[ -  ExtensionAdditionAlternativesGroup。 4つのUTF8Stringを、5つのINTEGER]]  - セカンドExtensionAdditionAlternative（E2）。 - 拡張挿入点は、ここで（I1）です。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is the grammar derived from this type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでは、この型から派生文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= one
         S ::= two
         S ::= E1
         S ::= E2
         S ::= I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         E1 ::= three
         E2 ::= four
         E2 ::= five
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         two ::= &#34;two&#34;
         three ::= &#34;three&#34;
         four ::= &#34;four&#34;
         five ::= &#34;five&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the CHOICE type were subject to a NO-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICEタイプがNO-挿入エンコード命令を受けた場合には、第五は、第六、第七および制作は除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the CHOICE type were subject to a HOLLOW-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICEタイプが中空挿入エンコード命令を受けた場合、第5、第6及び第7プロダクションによって置換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the CHOICE type were subject to a SINGULAR-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICEタイプが特異-挿入エンコード命令を受けた場合、第5、第6及び第7プロダクションによって置換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= &#34;*&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the CHOICE type were subject to a UNIFORM-INSERTIONS encoding instruction, then the fifth and sixth productions would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICEタイプが均一挿入エンコード命令を受けた場合、第5及び第六のプロダクションによって置換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= &#34;*&#34;
         S ::= &#34;*1&#34; I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         I1 ::= &#34;*1&#34; I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the CHOICE type were subject to a MULTIFORM-INSERTIONS encoding instruction, then the fifth production would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICEタイプは多形、挿入符号化命令を受けた場合には、第五の生産をすることによって置換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= &#34;*&#34; I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Constraints on a SEQUENCE, SET, or CHOICE type are ignored. They do not affect the grammar being generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE、SET、またはCHOICEタイプの制約は無視されます。彼らは、生成された文法には影響を与えません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: This avoids an awkward situation where values of a subtype have to be decoded differently from values of the parent type. It also simplifies the verification procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：これはサブタイプの値は、親の型の値とは異なるデコードする必要がある厄介な状況を回避することができます。また、検証手順を簡素化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given a primary non-terminal, N, and a type that has a SEQUENCE OF or SET OF base type and that permits a value of size zero (i.e., an empty sequence or set):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プライマリ非末端、N、及びOF SEQUENCEまたは塩基型のセットを有しており、それはサイズがゼロ（すなわち、空のシーケンスまたはセット）の値を許容タイプ与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）生産は、生産の左側がNであり、右側が続く、一連のまたは塩基型のセットの成分のNamedTypeための非末端第一級である文法に追加されますNによると、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）生産は、生産の左側がNであり、右側が空の文法に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given a primary non-terminal, N, a secondary non-terminal, N&#39;, and a type that has a SEQUENCE OF or SET OF base type and that does not permit a value of size zero: (1) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N&#39;, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
プライマリ非末端、N、二次非末端、N」与えられ、一連の又はベース型のセットを有しており、それは大きさゼロの値を許可しないタイプ：（1）生産が追加されています生産の左側はNと右側で文法は「N続いて、一次のシーケンスの成分のNamedTypeための非末端または塩基型の設定され、そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) a production is added to the grammar where the left-hand side of the production is N&#39; and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N&#39;, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）生産は生産の左側がN」であり、右側は、一次のシーケンスの成分のNamedTypeための非末端または塩基型の設定されている文法に追加され、 「Nが続き、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a production is added to the grammar where the left-hand side of the production is N&#39; and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）生産は、生産の左側がN」であり、右側が空の文法に追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のASN.1型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE SIZE(1..MAX) OF number INTEGER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
数INTEGERのシーケンスSIZE（1..MAX）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here is the grammar derived from this type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここでは、この型から派生文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= number S&#39;
         S&#39; ::= number S&#39;
         S&#39; ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All inner subtyping (InnerTypeContraints) is ignored for the purposes of deciding whether a value of size zero is permitted by a SEQUENCE OF or SET OF type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての内部サブタイプ（InnerTypeContraints）は、サイズがゼロの値は、一連のまたはタイプのセットによって許可されているかどうかを決定する目的のために無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This completes the description of the transformation of ASN.1 combining type definitions into a grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、文法にASN.1結合型定義の変換について説明しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.2. Unique Component Attribution
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.2。ユニークなコンポーネントの帰属
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes conditions that the grammar must satisfy so that each element and attribute in a received RXER encoding can be uniquely associated with an ASN.1 component definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、文法は、受信RXER符号化における各要素と属性が一意ASN.1コンポーネント定義に関連付けることができるように満足しなければならない条件を記述する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (used by the grammar): A non-terminal, N, is used by the grammar if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（文法によって使用される）定義：非末端、Nは、場合文法によって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) N is the start symbol or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）Nは、開始シンボルであるか、または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) N appears on the right-hand side of a production where the non-terminal on the left-hand side is used by the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）Nは、文法によって使用される非末端左側の生産の右側に表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (multiple derivation paths): A non-terminal, N, has multiple derivation paths if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（複数導出路）：非末端、Nは、場合に、複数の導出路を有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) N appears on the right-hand side of a production where the non-terminal on the left-hand side has multiple derivation paths, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）Nは、非末端左側に複数の導出路を有し、又は生産の右側に表示され
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) N appears on the right-hand side of more than one production where the non-terminal on the left-hand side is used by the grammar, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）Nは、文法によって使用される非末端左側に複数の生産の右側に表示され、又は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) N is the start symbol and it appears on the right-hand side of a production where the non-terminal on the left-hand side is used by the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）Nは、開始シンボルであり、それは文法で使用される非末端左側の生産の右側に表示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For every ASN.1 type with a base type containing components that are subject to a GROUP encoding instruction, the grammar derived by the method described in this document MUST NOT have:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ符号化命令の対象である成分を含有する基本型を持つすべてのASN.1タイプの場合、本文書に記載された方法によって得文法はあってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) two or more primary non-terminals that are used by the grammar and are associated with element components having the same expanded name, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）文法によって使用され、素子の構成要素は同じ拡張名を持つに関連付けられ、二種以上の一次非端子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) two or more primary non-terminals that are used by the grammar and are associated with attribute components having the same expanded name, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）文法によって使用され、属性の成分が同じ拡張名を持つに関連付けられ、二種以上の一次非端子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(3) a primary non-terminal that has multiple derivation paths and is associated with an attribute component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（3）複数の導出路を有しており、属性コンポーネントに関連付けられているプラ​​イマリ非終端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: Case (1) is in response to component referencing notations that are evaluated with respect to the XML encoding of an abstract value. Case (1) guarantees, without having to do extensive testing (which would necessarily have to take account of encoding instructions for all other encoding rules), that all sibling elements with the same expanded name will be associated with equivalent type definitions. Such equivalence allows a component referenced by element name to be re-encoded using a different set of ASN.1 encoding rules without ambiguity as to which type definition and encoding instructions apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：ケース（1）は、抽象値のXMLエンコーディングに関して評価されているコンポーネントの参照符号に対応しています。ケース（1）の保証、同じ拡張名を持つすべての兄弟要素が同等のタイプの定義に関連付けされること、（必ずしも他のすべての符号化規則の符号化の指示を考慮しなければならない）広範なテストを行うために必要はありません。そのような等価性タイプの定義と符号化命令が適用されるように要素名によって参照されるコンポーネントは、曖昧さなしにASN.1符号化規則の異なるセットを使用して再符号化することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Cases (2) and (3) ensure that an attribute name is always uniquely associated with one component that can occur at most once and is always nested in the same part of an abstract value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（2）及び（3）属性名は常に一意で最大1回発生することができ、常に抽象値の同じ部分にネストされている一つの成分に関連していることを確認してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following example types illustrate various uses and misuses of the GROUP encoding instruction with respect to unique component attribution:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の例のタイプは、一意のコンポーネント属性に対するGROUP符号化命令の様々な使用及び誤用を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA ::= SEQUENCE {
             a  [GROUP] TB,
             b  [GROUP] CHOICE {
                 a  [GROUP] TB,
                 b  [NAME AS &#34;c&#34;] [ATTRIBUTE] INTEGER,
                 c  INTEGER,
                 d  TB,
                 e  [GROUP] TD,
                 f  [ATTRIBUTE] UTF8String
             },
             c  [ATTRIBUTE] INTEGER,
             d  [GROUP] SEQUENCE OF
                 a [GROUP] SEQUENCE {
                     a  [ATTRIBUTE] OBJECT IDENTIFIER,
                     b  INTEGER
                 },
             e  [NAME AS &#34;c&#34;] INTEGER,
             COMPONENTS OF TD
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TB ::= SEQUENCE {
             a  INTEGER,
             b  [ATTRIBUTE] BOOLEAN,
             COMPONENTS OF TC
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TC ::= SEQUENCE {
             f  OBJECT IDENTIFIER
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TD ::= SEQUENCE {
             g  OBJECT IDENTIFIER
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The grammar for TA is constructed after performing the COMPONENTS OF transformation. The result of this transformation is shown next. This example will depart from the usual convention of using just the identifier of a NamedType to represent the primary non-terminal for that NamedType. A label relative to the outermost type will be used instead to better illustrate unique component attribution. The labels used for the non-terminals are shown down the right-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TAのための文法を、変換の構成要素を実行した後に構成されています。この変換の結果は次示されています。この例では、そのNamedTypeのプライマリ非末端を表すためにNamedTypeのちょうど識別子を使用して、通常の慣例から出発します。最も外側のタイプに対するラベルは、より良好な固有のコンポーネント属性を示すために代わりに使用されます。非端末のために使用されるラベルは、右側を下に示されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA ::= SEQUENCE {
             a  [GROUP] TB,                             -- TA.a
             b  [GROUP] CHOICE {                        -- TA.b
                 a  [GROUP] TB,                         -- TA.b.a
                 b  [NAME AS &#34;c&#34;] [ATTRIBUTE] INTEGER,  -- TA.b.b
                 c  INTEGER,                            -- TA.b.c
                 d  TB,                                 -- TA.b.d
                 e  [GROUP] TD,                         -- TA.b.e
                 f  [ATTRIBUTE] UTF8String              -- TA.b.f
             },
             c  [ATTRIBUTE] INTEGER,                    -- TA.c
             d  [GROUP] SEQUENCE OF                     -- TA.d
                 a [GROUP] SEQUENCE {                   -- TA.d.a
                     a  [ATTRIBUTE] OBJECT IDENTIFIER,  -- TA.d.a.a
                     b  INTEGER                         -- TA.d.a.b
                 },
             e  [NAME AS &#34;c&#34;] INTEGER,                  -- TA.e
             g  OBJECT IDENTIFIER                       -- TA.g
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TB ::= SEQUENCE {
             a  INTEGER,                                -- TB.a
             b  [ATTRIBUTE] BOOLEAN,                    -- TB.b
             f  OBJECT IDENTIFIER                       -- TB.f
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
-- Type TC is no longer of interest. --
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - タイプTCは、もはや関心のではありません。 - 
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TD ::= SEQUENCE {
             g  OBJECT IDENTIFIER                       -- TD.g
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= TA.a TA.b TA.c TA.d TA.e TA.g
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.a ::= TB.a TB.b TB.f
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TB.a ::= &#34;a&#34;
         TB.b ::= &#34;@b&#34;
         TB.f ::= &#34;f&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.b ::= TA.b.a
         TA.b ::= TA.b.b
         TA.b ::= TA.b.c
         TA.b ::= TA.b.d
         TA.b ::= TA.b.e
         TA.b ::= TA.b.f
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.b.a ::= TB.a TB.b TB.f
         TA.b.b ::= &#34;@c&#34;
         TA.b.c ::= &#34;c&#34;
         TA.b.d ::= &#34;d&#34;
         TA.b.e ::= TD.g
         TA.b.f ::= &#34;@f&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TD.g ::= &#34;g&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.c ::= &#34;@c&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.d ::= TA.d.a TA.d
         TA.d ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.d.a ::= TA.d.a.a TA.d.a.b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.d.a.a := &#34;@a&#34;
         TA.d.a.b ::= &#34;b&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.e ::= &#34;c&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         TA.g ::= &#34;g&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All the non-terminals are used by the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべての非端子は文法で使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The type definition for TA is invalid because there are two instances where two or more primary non-terminals are associated with element components having the same expanded name:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
二つ以上の一次非端末は要素部品は、同じ拡張名を持つ関連付けられている2つのインスタンスが存在するので、TAの型定義は無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) TA.b.c and TA.e (both generate the terminal &#34;c&#34;), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）TA.b.cとTA.e（両末端 &#34;c&#34; を生成する）、及び
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) TD.g and TA.g (both generate the terminal &#34;g&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）TD.g及びTA.gを（両方の端子 &#34;G&#34; を生成します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In case (2), TD.g and TA.g are derived from the same instance of NamedType notation, but become distinct components following the COMPONENTS OF transformation. AUTOMATIC tagging is applied after the COMPONENTS OF transformation, which means that the types of the components corresponding to TD.g and TA.g will end up with different tags, and therefore the types will not be equivalent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ケース（2）、TD.gとTA.gはNamedType表記の同じインスタンスに由来するが、変換の構成要素次の別個の構成要素となります。自動タグ付けはTD.gとTA.gに対応する成分の種類が異なるタグで終わるであろう、そのため型が等価でないことを意味し、変換の構成要素の後に適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The type definition for TA is also invalid because there is one instance where two or more primary non-terminals are associated with attribute components having the same expanded name: TA.b.b and TA.c (both generate the terminal &#34;@c&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
TA.b.bとTA.c（両末端「@c」を生成する）、2つ以上の一次非端子が同じ拡張名を持つ属性コンポーネントに関連する1つのインスタンスがあるのでTAの型定義も無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The non-terminals with multiple derivation paths are: TA.d, TA.d.a, TA.d.a.a, TA.d.a.b, TB.a, TB.b, and TB.f. The type definition for TA is also invalid because TA.d.a.a and TB.b are primary non-terminals that are associated with an attribute component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
複数の導出路を有する非端末である：TA.d、TA.d.a、TA.d.a.a、TA.d.a.b、TB.a、TB.b、及びTB.f. TA.d.a.aとTB.b属性コンポーネントに関連付けられているプラ​​イマリ非端末であるため、TAの型定義も無効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.3. Deterministic Grammars
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.3。決定論的な文法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let the First Set of a production P, denoted First(P), be the set of all element terminals T where T is the first element terminal in a sequence of terminals that can be generated from the right-hand side of P. There can be any number of leading attribute terminals before T.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
製造Pの第1のセットは、（P）まず付してみよう、すべての要素端末Tが存在することができ、Pの右側から生成することができる端末のシーケンスの最初の要素の端子であるTの組でありますT.前に主要な属性の任意の数の端末も
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let the Follow Set of a non-terminal N, denoted Follow(N), be the set of all element terminals T where T is the first element terminal following N in a sequence of non-terminals and terminals that can be generated from the grammar. There can be any number of attribute terminals between N and T. If a sequence of non-terminals and terminals can be generated from the grammar where N is not followed by any element terminals, then Follow(N) also contains a special end terminal, denoted by &#34;$&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非終端Nのフォロー集合を、フォロー（N）で表される、すべての要素端末Tは文法から生成することができる非端子及び端子の配列におけるN次の第一素子端子であるTの組であります。非端子及び端子の配列は、Nが任意の要素端子が続かない文法から生成することができる場合、NとTとの属性の任意の数の端末が存在することができ、その後、特別なエンド端末が含まれている（N）に従っ「$」で示されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: If N does not appear on the right-hand side of any production, then Follow(N) will be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：Nは、任意の生産の右側に表示されない場合は、その後、フォロー（N）は空になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a production P, let the predicate Empty(P) be true if and only if the empty sequence of terminals can be generated from P. Otherwise, Empty(P) is false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
製造Pのため、及び端末の空のシーケンスが他P.から生成することができる場合だけ述語空（P）が真であるとする、空（P）は偽です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Definition (base grammar): The base grammar is a rewriting of the grammar in which the non-terminals for every ExtensionAddition and ExtensionAdditionAlternative are removed from the right-hand side of all productions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定義（基本文法）：基本文法は、すべてExtensionAdditionとExtensionAdditionAlternativeための非端子が全てプロダクションの右側から除去された文法の書き換えです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a production P, let the predicate Preselected(P) be true if and only if every sequence of terminals that can be generated from the right-hand side of P using only the base grammar contains at least one attribute terminal. Otherwise, Preselected(P) is false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
製造Pのために、事前に選択された述語（P）は、唯一の基本文法を使用してPの右側から生成することができる端末のすべての配列は、少なくとも1台の属性端末が含ま場合にのみ真であるとします。それ以外の場合は、事前に選択された（P）は偽です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Select Set of a production P, denoted Select(P), is empty if Preselected(P) is true; otherwise, it contains First(P). Let N be the non-terminal on the left-hand side of P. If Empty(P) is true, then Select(P) also contains Follow(N).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
生産Pの選択セットは、選択（P）は、事前に選択された（P）が真である場合は空で示されます。それ以外の場合は、まず、（P）が含まれています。その後もフォロー（N）が含まれています（P）を選択し、空（P）が真である場合にはN Pの左側に非ターミナルとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: It may appear somewhat dubious to include the attribute components in the grammar because, in reality, attributes appear unordered within the start tag of an element, and not interspersed with the child elements as the grammar would suggest. This is why attribute terminals are ignored in composing the First Sets and Follow Sets. However, the attribute terminals are important in composing the Select Sets because they can preselect a production and can prevent a production from being able to generate an empty sequence of terminals. In real terms, this corresponds to an RXER decoder using the attributes to determine the presence or absence of optional components and to select between the alternatives of a CHOICE, even before considering the child elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：現実には、属性は要素の開始タグ内順不同表示され、文法が示唆しているとして、子要素が点在していない、ので、文法における属性のコンポーネントが含まれるように、やや怪しげな表示されることがあります。属性端子はまず設定を構成し、設定に従ってくださいに無視される理由はここにあります。ただし、属性の端子は、彼らが生産を事前に選択することができますし、端末の空のシーケンスを生成することができることから生産を防ぐことができるので、選択セットを構成する上で重要です。実際の用語では、これは、任意の成分の存在または非存在を決定するために、さらに子要素を考慮する前に、選択した代替の間で選択するために属性を使用してRXERデコーダに相当します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An attribute appearing in an extension isn&#39;t used to preselect a production since, in general, a decoder using an earlier version of the specification would not be able to associate the attribute with any particular extension insertion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に、仕様の以前のバージョンを使用して、デコーダは、任意の特定の拡張挿入ポイントに属性を関連付けることができない、ため拡張子に現れる属性は、生産を事前選択するために使用されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let the Reach Set of a non-terminal N, denoted Reach(N), be the set of all element terminals T where T appears in a sequence of terminals that can be generated from N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非終端Nのリーチ集合を、リーチ（N）は、TはNから生成することができる端子の配列に現れる全ての素子端子Tのセットで表さ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: It can be readily shown that all the optional attribute components and all but one of the mandatory attribute components of a SEQUENCE or SET type can be ignored in constructing the grammar because their omission does not alter the First, Follow, Select, or Reach Sets, or the evaluation of the Preselected and Empty predicates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：容易に彼らの不作為はまず、フォロー、選択、またはリーチを変更していないため、すべてのオプションの属性コンポーネントおよびSEQUENCEまたはSETタイプの必須属性要素のうちの1つを除くすべての文法を構築する上で無視することができますことを示すことができますセット、または事前に選択されたと空の述語の評価。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A grammar is deterministic (for the purposes of an RXER decoder) if and only if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
文法は（RXERデコーダの目的のために）決定論的である場合にのみ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) there do not exist two productions P and Q, with the same non-terminal on the left-hand side, where the intersection of Select(P) and Select(Q) is not empty, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）が選択（P）及び選択（Q）の交差が空ではない左側、上に同じ非末端を有する2つのプロダクションPとQを、存在し、ありません
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) there does not exist a non-terminal E for an ExtensionAddition or ExtensionAdditionAlternative where the intersection of Reach(E) and Follow(E) is not empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）リーチ（E）とフォロー（E）の交差が空でないExtensionAddition又はExtensionAdditionAlternativeための非端末Eが存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: In case (1), if the intersection is not empty, then a decoder would have two or more possible ways to attempt to decode the input into an abstract value. In case (2), if the intersection is not empty, then a decoder using an earlier version of the ASN.1 specification would confuse an element in an unknown (to that decoder) extension with a known component following the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：交差が空でなければ場合には（1）、その後、デコーダは、抽象値に入力を復号化しようとするには、2つ以上の可能な方法を有することになります。交差が空でない場合場合には（2）、次いで、ASN.1仕様の以前のバージョンを使用して、デコーダは、拡張次の既知の成分と拡張（つまり、デコーダ）が未知の要素を混乱させる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: In the absence of any attribute components, case (1) is the test for an LL(1) grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：任意の属性成分の非存在下では、ケース（1）LL（1）文法のための試験です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For every ASN.1 type with a base type containing components that are subject to a GROUP encoding instruction, the grammar derived by the method described in this document MUST be deterministic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ符号化命令の対象である成分を含有する基本型を持つすべてのASN.1タイプの場合、本文書に記載された方法によって得文法は決定論的でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.4. Attributes in Unknown Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.4。不明な拡張機能の属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An insertion point production is able to accept unknown attributes if the non-terminal on the left-hand side of the production does not have multiple derivation paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
挿入ポイントの生産は、生産の左側に非端末は、複数の導出路を有していない場合、未知の属性を受け入れることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aside: If the non-terminal has multiple derivation paths, then any future extension cannot possibly contain an attribute component because that would violate the requirements of Section 25.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
脇：非端末は、複数の派生パスを持っている場合それは、セクション25.1.2の要件に違反するので、その後、任意の将来の拡張はおそらく属性のコンポーネントを含めることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For a deterministic grammar, there is only one possible way to construct a sequence of element terminals matching the element content of an element in a correctly formed RXER encoding. Any unknown attributes of the element are accepted if at least one insertion point production that is able to accept unknown attributes is used in that construction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
決定論的文法のために、正しく形成RXER符号化における要素の要素内容と一致する要素端子の配列を構築するための唯一の可能な方法があります。未知の属性を受け入れることができる少なくとも一つの挿入ポイントの生産がその建設に使用されている場合、要素の任意の未知の属性が受け入れられています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このタイプの定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE { one UTF8String, two [GROUP] SEQUENCE { three INTEGER, ... } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE {1つのUTF8Stringを、2 [GROUP] SEQUENCE {3つのINTEGER、...}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         S ::= one
         S ::= two
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         two ::= three I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         three ::= &#34;three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The third production is an insertion point production, and it is able to accept unknown attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第3の製造には、挿入ポイントの生産であり、未知の属性を受け入れることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When decoding a value of this type, if the element content contains a &lt;one&gt; child element, then any unrecognized attribute would be illegal as the insertion point production would not be used to recognize the input (the &#34;one&#34; alternative does not admit an extension insertion point). If the element content contains a &lt;three&gt; element, then an unrecognized attribute would be accepted because the insertion point production would be used to recognize the input (the &#34;two&#34; alternative that generates the &lt;three&gt; element has an extensible type).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要素の内容は、&lt;1&gt;子要素が含まれている場合、このタイプの値をデコードすると、挿入ポイントの生産が入力を認識するために使用されないように、その後、未認識の属性は違法になります（「1」の代替は認めていません拡張挿入ポイント）。元素の含有量が&lt;3&gt;要素が含まれている場合、挿入ポイント生産が入力を認識するために使用されるので、その後、認識されていない属性は、（&lt;3&gt;要素を生成し、「二」の代替は、拡張型を持つ）受け入れられるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the SEQUENCE type were prefixed by a NO-INSERTIONS encoding instruction, then the third, fourth, and fifth productions would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCEタイプがNO-挿入符号化命令で始まるした場合、第三、第四、及び第五のプロダクションによって置換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         two ::= three
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With this change, any unrecognized attribute would be illegal for the &#34;two&#34; alternative also, since the replacement production is not an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
交換用の生産が挿入ポイントの生産ではありませんので、この変更により、未認識の属性は、また、「2」の代替のために違法になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If more than one insertion point production that is able to accept unknown attributes is used in constructing a matching sequence of element terminals, then a decoder is free to associate an unrecognized attribute with any one of the extension insertion points corresponding to those insertion point productions. The justification for doing so comes from the following two observations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
未知の属性を受け入れることができる複数の挿入ポイントの生産は、素子端子の一致シーケンスを構築する際に使用される場合、デコーダは、これらの挿入点制作に対応する拡張挿入点のいずれかで認識されていない属性を関連付けるために自由です。そうするための正当化は、次の2つの観察から来ています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(1) If the encoding of an abstract value contains an extension where the type of the extension is unknown to the receiver, then it is generally impossible to re-encode the value using a different set of encoding rules, including the canonical variant of the received encoding. This is true no matter which encoding rules are being used. It is desirable for a decoder to be able to accept and store the raw encoding of an extension without raising an error, and to re-insert the raw encoding of the extension when re-encoding the abstract value using the same non-canonical encoding rules. However, there is little more that an application can do with an unknown extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象値の符号化は、拡張のタイプは受信機に知られていない拡張が含まれている場合（1）、それは正規の変異体を含む、符号化規則の異なるセットを使用して再符号化値、一般に不可能ですエンコーディングを受けました。これは関係なく、符号化規則が使用されている真実ではありません。デコーダは受け入れることができ、エラーを上げることなく、拡張の生エンコーディングを格納し、同じ非標準符号化規則を使用して抽象値を再符号化する際に拡張の原符号化を再挿入することが望ましいです。ただし、アプリケーションが不明な拡張子で行うことができますもう少しあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       An application using RXER can successfully accept, store, and
       re-encode an unrecognized attribute regardless of which extension
       insertion point it might be ascribed to.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
(2) Even if there is a single extension insertion point, an unknown extension could still be the encoding of a value of any one of an infinite number of valid type definitions. For example, an attribute or element component could be nested to any arbitrary depth within CHOICEs whose components are subject to GROUP encoding instructions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（2）単一拡張挿入点があっても、未知の拡張は依然として有効な型定義の無数のいずれかの値の符号化とすることができます。例えば、属性または要素コンポーネントは、そのコンポーネントGROUP符号化指示の対象となっている選択肢の範囲内の任意の深さまでネストすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          Aside: A similar series of nested CHOICEs could describe an
          unknown extension in a Basic Encoding Rules (BER) encoding
          [X.690].
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
26. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
26.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1 compiler implementors should take special care to be thorough in checking that the GROUP encoding instruction has been correctly used; otherwise, ASN.1 specifications with ambiguous RXER encodings could be deployed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ASN.1コンパイラの実装は、GROUPエンコーディング命令が正しく使用されていることを確認するに徹底する特別な注意を払う必要があります。それ以外の場合は、あいまいなRXERエンコーディングとのASN.1仕様が展開することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Ambiguous encodings mean that the abstract value recovered by a decoder may differ from the original abstract value that was encoded. If that is the case, then a digital signature generated with respect to the original abstract value (using a canonical encoding other than CRXER) will not be successfully verified by a receiver using the decoded abstract value. Also, an abstract value may have security-sensitive fields, and in particular, fields used to grant or deny access. If the decoded abstract value differs from the encoded abstract value, then a receiver using the decoded abstract value will be applying different security policy than that embodied in the original abstract value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
あいまいなエンコーディングは、デコーダによって回収抽象値が符号化された元の抽象値と異なってもよいことを意味します。その場合は、その後（CRXER以外の正規符号化を使用して）元の抽象値に対して生成されたデジタル署名が正しく復号抽象値を用いて受信機によって検証されることはありません。また、抽象値は、セキュリティに敏感なフィールドを有していてもよく、特に、フィールドがアクセスを許可または拒否するために使用しました。復号化されたアブストラクト値が符号化された抽象値と異なる場合には、復号されたアブストラクト値を用いて、受信機は、元の抽象値で具現化されるものとは異なるセキュリティポリシーを適用することであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BCP14] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[BCP14]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[URI] Berners-Lee, T., Fielding, R. and L. Masinter, &#34;Uniform Resource Identifiers (URI): Generic Syntax&#34;, STD 66, RFC 3986, January 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[URI]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 &#34;ユニフォームリソース識別子（URI）：汎用構文&#34;、STD 66、RFC 3986、2005年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RXER] Legg, S. and D. Prager, &#34;Robust XML Encoding Rules (RXER) for Abstract Syntax Notation One (ASN.1)&#34;, RFC 4910, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RXER]レッグ、S.​​と、RFC 4910、2007年7月 &#34;抽象構文記法1（ASN.1）のための堅牢なXMLエンコーディング規則（RXER）&#34; D.バッドミットプラーガー、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[ASN.X] Legg, S., &#34;Abstract Syntax Notation X (ASN.X)&#34;, RFC 4912, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【ASN.X】レッグ、S.​​、 &#34;抽象構文記法X（ASN.X）&#34;、RFC 4912、2007年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X.680] ITU-T Recommendation X.680 (07/02) | ISO/IEC 8824-1, Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X.680] ITU-T勧告X.680（7月2日）| ISO / IEC 8824から1、情報技術 - 抽象構文記法1（ASN.1）：基本的な記法の仕様。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X.680-1] ITU-T Recommendation X.680 (2002) Amendment 1 (10/03) | ISO/IEC 8824-1:2002/Amd 1:2004, Support for EXTENDED-XER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【X.680-1] ITU-T勧告X.680（2002）追補1（10/03）| ISO / IEC 8824から1：2002 / Amdの1：2004、EXTENDED-XERのサポート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X.683] ITU-T Recommendation X.683 (07/02) | ISO/IEC 8824-4, Information technology - Abstract Syntax Notation One (ASN.1): Parameterization of ASN.1 specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X.683] ITU-T勧告X.683（7月2日）| ISO / IEC 8824から4、情報技術 - 抽象構文記法1（ASN.1）：ASN.1仕様のパラメータ化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[XML10] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E. and F. Yergeau, &#34;Extensible Markup Language (XML) 1.0 (Fourth Edition)&#34;, W3C Recommendation, http://www.w3.org/TR/2006/REC-xml-20060816, August 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[XML10]ブレイ、T.、パオリ、J.、Sperberg-マックィーン、C.、MALER、EおよびF Yergeau、 &#34;拡張マークアップ言語（XML）1.0（第4版）&#34;、W3C勧告は、http：// www.w3.org/TR/2006/REC-xml-20060816、2006年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[XMLNS10] Bray, T., Hollander, D., Layman, A., and R. Tobin, &#34;Namespaces in XML 1.0 (Second Edition)&#34;, W3C Recommendation, http://www.w3.org/TR/2006/REC-xml-names-20060816, August 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【XMLNS10]ブレイ、T.、オランダ、D.、素人、A.、およびR.トビン、 &#34;XML 1.0に名前空間（第二版）&#34;、W3C勧告、http://www.w3.org/TR/2006 / REC-XML-名-20060816、2006年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[XSD1] Thompson, H., Beech, D., Maloney, M. and N. Mendelsohn, &#34;XML Schema Part 1: Structures Second Edition&#34;, W3C Recommendation, http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/, October 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【XSD1]トンプソン、H.、ブナ、D.、マロニー、M.およびN.メンデルゾーン、 &#34;XMLスキーマパート1：構造第二版&#34;、W3C勧告、http://www.w3.org/TR/2004/ REC-XMLSCHEMA-1-20041028 /、2004年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[XSD2] Biron, P. and A. Malhotra, &#34;XML Schema Part 2: Datatypes Second Edition&#34;, W3C Recommendation, http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/, October 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[XSD2]ビロン、P.およびA.マルホトラ、 &#34;XMLスキーマパート2：データ型第二版&#34;、W3C勧告、http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/、10月2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RNG] Clark, J. and M. Makoto, &#34;RELAX NG Tutorial&#34;, OASIS Committee Specification, http://www.oasis-open.org/ committees/relax-ng/tutorial-20011203.html, December 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[RNG]クラーク、J.とM.誠、委員会は/リラックス-NG /チュートリアル-20011203.html、2001年12月に、OASIS委員会仕様、http://www.oasis-open.org/ &#34;NGチュートリアルをRELAX&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[INFOSET] Cowan, J. and R. Tobin, &#34;XML Information Set (Second Edition)&#34;, W3C Recommendation, http://www.w3.org/ TR/2004/REC-xml-infoset-20040204, February 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[INFOSET]コーワン、J.とR.トビン、 &#34;XML情報セット（第二版）&#34;、W3C勧告、http://www.w3.org/ TR / 2004 / REC-XML-インフォセット-20040204、2004年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X.690] ITU-T Recommendation X.690 (07/02) | ISO/IEC 8825-1, Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[X.690] ITU-T勧告X.690（7月2日）| ISO / IEC 8825から1、情報技術 -  ASN.1エンコーディング規則：基本符号化規則（BER）の仕様、Canonicalの符号化規則（CER）、および顕著な符号化規則（DER）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A. GROUP Encoding Instruction Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A. GROUPエンコーディング命令の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix is non-normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録は非規範的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix contains examples of both correct and incorrect use of the GROUP encoding instruction, determined with respect to the grammars derived from the example type definitions. The productions of the grammars are labeled for convenience. Sets and predicates for non-terminals with only one production will be omitted from the examples since they never indicate non-determinism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録では、例えば、型定義に由来する文法に対して決定されたグループの符号化命令の正しいと不適切な使用、の両方の例を含んでいます。文法のプロダクションは、利便性のために標識されています。彼らは非決定論を示したことがないので、唯一の生産と非端末のセットと述語が例から省略されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The requirements of Section 25.1.2 (&#34;Unique Component Attribution&#34;) are satisfied by all the examples in this appendix and the appendices that follow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション25.1.2（「ユニークなコンポーネントの帰属」）の要件は、すべてこの付録の例と、それに続く付録によって満たされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1. Example 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.1。例1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このタイプの定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] SEQUENCE { two UTF8String OPTIONAL } OPTIONAL, three INTEGER }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] SEQUENCE {2 UTF8StringをOPTIONAL} OPTIONAL三のINTEGER}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P3:  one ::=
      P4:  two ::= &#34;two&#34;
      P5:  two ::=
      P6:  three ::= &#34;three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Select Sets have to be evaluated to test the validity of the type definition. The grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択セットは型定義の有効性をテストするために評価する必要があります。文法は以下のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;two&#34; } First(P3) = { } Preselected(P2) = Preselected(P3) = false Empty(P2) = Empty(P3) = true Follow(one) = { &#34;three&#34; } Select(P2) = First(P2) + Follow(one) = { &#34;two&#34;, &#34;three&#34; } Select(P3) = First(P3) + Follow(one) = { &#34;three&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;2&#34;}最初の（P3）= {}事前に選択された事前に選択された（P3）が偽空（P2）を= =（P2）=空（P3）は、真のフォロー（1）=を= { &#34;三&#34;}を選択（P2）まず（P2）+フォロー（一つ）= = { &#34;2&#34;、 &#34;3&#34;}（P3）を選択するには、最初の（P3）+フォロー（1）= { &#34;三&#34;}を=
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P4) = { &#34;two&#34; } First(P5) = { } Preselected(P4) = Preselected(P5) = Empty(P4) = false Empty(P5) = true Follow(two) = { &#34;three&#34; } Select(P4) = First(P4) = { &#34;two&#34; } Select(P5) = First(P5) + Follow(two) = { &#34;three&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P4）= { &#34;2&#34;}最初の（P5）= {}事前に選択され（P4）=事前に選択され（P5）=空（P4）が偽空（P5）を= TRUEフォローを=（2）= { &#34;三&#34;}を選択（P4）第（P4）を= = { &#34;2&#34;}（P5）を選択するには、最初の（P5）+フォロー（2つ）= = { &#34;三&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type does not have a child element &lt;two&gt;, then it is not possible to determine whether the &#34;one&#34; component is present or absent in the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P2）と選択（P3）の交差は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。タイプの値のRXERエンコード子要素&lt;2&gt;を持っていない場合、「1」の成分値に存在するか否かを判断することは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Now consider this type definition with attributes in the &#34;one&#34; component:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
今、「1」のコンポーネントの属性を持つこの型の定義を考えてみます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] SEQUENCE { two UTF8String OPTIONAL, four [ATTRIBUTE] BOOLEAN, five [ATTRIBUTE] BOOLEAN OPTIONAL } OPTIONAL, three INTEGER }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] SEQUENCE {2つのUTF8StringをOPTIONAL 4 [ATTRIBUTE] BOOLEAN、5 [ATTRIBUTE] BOOLEAN OPTIONAL} OPTIONAL三のINTEGER}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two four five
      P3:  one ::=
      P4:  two ::= &#34;two&#34;
      P5:  two ::=
      P6:  four ::= &#34;@four&#34;
      P7:  five ::= &#34;@five&#34;
      P8:  five ::=
      P9:  three ::= &#34;three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;two&#34; } First(P3) = { } Preselected(P3) = Empty(P2) = false Preselected(P2) = Empty(P3) = true Follow(one) = { &#34;three&#34; } Select(P2) = { } Select(P3) = First(P3) + Follow(one) = { &#34;three&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;2&#34;}最初の（P3）= {}事前に選択された（P3）=空（P2）= FALSE事前に選択された（P2）=空（P3）は、真のフォロー（1）=を= { &#34;三&#34;}を選択（P2）= {}（P3）を選択するには、最初の（P3）+フォロー（1）= { &#34;三&#34;}を=
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P4) = { &#34;two&#34; } First(P5) = { } Preselected(P4) = Preselected(P5) = Empty(P4) = false Empty(P5) = true Follow(two) = { &#34;three&#34; } Select(P4) = First(P4) = { &#34;two&#34; } Select(P5) = First(P5) + Follow(two) = { &#34;three&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P4）= { &#34;2&#34;}最初の（P5）= {}事前に選択され（P4）=事前に選択され（P5）=空（P4）が偽空（P5）を= TRUEフォローを=（2）= { &#34;三&#34;}を選択（P4）第（P4）を= = { &#34;2&#34;}（P5）を選択するには、最初の（P5）+フォロー（2つ）= = { &#34;三&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P7) = { } First(P8) = { } Preselected(P8) = Empty(P7) = false Preselected(P7) = Empty(P8) = true Follow(five) = { &#34;three&#34; } Select(P7) = { } Select(P8) = First(P8) + Follow(five) = { &#34;three&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず（P7）= {}まず（P8）= {}事前に選択された（P8）=空（P7）偽事前に選択された（P7）を= =空（P8）が真のフォロー（5）=を= { &#34;3&#34;}セレクト（P7） = {}選択（P8）まず（P8）+フォロー（5）=を= { &#34;三&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P3) is empty, as is the intersection of Select(P4) and Select(P5) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. In a correct RXER encoding, the &#34;one&#34; component will be present if and only if the &#34;four&#34; attribute is present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P4）と選択（P5）と選択（P7）と選択（P8）の交差点の交差点であるように選択（P2）と選択（P3）の交差は空です。したがって、文法は確定的で、型定義が有効です。正しいRXER符号化では、「1」の成分は、「4つの」属性が存在している場合にのみ存在するであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.2. Example 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.2。例2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このタイプの定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE { one [GROUP] SEQUENCE { two [ATTRIBUTE] BOOLEAN OPTIONAL }, three INTEGER, four [GROUP] SEQUENCE { five BOOLEAN OPTIONAL } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE {1 [GROUP] SEQUENCE {2 [ATTRIBUTE] BOOLEAN OPTIONAL}三のINTEGER 4 [GROUP] SEQUENCE {5 BOOLEAN OPTIONAL}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= three
      P3:  S ::= four
      P4:  one ::= two
      P5:  two ::= &#34;@two&#34;
      P6:  two ::=
      P7:  three ::= &#34;three&#34;
      P8:  four ::= five
      P9:  five ::= &#34;five&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P10: five ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { } First(P2) = { &#34;three&#34; } First(P3) = { &#34;five&#34; } Preselected(P1) = Preselected(P2) = Preselected(P3) = false Empty(P2) = false Empty(P1) = Empty(P3) = true Follow(S) = { &#34;$&#34; } Select(P1) = First(P1) + Follow(S) = { &#34;$&#34; } Select(P2) = First(P2) = { &#34;three&#34; } Select(P3) = First(P3) + Follow(S) = { &#34;five&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= {}最初の（P2）= { &#34;三&#34;}最初の（P3）= { &#34;5&#34;}事前に選択され（P1）=事前に選択された（P2）=事前に選択された（P3）が偽空（P2）が偽空の==します（P1）=空（P3）は、真のフォロー（S）=を= { &#34;$&#34; は}選択（P1）まず（P1）+フォロー（S）= { &#34;$&#34; が}選択（P2）は=最初の（P2）= = { &#34;3&#34;}（P3）を選択するには、最初の（P3）+フォロー（S）を= = { &#34;5&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P5) = { } First(P6) = { } Preselected(P6) = Empty(P5) = false Preselected(P5) = Empty(P6) = true Follow(two) = { &#34;$&#34; } Select(P5) = { } Select(P6) = First(P6) + Follow(two) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P5）= {}まず（P6）= {}事前に選択された（P6）=空（P5）偽事前に選択された（P5）を= =空（P6）が真のフォロー（2）=を= { &#34;$&#34;}セレクト（P5） = {}（P6）を選択するには、最初の（P6）+フォロー（2）= { &#34;$&#34; を} =
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P9) = { &#34;five&#34; } First(P10) = { } Preselected(P9) = Preselected(P10) = Empty(P9) = false Empty(P10) = true Follow(five) = { &#34;$&#34; } Select(P9) = First(P9) = { &#34;five&#34; } Select(P10) = First(P10) + Follow(five) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず（P9）= { &#34;5&#34;}まず（P10）= {}事前に選択された（P9）=事前に選択された（P10）=空（P9）が偽空（P10）が真のフォローは（5）= { &#34;$&#34;}選択します= = （P9）はまず（P9）を= = { &#34;5&#34;}（P10）=最初の（P10）+フォロー（5）= { &#34;$&#34;}を選択
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P1) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type is empty, then it is not possible to determine whether the &#34;one&#34; alternative or the &#34;four&#34; alternative has been chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P1）と選択（P3）の交差は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。タイプの値のRXERエンコーディングが空である場合、「1」の代替又は「4」の選択肢は、選択されたかどうかを決定することは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Now consider this slightly different type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
今、このわずかに異なるタイプの定義を考えてみます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE { one [GROUP] SEQUENCE { two [ATTRIBUTE] BOOLEAN }, three INTEGER, four [GROUP] SEQUENCE { five BOOLEAN OPTIONAL } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE {1 [GROUP] SEQUENCE {2 [ATTRIBUTE] BOOLEAN}三のINTEGER 4 [GROUP] SEQUENCE {5 BOOLEAN OPTIONAL}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= three
      P3:  S ::= four
      P4:  one ::= two
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= &#34;three&#34;
      P7:  four ::= five
      P8:  five ::= &#34;five&#34;
      P9:  five ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { } First(P2) = { &#34;three&#34; } First(P3) = { &#34;five&#34; } Preselected(P2) = Preselected(P3) = false Empty(P1) = Empty(P2) = false Preselected(P1) = Empty(P3) = true Follow(S) = { &#34;$&#34; } Select(P1) = { } Select(P2) = First(P2) = { &#34;three&#34; } Select(P3) = First(P3) + Follow(S) = { &#34;five&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= {}最初の（P2）= { &#34;三&#34;}最初の（P3）= { &#34;5&#34;}事前に選択された（P2）=事前に選択された（P3）が偽空（P1）=空（P2）が偽事前に選択された==します（P1）=空（P3）は、真のフォロー（S）= { &#34;$&#34;}選択（P1）= {}選択（P2）をまず（P2）=を== { &#34;三&#34; は}選択（P3）まず（P3を= ）+フォロー（S）= { &#34;5&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P8) = { &#34;five&#34; } First(P9) = { } Preselected(P8) = Preselected(P9) = Empty(P8) = false Empty(P9) = true Follow(five) = { &#34;$&#34; } Select(P8) = First(P8) = { &#34;five&#34; } Select(P9) = First(P9) + Follow(five) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P8）= { &#34;5&#34;}まず（P9）= {}事前に選択された（P8）=事前に選択された（P9）=空（P8）が偽空（P9）を= TRUEフォロー（5）= { &#34;$&#34;}選択= （P8）（P9）を選択するには、最初の（P8）= { &#34;5&#34;} = =最初の（P9）+フォロー（5）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P1) and Select(P2) is empty, the intersection of Select(P1) and Select(P3) is empty, the intersection of Select(P2) and Select(P3) is empty, and the intersection of Select(P8) and Select(P9) is empty; hence, the grammar is deterministic, and the type definition is valid. The &#34;one&#34; and &#34;four&#34; alternatives can be distinguished because the &#34;one&#34; alternative has a mandatory attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P1）と選択（P2）の交差が空で、選択（P1）と選択（P3）の交差が空で、選択（P2）と選択（P3）の交差は空であり、そして選択の交差点（P8）と選択（P9）が空です。したがって、文法は確定的で、型定義が有効です。 「1」の代替は必須属性を持っているので、「1」と「4」の選択肢は区別することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.3. Example 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.3。例3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このタイプの定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] CHOICE { two [ATTRIBUTE] BOOLEAN, three [GROUP] SEQUENCE OF number INTEGER } OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {数INTEGERの[GROUP] CHOICE {2 [ATTRIBUTE] BOOLEAN三[GROUP] SEQUENCE} OPTIONAL}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= three
      P4:  one ::=
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= number three
      P7:  three ::=
      P8:  number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { } First(P3) = { &#34;number&#34; } First(P4) = { } Preselected(P3) = Preselected(P4) = Empty(P2) = false Preselected(P2) = Empty(P3) = Empty(P4) = true Follow(one) = { &#34;$&#34; } Select(P2) = { } Select(P3) = First(P3) + Follow(one) = { &#34;number&#34;, &#34;$&#34; } Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= {}最初（P3）= { &#34;数&#34;}最初の（P4）= {}事前に選択された（P3）=事前に選択され（P4）=空（P2）が偽事前に選択された（P2）=空（P3）を= =空の（P4）は、真のフォロー（1）= { &#34;$&#34;}選択（P2）= {}選択（P3）をまず（P3）+フォロー（1）= { &#34;ナンバー&#34;、 &#34;$&#34;}を選択し（P4 ==します）=最初の（P4）+フォロー（1）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P6) = { &#34;number&#34; } First(P7) = { } Preselected(P6) = Preselected(P7) = Empty(P6) = false Empty(P7) = true Follow(three) = { &#34;$&#34; } Select(P6) = First(P6) = { &#34;number&#34; } Select(P7) = First(P7) + Follow(three) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P6）= { &#34;数&#34;}まず（P7）= {}事前に選択された（P6）=事前に選択された（P7）=空（P6）が偽空（P7）を= TRUEフォロー（3）= { &#34;$&#34;}選択= （P6）第（P6）= { &#34;数&#34; は}（P7）を選択= =最初の（P7）+フォロー（3）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type is empty, then it is not possible to determine whether the &#34;one&#34; component is absent or the empty &#34;three&#34; alternative has been chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P3）と選択（P4）の交点は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。タイプの値のRXERエンコーディングが空である場合、「1」の成分が存在しないか、または空の「三」代替が選択されているかどうかを決定することは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4. Example 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.4。例4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このタイプの定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] CHOICE { two [ATTRIBUTE] BOOLEAN, three [ATTRIBUTE] BOOLEAN } OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] CHOICE {2 [ATTRIBUTE] BOOLEAN三[ATTRIBUTE] BOOLEAN} OPTIONAL}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= three
      P4:  one ::=
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= &#34;@three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { } First(P3) = { } First(P4) = { } Preselected(P4) = Empty(P2) = Empty(P3) = false Preselected(P2) = Preselected(P3) = Empty(P4) = true Follow(one) = { &#34;$&#34; } Select(P2) = { } Select(P3) = { } Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= {}最初（P3）= {}最初の（P4）= {}事前に選択され（P4）=空（P2）=空（P3）は= FALSE事前に選択された（P2）=事前に選択された（P3）=空（P4 ）真のフォロー（1）= { &#34;$&#34; は}（P2）を選択= = {}（P3）を選択= {}（P4）=最初の（P4）+フォロー（1）= { &#34;$&#34;}を選択
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P3) is empty, the intersection of Select(P2) and Select(P4) is empty, and the intersection of Select(P3) and Select(P4) is empty; hence, the grammar is deterministic, and the type definition is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P2）と選択（P3）の交差が空で、選択（P2）と選択（P4）の交差は空であり、選択（P3）と選択（P4）の交差は空です。したがって、文法は確定的で、型定義が有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5. Example 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.5。例5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このタイプの定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] SEQUENCE OF number INTEGER OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {数INTEGER OPTIONALの[GROUP] SEQUENCE}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= number one
      P3:  one ::=
      P4:  one ::=
      P5:  number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
P3 is generated during the processing of the SEQUENCE OF type. P4 is generated because the &#34;one&#34; component is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
P3タイプのシーケンスの処理中に生成されます。 「1」のコンポーネントはオプションであるため、P4が生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;number&#34; } First(P3) = { } First(P4) = { } Preselected(P2) = Preselected(P3) = Preselected(P4) = false Empty(P2) = false Empty(P3) = Empty(P4) = true Follow(one) = { &#34;$&#34; } Select(P2) = First(P2) = { &#34;number&#34; } Select(P3) = First(P3) + Follow(one) = { &#34;$&#34; } Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;数&#34;}最初の（P3）= {}最初の（P4）= {}事前に選択された（P2）=事前に選択された（P3）=事前に選択され（P4）偽空（P2）を= FALSE空（P3）を= =空（P4）真フォロー（一つ）= = { &#34;$&#34; は}（P2）を選択するには、最初の（P2）= { &#34;番号&#34;} =（P3）を選択するには、最初の（P3）+フォロー（1）= {「$を= $ &#34;}&#34;}（P4）=最初の（P4）+フォロー（1）= {選択&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type does not have any &lt;number&gt; child elements, then it is not possible to determine whether the &#34;one&#34; component is present or absent in the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P3）と選択（P4）の交点は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。タイプの値のRXER符号化は、任意の&lt;番号&gt;子要素を持たない場合、「1」の成分値に存在するか否かを判断することは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider this similar type definition with a SIZE constraint:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SIZE制約と、この同様のタイプの定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {数INTEGER OPTIONALの[GROUP] SEQUENCEサイズ（1..MAX）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= number one&#39;
      P3:  one&#39; ::= number one&#39;
      P4:  one&#39; ::=
      P5:  one ::=
      P6:  number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;number&#34; } First(P5) = { } Preselected(P2) = Preselected(P5) = Empty(P2) = false Empty(P5) = true Follow(one) = { &#34;$&#34; } Select(P2) = First(P2) = { &#34;number&#34; } Select(P5) = First(P5) + Follow(one) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P2）= { &#34;数&#34;}まず（P5）= {}事前に選択された（P2）=事前に選択された（P5）=空（P2）が偽空（P5）を= trueをフォロー（1）=を= { &#34;$&#34;}を選択（P2）が最初に（P2）= { &#34;数&#34; は}（P5）を選択=最初の（P5）+フォロー（一つ）= = { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P3) = { &#34;number&#34; } First(P4) = { } Preselected(P3) = Preselected(P4) = Empty(P3) = false Empty(P4) = true Follow(one&#39;) = { &#34;$&#34; } Select(P3) = First(P3) = { &#34;number&#34; } Select(P4) = First(P4) + Follow(one&#39;) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P3）= { &#34;数&#34;}まず（P4）= {}事前に選択された（P3）=事前に選択された（P4）=空（P3）が偽空（P4）が真のフォロー（1 &#39;）を= = = { &#34;$&#34;} （P3）ファースト（P3）= { &#34;数&#34;}（P4）を選択する=最初の（P4）+フォロー（1 &#39;）を= = { &#34;$&#34;}を選択
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P5) is empty, as is the intersection of Select(P3) and Select(P4); hence, the grammar is deterministic, and the type definition is valid. If there are no &lt;number&gt; child elements, then the &#34;one&#34; component is necessarily absent and there is no ambiguity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P3）と選択（P4）との交点であるように選択（P2）と選択（P5）の交差点は、空です。したがって、文法は確定的で、型定義が有効です。何&lt;番号&gt;子要素が存在しない場合は、「1」の成分は必ずしも存在せず、全くあいまいさは存在しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.6. Example 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.6。例6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このタイプの定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { beginning [GROUP] List, middle UTF8String OPTIONAL, end [GROUP] List }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
{[GROUP]一覧、中央UTF8StringをOPTIONAL、エンド[GROUP]一覧開始} SEQUENCE
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= beginning middle end
      P2:  beginning ::= string beginning
      P3:  beginning ::=
      P4:  middle ::= &#34;middle&#34;
      P5:  middle ::=
      P6:  end ::= string end
      P7:  end ::=
      P8:  string ::= &#34;string&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;string&#34; } First(P3) = { } Preselected(P2) = Preselected(P3) = Empty(P2) = false Empty(P3) = true Follow(beginning) = { &#34;middle&#34;, &#34;string&#34;, &#34;$&#34; } Select(P2) = First(P2) = { &#34;string&#34; } Select(P3) = First(P3) + Follow(beginning) = { &#34;middle&#34;, &#34;string&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;文字列&#34;}最初の（P3）= {}事前に選択された（P2）=事前に選択された（P3）=空（P2）が偽空（P3）を= &#34;真のフォロー（開始）= { &#34;中央の&#34;=文字列」、 &#34;$&#34;}]を選択します（P2）ファースト（P2）= {= &#34;文字列は&#34;}（P3）を選択=最初の（P3）+フォロー（開始）= { &#34;中&#34;、 &#34;文字列&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P4) = { &#34;middle&#34; } First(P5) = { } Preselected(P4) = Preselected(P5) = Empty(P4) = false Empty(P5) = true Follow(middle) = { &#34;string&#34;, &#34;$&#34; } Select(P4) = First(P4) = { &#34;middle&#34; } Select(P5) = First(P5) + Follow(middle) = { &#34;string&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P4）= { &#34;中間&#34;}最初の（P5）= {}事前に選択され（P4）=事前に選択され（P5）=空（P4）」は、真のフォロー（中央）= { &#34;string&#34; を= FALSE空（P5）を= $」}（P4）=最初の（P4）= {SELECT &#34;中間の&#34;（P5）を選択}まず（P5）+フォロー（真ん中）= = { &#34;文字列&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P6) = { &#34;string&#34; } First(P7) = { } Preselected(P6) = Preselected(P7) = Empty(P6) = false Empty(P7) = true Follow(end) = { &#34;$&#34; } Select(P6) = First(P6) = { &#34;string&#34; } Select(P7) = First(P7) + Follow(end) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P6）= { &#34;文字列&#34;}まず（P7）= {}事前に選択された（P6）=事前に選択された（P7）=空（P6）が偽空（P7）を= trueをフォロー（終了）=を= { &#34;$&#34;}を選択（P6）が最初に（P6）= { &#34;文字列&#34;} =（P7）を選択するには、最初の（P7）+フォロー（エンド）= = { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P2）と選択（P3）の交差は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Now consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで、次の型定義を考えてみます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { beginning [GROUP] List, middleAndEnd [GROUP] SEQUENCE { middle UTF8String, end [GROUP] List } OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {[GROUP]一覧、middleAndEnd [GROUP] SEQUENCE {中間UTF8Stringを、エンド[GROUP]一覧を開始} OPTIONAL}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= beginning middleAndEnd
      P2:  beginning ::= string beginning
      P3:  beginning ::=
      P4:  middleAndEnd ::= middle end
      P5:  middleAndEnd ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P6:  middle ::= &#34;middle&#34;
      P7:  end ::= string end
      P8:  end ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;string&#34; } First(P3) = { } Preselected(P2) = Preselected(P3) = Empty(P2) = false Empty(P3) = true Follow(beginning) = { &#34;middle&#34;, &#34;$&#34; } Select(P2) = First(P2) = { &#34;string&#34; } Select(P3) = First(P3) + Follow(beginning) = { &#34;middle&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;文字列&#34;}最初の（P3）= {}事前に選択された（P2）=事前に選択された（P3）=空（P2）が偽空（P3）を= &#34;真のフォロー（開始）= { &#34;中央の&#34;= $」}（P2）=最初の（P2）= {SELECT &#34;の文字列を&#34;（P3）を選択}まず（P3）+フォロー（開始）を= = { &#34;中&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P4) = { &#34;middle&#34; } First(P5) = { } Preselected(P4) = Preselected(P5) = Empty(P4) = false Empty(P5) = true Follow(middleAndEnd) = { &#34;$&#34; } Select(P4) = First(P4) = { &#34;middle&#34; } Select(P5) = First(P5) + Follow(middleAndEnd) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P4）= { &#34;中&#34;}まず（P5）= {}は事前に選択された（P4）=事前に選択された（P5）=空（P4）が偽空（P5）を= trueをフォロー（middleAndEnd）=を= { &#34;$&#34;}を選択（P4）=最初の（P4）= { &#34;中間&#34;}（P5）を選択=最初の（P5）+フォロー（middleAndEnd）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P7) = { &#34;string&#34; } First(P8) = { } Preselected(P7) = Preselected(P8) = Empty(P7) = false Empty(P8) = true Follow(end) = { &#34;$&#34; } Select(P7) = First(P7) = { &#34;string&#34; } Select(P8) = First(P8) + Follow(end) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず（P7）= { &#34;文字列&#34;}まず（P8）= {}事前に選択された（P7）=事前に選択された（P8）=空（P7）が偽空（P8）を= trueをフォロー（終了）=を= { &#34;$&#34;}を選択（P7）が最初に（P7）= { &#34;文字列&#34;} =（P8）を選択するには、最初の（P8）+フォロー（エンド）= = { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P3) is empty, as is the intersection of Select(P4) and Select(P5) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P4）と選択（P5）と選択（P7）と選択（P8）の交差点の交差点であるように選択（P2）と選択（P3）の交差は空です。したがって、文法は確定的で、型定義が有効です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.7. Example 7
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.7。実施例7
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE SIZE(1..MAX) OF one [GROUP] SEQUENCE { two INTEGER OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 [GROUP] SEQUENCE {2つの整数OPTIONAL}のシーケンスSIZE（1..MAX）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one S&#39;
      P2:  S&#39; ::= one S&#39;
      P3:  S&#39; ::=
      P4:  one ::= two
      P5:  two ::= &#34;two&#34;
      P6:  two ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;two&#34; } First(P3) = { } Preselected(P2) = Preselected(P3) = false Empty(P2) = Empty(P3) = true Follow(S&#39;) = { &#34;$&#34; } Select(P2) = First(P2) + Follow(S&#39;) = { &#34;two&#34;, &#34;$&#34; } Select(P3) = First(P3) + Follow(S&#39;) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P2）= { &#34;2&#34;}まず（P3）= {}事前に選択された（P2）=事前に選択された（P3）が偽空（P2）=空（P3）が真のフォロー（S &#39;）を= = = { &#34;$&#34;}選択（P2）は=最初の（P2）+フォロー（S &#39;）= { &#34;2&#34; は、 &#34;$&#34;}選択（P3）は=最初の（P3）+フォロー（S&#39;）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P5) = { &#34;two&#34; } First(P6) = { } Preselected(P5) = Preselected(P6) = Empty(P5) = false Empty(P6) = true Follow(two) = { &#34;two&#34;, &#34;$&#34; } Select(P5) = First(P5) = { &#34;two&#34; } Select(P6) = First(P6) + Follow(two) = { &#34;two&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P5）= { &#34;2&#34;}最初の（P6）= {}事前に選択され（P5）=事前に選択された（P6）=空（P5）は偽空（P6）を= TRUEフォロー（2）= { &#34;2&#34; を、 &#34;= $」}（P5）を選択まず（P5）を= = { &#34;2&#34;}（P6）を選択するには、最初の（P6）+フォロー（2）= {= &#34;2&#34;、 &#34;$&#34; を}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P3) is not empty and the intersection of Select(P5) and Select(P6) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. The encoding of a value of the type contains an indeterminate number of empty instances of the component type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P2）と選択（P3）の交差は空ではなく、選択（P5）と選択（P6）の交差は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。タイプの値の符号化は、コンポーネントタイプの空のインスタンスの不確定数を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.8. Example 8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.8。実施例8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE OF list [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
数の整数リストのシーケンス[GROUP] SEQUENCEサイズ（1..MAX）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= list S
      P2:  S ::=
      P3:  list ::= number list&#39;
      P4:  list&#39; ::= number list&#39;
      P5:  list&#39; ::=
      P6:  number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { &#34;number&#34; } First(P2) = { } Preselected(P1) = Preselected(P2) = Empty(P1) = false Empty(P2) = true Follow(S) = { &#34;$&#34; } Select(P1) = First(P1) = { &#34;number&#34; } Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= { &#34;数&#34;}最初の（P2）= {}事前に選択され（P1）=事前に選択された（P2）=空（P1）が偽空（P2）を= trueをフォロー（S）=を= { &#34;$&#34;}を選択（P1）=最初の（P1）= { &#34;数&#34;}を選択し（P2）=最初の（P2）+フォロー（S）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P4) = { &#34;number&#34; } First(P5) = { } Preselected(P4) = Preselected(P5) = Empty(P4) = false Empty(P5) = true Follow(list&#39;) = { &#34;number&#34;, &#34;$&#34; } Select(P4) = First(P4) = { &#34;number&#34; } Select(P5) = First(P5) + Follow(list&#39;) = { &#34;number&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P4）= { &#34;数&#34;}最初の（P5）= {}事前に選択され（P4）=事前に選択され（P5）=空（P4）が偽空（P5）は、真のフォロー（リスト &#39;）= { &#34;番号&#34; = = &#34;$&#34;}（P4）を選択しますが、まず（P4）を= = { &#34;数&#34;}（P5）を選択するには、最初の（P5）+フォロー（リスト &#39;）= = { &#34;数&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P4) and Select(P5) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. The type describes a list of lists, but it is not possible for a decoder to determine where the outer lists begin and end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P4）と選択（P5）の交点は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。タイプは、リストのリストを記述し、それは外側のリストの開始と終了場所を決定するためにデコーダのために不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.9. Example 9
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.9。実施例9
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE OF item [GROUP] SEQUENCE { before [GROUP] OneAndTwo, core UTF8String, after [GROUP] OneAndTwo OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
項目[GROUP] SEQUENCE OF SEQUENCE {以前[GROUP] OneAndTwo、コアUTF8Stringを、[GROUP]はOPTIONAL OneAndTwo後}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      OneAndTwo ::= SEQUENCE {
          non-core  UTF8String
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= item S
      P2:  S ::=
      P3:  item ::= before core after
      P4:  before ::= non-core
      P5:  non-core ::= &#34;non-core&#34;
      P6:  core ::= &#34;core&#34;
      P7:  after ::= non-core
      P8:  after ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { &#34;non-core&#34; } First(P2) = { } Preselected(P1) = Preselected(P2) = Empty(P1) = false Empty(P2) = true Follow(S) = { &#34;$&#34; } Select(P1) = First(P1) = { &#34;non-core&#34; } Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= { &#34;非コア&#34;}最初の（P2）= {}は事前に選択され（P1）=事前に選択された（P2）=空（P1）が偽空（P2）を= TRUEフォロー（S）= { &#34;$&#34; を= }選択（P1）まず（P1）= { &#34;非コア&#34;}選択（P2）=最初の（P2）+フォロー（S）= { &#34;$&#34; を} =
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P7) = { &#34;non-core&#34; } First(P8) = { } Preselected(P7) = Preselected(P8) = Empty(P7) = false Empty(P8) = true Follow(after) = { &#34;non-core&#34;, &#34;$&#34; } Select(P7) = First(P7) = { &#34;non-core&#34; } Select(P8) = First(P8) + Follow(after) = { &#34;non-core&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P7）= { &#34;非コア&#34;}最初（P8）= {}事前に選択された（P7）=事前に選択された（P8）=空（P7）が偽空（P8）を= TRUEフォロー（後）= {「非を=コア」、 &#34;$&#34;}を選択（P7）が最初に（P7）を= = { &#34;非コア&#34;}（P8）を選択するには、最初の（P8）+フォロー（後）= {= &#34;非コア&#34;、 &#34;$&#34; を}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P7) and Select(P8) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. There is ambiguity between the end of one item and the start of the next. Without looking ahead in an encoding, it is not possible to determine whether a &lt;non-core&gt; element belongs with the preceding or following &lt;core&gt; element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P7）と選択（P8）の交点は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。 1つの項目の終了と次の開始の間の曖昧さがあります。エンコーディングに先読みすることなく、&lt;非コア&gt;要素には、前後の&lt;コア&gt;要素に属するか否かを決定することは不可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.10. Example 10
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
A.10。実施例10
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE { one [GROUP] List, two [GROUP] SEQUENCE { three [ATTRIBUTE] UTF8String, four [GROUP] List } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CHOICE {1 [GROUP]一覧、2 [GROUP] SEQUENCE {3 [ATTRIBUTE] UTF8Stringを4 [GROUP]一覧}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= two
      P3:  one ::= string one
      P4:  one ::=
      P5:  two ::= three four
      P6:  three ::= &#34;@three&#34;
      P7:  four ::= string four
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P8:  four ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { &#34;string&#34; } First(P2) = { &#34;string&#34; } Preselected(P1) = Empty(P2) = false Preselected(P2) = Empty(P1) = true Follow(S) = { &#34;$&#34; } Select(P1) = First(P1) + Follow(S) = { &#34;string&#34;, &#34;$&#34; } Select(P2) = { }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= { &#34;文字列&#34;}最初の（P2）= { &#34;文字列&#34;}事前に選択され（P1）=空（P2）が偽事前に選択された（P2）を= =空（P1）は、真のフォロー（S）= {「$を=文字列 &#34;}選択（P1）まず（P1）+フォロー（S）=を{= &#34;&#34;、 &#34;$&#34;}選択（P2）= {}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P3) = { &#34;string&#34; } First(P4) = { } Preselected(P3) = Preselected(P4) = Empty(P3) = false Empty(P4) = true Follow(one) = { &#34;$&#34; } Select(P3) = First(P3) = { &#34;string&#34; } Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P3）= { &#34;文字列&#34;}まず（P4）= {}事前に選択された（P3）=事前に選択された（P4）=空（P3）が偽空（P4）を= trueをフォロー（1）=を= { &#34;$&#34;}を選択（P3）はまず（P3）= { &#34;string&#34; を} =（P4）を選択=最初の（P4）+フォロー（1）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P7) = { &#34;string&#34; } First(P8) = { } Preselected(P7) = Preselected(P8) = Empty(P7) = false Empty(P8) = true Follow(four) = { &#34;$&#34; } Select(P7) = First(P7) = { &#34;string&#34; } Select(P8) = First(P8) + Follow(four) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず（P7）= { &#34;文字列&#34;}まず（P8）= {}事前に選択された（P7）=事前に選択された（P8）=空（P7）が偽空（P8）を= trueをフォロー（4）=を= { &#34;$&#34;}を選択（P7）（P8）を選択するには、最初の（P7）= { &#34;の文字列を&#34;} = =最初の（P8）+フォロー（4）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P1) and Select(P2) is empty, as is the intersection of Select(P3) and Select(P4) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. Although both alternatives of the CHOICE can begin with a &lt;string&gt; element, an RXER decoder would use the presence of a &#34;three&#34; attribute to decide whether to select or disregard the &#34;two&#34; alternative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P3）と選択（P4）と選択（P7）と選択（P8）の交差点の交差点であるように選択（P1）と選択（P2）との交点は、空です。したがって、文法は確定的で、型定義が有効です。 CHOICEの両方の選択肢が&lt;文字列&gt;要素で始めることができますが、RXERデコーダは、「2」の代替を選択するか、無視するかどうかを決定するために、「3」の属性の存在を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, an attribute in an extension cannot be used to select between alternatives. Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、拡張内の属性は、選択肢の間で選択するために使用することはできません。次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SINGULAR-INSERTIONS] CHOICE { one [GROUP] List, ..., two [GROUP] SEQUENCE { three [ATTRIBUTE] UTF8String, four [GROUP] List } -- ExtensionAdditionAlternative (E1). -- The extension insertion point is here (I1). }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【の特異挿入] CHOICE {1 [GROUP]リスト、...、2 [GROUP] SEQUENCE {3 [ATTRIBUTE] UTF8Stringを4 [GROUP]一覧}  -  ExtensionAdditionAlternative（E1）。 - 拡張挿入点は、ここで（I1）です。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P10: S ::= E1
      P11: S ::= &#34;*&#34;
      P12: E1 ::= two
      P3:  one ::= string one
      P4:  one ::=
      P5:  two ::= three four
      P6:  three ::= &#34;@three&#34;
      P7:  four ::= string four
      P8:  four ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates for P1, P10 and P11:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、P1、P10とP11のために、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { &#34;string&#34; } First(P10) = { &#34;string&#34; } First(P11) = { &#34;*&#34; } Preselected(P1) = Preselected(P10) = Preselected(P11) = false Empty(P10) = Empty(P11) = false Empty(P1) = true Follow(S) = { &#34;$&#34; } Select(P1) = First(P1) + Follow(S) = { &#34;string&#34;, &#34;$&#34; } Select(P10) = First(P10) = { &#34;string&#34; } Select(P11) = First(P11) = { &#34;*&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= { &#34;文字列&#34;}最初の（P10）= { &#34;文字列&#34;}最初の（P11）= { &#34;*&#34;}事前に選択され（P1）=事前に選択され（P10）=事前に選択され（P11）偽空（P10）を= =空（P11）が偽空（P1）を=には、真のフォロー（S）= { &#34;$&#34;}セレクト（P1）=最初の（P1）+フォロー（S）= { &#34;文字列&#34;、 &#34;$&#34;}選択（P10を= ）=最初の（P10）= { &#34;文字列&#34;}（P11を選択）が最初に（P11）を= = { &#34;*&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Preselected(P10) evaluates to false because Preselected(P10) is evaluated on the base grammar, wherein P10 is rewritten as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
予め選択された（P10）は、P10は次のように書き換えられる前記ベース文法、上で評価されているため、予め選択され（P10）が偽と評価されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P10: S ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P1) and Select(P10) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. An RXER decoder using the original, unextended version of the definition would not know that the &#34;three&#34; attribute selects between the &#34;one&#34; alternative and the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P1）と選択（P10）との交点が空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。定義の元、拡張されていないバージョンを使用してRXERデコーダは「3」属性が「1」の代替と拡張子の間を選択することを知ることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix B. Insertion Encoding Instruction Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録B.挿入エンコード命令の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix is non-normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録は非規範的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix contains examples showing the use of insertion encoding instructions to remove extension ambiguity arising from use of the GROUP encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録では、グループ符号化命令の使用から生じる拡張の曖昧さを除去するために挿入エンコード命令の使用を示す例を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1. Example 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.1。例1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] SEQUENCE { two UTF8String, ... -- Extension insertion point (I1). }, three INTEGER OPTIONAL, ... -- Extension insertion point (I2). }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] SEQUENCE {2つのUTF8Stringを...  - 拡張挿入ポイント（I1）。 }三のINTEGER OPTIONAL、...  - 拡張挿入ポイント（I2）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one three I2
      P2:  one ::= two I1
      P3:  two ::= &#34;two&#34;
      P4:  I1 ::= &#34;*&#34; I1
      P5:  I1 ::=
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
      P8:  I2 ::= &#34;*&#34; I2
      P9:  I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P4) = { &#34;*&#34; } First(P5) = { } Preselected(P4) = Preselected(P5) = Empty(P4) = false Empty(P5) = true Follow(I1) = { &#34;three&#34;, &#34;*&#34;, &#34;$&#34; } Select(P4) = First(P4) = { &#34;*&#34; } Select(P5) = First(P5) + Follow(I1) = { &#34;three&#34;, &#34;*&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P4）= { &#34;*&#34;}最初の（P5）= {}事前に選択され（P4）=事前に選択され（P5）=空（P4）が偽空（P5）を= = TRUEフォロー（I1）= { &#34;3&#34;、 &#34; *」、 &#34;$ *&#34;}選択（P4）は、まず（P4）= {= &#34;&#34;}選択（P5）を=最初の（P5）+フォロー（I1）= { &#34;3&#34;、 &#34;*&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P6) = { &#34;three&#34; } First(P7) = { } Preselected(P6) = Preselected(P7) = Empty(P6) = false Empty(P7) = true Follow(three) = { &#34;*&#34;, &#34;$&#34; } Select(P6) = First(P6) = { &#34;three&#34; } Select(P7) = First(P7) + Follow(three) = { &#34;*&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P6）= { &#34;三&#34;}最初の（P7）= {}事前に選択された（P6）=事前に選択された（P7）=空（P6）が偽空（P7）を= TRUEフォローを（3つ）= { &#34;*&#34;、 &#34;= $」}（P6）を選択は、まず（P6）を= = { &#34;3&#34;}（P7）を選択するには、最初の（P7）+フォロー（3）= {= &#34;*&#34;、 &#34;$&#34; を}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P8) = { &#34;*&#34; } First(P9) = { } Preselected(P8) = Preselected(P9) = Empty(P8) = false Empty(P9) = true Follow(I2) = { &#34;$&#34; } Select(P8) = First(P8) = { &#34;*&#34; } Select(P9) = First(P9) + Follow(I2) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P8）= { &#34;*&#34;}まず（P9）= {}事前に選択された（P8）=事前に選択された（P9）=空（P8）が偽空（P9）を= TRUEフォロー（I2）= { &#34;$&#34; を} =を選択（P8）（P9）を選択するには、最初の（P8）= { &#34;*&#34;} = =最初の（P9）+フォロー（I2）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P4) and Select(P5) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If an RXER decoder encounters an unrecognized element immediately after a &lt;two&gt; element, then it will not know whether to associate it with extension insertion point I1 or I2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P4）と選択（P5）の交点は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。 RXERデコーダは、&lt;2&gt;要素の直後に認識されていない要素に遭遇した場合、それは、拡張挿入点I1又はI2に関連付けするかどうかを知ることができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The non-determinism can be resolved with either a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction. Consider this revised type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非決定性は、NO-挿入または中空挿入エンコード命令のいずれかで解決することができます。この改訂された型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] [HOLLOW-INSERTIONS] SEQUENCE { two UTF8String, ... -- Extension insertion point (I1). }, three INTEGER OPTIONAL, ... -- Extension insertion point (I2). }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] [中空挿入] SEQUENCE {2つのUTF8Stringを...  - 拡張挿入ポイント（I1）。 }三のINTEGER OPTIONAL、...  - 拡張挿入ポイント（I2）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one three I2
      P10: one ::= two
      P3:  two ::= &#34;two&#34;
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
      P8:  I2 ::= &#34;*&#34; I2
      P9:  I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the addition of the HOLLOW-INSERTIONS encoding instruction, the P4 and P5 productions are no longer generated, and the conflict between Select(P4) and Select(P5) no longer exists. The Select Sets for P6, P7, P8, and P9 are unchanged. A decoder will now assume that an unrecognized element is to be associated with extension insertion point I2. It is still free to associate an unrecognized attribute with either extension insertion point. If a NO-INSERTIONS encoding instruction had been used, then an unrecognized attribute could only be associated with extension insertion point I2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
中空挿入エンコード命令を添加して、P4及びP5生産はもはや発生せず、及び選択（P4）と選択（P5）との間の競合がもはや存在しています。 P6、P7、P8、およびP9のための選択設定は変更されません。デコーダは、現在認識されていない要素は、拡張挿入点I2に関連付けられると仮定する。まだ拡張挿入点のいずれかで認識されていない属性を関連付けることが自由です。 NO-挿入エンコード命令が使用されていた場合、認識されていない属性は、拡張挿入点I2に関連付けすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The non-determinism could also be resolved by adding a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction to the outer SEQUENCE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非決定論は、外側の配列にNO-挿入または中空挿入エンコード命令を追加することによって解決することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HOLLOW-INSERTIONS] SEQUENCE { one [GROUP] SEQUENCE { two UTF8String, ... -- Extension insertion point (I1). }, three INTEGER OPTIONAL, ... -- Extension insertion point (I2). }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[中空挿入] SEQUENCE {1 [GROUP] SEQUENCE {2つのUTF8Stringを...  - 拡張挿入ポイント（I1）。 }三のINTEGER OPTIONAL、...  - 拡張挿入ポイント（I2）。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P11: S ::= one three
      P2:  one ::= two I1
      P3:  two ::= &#34;two&#34;
      P4:  I1 ::= &#34;*&#34; I1
      P5:  I1 ::=
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P4) = { &#34;*&#34; } First(P5) = { } Preselected(P4) = Preselected(P5) = Empty(P4) = false Empty(P5) = true Follow(I1) = { &#34;three&#34;, &#34;$&#34; } Select(P4) = First(P4) = { &#34;*&#34; } Select(P5) = First(P5) + Follow(I1) = { &#34;three&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P4）= { &#34;*&#34;}最初の（P5）= {}事前に選択され（P4）=事前に選択され（P5）=空（P4）が偽空（P5）を= = TRUEフォロー（I1）= { &#34;3&#34;、 &#34; $ *」}選択（P4）は、まず（P4）= {= &#34;&#34;}選択（P5）を=最初の（P5）+フォロー（I1）= { &#34;3&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P6) = { &#34;three&#34; } First(P7) = { } Preselected(P6) = Preselected(P7) = Empty(P6) = false Empty(P7) = true Follow(three) = { &#34;$&#34; } Select(P6) = First(P6) = { &#34;three&#34; } Select(P7) = First(P7) + Follow(three) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず、（P6）= { &#34;3&#34;}まず（P7）= {}事前に選択された（P6）=事前に選択された（P7）=空（P6）が偽空（P7）を= TRUEフォロー（3）= { &#34;$&#34;}選択= （P6）、（P7）を選択するには、最初の（P6）= { &#34;三&#34;} = =最初の（P7）+フォロー（3）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P4) and Select(P5) is empty, as is the intersection of Select(P6) and Select(P7); hence, the grammar is deterministic, and the type definition is valid. A decoder will now assume that an unrecognized element is to be associated with extension insertion point I1. It is still free to associate an unrecognized attribute with either extension insertion point. If a NO-INSERTIONS encoding instruction had been used, then an unrecognized attribute could only be associated with extension insertion point I1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P6）と選択（P7）との交点であるように選択（P4）と選択（P5）の交差点は、空です。したがって、文法は確定的で、型定義が有効です。デコーダは、現在認識されていない要素は、拡張挿入点I1に関連付けられると仮定する。まだ拡張挿入点のいずれかで認識されていない属性を関連付けることが自由です。 NO-挿入エンコード命令が使用されていた場合、認識されていない属性は、拡張挿入点I1に関連付けすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2. Example 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.2。例2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] CHOICE { two UTF8String, ... -- Extension insertion point (I1). } OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] CHOICE {2つのUTF8Stringを...  - 拡張挿入ポイント（I1）。 }} OPTIONAL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= I1
      P4:  one ::=
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;two&#34; } First(P3) = { &#34;*&#34; } First(P4) = { } Preselected(P2) = Preselected(P3) = Preselected(P4) = false Empty(P2) = false Empty(P3) = Empty(P4) = true Follow(one) = { &#34;$&#34; } Select(P2) = First(P2) = { &#34;two&#34; } Select(P3) = First(P3) + Follow(one) = { &#34;*&#34;, &#34;$&#34; } Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;2&#34;}最初の（P3）= { &#34;*&#34;}最初の（P4）= {}事前に選択された（P2）=事前に選択された（P3）=事前に選択され（P4）が偽空（P2）が偽空の==します（P3）=空（P4）が真のフォロー（1）= { &#34;$&#34; は}（P2）を選択=最初の（P2）を= = { &#34;2&#34;}は、（P3）を選択するには、最初の（P3）+フォロー（一つ）= = { &#34;*&#34;、 &#34;$&#34;}選択（P4）は、まず（P4）+フォロー（1）= { &#34;$&#34;} =
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P6) = { &#34;*&#34; } First(P7) = { } Preselected(P6) = Preselected(P7) = Empty(P6) = false Empty(P7) = true
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P6）= { &#34;*&#34;}最初の（P7）= {}事前に選択された（P6）=事前に選択された（P7）=空（P6）が偽空（P7）を= TRUE =
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Follow(I1) = { &#34;$&#34; } Select(P6) = First(P6) = { &#34;*&#34; } Select(P7) = First(P7) + Follow(I1) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（I1）をフォロー= { &#34;$&#34;}（P6）を選択するには、最初の（P6）を= = { &#34;*&#34;}（P7）を選択=最初の（P7）+フォロー（I1）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the &lt;two&gt; element is not present, then a decoder cannot determine whether the &#34;one&#34; alternative is absent, or present with an unknown extension that generates no elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P3）と選択（P4）の交点は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。 &lt;2&gt;要素が存在しない場合、デコーダは、「1」の選択肢は存在しないか、または全く要素を生成しない未知の拡張子を持つ存在するかどうかを決定することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The non-determinism can be resolved with either a SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, or MULTIFORM-INSERTIONS encoding instruction. The MULTIFORM-INSERTIONS encoding instruction is the least restrictive. Consider this revised type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非決定性は、特異-挿入、均一挿入、または多形-挿入エンコード命令のいずれかで解決することができます。多形-挿入エンコード命令は最も制限的です。この改訂された型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] [MULTIFORM-INSERTIONS] CHOICE { two UTF8String, ... -- Extension insertion point (I1). } OPTIONAL }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] [多形-挿入] CHOICE {2つのUTF8Stringを...  - 拡張挿入ポイント（I1）。 }} OPTIONAL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P8:  one ::= &#34;*&#34; I1
      P4:  one ::=
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;two&#34; } First(P8) = { &#34;*&#34; } First(P4) = { } Preselected(P2) = Preselected(P8) = Preselected(P4) = false Empty(P2) = Empty(P8) = false Empty(P4) = true Follow(one) = { &#34;$&#34; } Select(P2) = First(P2) = { &#34;two&#34; } Select(P8) = First(P8) = { &#34;*&#34; } Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;2&#34;}最初の（P8）= { &#34;*&#34;}最初の（P4）= {}事前に選択された（P2）=事前に選択された事前に選択され（P4）が偽空（P2）を= =（P8）=空（ P8）偽（空P4を=）が真のフォロー（1）を= = { &#34;$&#34;}は（P2を選択します）まず（P2）を= = { &#34;2&#34;}（P8を選択します）まず、（P8）を= = { &#34;*&#34;}まず、（P4）+フォロー（1）を=（P4）を選択= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P6) = { &#34;*&#34; } First(P7) = { } Preselected(P6) = Preselected(P7) = Empty(P6) = false
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P6）= { &#34;*&#34;}最初の（P7）= {}事前に選択された（P6）=事前に選択された（P7）=空（P6）が偽=
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Empty(P7) = true Follow(I1) = { &#34;$&#34; } Select(P6) = First(P6) = { &#34;*&#34; } Select(P7) = First(P7) + Follow(I1) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
空の（P7）真フォロー（I1）を= = { &#34;$&#34; は}（P6）を選択するには、最初の（P6）を= = { &#34;*&#34;}（P7）を選択するには、最初の（P7）+フォロー（I1）を= = { &#34;$&#34; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P8) is empty, as is the intersection of Select(P2) and Select(P4), the intersection of Select(P8) and Select(P4), and the intersection of Select(P6) and Select(P7); hence, the grammar is deterministic, and the type definition is valid. A decoder will now assume the &#34;one&#34; alternative is present if it sees at least one unrecognized element, and absent otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P2）と選択（P4）、選択（P8）と選択（P4）の交差点の交差点、及び選択の交点（P6がそのまま選択（P2）と選択（P8）の交差点は、空であります）と選択（P7）。したがって、文法は確定的で、型定義が有効です。デコーダは、今では少なくとも一つの認識されていない要素、および不在さもなければを見れば「1」の代替が存在すると仮定する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3. Example 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.3。例3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] CHOICE { two UTF8String, ... -- Extension insertion point (I1). }, three [GROUP] CHOICE { four UTF8String, ... -- Extension insertion point (I2). } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] CHOICE {2つのUTF8Stringを...  - 拡張挿入ポイント（I1）。 }三[GROUP] CHOICE {4つのUTF8Stringを...  - 拡張挿入ポイント（I2）。 }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P3:  one ::= I1
      P4:  two ::= &#34;two&#34;
      P5:  I1 ::= &#34;*&#34; I1
      P6:  I1 ::=
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;two&#34; } First(P3) = { &#34;*&#34; } Preselected(P2) = Preselected(P3) = Empty(P2) = false Empty(P3) = true
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;2&#34;}最初の（P3）= { &#34;*&#34;}事前に選択された（P2）=事前に選択された（P3）=空（P2）が偽空（P3）を= TRUE =
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; } Select(P2) = First(P2) = { &#34;two&#34; } Select(P3) = First(P3) + Follow(one) = { &#34;*&#34;, &#34;four&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（1）= { &#34;4&#34;、 &#34;*&#34;、 &#34;$&#34;}フォローを選択し（P2）ファースト（P2）を= = { &#34;2&#34;}（P3）を選択するには、最初の（P3）+フォロー（1）を= = { &#34; *」、 &#34;4&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P5) = { &#34;*&#34; } First(P6) = { } Preselected(P5) = Preselected(P6) = Empty(P5) = false Empty(P6) = true Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; } Select(P5) = First(P5) = { &#34;*&#34; } Select(P6) = First(P6) + Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P5）= { &#34;*&#34;}最初の（P6）= {}事前に選択され（P5）=事前に選択された（P6）=空（P5）は偽空（P6）を= = TRUEフォロー（I1）= { &#34;4&#34;、 &#34; *」、 &#34;$ *&#34;}選択（P5）まず（P5）= {= &#34;&#34;}選択（P6）を=最初の（P6）+フォロー（I1）= { &#34;4&#34;、 &#34;*&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P7) = { &#34;four&#34; } First(P8) = { &#34;*&#34; } Preselected(P7) = Preselected(P8) = Empty(P7) = false Empty(P8) = true Follow(three) = { &#34;$&#34; } Select(P7) = First(P7) = { &#34;four&#34; } Select(P8) = First(P8) + Follow(three) = { &#34;*&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず（P7）= { &#34;4&#34;}まず（P8）= { &#34;*&#34;}事前に選択された（P7）=事前に選択された（P8）=空（P7）が偽空（P8）を= TRUEフォロー（3）= {「$を= &#34;}（P7）を選択するには、最初の（P7）を= = { &#34;4&#34;}（P8）を選択するには、最初の（P8）+フォロー（3）= {= &#34;*&#34;、 &#34;$&#34; を}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P10) = { &#34;*&#34; } First(P11) = { } Preselected(P10) = Preselected(P11) = Empty(P10) = false Empty(P11) = true Follow(I2) = { &#34;$&#34; } Select(P10) = First(P10) = { &#34;*&#34; } Select(P11) = First(P11) + Follow(I2) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
まず（P10）= { &#34;*&#34;}まず（P11）= {}事前に選択された（P10）=事前に選択された（P11）=空（P10）が偽空（P11）を= trueをフォロー（I2）=を= { &#34;$&#34;}を選択（P10）=最初の（P10）= { &#34;*&#34;}を選択（P11）=最初の（P11）+フォロー（I2）= { &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P5) and Select(P6) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the first child element is an unrecognized element, then a decoder cannot determine whether to associate it with extension insertion point I1, or to associate it with extension insertion point I2 by assuming that the &#34;one&#34; component has an unknown extension that generates no elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セレクト（P5）と選択（P6）の交点は空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。最初の子要素が認識されない要素である場合、デコーダは、拡張挿入点I1に関連付けするかどうかを決定することができない、または「1」の成分が要素を生成しない未知の拡張子を持っていると仮定して拡張挿入点I2に関連付けること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The non-determinism can be resolved with either a SINGULAR-INSERTIONS or UNIFORM-INSERTIONS encoding instruction. Consider this revised type definition using the SINGULAR-INSERTIONS encoding instruction:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非決定性は、特異-挿入または均一挿入エンコード命令のいずれかで解決することができます。 SINGULAR-挿入エンコーディング命令を使用して、この改訂された型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] [SINGULAR-INSERTIONS] CHOICE { two UTF8String, ... -- Extension insertion point (I1). }, three [GROUP] CHOICE { four UTF8String, ... -- Extension insertion point (I2). } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] [の特異挿入] CHOICE {2つのUTF8Stringを...  - 拡張挿入ポイント（I1）。 }三[GROUP] CHOICE {4つのUTF8Stringを...  - 拡張挿入ポイント（I2）。 }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P12: one ::= &#34;*&#34;
      P4:  two ::= &#34;two&#34;
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the addition of the SINGULAR-INSERTIONS encoding instruction, the P5 and P6 productions are no longer generated. The grammar leads to the following sets and predicates for the P2 and P12 productions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特異挿入エンコード命令を添加して、P5およびP6生産はもはや生成されません。文法は、P2およびP12の制作のために、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;two&#34; } First(P12) = { &#34;*&#34; } Preselected(P2) = Preselected(P12) = false Empty(P2) = Empty(P12) = false Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; } Select(P2) = First(P2) = { &#34;two&#34; } Select(P12) = First(P12) = { &#34;*&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;2&#34;}最初の（P12）= { &#34;*&#34;}事前に選択された（P2）=事前に選択され（P12）が偽空（P2）を= =空（P12）が偽フォロー（一つ）= = {「4 」、 &#34;*&#34;、 &#34;$&#34;}（P2）を選択するには、最初の（P2）を= = { &#34;2&#34;}（P12）を選択するには、最初の（P12）を= = { &#34;*&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sets for P5 and P6 are no longer generated, and the remaining sets are unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
P5とP6のためのセットはもはや生成されず、残りのセットは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P12) is empty, as is the intersection of Select(P7) and Select(P8) and the intersection of Select(P10) and Select(P11); hence, the grammar is deterministic, and the type definition is valid. If the first child element is an unrecognized element, then a decoder will now assume that it is associated with extension insertion point I1. Whatever follows, possibly including another unrecognized element, will belong to the &#34;three&#34; component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P7）と選択（P8）と選択（P10）と選択（P11）の交差点の交差点であるように選択（P2）と選択（P12）の交差点は、空です。したがって、文法は確定的で、型定義が有効です。最初の子要素が認識されない要素である場合、デコーダは、現在、それが拡張挿入点I1に関連付けられていると仮定する。おそらく他の認識されていない要素を含め、以下のものは何でも、「3」のコンポーネントに属します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Now consider the type definition using the UNIFORM-INSERTIONS encoding instruction instead:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
今、代わりにUNIFORM-挿入エンコーディング命令を使用して型定義を考えてみます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE { one [GROUP] [UNIFORM-INSERTIONS] CHOICE { two UTF8String, ... -- Extension insertion point (I1). }, three [GROUP] CHOICE { four UTF8String, ... -- Extension insertion point (I2). } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE {1 [GROUP] [UNIFORM-挿入] CHOICE {2つのUTF8Stringを...  - 拡張挿入ポイント（I1）。 }三[GROUP] CHOICE {4つのUTF8Stringを...  - 拡張挿入ポイント（I2）。 }}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P13: one ::= &#34;*&#34;
      P14: one ::= &#34;*1&#34; I1
      P4:  two ::= &#34;two&#34;
      P15: I1 ::= &#34;*1&#34; I1
      P6:  I1 ::=
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates for the P2, P13, P14, P15, and P6 productions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットにつながり、P2、P13、P14、P15、およびP6制作のための述語：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P2) = { &#34;two&#34; } First(P13) = { &#34;*&#34; } First(P14) = { &#34;*1&#34; } Preselected(P2) = Preselected(P13) = Preselected(P14) = false Empty(P2) = Empty(P13) = Empty(P14) = false Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; } Select(P2) = First(P2) = { &#34;two&#34; } Select(P13) = First(P13) = { &#34;*&#34; } Select(P14) = First(P14) = { &#34;*1&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P2）= { &#34;2&#34;}最初の（P13）= { &#34;*&#34;}最初の（P14）= { &#34;* 1&#34;}事前に選択された（P2）=事前に選択され（P13）=事前に選択され（P14）は= FALSE空（P2 ）=空（P13）=空（P14）が偽フォロー（1）= { &#34;4&#34;、 &#34;*&#34;、 &#34;$&#34; は}（P2を選択=）=最初の（P2）= { &#34;2&#34;}（P13）を選択します=最初の（P13）= { &#34;*&#34;}選択（P14）は=最初の（P14）= { &#34;* 1&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P15) = { &#34;*1&#34; } First(P6) = { } Preselected(P15) = Preselected(P6) = Empty(P15) = false Empty(P6) = true Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; } Select(P15) = First(P15) = { &#34;*1&#34; } Select(P6) = First(P6) + Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P15）= { &#34;* 1&#34;}最初（P6）= {}事前に選択され（P15）=事前に選択された（P6）=空（P15）が偽空（P6）を= TRUEフォロー（I1）= { &#34;4&#34; を= &#34;*&#34;、 &#34;$&#34;}選択（P15）まず（P15）= { &#34;* 1&#34;}選択（P6）=最初の（P6）+フォロー（I1）= { &#34;4&#34;、 &#34;*&#34;、「$を= &#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The remaining sets are unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
残りのセットは変更されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P2) and Select(P13) is empty, as is the intersection of Select(P2) and Select(P14), the intersection of Select(P13) and Select(P14) and the intersection of Select(P15) and Select(P6); hence, the grammar is deterministic, and the type definition is valid. If the first child element is an unrecognized element, then a decoder will now assume that it and every subsequent unrecognized element with the same name are associated with I1. Whatever follows, possibly including another unrecognized element with a different name, will belong to the &#34;three&#34; component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P2）と選択（P14）との交点であるように選択（P2）と選択（P13）の交差点は、空である、選択（P13）と選択（P14）の交点と選択の交点（P15）そして、（P6）を選択します。したがって、文法は確定的で、型定義が有効です。最初の子要素が認識されない要素である場合には、デコーダは今と同じ名前を持つ後続のすべての認識できない要素がI1と関連していることを前提としています。おそらく異なる名前を持つ別の認識できない要素を含め、以下のものは何でも、「3」のコンポーネントに属します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A consequence of using the UNIFORM-INSERTIONS encoding instruction is that any future extension to the &#34;three&#34; component will be required to generate elements with names that are different from the names of the elements generated by the &#34;one&#34; component. With the SINGULAR-INSERTIONS encoding instruction, extensions to the &#34;three&#34; component are permitted to generate elements with names that are the same as the names of the elements generated by the &#34;one&#34; component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
均一挿入エンコード命令を使用しての結果は、「三」成分に任意の将来の拡張が「1」のコンポーネントによって生成された要素の名前とは異なる名前を持つ要素を生成するために必要とされることです。特異挿入エンコード命令と、「三」コンポーネントへの拡張は、「1」のコンポーネントによって生成された要素の名前と同じである名前の要素を生成することが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.4. Example 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B.4。例4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次の型の定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE OF one [GROUP] CHOICE { two UTF8String, ... -- Extension insertion point (I1). }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張挿入ポイント（I1） - オン[GROUP] CHOICE {2つのUTF8Stringを、...のシーケンス。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P4:  one ::= I1
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { &#34;two&#34;, &#34;*&#34; } First(P2) = { } Preselected(P1) = Preselected(P2) = false Empty(P1) = Empty(P2) = true Follow(S) = { &#34;$&#34; } Select(P1) = First(P1) + Follow(S) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; } Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= { &#34;2&#34;、 &#34;*&#34;}最初の（P2）= {}事前に選択され（P1）=事前に選択された（P2）が偽空（P1）を= =空（P2）は、真のフォロー（S）=を{ &#34;= $」}（P1）を選択するには、最初の（P1）+フォロー（S）を= = { &#34;2&#34;、 &#34;*&#34;、 &#34;$&#34;}（P2）を選択まず（P2）+フォロー（S）を= = { &#34;$&#34; }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P3) = { &#34;two&#34; } First(P4) = { &#34;*&#34; } Preselected(P3) = Preselected(P4) = Empty(P3) = false Empty(P4) = true Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; } Select(P3) = First(P3) = { &#34;two&#34; } Select(P4) = First(P4) + Follow(one) = { &#34;*&#34;, &#34;two&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P3）= { &#34;2&#34;}最初の（P4）= { &#34;*&#34;}事前に選択された（P3）=事前に選択され（P4）=空（P3）が偽空（P4）を= TRUEフォロー（一つ）= = {「二&#34; &#34;*&#34;、 &#34;$&#34;}（P3）を選択するには、最初の（P3）を= = { &#34;2&#34;}（P4）を選択するには、最初の（P4）+フォロー（1）を= = { &#34;*&#34;、 &#34;2&#34;、&#34; $」}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P6) = { &#34;*&#34; } First(P7) = { } Preselected(P6) = Preselected(P7) = Empty(P6) = false Empty(P7) = true Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; } Select(P6) = First(P6) = { &#34;*&#34; } Select(P7) = First(P7) + Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P6）= { &#34;*&#34;}最初の（P7）= {}事前に選択された（P6）=事前に選択された（P7）=空（P6）が偽空（P7）を= = TRUEフォロー（I1）= { &#34;2&#34;、 &#34; *」、 &#34;$ *&#34;}選択（P6）まず（P6）= {= &#34;&#34;}選択（P7）を=最初の（P7）+フォロー（I1）= { &#34;2&#34;、 &#34;*&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P1) and Select(P2) is not empty, as is the intersection of Select(P3) and Select(P4) and the intersection of Select(P6) and Select(P7); hence, the grammar is not deterministic, and the type definition is not valid. If a decoder encounters two or more unrecognized elements in a row, then it cannot determine whether this represents one instance or more than one instance of the &#34;one&#34; component. Even without unrecognized elements, there is still a problem that an encoding could contain an indeterminate number of &#34;one&#34; components using an extension that generates no elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P3）と選択（P4）と選択（P6）と選択（P7）の交差点の交差点であるように選択（P1）と選択（P2）との交点は、空ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。デコーダは、行に2つの以上の認識されていない要素に遭遇した場合、これは一例又は「1」の成分の複数のインスタンスを表しているかどうかを決定することができません。認識されていない要素なし、符号が要素を生成しない拡張子を使用して「1」の成分の不確定数を含むことができるという問題が依然として存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The non-determinism cannot be resolved with a UNIFORM-INSERTIONS encoding instruction. Consider this revised type definition using the UNIFORM-INSERTIONS encoding instruction:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非決定論は、UNIFORM-挿入エンコードの命令で解決することはできません。 UNIFORM-挿入エンコーディング命令を使用して、この改訂された型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE OF one [GROUP] [UNIFORM-INSERTIONS] CHOICE { two UTF8String, ... -- Extension insertion point (I1). }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張挿入ポイント（I1） - オン[GROUP] [UNIFORM-挿入] CHOICE {2つのUTF8Stringを、...のシーケンス。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P8:  one ::= &#34;*&#34;
      P9:  one ::= &#34;*1&#34; I1
      P5:  two ::= &#34;two&#34;
      P10: I1 ::= &#34;*1&#34; I1
      P7:  I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34; } First(P2) = { } Preselected(P1) = Preselected(P2) = Empty(P1) = false Empty(P2) = true Follow(S) = { &#34;$&#34; } Select(P1) = First(P1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34; } Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= { &#34;2&#34;、 &#34;*&#34;、 &#34;* 1&#34;}最初の（P2）= {}事前に選択され（P1）=事前に選択された（P2）=空（P1）が偽空（P2）を=（真のフォローを= S）= { &#34;$&#34;}選択（P1）がまず=（P1）= { &#34;2&#34;、 &#34;*&#34;、 &#34;* 1&#34;}（P2を選択）まず（P2）+フォロー（S）= {「$を= &#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P3) = { &#34;two&#34; } First(P8) = { &#34;*&#34; } First(P9) = { &#34;*1&#34; } Preselected(P3) = Preselected(P8) = Preselected(P9) = false Empty(P3) = Empty(P8) = Empty(P9) = false Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; } Select(P3) = First(P3) = { &#34;two&#34; } Select(P8) = First(P8) = { &#34;*&#34; } Select(P9) = First(P9) = { &#34;*1&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P3）= { &#34;2&#34;}最初の（P8）= { &#34;*&#34;}最初の（P9）= { &#34;* 1&#34;}事前に選択された（P3）=事前に選択された（P8）=事前に選択され（P9）は= FALSE空（P3 ）=空（P8）=空（P9）が偽フォロー（1）= { &#34;2&#34;、 &#34;*&#34;、 &#34;* 1&#34;、 &#34;$&#34; は}（P3を選択=）=最初の（P3）= { &#34;2&#34; }選択（P8）が最初に（P8）= { &#34;*&#34;}を選択し（P9）を= =最初の（P9）= { &#34;* 1&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P10) = { &#34;*1&#34; } First(P7) = { } Preselected(P10) = Preselected(P7) = Empty(P10) = false Empty(P7) = true Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; } Select(P10) = First(P10) = { &#34;*1&#34; } Select(P7) = First(P7) + Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P10）= { &#34;* 1&#34;}最初（P7）= {}事前に選択され（P10）=事前に選択された（P7）=空（P10）が偽空（P7）を= TRUEフォロー（I1）= { &#34;二&#34; を= &#34;*&#34;、 &#34;* 1&#34;、 &#34;$&#34;}選択（P10）は=最初の（P10）= { &#34;* 1&#34;}選択（P7）=最初の（P7）+フォロー（I1）= { &#34;2&#34;、 &#34; *」、 &#34;* 1&#34;、 &#34;$&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P1) and Select(P2) is now empty, but the intersection of Select(P10) and Select(P7) is not; hence, the grammar is not deterministic, and the type definition is not valid. The problem of an indeterminate number of &#34;one&#34; components from an extension that generates no elements has been solved. However, if a decoder encounters a series of elements with the same name, it cannot determine whether this represents one instance or more than one instance of the &#34;one&#34; component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P1）と選択（P2）との交点は、現在空であるが、選択（P10）と選択（P7）の交差点ではありません。したがって、文法は確定的ではなく、型定義は有効ではありません。いかなる要素を生成しない拡張子から「1」の構成要素の不確定数の問題が解決されています。デコーダは、同じ名前を持つ一連の要素に遭遇した場合は、これは一例又は「1」の成分の複数のインスタンスを表しているかどうかを決定することができません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The non-determinism can be fully resolved with a SINGULAR-INSERTIONS encoding instruction. Consider this revised type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
非決定論は完全にSINGULAR-挿入エンコードの命令で解決することができます。この改訂された型定義を考えてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SEQUENCE OF one [GROUP] [SINGULAR-INSERTIONS] CHOICE { two UTF8String, ... -- Extension insertion point (I1). }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
拡張挿入ポイント（I1） - オン〔GROUP〕〔の特異挿入] CHOICE {2つのUTF8Stringを、...のシーケンス。 }
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連する文法は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P8:  one ::= &#34;*&#34;
      P5:  two ::= &#34;two&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文法は、次のセットと述語につながります：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P1) = { &#34;two&#34;, &#34;*&#34; } First(P2) = { } Preselected(P1) = Preselected(P2) = Empty(P1) = false Empty(P2) = true Follow(S) = { &#34;$&#34; } Select(P1) = First(P1) = { &#34;two&#34;, &#34;*&#34; } Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の（P1）= { &#34;2&#34;、 &#34;*&#34;}最初の（P2）= {}事前に選択され（P1）=事前に選択された（P2）=空（P1）が偽空（P2）を= TRUEフォロー（S）を= = { &#34; $」}を選択（P1）が最初に（P1）を= = { &#34;2&#34;、 &#34;* $ &#34;}&#34;}（P2）=最初の（P2）+フォロー（S）= {選択&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
First(P3) = { &#34;two&#34; } First(P8) = { &#34;*&#34; } Preselected(P3) = Preselected(P8) = false Empty(P3) = Empty(P8) = false Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; } Select(P3) = First(P3) = { &#34;two&#34; } Select(P8) = First(P8) = { &#34;*&#34; }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初（P3）= { &#34;2&#34;}最初の（P8）= { &#34;*&#34;}事前に選択された事前に選択された（P8）が偽空（P3）を= =（P3）=空（P8）が偽フォロー（1）= {「二つ= 」、 &#34;*&#34;、 &#34;$&#34;}（P3）を選択するには、最初の（P3）を= = { &#34;2&#34;}（P8）を選択するには、最初の（P8）を= = { &#34;*&#34;}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The intersection of Select(P1) and Select(P2) is empty, as is the intersection of Select(P3) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. A decoder now knows that every extension to the &#34;one&#34; component will generate a single element, so the correct number of &#34;one&#34; components will be decoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
選択（P3）と選択（P8）の交点であるように選択（P1）と選択（P2）との交点は、空です。したがって、文法は確定的で、型定義が有効です。デコーダは、現在「1」の成分の正確な数が復号されるように「1」コンポーネントにすべての拡張は、単一の要素を生成することを知っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix C. Extension and Versioning Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録C.拡張とバージョン管理の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This appendix is non-normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この付録は非規範的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.1. Valid Extensions for Insertion Encoding Instructions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.1。挿入エンコーディング手順の有効な拡張機能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The first example shows extensions that satisfy the HOLLOW-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最初の例では、中空挿入エンコード命令を満たす拡張を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[HOLLOW-INSERTIONS] CHOICE { one BOOLEAN, ..., two [ATTRIBUTE] INTEGER, three [GROUP] SEQUENCE { four [ATTRIBUTE] UTF8String, five [ATTRIBUTE] INTEGER OPTIONAL, ... }, six [GROUP] CHOICE { seven [ATTRIBUTE] BOOLEAN, eight [ATTRIBUTE] INTEGER } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[中空挿入] CHOICE {1つのBOOLEAN、...、2 [ATTRIBUTE] INTEGER、3 [GROUP] SEQUENCE {4 [ATTRIBUTE] UTF8Stringを、5 [ATTRIBUTE] INTEGER OPTIONAL、...}、6 [GROUP] CHOICE { 7 [ATTRIBUTE] BOOLEAN 8 [ATTRIBUTE] INTEGER}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;two&#34; and &#34;six&#34; components generate only attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「2」と「6」のコンポーネントは、属性のみ発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;three&#34; component in its current form does not generate elements. Any extension to the &#34;three&#34; component will need to do likewise to avoid breaking forward compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在の形での「3」コンポーネントは、要素を生成しません。 「3」のコンポーネントに任意の拡張子は、前方互換性を壊す避けるためにも同様に行う必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The second example shows extensions that satisfy the SINGULAR-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第二の例は、特異-挿入エンコード命令を満たす拡張を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[SINGULAR-INSERTIONS] CHOICE { one BOOLEAN, ..., two INTEGER, three [GROUP] SEQUENCE { four [ATTRIBUTE] UTF8String, five INTEGER }, six [GROUP] CHOICE { seven BOOLEAN, eight INTEGER } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
【の特異挿入] CHOICE {1つのBOOLEAN、...、2つの整数、3 [GROUP] SEQUENCE {4 [ATTRIBUTE] UTF8Stringを、5つのINTEGER}、6 [GROUP] CHOICE {7つのBOOLEAN 8つのINTEGER}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;two&#34; component will always generate a single &lt;two&gt; element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「2」の成分は、常に単一の&lt;2&gt;要素を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;three&#34; component will always generate a single &lt;five&gt; element. It will also generate a &#34;four&#34; attribute, but any number of attributes is allowed by the SINGULAR-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「3」の成分は、常に単一の&lt;5&gt;要素を生成します。また、「4」の属性を生成しますが、任意の数の属性は、特異-挿入エンコードの命令によって許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;six&#34; component will either generate a single &lt;seven&gt; element or a single &lt;eight&gt; element. Either case will satisfy the requirement that there will be a single element in any given encoding of the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「6」の成分は、いずれかの単一の&lt;7&gt;要素または単一の&lt;8&gt;要素を生成します。どちらの場合は、拡張の任意の符号化に単一の要素が存在することになる要件を満足します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The third example shows extensions that satisfy the UNIFORM-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第3の例は、均一挿入エンコード命令を満たす拡張を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[UNIFORM-INSERTIONS] CHOICE { one BOOLEAN, ..., two INTEGER, three [GROUP] SEQUENCE SIZE(1..MAX) OF four INTEGER, five [GROUP] SEQUENCE { six [ATTRIBUTE] UTF8String OPTIONAL, seven INTEGER }, eight [GROUP] CHOICE { nine BOOLEAN, ten [GROUP] SEQUENCE SIZE(1..MAX) OF eleven INTEGER } }
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[均一挿入] CHOICE {1つのBOOLEAN、...、2つの整数、3 [GROUP] SEQUENCEサイズ4つの整数の（1..MAX）OPTIONAL、7つのINTEGERをUTF8STRING、5 [GROUP] SEQUENCE {6 [ATTRIBUTE]}、 8 [GROUP] CHOICE {9つのBOOLEAN、10〔GROUP〕11 INTEGERのシーケンスSIZE（1..MAX）}}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;two&#34; component will always generate a single &lt;two&gt; element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「2」の成分は、常に単一の&lt;2&gt;要素を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;three&#34; component will always generate one or more &lt;four&gt; elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「3」のコンポーネントは、常に1つ以上の&lt;4&gt;要素を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;five&#34; component will always generate a single &lt;seven&gt; element. It may also generate a &#34;six&#34; attribute, but any number of attributes is allowed by the UNIFORM-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「5」の成分は、常に単一の&lt;7&gt;要素を生成します。また、「6」の属性を生成することがありますが、任意の数の属性は、UNIFORM-挿入エンコードの命令によって許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;eight&#34; component will either generate a single &lt;nine&gt; element or one or more &lt;eleven&gt; elements. Either case will satisfy the requirement that there must be one or more elements with the same name in any given encoding of the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「8」の成分は、単一の&lt;9&gt;要素または1つ以上の&lt;11&gt;要素を生成しますか。どちらの場合は、拡張の任意のエンコーディングに同じ名前を有する1つ以上の要素が存在しなければならないことを要件を満たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.2. Versioning Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
C.2。バージョン管理の例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Making extensions that are not forward compatible is permitted provided that the incompatibility is signalled with a version indicator attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
前方の非互換性が、バージョンインジケータ属性で通知されていることに許可された互換性のない拡張機能を作ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Suppose that version 1.0 of a specification contains the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
仕様のバージョン1.0は、次の型の定義が含まれているとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ...) DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two  BOOLEAN,
             ...
         },
         ...
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
An attribute is to be added to the CHOICE for version 1.1. This change is not forward compatible since it does not satisfy the SINGULAR-INSERTIONS encoding instruction. Therefore, the version indicator attribute must be updated at the same time (or added if it wasn&#39;t already present). This results in the following new type definition for version 1.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
属性は、バージョン1.1のための選択に追加されます。それが特異-挿入エンコードの指示を満たしていないので、この変更は、前方互換性がありません。そのため、バージョンインジケータ属性が同時に更新（または、それが既に存在していなかった場合は追加）する必要があります。これは、バージョン1.1のための次の新しい型定義での結果：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34;) DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two    BOOLEAN,
             ...,
             three  [ATTRIBUTE] INTEGER -- Added in Version 1.1
         },
         ...
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a version 1.1 conformant application hasn&#39;t used the version 1.1 extension in a value of MyMessageType, then it is allowed to set the value of the version attribute to &#34;1.0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バージョン1.1準拠のアプリケーションがMyMessageTypeの値でバージョン1.1の拡張を使用していない場合、「1.0」にバージョン属性の値を設定することが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A pair of elements is added to the CHOICE for version 1.2. Again the change does not satisfy the SINGULAR-INSERTIONS encoding instruction. The type definition for version 1.2 is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要素の対は、バージョン1.2のための選択に追加されます。再び変更は、特異-挿入エンコードの指示を満たしていません。バージョン1.2のための型定義は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34; | &#34;1.2&#34;)
                          DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two    BOOLEAN,
             ...,
             three  [ATTRIBUTE] INTEGER, -- Added in Version 1.1
             four   [GROUP] SEQUENCE {
                 five  UTF8String,
                 six   GeneralizedTime
             } -- Added in version 1.2
         },
         ...
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a version 1.2 conformant application hasn&#39;t used the version 1.2 extension in a value of MyMessageType, then it is allowed to set the value of the version attribute to &#34;1.1&#34;. If it hasn&#39;t used either of the extensions, then it is allowed to set the value of the version attribute to &#34;1.0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バージョン1.2準拠のアプリケーションがMyMessageTypeの値でバージョン1.2の拡張を使用していない場合、「1.1」にバージョン属性の値を設定することが許可されています。それは拡張のいずれかを使用していない場合、「1.0」にバージョン属性の値を設定することが許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Dr. Steven Legg eB2Bcom Suite 3, Woodhouse Corporate Centre 935 Station Street Box Hill North, Victoria 3129 AUSTRALIA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スティーブンレッグeB2Bcomスイート3、ウッドハウスコーポレートセンター935駅ストリートボックスヒルノース、ビクトリア3129オーストラリア
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: +61 3 9896 7830 Fax: +61 3 9896 7801 EMail: steven.legg@eb2bcom.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：+61 3 9896 7830ファックス：+61 3 9896 7801 Eメール：steven.legg@eb2bcom.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The IETF Trust (2007).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）IETFトラスト（2007）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットSOCIETY、（もしあれば）を後援し、IETF TRUST ANDインターネットエンジニアリングタスクフォース放棄ALLに設けられています。保証は、明示または黙示、この情報の利用および特定目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証がこれらに限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
