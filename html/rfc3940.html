<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 3940 - Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3940</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 3940 - Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc3940">
              https://tools.ietf.org/html/rfc3940
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 3940 - 否定応答（NACK）指向の信頼性の高いマルチキャスト（NORM）プロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                         B. Adamson
Request for Comments: 3940                                           NRL
Category: Experimental                                        C. Bormann
                                                 Universitaet Bremen TZI
                                                              M. Handley
                                                                     UCL
                                                               J. Macker
                                                                     NRL
                                                           November 2004
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                Negative-acknowledgment (NACK)-Oriented
                   Reliable Multicast (NORM) Protocol
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモはインターネットコミュニティのためにExperimentalプロトコルを定義します。それはどんな種類のインターネット標準を指定しません。改善のための議論や提案が要求されています。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2004).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2004）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document describes the messages and procedures of the Negative-acknowledgment (NACK) Oriented Reliable Multicast (NORM) protocol. This protocol is designed to provide end-to-end reliable transport of bulk data objects or streams over generic IP multicast routing and forwarding services. NORM uses a selective, negative acknowledgment mechanism for transport reliability and offers additional protocol mechanisms to allow for operation with minimal &#34;a priori&#34; coordination among senders and receivers. A congestion control scheme is specified to allow the NORM protocol to fairly share available network bandwidth with other transport protocols such as Transmission Control Protocol (TCP). It is capable of operating with both reciprocal multicast routing among senders and receivers and with asymmetric connectivity (possibly a unicast return path) between the senders and receivers. The protocol offers a number of features to allow different types of applications or possibly other higher level transport protocols to utilize its service in different ways. The protocol leverages the use of FEC-based repair and other IETF reliable multicast transport (RMT) building blocks in its design.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、メッセージと否定応答（NACK）指向の信頼性の高いマルチキャスト（NORM）プロトコルの手順を説明します。このプロトコルは、大量のデータオブジェクトのエンドツーエンドの信頼性の高いトランスポートを提供するように設計またはジェネリックIPマルチキャストルーティングおよび転送サービス上にストリームされます。 NORMは、輸送の信頼性のための選択的、否定応答機構を使用して送信者と受信者の間で最小の「先験的」配位での動作を可能にするために追加のプロトコルメカニズムを提供します。輻輳制御方式はNORMプロトコルはかなりそのような伝送制御プロトコル（TCP）などの他のトランスポートプロトコルで利用可能なネットワーク帯域幅を共有することを可能にするために指定されています。これは、送信者と受信者の間で相互マルチキャストルーティングの両方とし、送信者と受信者との間の非対称接続（おそらくユニキャスト復路）で動作することが可能です。プロトコルは、さまざまな方法でそのサービスを利用するアプリケーションやおそらく他のより高いレベルのトランスポートプロトコルの種類を許可するように多数の機能を提供しています。プロトコルは、FECベースの修復およびその設計の他のIETF信頼性の高いマルチキャストトランスポート（RMT）ビルディングブロックの使用を活用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction and Applicability. . . . . . . . . . . . . . . .   3
       1.1. NORM Delivery Service Model. . . . . . . . . . . . . . .   4
       1.2. NORM Scalability . . . . . . . . . . . . . . . . . . . .   6
       1.3. Environmental Requirements and Considerations. . . . . .   7
   2.  Architecture Definition . . . . . . . . . . . . . . . . . . .   7
       2.1. Protocol Operation Overview. . . . . . . . . . . . . . .   9
       2.2. Protocol Building Blocks . . . . . . . . . . . . . . . .  10
       2.3. Design Tradeoffs . . . . . . . . . . . . . . . . . . . .  11
   3.  Conformance Statement . . . . . . . . . . . . . . . . . . . .  12
   4.  Message Formats . . . . . . . . . . . . . . . . . . . . . . .  13
       4.1. NORM Common Message Header and Extensions. . . . . . . .  14
       4.2. Sender Messages. . . . . . . . . . . . . . . . . . . . .  16
            4.2.1. NORM_DATA Message . . . . . . . . . . . . . . . .  16
            4.2.2. NORM_INFO Message . . . . . . . . . . . . . . . .  24
            4.2.3. NORM_CMD Messages . . . . . . . . . . . . . . . .  26
       4.3. Receiver Messages. . . . . . . . . . . . . . . . . . . .  43
            4.3.1. NORM_NACK Message . . . . . . . . . . . . . . . .  43
            4.3.2. NORM_ACK Message. . . . . . . . . . . . . . . . .  50
       4.4. General Purpose Messages . . . . . . . . . . . . . . . .  52
            4.4.1. NORM_REPORT Message . . . . . . . . . . . . . . .  52
   5.  Detailed Protocol Operation . . . . . . . . . . . . . . . . .  52
       5.1. Sender Initialization and Transmission . . . . . . . . .  54
            5.1.1. Object Segmentation Algorithm . . . . . . . . . .  55
       5.2. Receiver Initialization and Reception. . . . . . . . . .  57
       5.3. Receiver NACK Procedure. . . . . . . . . . . . . . . . .  57
       5.4. Sender NACK Processing and Response. . . . . . . . . . .  59
            5.4.1. Sender Repair State Aggregation . . . . . . . . .  60
            5.4.2. Sender FEC Repair Transmission Strategy . . . . .  61
            5.4.3. Sender NORM_CMD(SQUELCH) Generation . . . . . . .  62
            5.4.4. Sender NORM_CMD(REPAIR_ADV) Generation. . . . . .  62
       5.5. Additional Protocol Mechanisms . . . . . . . . . . . . .  63
            5.5.1. Greatest Round-trip Time Collection . . . . . . .  63
            5.5.2. NORM Congestion Control Operation . . . . . . . .  64
            5.5.3. NORM Positive Acknowledgment Procedure. . . . . .  72
            5.5.4. Group Size Estimate . . . . . . . . . . . . . . .  74
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  75
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  75
   8.  Suggested Use . . . . . . . . . . . . . . . . . . . . . . . .  75
   9.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  76
   10. References. . . . . . . . . . . . . . . . . . . . . . . . . .  76
       10.1. Normative References. . . . . . . . . . . . . . . . . .  76
       10.2. Informative References. . . . . . . . . . . . . . . . .  77
   11. Authors&#39; Addresses. . . . . . . . . . . . . . . . . . . . . .  79
       Full Copyright Statement. . . . . . . . . . . . . . . . . . .  80
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction and Applicability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.序論と適用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Negative-acknowledgment (NACK) Oriented Reliable Multicast (NORM) protocol is designed to provide reliable transport of data from one or more sender(s) to a group of receivers over an IP multicast network. The primary design goals of NORM are to provide efficient, scalable, and robust bulk data (e.g., computer files, transmission of persistent data) transfer across possibly heterogeneous IP networks and topologies. The NORM protocol design provides support for distributed multicast session participation with minimal coordination among senders and receivers. NORM allows senders and receivers to dynamically join and leave multicast sessions at will with minimal overhead for control information and timing synchronization among participants. To accommodate this capability, NORM protocol message headers contain some common information allowing receivers to easily synchronize to senders throughout the lifetime of a reliable multicast session. NORM is designed to be self-adapting to a wide range of dynamic network conditions with little or no pre-configuration. The protocol is purposely designed to be tolerant of inaccurate timing estimations or lossy conditions that may occur in many networks including mobile and wireless. The protocol is also designed to exhibit convergence and efficient operation even in situations of heavy packet loss and large queuing or transmission delays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
否定応答（NACK）指向高信頼マルチキャスト（NORM）プロトコルは、IPマルチキャストネットワーク上の受信機のグループに1つのまたは複数の送信者（複数可）からのデータの信頼性の高いトランスポートを提供するように設計されています。 NORMの主要な設計目標は、効率的でスケーラブル、かつ堅牢な大量のデータを提供している（例えば、コンピュータファイル、永続的なデータの伝送）、おそらく異種IPネットワークおよびトポロジ全体で転送。 NORMプロトコルの設計は、送信側と受信側の間で最小の配位を有する分散マルチキャストセッションへの参加のためのサポートを提供します。 NORMは、送信側と受信側が動的に参加し、参加者間の制御情報とタイミング同期のための最小限のオーバーヘッドでの意志でマルチキャストセッションを残すことができます。この機能に対応するために、NORMプロトコルメッセージヘッダは受信機が容易に信頼性の高いマルチキャストセッションの寿命を通して送信者と同期することを可能にするいくつかの一般的な情報を含んでいます。 NORMは、自己適応ほとんど又は全く事前に構成された動的なネットワーク条件の広い範囲になるように設計されます。プロトコルは、意図的に移動し、無線を含む多くのネットワークで発生する可能性があり、不正確なタイミング推定又は損失性条件に耐えるように設計されています。プロトコルはまたしても重いパケットロスや大きなキューイングの状況や伝送遅延に収束し、効率的な動作を示すように設計されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is a product of the IETF RMT WG and follows the guidelines provided in RFC 3269 [1]. The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14, RFC 2119 [2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、IETF RMT WGの製品であり、[1] RFC 3269に設けられたガイドラインに従います。この文書のキーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、、、、 &#34;べきではない&#34; &#34;べきである&#34; &#34;ないもの&#34; &#34;ものとし&#34;、 &#34;推奨&#34;、 &#34;MAY&#34;、および &#34;OPTIONAL&#34; はありますBCP 14、RFC 2119に記載されるように解釈される[2]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Statement of Intent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
主旨書
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This memo contains part of the definitions necessary to fully specify a Reliable Multicast Transport protocol in accordance with RFC 2357. As per RFC 2357, the use of any reliable multicast protocol in the Internet requires an adequate congestion control scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモは、完全にRFC 2357を1としてRFC 2357.に従い、信頼性の高いマルチキャストトランスポートプロトコルを指定するために必要な定義の一部が含まれている、インターネットのいずれかの信頼できるマルチキャストプロトコルの使用は、適切な輻輳制御方式が必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While waiting for such a scheme to be available, or for an existing scheme to be proven adequate, the Reliable Multicast Transport working group (RMT) publishes this Request for Comments in the &#34;Experimental&#34; category.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このようなスキームを待っているが利用できるようにする、または既存のスキームのための十分な証明することが、信頼性の高いマルチキャスト交通ワーキンググループ（RMT）は「実験」カテゴリ内のコメントのためにこの要求を発行しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is the intent of RMT to re-submit this specification as an IETF Proposed Standard as soon as the above condition is met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すぐに上記の条件が満たされたとしてIETFのProposed Standardとして、この明細書を再提出するRMTの意図です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. NORM Delivery Service Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。 NORM配信サービスモデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A NORM protocol instance (NormSession) is defined within the context of participants communicating connectionless (e.g., Internet Protocol (IP) or User Datagram Protocol (UDP)) packets over a network using pre-determined addresses and host port numbers. Generally, the participants exchange packets using an IP multicast group address, but unicast transport may also be established or applied as an adjunct to multicast delivery. In the case of multicast, the participating NormNodes will communicate using a common IP multicast group address and port number that has been chosen via means outside the context of the given NormSession. Other IETF data format and protocol standards exist that may be applied to describe and convey the required &#34;a priori&#34; information for a specific NormSession (e.g., Session Description Protocol (SDP) [7], Session Announcement Protocol (SAP) [8], etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMプロトコルインスタンス（NormSession）が所定のアドレスとホスト・ポート番号を使用してネットワークを介してコネクション（例えば、インターネットプロトコル（IP）またはユーザデータグラムプロトコル（UDP））パケットを通信する参加者のコンテキスト内で定義されています。一般的に、参加者は、IPマルチキャストグループアドレスを使用してパケットを交換するが、ユニキャストトランスポートはまた、確立された、またはマルチキャスト配信の補助として適用することができます。マルチキャストの場合には、参加NormNodesは所与NormSessionのコンテキスト外の手段を介して選択されている共通のIPマルチキャストグループアドレスとポート番号を使用して通信します。他のIETFデータフォーマットとプロトコル規格は、その特定のNormSession（例えば、セッション記述プロトコル（SDP）[7]、セッションアナウンスメントプロトコル（SAP）[8]のために必要な「アプリオリ」情報を記述し、搬送するために適用されてもよい存在します、等。）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM protocol design is principally driven by the assumption of a single sender transmitting bulk data content to a group of receivers. However, the protocol MAY operate with multiple senders within the context of a single NormSession. In initial implementations of this protocol, it is anticipated that multiple senders will transmit independent of one another and receivers will maintain state as necessary for each sender. However, in future versions of NORM, it is possible that some aspects of protocol operation (e.g., round-trip time collection) may provide for alternate modes allowing more efficient performance for applications requiring multiple senders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMプロトコルの設計は、主に受信機のグループにバルクデータコンテンツを送信する単一の送信者の仮定によって駆動されます。しかし、プロトコルは、単一NormSessionのコンテキスト内で複数の送信者で動作することができます。このプロトコルの初期の実装では、複数の送信者が、互いに独立し送信すると、受信機は、各送信者のために、必要に応じて状態を維持することが予想されます。しかしながら、NORMの将来のバージョンでは、プロトコルの動作（例えば、ラウンドトリップ時間コレクション）のいくつかの態様は、複数の送信者を必要とするアプリケーションのためのより効率的なパフォーマンスを可能にする代替モードを提供することが可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM provides for three types of bulk data content objects (NormObjects) to be reliably transported. These types include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMを確実に搬送されるバルクデータコンテンツオブジェクト（NormObjects）の3種類を提供します。これらのタイプは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) static computer memory data content (NORM_OBJECT_DATA type),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）静的なコンピュータ・メモリ・データ・コンテンツ（NORM_OBJECT_DATA型）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) computer storage files (NORM_OBJECT_FILE type), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）コンピュータ・ストレージ・ファイル（NORM_OBJECT_FILEタイプ）、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) non-finite streams of continuous data content (NORM_OBJECT_STREAM type).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3）連続データコンテンツ（NORM_OBJECT_STREAM型）の非有限のストリーム。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The distinction between NORM_OBJECT_DATA and NORM_OBJECT_FILE is simply to provide a &#34;hint&#34; to receivers in NormSessions serving multiple types of content as to what type of storage should be allocated for received content (i.e., memory or file storage). Other than that distinction, the two are identical, providing for reliable transport of finite (but potentially very large) units of content. These static data and file services are anticipated to be useful for multicast-based cache applications with the ability to reliably provide transmission of large quantities of static data. Other types of static data/file delivery services might make use of these transport object types, too. The use of the NORM_OBJECT_STREAM type is at the application&#39;s discretion and could be used to carry static data or file content also. The NORM reliable stream service opens up additional possibilities such as serialized reliable messaging or other unbounded, perhaps dynamically produced content. The NORM_OBJECT_STREAM provides for reliable transport analogous to that of the Transmission Control Protocol (TCP), although NORM receivers will be able to begin receiving stream content at any point in time. The applicability of this feature will depend upon the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_OBJECT_DATAとNORM_OBJECT_FILEの区別は、受信したコンテンツ（すなわち、メモリやファイルストレージ）のために割り当てられなければならないストレージの種類に、コンテンツの複数のタイプのサービスを提供NormSessionsで受信機に「ヒント」を提供するだけです。その違い以外、両者はコンテンツの有限の（潜在的に非常に大きい）ユニットの信頼性の高いトランスポートを提供する、同一です。これらの静的なデータやファイルサービスを確実に静的な大量のデータの伝送を提供する能力を持つマルチキャストベースのキャッシュの用途に有用であることが予想されます。静的データ/ファイル配信サービスの他のタイプも、これらのトランスポート・オブジェクト・タイプを利用するかもしれません。 NORM_OBJECT_STREAMタイプの使用は、アプリケーションの裁量であり、また、静的なデータやファイルの内容を運ぶために使用することができます。 NORM信頼性の高いストリームサービスは、このような直列化、信頼性の高いメッセージングや他の無制限、おそらく動的に作成されたコンテンツなどの追加の可能性を開きます。 NORMの受信機は、任意の時点でストリームコンテンツの受信を開始することができるであろうがNORM_OBJECT_STREAMは、伝送制御プロトコル（TCP）のものと類似した信頼性の高いトランスポートを提供します。この機能の適用は、用途に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM protocol also allows for a small amount of &#34;out-of-band&#34; data (sent as NORM_INFO messages) to be attached to the data content objects transmitted by the sender. This readily-available &#34;out-of-band&#34; data allows multicast receivers to quickly and efficiently determine the nature of the corresponding data, file, or stream bulk content being transmitted. This allows application-level control of the receiver node&#39;s participation in the current transport activity. This also allows the protocol to be flexible with minimal pre-coordination among senders and receivers. The NORM_INFO content is designed to be atomic in that its size MUST fit into the payload portion of a single NORM message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMプロトコルはまた、送信者によって送信されたデータコンテンツオブジェクトに取り付けられる（NORM_INFOメッセージとして送信される）「アウトオブバンド」データの少量を可能にします。この容易に入手可能な「アウトオブバンド」データは、マルチキャスト受信機が迅速かつ効率的に対応するデータ、ファイルの性質を決定することができ、又は送信されているバルクコンテンツをストリーミングします。これは、現在の輸送活性における受信ノードの参加のアプリケーションレベルの制御を可能にします。これはまた、プロトコルは、送信側と受信側の間で最小の事前配位を有する柔軟にすることができます。 NORM_INFOコンテンツは、そのサイズが単一NORMメッセージのペイロード部分に適合しなければならないことでアトミックであるように設計されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM does _not_ provide for global or application-level identification of data content within in its message headers. Note the NORM_INFO out-of-band data mechanism could be leveraged by the application for this purpose if desired, or identification could alternatively be embedded within the data content. NORM does identify transmitted content (NormObjects) with transport identifiers that are applicable only while the sender is transmitting and/or repairing the given object. These transport data content identifiers (NormTransportIds) are assigned in a monotonically increasing fashion by each NORM sender during the course of a NormSession. Each sender maintains its NormTransportId assignments independently so that individual NormObjects may be uniquely identified during transport with the concatenation of the sender session-unique identifier (NormNodeId) and the assigned NormTransportId. The NormTransportIds are assigned from a large, but fixed, numeric space in increasing order and may be reassigned during long-lived sessions. The NORM protocol provides mechanisms so that the sender application may terminate transmission of data content and inform the group of this in an efficient manner. Other similar protocol control mechanisms (e.g., session termination, receiver synchronization, etc.) are specified so that reliable multicast application variants may construct different, complete bulk transfer communication models to meet their goals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMは_not_そのメッセージヘッダーの内のデータコンテンツのグローバルまたはアプリケーションレベルの識別を提供しません。所望であれば、この目的のためのアプリケーションで利用することができ、または識別は、代替的に、データコンテンツ内に埋め込むことができるNORM_INFO帯域外データのメカニズムに留意されたいです。 NORMは、送信者が送信および/または指定されたオブジェクトを修復している間だけ適用されるトランスポート識別子とともに送信されたコンテンツ（NormObjects）を識別し。これらトランスポート・データ・コンテンツ識別子（NormTransportIds）はNormSessionの過程で各NORM送信者によって単調に増加する方式で割り当てられます。個々NormObjects一意送信元セッションの一意の識別子（NormNodeId）と割り当てNormTransportIdの連結と輸送中に同定することができるように、各送信側は、独立して、そのNormTransportId割り当てを維持します。 NormTransportIdsが大から割り当てられたが、昇順で、数値のスペースを固定し、長寿命のセッション中に再割り当てすることができるされています。送信側アプリケーションは、データコンテンツの送信を終了し、効率的な方法でこのグループに通知することができるように、NORMプロトコルはメカニズムを提供します。信頼性の高いマルチキャストアプリケーションの変異体は、それらの目標を達成するために異なる、完全バルク転送通信のモデルを構築することができるように、他の同様のプロトコル制御機構（例えば、セッション終了、受信機の同期など）が指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To summarize, the NORM protocol provides reliable transport of different types of data content (including potentially mixed types). The senders enqueue and transmit bulk content in the form of static data or files and/or non-finite, ongoing stream types. NORM senders provide for repair transmission of data and/or FEC content in response to NACK messages received from the receiver group. Mechanisms for &#34;out-of-band&#34; information and other transport control mechanisms are specified for use by applications to form complete reliable multicast solutions for different purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
要約すると、NORMプロトコルは、（潜在的混合型を含む）のデータ内容の異なる種類の信頼性の高いトランスポートを提供します。送信者は、エンキューおよび静的なデータやファイル、および/または非有限、継続的なストリーム型の形で一括コンテンツを送信します。 NORMの送信者は、受信機グループから受信したNACKメッセージに応答して、データおよび/またはFECコンテンツの修復伝送を提供します。 「アウトオブバンド」情報のためのメカニズムと他のトランスポート制御機構は、異なる目的のために完全な信頼性の高いマルチキャストソリューションを形成するためのアプリケーションによる使用のために指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. NORM Scalability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2。 NORMスケーラビリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Group communication scalability requirements lead to adaptation of negative acknowledgment (NACK) based protocol schemes when feedback for reliability is required [9]. NORM is a protocol centered around the use of selective NACKs to request repairs of missing data. NORM provides for the use of packet-level forward error correction (FEC) techniques for efficient multicast repair and optional proactive transmission robustness [10]. FEC-based repair can be used to greatly reduce the quantity of reliable multicast repair requests and repair transmissions [11] in a NACK-oriented protocol. The principal factor in NORM scalability is the volume of feedback traffic generated by the receiver set to facilitate reliability and congestion control. NORM uses probabilistic suppression of redundant feedback based on exponentially distributed random backoff timers. The performance of this type of suppression relative to other techniques is described in [12]. NORM dynamically measures the group&#39;s roundtrip timing status to set its suppression and other protocol timers. This allows NORM to scale well while maintaining reliable data delivery transport with low latency relative to the network topology over which it is operating.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループ通信スケーラビリティ要件は、信頼性のフィードバックが必要とされる場合、否定応答（NACK）ベースのプロトコルスキームの適応につながる[9]。 NORMは、欠落データの修理を依頼して、選択NACKの使用を中心とするプロトコルです。 NORMは、効率的なマルチキャスト修復および任意の積極的な送信ロバスト性[10]のためのパケットレベルの順方向誤り訂正（FEC）技術の使用を提供します。 FECベースの修復はNACK指向プロトコルに[11]大幅に信頼性の高いマルチキャスト修復要求および修復送信の量を減少させるために使用することができます。 NORMスケーラビリティの主要因は、信頼性と輻輳制御を容易にするために、設定受信機によって生成されたフィードバックトラフィックの量です。 NORMは指数関数的に分布するランダムバックオフタイマーに基づく冗長フィードバックの確率抑制を使用します。他の技術に抑制に対するこのタイプの性能は、[12]に記載されています。 NORMは、動的に抑制し、他のプロトコルタイマーを設定するには、グループの往復タイミングの状態を測定します。これは、それが動作している上に、ネットワークトポロジへの低レイテンシ相対有する信頼性の高いデータ配信輸送を維持しながら、NORMがうまくスケーリングすることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Feedback messages can be either multicast to the group at large or sent via unicast routing to the sender. In the case of unicast feedback, the sender &#34;advertises&#34; the feedback state to the group to facilitate feedback suppression. In typical Internet environments, it is expected that the NORM protocol will readily scale to group sizes on the order of tens of thousands of receivers. A study of the quantity of feedback for this type of protocol is described in [13]. NORM is able to operate with a smaller amount of feedback than a single TCP connection, even with relatively large numbers of receivers. Thus, depending upon the network topology, it is possible that NORM may scale to larger group sizes. With respect to computer resource usage, the NORM protocol does _not_ require that state be kept on all receivers in the group. NORM senders maintain state only for receivers providing explicit congestion control feedback. NORM receivers must maintain state for each active sender. This may constrain the number of simultaneous senders in some uses of NORM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィードバックメッセージは大でグループへのマルチキャストまたは送信者へのユニキャストルーティングを介して送信のいずれかであり得ます。ユニキャストフィードバックの場合、送信者は、グループへのフィードバック状態は、フィードバック抑制を容易にするために「宣伝します」。典型的なインターネット環境では、NORMプロトコルは容易に数十受信機の数千のオーダーのグループサイズにスケーリングすることが期待されます。プロトコルのこのタイプのフィードバックの量の研究は、[13]に記載されています。 NORMも受信機の比較的大きな数と、単一のTCP接続よりもフィードバックの少ない量で動作することが可能です。これにより、ネットワークトポロジに依存し、ノルムが大きいグループサイズにスケーリングすることが可能です。コンピュータのリソース使用量に関しては、NORMプロトコルは_not_状態は、グループ内のすべての受信機に保持する必要がありません。 NORMの送信者は、明示的な輻輳制御フィードバックを提供する受信機の状態を維持します。 NORM受信機は、各アクティブな送信者の状態を維持しなければなりません。これは、NORMのいくつかの用途での同時送信者の数を制限することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Environmental Requirements and Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3。環境要件および考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All of the environmental requirements and considerations that apply to the RMT NORM Building Block [4] and the RMT FEC Building Block [5] also apply to the NORM protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RMT NORMビルディングブロック[4]とRMT FECビルディングブロックに適用される環境要件と考慮事項のすべては、[5]また、NORMプロトコルに適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM protocol SHALL be capable of operating in an end-to-end fashion with no assistance from intermediate systems beyond basic IP multicast group management, routing, and forwarding services. While the techniques utilized in NORM are principally applicable to &#34;flat&#34; end-to-end IP multicast topologies, they could also be applied in the sub-levels of hierarchical (e.g., tree-based) multicast distribution if so desired. NORM can make use of reciprocal (among senders and receivers) multicast communication under the Any-Source Multicast (ASM) model defined in RFC 1112 [3], but SHALL also be capable of scalable operation in asymmetric topologies such as Source Specific Multicast (SSM) [14] where there may only be unicast routing service from the receivers to the sender(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMプロトコルは、基本的なIPマルチキャストグループ管理、ルーティング、および転送サービスを越えて、中間システムからのない支援を受けて、エンドツーエンド方式で動作可能でなければなりません。 NORMに利用技術が「フラット」エンド・ツー・エンドのIPマルチキャストトポロジ主に適用可能であるが、所望であれば、それらはまた、階層（例えば、ツリーベースの）マルチキャスト配信のサブレベルで適用することができます。 NORMは、RFC 1112で定義された、ソースマルチキャスト（ASM）モデル[3]の（送信者と受信者の間で）相互マルチキャスト通信を利用することができるだけでなく、ソース固有マルチキャスト（SSM非対称トポロジでスケーラブルな動作が可能でなければなりません唯一の受信機から送信者（複数可）にユニキャストルーティングサービスが存在してもよい）[14]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM is compatible with IPv4 and IPv6. Additionally, NORM may be used with networks employing Network Address Translation (NAT) providing the NAT device supports IP multicast and/or can cache UDP traffic source port numbers for remapping feedback traffic from receivers to the sender(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMは、IPv4とIPv6と互換性があります。さらに、NORMは、NATデバイスのIPマルチキャストをサポートし、および/または送信者（複数可）に受信機からのフィードバックトラフィックを再マッピングするためにUDPトラフィックの送信元ポート番号をキャッシュすることができますを提供するネットワークアドレス変換（NAT）を使用するネットワークで使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Architecture Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.アーキテクチャの定義
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A NormSession is comprised of participants (NormNodes) acting as senders and/or receivers. NORM senders transmit data content in the form of NormObjects to the session destination address and the NORM receivers attempt to reliably receive the transmitted content using negative acknowledgments to request repair. Each NormNode within a NormSession is assumed to have a preselected unique 32-bit identifier (NormNodeId). NormNodes MUST have uniquely assigned identifiers within a single NormSession to distinguish between possible multiple senders and to distinguish feedback information from different receivers. There are two reserved NormNodeId values. A value of 0x00000000 is considered an invalid NormNodeId value and a value of 0xffffffff is a &#34;wildcard&#34; NormNodeId. While the protocol does not preclude multiple sender nodes concurrently transmitting within the context of a single NORM session (i.e., many-to-many operation), any type of interactive coordination among NORM senders is assumed to be controlled by the application or higher protocol layer. There are some optional mechanisms specified in this document that can be leveraged for such application layer coordination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NormSessionは、送信者及び/又は受信機として動作する参加者（NormNodes）から構成されています。 NORMの送信者を確実に修理を要求する否定応答を使用して送信されたコンテンツを受信しようとするセッションの宛先アドレスとNORMレシーバへNormObjectsの形態におけるデータコンテンツを送信します。 NormSession内の各NormNodeは、予め選択された一意の32ビット識別子（NormNodeId）を有するものとします。 NormNodes一意可能な複数の送信者を区別し、異なる受信機からのフィードバック情報を区別するために単一NormSession内に識別子を割り当てておく必要があります。 2つの予約NormNodeId値があります。 0x00000000の値が無効NormNodeId値とみなされ、値0xFFFFFFFFは、「ワイルドカード」NormNodeIdです。プロトコルは、同時に単一NORMセッション（すなわち、多対多の操作）のコンテキスト内で送信する複数の送信ノードを排除するものではないが、NORMの送信者の間で対話協調の任意のタイプは、アプリケーションまたは上位プロトコル層によって制御されているものとします。このようなアプリケーションレイヤ連携に活用することができ、この文書で指定されたいくつかのオプションのメカニズムがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As previously noted, NORM allows for reliable transmission of three different basic types of data content. The first type is NORM_OBJECT_DATA, which is used for static, persistent blocks of data content maintained in the sender&#39;s application memory storage. The second type is NORM_OBJECT_FILE, which corresponds to data stored in the sender&#39;s non-volatile file system. The NORM_OBJECT_DATA and NORM_OBJECT_FILE types both represent &#34;NormObjects&#34; of finite but potentially very large size. The third type of data content is NORM_OBJECT_STREAM, which corresponds to an ongoing transmission of undefined length. This is analogous to the reliable stream service provide by TCP for unicast data transport. The format of the stream content is application-defined and may be byte or message oriented. The NORM protocol provides for &#34;flushing&#34; of the stream to expedite delivery or possibly enforce application message boundaries. NORM protocol implementations may offer either (or both) in-order delivery of the stream data to the receive application or out-of-order (more immediate) delivery of received segments of the stream to the receiver application. In either case, NORM sender and receiver implementations provide buffering to facilitate repair of the stream as it is transported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
先に述べたように、NORMは、データコンテンツの三つの異なる基本的な種類の信頼性のある伝送を可能にします。第一のタイプは、送信者のアプリケーションのメモリ記憶装置内に維持されるデータコンテンツの静的な、永続的なブロックのために使用されるNORM_OBJECT_DATA、です。第二のタイプは、送信者の不揮発性ファイルシステムに格納されたデータに対応NORM_OBJECT_FILE、です。 NORM_OBJECT_DATAとNORM_OBJECT_FILE種類は有限でなく、潜在的に非常に大きなサイズの「NormObjects」を表すの両方。データコンテンツの第三のタイプは、不定長の進行中の送信に対応NORM_OBJECT_STREAM、です。ユニキャストデータ転送のためのTCPによって提供これは、信頼性の高いストリームサービスに類似しています。ストリームコンテンツのフォーマットは、アプリケーション定義され、バイトまたはメッセージ指向であってもよいです。 NORMプロトコルは、送達を促進または可能性アプリケーションメッセージの境界を適用するストリームの「フラッシング」を提供します。 NORMプロトコル実装は、インオーダー受信アプリケーションへのストリームデータの配信または受信機アプリケーションへのストリームの受信セグメントのアウトオブオーダー（より迅速）の送達のいずれか（または両方）を提供することができます。いずれの場合においても、NORMの送信側と受信側の実装は、それが搬送されるストリームの修復を促進するためにバッファリングを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
All NormObjects are logically segmented into FEC coding blocks and symbols for transmission by the sender. In NORM, an FEC encoding symbol directly corresponds to the payload of NORM_DATA messages or &#34;segment&#34;. Note that when systematic FEC codes are used, the payload of NORM_DATA messages sent for the first portion of a FEC encoding block are source symbols (actual segments of original user data), while the remaining symbols for the block consist of parity symbols generated by FEC encoding. These parity symbols are generally sent in response to repair requests, but some number may be sent proactively at the end each encoding block to increase the robustness of transmission. When non-systematic FEC codes are used, all symbols sent consist of FEC encoding parity content. In this case, the receiver must receive a sufficient number of symbols to reconstruct (via FEC decoding) the original user data for the given block. In this document, the terms &#34;symbol&#34; and &#34;segment&#34; are used interchangeably.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのNormObjectsは、論理的に、送信者による送信のためFEC符号化ブロックとシンボルに分割されています。 NORMでは、FEC符号化シンボルは、直接NORM_DATAメッセージのペイロードまたは「セグメント」に相当します。システマティックFEC符号が使用される場合、ブロックの残りのシンボルがFECによって生成されたパリティシンボルで構成しながら、FEC符号化ブロックの最初の部分のために送らNORM_DATAメッセージのペイロードは、ソースシンボル（元のユーザーデータの実際のセグメント）であることに注意してくださいエンコーディング。これらのパリティシンボルは、一般に修復要求に応じて送信されるが、いくつかの数は、伝送のロバスト性を高めるために端部に積極的に各符号化ブロックを送信することができます。非体系的FECコードが使用されている場合は、送信されたすべてのシンボルは、FEC符号化パリティ内容で構成されています。この場合、受信機は、所与のブロックについて（FEC復号化を介して）元のユーザーデータを再構成するシンボルの十分な数を受信しなければなりません。この文書では、用語「シンボル」および「セグメント」は互換的に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transmitted NormObjects are temporarily yet uniquely identified within the NormSession context using the given sender&#39;s NormNodeId, NormInstanceId, and a temporary NormObjectTransportId. Depending upon the implementation, individual NORM senders may manage their NormInstanceIds independently, or a common NormInstanceId may be agreed upon for all participating nodes within a session if needed as a session identifier. NORM NormObjectTransportId data content identifiers are sender-assigned and applicable and valid only during a NormObject&#39;s actual _transport_ (i.e., for as long as the sender is transmitting and providing repair of the indicated NormObject). For a long-lived session, the NormObjectTransportId field can wrap and previously-used identifiers may be re-used. Note that globally unique identification of transported data content is not provided by NORM and, if required, must be managed by the NORM application. The individual segments or symbols of the NormObject are further identified with FEC payload identifiers which include coding block and symbol identifiers. These are discussed in detail later in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信NormObjectsは一時的にまだ一意に与えられた送信者のNormNodeId、NormInstanceId、一時NormObjectTransportIdを使用してNormSessionコンテキスト内で識別されます。実装に応じて、個々のNORMの送信者は、独立して自分のNormInstanceIdsを管理したり、セッション識別子として、必要に応じて共通NormInstanceIdは、セッション内のすべての参加ノードのために合意されます。 NORM NormObjectTransportIdデータコンテンツ識別子のみNormObjectの実際_transport_中に送信者に割り当てられ、該当すると有効である（すなわち、限り、送信者が送信し、指示NormObjectの修復を提供しているようにするため）。長寿命のセッションの場合、NormObjectTransportIdフィールドをラップすることができますし、以前に使用される識別子を再利用することができます。転送されるデータ内容のグローバル一意識別子は、NORMによって提供されていないと、必要に応じて、NORMアプリケーションによって管理されなければならないことに注意してください。 NormObjectの個々のセグメント又はシンボルはさらにブロックとシンボル識別子をコーディング含むFECペイロード識別子で識別されます。これらは、このドキュメントの後半で詳しく説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Protocol Operation Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。プロトコルの動作概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A NORM sender primarily generates messages of type NORM_DATA. These messages carry original data segments or FEC symbols and repair segments/symbols for the bulk data/file or stream NormObjects being transferred. By default, redundant FEC symbols are sent only in response to receiver repair requests (NACKs) and thus normally little or no additional transmission overhead is imposed due to FEC encoding. However, the NORM implementation MAY be optionally configured to proactively transmit some amount of redundant FEC symbols along with the original content to potentially enhance performance (e.g., improved delay) at the cost of additional transmission overhead. This option may be sensible for certain network conditions and can allow for robust, asymmetric multicast (e.g., unidirectional routing, satellite, cable) [15] with reduced receiver feedback, or, in some cases, no feedback.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMの送信者は、主に型NORM_DATAのメッセージを生成します。これらのメッセージは、元のデータセグメント又はFEC記号と転送されるバルクデータ/ファイルまたはストリームNormObjectsの修復セグメント/シンボルを搬送します。デフォルトでは、冗長FECシンボルはリペア要求（NACKを）受信機のみ応答して送信され、従って、通常はほとんどまたは全く追加の送信オーバーヘッドを伴うFEC符号化に課されます。しかし、NORMの実装は、必要に応じて積極的に、潜在的に追加の送信オーバーヘッドのコストでの性能（例えば、改善された遅延）を増強するために元のコンテンツと一緒に冗長FEC記号のある量を送信するように構成され得ます。このオプションは、特定のネットワーク条件のために賢明であり得ると還元受信フィードバック、または、いくつかの場合には、フィードバックのない堅固な、非対称マルチキャスト（例えば、一方向ルーティング、衛星、ケーブル）[15]を可能にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A sender message of type NORM_INFO is also defined and is used to carry OPTIONAL &#34;out-of-band&#34; context information for a given transport object. A single NORM_INFO message can be associated with a NormObject. Because of its atomic nature, missing NORM_INFO messages can be NACKed and repaired with a slightly lower delay process than NORM&#39;s general FEC-encoded data content. NORM_INFO may serve special purposes for some bulk transfer, reliable multicast applications where receivers join the group mid-stream and need to ascertain contextual information on the current content being transmitted. The NACK process for NORM_INFO will be described later. When the NORM_INFO message type is used, its transmission should precede transmission of any NORM_DATA message for the associated NormObject.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
タイプNORM_INFOの送信者メッセージも定義され、所定のトランスポート・オブジェクトのOPTIONAL「アウトオブバンド」コンテキスト情報を搬送するために使用されます。単一NORM_INFOメッセージはNormObjectに関連付けることができます。理由は、その原子の性質上、行方不明NORM_INFOメッセージがNORMの一般的なFEC符号化されたデータの内容よりも若干低い遅延処理でNACKされ、修復することができます。 NORM_INFOは、いくつかのバルク転送、受信機がグループミッドストリームに参加して送信されている現在のコンテンツのコンテキスト情報を把握する必要がある信頼性の高いマルチキャストアプリケーションのための特別な目的を果たすことができます。 NORM_INFOのためのNACK処理については後述します。 NORM_INFOメッセージタイプを使用した場合、その送信は、関連NormObjectための任意NORM_DATAメッセージの送信に先行しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sender also generates messages of type NORM_CMD to assist in certain protocol operations such as congestion control, end-of-transmission flushing, round trip time estimation, receiver synchronization, and optional positive acknowledgment requests or application defined commands. The transmission of NORM_CMD messages from the sender is accomplished by one of three different procedures. These procedures are: single, best effort unreliable transmission of the command; repeated redundant transmissions of the command; and positively-acknowledged commands. The transmission technique used for a given command depends upon the function of the command. Several core commands are defined for basic protocol operation. Additionally, implementations MAY wish to consider providing the OPTIONAL application-defined commands that can take advantage of the transmission methodologies available for commands. This allows for application-level session management mechanisms that can make use of information available to the underlying NORM protocol engine (e.g., round-trip timing, transmission rate, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者はまた、輻輳制御、エンドオブ送信フラッシング、ラウンドトリップ時間推定、受信機の同期、およびオプションの肯定応答要求またはアプリケーション定義されたコマンドなどの特定のプロトコル操作を補助するために型NORM_CMDのメッセージを生成します。送信者からNORM_CMDメッセージの送信は、3つの異なる手順のいずれかによって達成されます。これらの手順は以下のとおりです。コマンドのシングル、ベストエフォート信頼できない伝送。コマンドの冗長送信を繰り返しました。そして、コマンドを積極-認めました。所与のコマンドに使用される伝送技術は、コマンドの機能に依存します。いくつかのコアコマンドは、基本的なプロトコルの動作のために定義されています。また、実装はコマンドの利用可能な伝送方法論を利用することができますオプションのアプリケーション定義コマンドを提供することを検討することを望むかもしれません。これは、基礎となるNORMプロトコルエンジンへの情報の使用は、利用可能にするアプリケーション・レベルのセッション管理メカニズムを可能にする（例えば、往復タイミング、送信レート、等）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM receivers generate messages of type NORM_NACK or NORM_ACK in response to transmissions of data and commands from a sender. The NORM_NACK messages are generated to request repair of detected data transmission losses. Receivers generally detect losses by tracking the sequence of transmission from a sender. Sequencing information is embedded in the transmitted data packets and end-of-transmission commands from the sender. NORM_ACK messages are generated in response to certain commands transmitted by the sender. In the general (and most scalable) protocol mode, NORM_ACK messages are sent only in response to congestion control commands from the sender. The feedback volume of these congestion control NORM_ACK messages is controlled using the same timer-based probabilistic suppression techniques as for NORM_NACK messages to avoid feedback implosion. In order to meet potential application requirements for positive acknowledgment from receivers, other NORM_ACK messages are defined and available for use. All sender and receiver transmissions are subject to rate control governed by a peak transmission rate set for each participant by the application. This can be used to limit the quantity of multicast data transmitted by the group. When NORM&#39;s congestion control algorithm is enabled the rate for senders is automatically adjusted. In some networks, it may be desirable to establish minimum and maximum bounds for the rate adjustment depending upon the application even when dynamic congestion control is enabled. However, in the case of the general Internet, congestion control policy SHALL be observed that is compatible with coexistent TCP flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM受信機は、送信者からのデータやコマンドの送信に応じて、型NORM_NACKまたはNORM_ACKのメッセージを生成します。 NORM_NACKメッセージが検出されたデータ伝送損失の修理を依頼するために生成されます。受信機は、一般的に、送信者からの送信の順序を追跡することによって損失を検出します。シーケンシング情報は、送信者から送信されるデータパケットと終了の送信コマンドに埋め込まれています。 NORM_ACKメッセージは送信者によって送信された特定のコマンドに応答して生成されます。一般的な（そして最もスケーラブルな）プロトコルモードでは、NORM_ACKメッセージは送信者だけから輻輳制御コマンドに応答して送信されます。これらの輻輳制御NORM_ACKメッセージのフィードバック量は、フィードバック内部破裂を避けるためにNORM_NACKメッセージのと同じタイマによる確率的抑制技術を使用して制御されます。受信機からの肯定応答のための潜在的なアプリケーション要件を満たすために、他のNORM_ACKメッセージが定義され、使用可能。すべての送信者と受信者の送信は、アプリケーションによって、各参加者のために設定されたピーク伝送速度に支配レート制御の対象となっています。これは、グループによって送信されたマルチキャストデータの量を制限するために使用することができます。 NORMの輻輳制御アルゴリズムを有効にすると送信者のレートが自動的に調整されます。一部のネットワークでは、動的な輻輳制御が有効になっても、用途に応じて速度調整の最小と最大の境界を確立することが望ましい場合があります。しかし、一般的なインターネットの場合には、輻輳制御ポリシーが共存TCPフローと互換性のある観察します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Protocol Building Blocks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2。プロトコル・ビルディング・ブロック
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The operation of the NORM protocol is based primarily upon the concepts presented in the Nack-Oriented Reliable Multicast (NORM) Building Block document [4]. This includes the basic NORM architecture and the data transmission, repair, and feedback strategies discussed in that document. Additional reliable multicast building blocks are applied in creating the full NORM protocol instantiation [16]. NORM also makes use of Forward Error Correction encoding techniques for repair messaging and optional transmission robustness as described in [10]. NORM uses the FEC Payload ID as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMプロトコルの動作は、主にNACK-指向高信頼マルチキャスト（NORM）ビルディングブロック文献[4]で説明する概念に基づいています。これは、その文書で説明する基本的なNORMアーキテクチャとデータ伝送、修理、およびフィードバック戦略が含まれています。付加的な信頼性の高いマルチキャストビルディングブロックは完全NORMプロトコルインスタンス化[16]を作成する際に適用されます。 [10]に記載のようにNORMはまた、修復メッセージングおよび任意送信ロバスト性のための順方向誤り訂正符号化技術を利用します。 NORMは、FECペイロードIDなどを使用しています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
specified by the FEC Building Block Document [5]. Additionally, for congestion control, this document includes a baseline congestion control mechanism (NORM-CC) based on the TCP-Friendly Multicast Congestion Control (TFMCC) scheme described in [19].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FECビルディングブロック文書で指定された[5]。また、輻輳制御のために、この文書は、[19]に記載のTCPフレンドリーマルチキャスト輻輳制御（TFMCC）方式に基づいて基準輻輳制御機構（NORM-CC）を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Design Tradeoffs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3。設計トレードオフ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While the various features of NORM are designed to provide some measure of general purpose utility, it is important to emphasize the understanding that &#34;no one size fits all&#34; in the reliable multicast transport arena. There are numerous engineering tradeoffs involved in reliable multicast transport design and this requires an increased awareness of application and network architecture considerations. Performance requirements affecting design can include: group size, heterogeneity (e.g., capacity and/or delay), asymmetric delivery, data ordering, delivery delay, group dynamics, mobility, congestion control, and transport across low capacity connections. NORM contains various parameters to accommodate many of these differing requirements. The NORM protocol and its mechanisms MAY be applied in multicast applications outside of bulk data transfer, but there is an assumed model of bulk transfer transport service that drives the trade-offs that determine the scalability and performance described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMのさまざまな機能が汎用ユーティリティのいくつかの指標を提供するように設計されていますが、信頼性の高いマルチキャストトランスポートアリーナで「誰のサイズはすべてに適合しない」という理解を強調することが重要です。そこ信頼性の高いマルチキャストトランスポート・デザインに関わる数々のエンジニアリング・トレードオフがあり、これは、アプリケーションとネットワークアーキテクチャの配慮の意識向上が必要です。デザインに影響を与えるパフォーマンスの要件は含めることができます。低容量接続間グループサイズ、異質性（例えば、容量および/または遅延）、非対称配信、データ発注、配達遅延、グループダイナミックス、モビリティ、輻輳制御、および輸送を。 NORMは、これらの異なる要件の多くに対応するために様々なパラメータが含まれています。 NORMプロトコルとそのメカニズムは、バルクデータ転送の外側マルチキャストアプリケーションに適用することができるが、この文書に記載さスケーラビリティとパフォーマンスを決定するトレードオフを駆動するバルク転送輸送サービスの仮定されたモデルがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ability of NORM to provide reliable data delivery is also governed by any buffer constraints of the sender and receiver applications. NORM protocol implementations SHOULD be designed to operate with the greatest efficiency and robustness possible within application-defined buffer constraints. Buffer requirements for reliability, as always, are a function of the delay-bandwidth product of the network topology. NORM performs best when allowed more buffering resources than typical point-to-point transport protocols. This is because NORM feedback suppression is based upon randomly-delayed transmissions from the receiver set, rather than immediately transmitted feedback. There are definitive tradeoffs between buffer utilization, group size scalability, and efficiency of performance. Large buffer sizes allow the NORM protocol to perform most efficiently in large delay-bandwidth topologies and allow for longer feedback suppression backoff timeouts. This yields improved group size scalability. NORM can operate with reduced buffering but at a cost of decreased efficiency (lower relative goodput) and reduced group size scalability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
信頼性の高いデータ配信を提供するために、NORMの能力も、送信側と受信側のアプリケーションのいずれかのバッファの制約によって支配されています。 NORMプロトコル実装が最大効率とアプリケーション定義のバッファの制約内で可能な堅牢で動作するように設計されるべきです。バッファ要件は、信頼性のために、いつものように、ネットワークトポロジの遅延帯域幅積の関数です。典型的なポイントツーポイントのトランスポートプロトコルよりも多くのバッファリング資源を許可するときNORMは、最高の性能が得られます。 NORMフィードバック抑制が受信機セットではなく、すぐに送信されたフィードバックからランダム遅延伝送に基づいているためです。バッファ利用、グループサイズの拡張性、およびパフォーマンスの効率性との間に決定的なトレードオフがあります。大きなバッファサイズがNORMプロトコルは大きな遅延帯域トポロジで最も効率的に実行し、より長いフィードバック抑制バックオフタイムアウトを可能にすることを可能にします。これは、改善グループサイズのスケーラビリティが得られます。 NORMは減少バッファで動作するが、減少した効率（低い相対グッドプット）と減少グループサイズのスケーラビリティを犠牲にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Conformance Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.適合性宣言
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This Protocol Instantiation document, in conjunction with the RMT Building Block documents of [4] and [5], completely specifies a working reliable multicast transport protocol that conforms to the requirements described in RFC 2357 [17].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このプロトコルインスタンス化文書のRMTビルディングブロックの文書と併せて、[4]、[5]、完全にRFC 2357 [17]に記載の要件に適合する作動信頼できるマルチキャストトランスポートプロトコルを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies the following message types and mechanisms which are REQUIRED in complying NORM protocol implementations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、NORMプロトコル実装を準拠に必要とされる次のメッセージタイプおよびメカニズムを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
+--------------------+-----------------------------------------------+
|    Message Type    |                    Purpose                    |
+--------------------+-----------------------------------------------+
|NORM_DATA           | Sender message for application data           |
|                    | transmission.  Implementations must support   |
|                    | at least one of the NORM_OBJECT_DATA,         |
|                    | NORM_OBJECT_FILE, or NORM_OBJECT_STREAM       |
|                    | delivery services.  The use of the NORM FEC   |
|                    | Object Transmission Information header        |
|                    | extension is OPTIONAL with NORM_DATA          |
|                    | messages.                                     |
+--------------------+-----------------------------------------------+
|NORM_CMD(FLUSH)     | Sender command to excite receivers for repair |
|                    | requests in lieu of ongoing NORM_DATA         |
|                    | transmissions.  Note the use of the           |
|                    | NORM_CMD(FLUSH) for positive acknowledgment   |
|                    | of data receipt is OPTIONAL.                  |
+--------------------+-----------------------------------------------+
|NORM_CMD(SQUELCH)   | Sender command to advertise its current valid |
|                    | repair window in response to invalid requests |
|                    | for repair.                                   |
+--------------------+-----------------------------------------------+
|NORM_CMD(REPAIR_ADV)| Sender command to advertise current repair    |
|                    | (and congestion control state) to group when  |
|                    | unicast feedback messages are detected.  Used |
|                    | to control/suppress excessive receiver        |
|                    | feedback in asymmetric multicast topologies.  |
+--------------------+-----------------------------------------------+
|NORM_CMD(CC)        | Sender command used in collection of round    |
|                    | trip timing and congestion control status     |
|                    | from group (this may be OPTIONAL if           |
|                    | alternative congestion control mechanism and  |
|                    | round trip timing collection is used).        |
+--------------------+-----------------------------------------------+
|NORM_NACK           | Receiver message used to request repair of    |
|                    | missing transmitted content.                  |
+--------------------+-----------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
+--------------------+-----------------------------------------------+
|NORM_ACK            | Receiver message used to proactively provide  |
|                    | feedback for congestion control purposes.     |
|                    | Also used with the OPTIONAL NORM Positive     |
|                    | Acknowledgment Process.                       |
+--------------------+-----------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document also describes the following message types and associated mechanisms which are OPTIONAL for complying NORM protocol implementations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書はまた、NORMプロトコルの実装を遵守するためのオプションで、次のメッセージタイプおよび関連する機構について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
+----------------------+----------------------------------------------+
|     Message Type     |                    Purpose                   |
+----------------------+----------------------------------------------+
|NORM_INFO             | Sender message for providing ancillary       |
|                      | context information associated with NORM     |
|                      | transport objects.  The use of the NORM FEC  |
|                      | Object Transmission Information header       |
|                      | extension is OPTIONAL with NORM_INFO         |
|                      | messages.                                    |
+----------------------+----------------------------------------------+
|NORM_CMD(EOT)         | Sender command to indicate it has reached    |
|                      | end-of-transmission and will no longer       |
|                      | respond to repair requests.                  |
+----------------------+----------------------------------------------+
|NORM_CMD(ACK_REQ)     | Sender command to support application-       |
|                      | defined, positively acknowledged commands    |
|                      | sent outside of the context of the bulk data |
|                      | content being transmitted.  The NORM Positive|
|                      | Acknowledgment Procedure associated with this|
|                      | message type is OPTIONAL.                    |
+----------------------+----------------------------------------------+
|NORM_CMD(APPLICATION) | Sender command containing application-defined|
|                      | commands sent outside of the context of the  |
|                      | bulk data content being transmitted.         |
+----------------------+----------------------------------------------+
|NORM_REPORT           | Optional message type reserved for           |
|                      | experimental implementations of the NORM     |
|                      | protocol.                                    |
+----------------------+----------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Message Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.メッセージフォーマット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As mentioned in Section 2.1, there are two primary classes of NORM messages: sender messages and receiver messages. NORM_CMD, NORM_INFO, and NORM_DATA message types are generated by senders of data content, and NORM_NACK and NORM_ACK messages generated by receivers within a NormSession. An auxiliary message type of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者のメッセージと受信メッセージ：2.1節で述べたように、NORMメッセージの二つの主要なクラスがあります。 NORM_CMD、NORM_INFO、及びNORM_DATAメッセージタイプはNormSession内の受信機によって生成されたデータコンテンツの送信者、およびNORM_NACKとNORM_ACKメッセージによって生成されます。の補助メッセージタイプ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_REPORT is also provided for experimental purposes. This section describes the message formats used by the NORM protocol. These messages and their fields are referenced in the detailed functional description of the NORM protocol given in Section 5. Individual NORM messages are designed to be compatible with the MTU limitations of encapsulating Internet protocols including IPv4, IPv6, and UDP. The current NORM protocol specification assumes UDP encapsulation and leverages the transport features of UDP. The NORM messages are independent of network addresses and can be used in IPv4 and IPv6 networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_REPORTまた、実験的な目的のために提供されます。このセクションでは、NORMプロトコルによって使用されるメッセージフォーマットを記載しています。これらのメッセージとそのフィールドは、前記個々のNORMメッセージはのIPv4、IPv6、およびUDPを含むインターネット・プロトコルをカプセル化するのMTU制限に適合するように設計されているセクションで与えられたNORMプロトコルの詳細な機能の説明において参照されます。現在NORMプロトコル仕様は、UDPカプセル化を想定し、UDPのトランスポート機能を活用しています。 NORMメッセージは、ネットワークアドレスの独立しており、IPv4とIPv6のネットワークで使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. NORM Common Message Header and Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1。 NORM共通メッセージのヘッダーと拡張機能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are some common message fields contained in all NORM message types. Additionally, a header extension mechanism is defined to expand the functionality of the NORM protocol without revision to this document. All NORM protocol messages begin with a common header with information fields as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてNORMメッセージタイプに含まれるいくつかの一般的なメッセージのフィールドがあります。また、ヘッダ拡張機構は、この文書に改訂することなく、NORMプロトコルの機能を拡張するために定義されています。次のようにすべてのNORMプロトコルメッセージは、情報フィールドと共通ヘッダーで始まります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version|  type |    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM Common Message Header Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM一般的なメッセージヘッダのフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;version&#34; field is a 4-bit value indicating the protocol version number. NORM implementations SHOULD ignore received messages with version numbers different from their own. This number is intended to indicate and distinguish upgrades of the protocol which may be non-interoperable. The NORM version number for this specification is 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「バージョン」フィールドは、プロトコルのバージョン番号を示す4ビットの値です。 NORMの実装は、独自の異なるバージョン番号が受信したメッセージを無視します。この数は、非相互運用することができるプロトコルのアップグレードを示し、区別することを意図しています。この仕様のためNORMのバージョン番号は1です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The message &#34;type&#34; field is a 4-bit value indicating the NORM protocol message type. These types are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージ「タイプ」フィールドはNORMプロトコルメッセージのタイプを示す4ビットの値です。次のようにこれらのタイプは定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Message Value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メッセージ値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_INFO 1 NORM_DATA 2 NORM_CMD 3 NORM_NACK 4 NORM_ACK 5 NORM_REPORT 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_INFO 1 NORM_DATA 2 NORM_CMD 3 NORM_NACK 4 NORM_ACK 5 NORM_REPORT 6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 8-bit &#34;hdr_len&#34; field indicates the number of 32-bit words that comprise the given message&#39;s header portion. This is used to facilitate header extensions that may be applied. The presence of header extensions are implied when the &#34;hdr_len&#34; value is greater than the base value for the given message &#34;type&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
8ビットの「hdr_len」フィールドは、指定されたメッセージのヘッダー部分を含む32ビット・ワードの数を示します。これは、適用され得るヘッダ拡張を容易にするために使用されます。 「hdr_len」値が与えられたメッセージ「タイプ」の基準値よりも大きい場合に、ヘッダ拡張の存在を暗示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;sequence&#34; field is a 16-bit value that is set by the message originator as a monotonically increasing number incremented with each NORM message transmitted to a given destination address. A &#34;sequence&#34; field number space SHOULD be maintained for messages sent to the NormSession group address. This value can be monitored by receiving nodes to detect packet losses in the transmission from a sender and used in estimating raw packet loss for congestion control purposes. Note that this value is NOT used in the NORM protocol to detect missing reliable data content and does NOT identify the application data or FEC payload that may be attached. With message authentication, the &#34;sequence&#34; field may also be leveraged for protection from message &#34;replay&#34; attacks, particularly of NORM_NACK or other feedback messages. In this case, the receiver node should maintain a monotonically increasing &#34;sequence&#34; field space for each destination to which it transmits (this may be multiple destinations when unicast feedback is used). The size of this field is intended to be sufficient to allow detection of a reasonable range of packet loss within the delay-bandwidth product of expected network connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「配列」フィールドは、指定された宛先アドレスに送信される各NORMメッセージでインクリメント単調に増加する数としてメッセージ発信者によって設定された16ビットの値です。 「配列」フィールドの番号空間はNormSessionグループアドレスに送信されたメッセージのために維持されるべきです。この値は、送信者からの送信中のパケット損失を検出するために受信ノードによって監視および輻輳制御の目的のために、生のパケット損失を推定する際に使用することができます。この値は信頼性のあるデータコンテンツを欠落検出するNORMプロトコルで使用されていないと取り付けることができるアプリケーションデータまたはFECペイロードを識別しないことに留意されたいです。メッセージ認証では、「順序」フィールドには、特にNORM_NACKまたはその他のフィードバックメッセージのメッセージ「リプレイ」攻撃からの保護のために活用することができます。この場合、受信ノードは、（ユニキャストフィードバックが使用される場合、これは複数の宛先であってもよい）、それが送信する宛先ごとに単調に増加する「配列」フィールドのスペースを維持しなければなりません。このフィールドのサイズは、予想されるネットワーク接続の遅延帯域幅積内のパケット損失の合理的な範囲の検出を可能にするのに十分であることが意図されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;source_id&#34; field is a 32-bit value identifying the node that sent the message. A participant&#39;s NORM node identifier (NormNodeId) can be set according to application needs but unique identifiers must be assigned within a single NormSession. In some cases, use of the host IP address or a hash of it can suffice, but alternative methodologies for assignment and potential collision resolution of node identifiers within a multicast session need to be considered. For example, the &#34;source identifier&#34; mechanism defined in the Real-Time Protocol (RTP) specification [18] may be applicable to use for NORM node identifiers. At this point in time, the protocol makes no assumptions about how these unique identifiers are actually assigned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「SOURCE_ID」フィールドは、メッセージを送信したノードを識別する32ビット値です。参加者のNORMノード識別子（NormNodeId）は、アプリケーションのニーズに応じて設定することができるが、ユニークな識別子は、単一NormSession内で割り当てられなければなりません。いくつかのケースでは、ホストのIPアドレスまたはそれのハッシュを使用することは十分できますが、マルチキャストセッション内の割り当てとノード識別子の潜在的な衝突解決のための代替方法論を考慮する必要があります。例えば、リアルタイムプロトコル（RTP）仕様[18]で定義された「ソース識別子」機構は、NORMノード識別子の使用に適用可能です。この時点では、プロトコルは、これらのユニークな識別子が実際に割り当てられているかについての仮定を行いません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM Header Extensions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMヘッダの拡張
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When header extensions are applied, they follow the message type&#39;s base header and precede any payload portion. There are two formats for header extensions, both of which begin with an 8-bit &#34;het&#34; (header extension type) field. One format is provided for variable-length extensions with &#34;het&#34; values in the range from 0 through 127. The other format is for fixed length (one 32-bit word) extensions with &#34;het&#34; values in the range from 128 through 255. These formats are given here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ヘッダ拡張が適用される場合、それらは、メッセージ・タイプのベースヘッダに従い、任意のペイロード部分に先行します。 8ビットの「HET」（ヘッダ拡張タイプ）フィールドで始まりどちらのヘッダ拡張のための2つの形式があります。一つの形式は、0から127までの範囲における「HET」の値を持つ可変長の拡張のために提供される他の形式は、固定長（1つの32ビット・ワード）128から255までの範囲における「HET」値を拡張するためのものです。これらのフォーマットは、ここに与えられています：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   het &lt;=127   |      hel      |                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
   |                    Header Extension Content                   |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM Variable Length Header Extension Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM可変長ヘッダ拡張フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   het &gt;=128   |   reserved    |    Header Extension Content   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           NORM Fixed Length (32-bit) Header Extension Format
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;Header Extension Content&#34; portion of these header extension format is defined for each header extension type defined for NORM messages. Some header extensions are defined within this document for NORM baseline FEC and congestion control operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのヘッダ拡張フォーマットの「ヘッダ拡張コンテンツ」部分は、NORMメッセージに対して定義された各ヘッダ拡張タイプのために定義されています。いくつかのヘッダ拡張はNORMベースラインFEC及び輻輳制御動作については、この文書内で定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Sender Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2。メッセージの送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM sender messages include the NORM_DATA type, the NORM_INFO type, and the NORM_CMD type. NORM_DATA and NORM_INFO messages contain application data content while NORM_CMD messages are used for various protocol control functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMの送信者のメッセージがNORM_DATAタイプ、NORM_INFOタイプ、およびNORM_CMDタイプが含まれます。 NORM_CMDメッセージは、様々なプロトコルの制御機能のために使用されている間NORM_DATAとNORM_INFOメッセージは、アプリケーション・データ・コンテンツを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. NORM_DATA Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1。 NORM_DATAメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_DATA message is expected to be the predominant type transmitted by NORM senders. These messages are used to encapsulate segmented data content for objects of type NORM_OBJECT_DATA, NORM_OBJECT_FILE, and NORM_OBJECT_STREAM. NORM_DATA messages may contain original or FEC-encoded application data content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_DATAメッセージはNORM送信者によって送信された優勢なタイプであることが期待されます。これらのメッセージはタイプNORM_OBJECT_DATA、NORM_OBJECT_FILE、およびNORM_OBJECT_STREAMのオブジェクトのためのセグメント化されたデータの内容をカプセル化するために使用されています。 NORM_DATAメッセージは、元のまたは、FECコード化されたアプリケーションデータの内容を含んでいてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The format of NORM_DATA messages is comprised of three logical portions: 1) a fixed-format NORM_DATA header portion, 2) a FEC Payload ID portion with a format dependent upon the FEC encoding used, and 3) a payload portion containing source or encoded application data content. Note for objects of type NORM_OBJECT_STREAM, the payload portion contains additional fields used to appropriately recover stream content. NORM implementations MAY also extend the NORM_DATA header to include a FEC Object
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）固定形式NORM_DATAヘッダ部分、使用FEC符号化に依存する形式の2）FECペイロードID部、及びソースまたはコード化されたアプリケーションを含む3）ペイロード部：NORM_DATAメッセージのフォーマットは、3つの論理部分で構成されていますデータ内容。型NORM_OBJECT_STREAMのオブジェクトに関する注意、ペイロード部分は、適宜、ストリームコンテンツを回復するために使用される追加フィールドを含んでいます。 NORM実装はまた、FECオブジェクトを含むようにNORM_DATAヘッダを延長することができます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Transmission Information (EXT_FTI) header extension. This allows NORM receivers to automatically allocate resources and properly perform FEC decoding without the need for pre-configuration or out-of-band information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信情報（EXT_FTI）ヘッダ拡張。これは、NORM受信機が自動的にリソースを割り当て、適切に事前構成またはアウトオブバンド情報を必要とせずにFEC復号化を実行することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=2|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     flags     |    fec_id     |     object_transport_id       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         fec_payload_id                        |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                header_extensions (if applicable)              |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       payload_reserved*       |          payload_len*         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        payload_offset*                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          payload_data*                        |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_DATA Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_DATAメッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
*NOTE: The &#34;payload_reserved&#34;, &#34;payload_len&#34; and &#34;payload_offset&#34; fields are present only for objects of type NORM_OBJECT_STREAM. The &#34;payload_len&#34; and &#34;payload_offset&#34; fields allow senders to arbitrarily vary the size of NORM_DATA payload segments for streams. This allows applications to flush transmitted streams as needed to meet unique streaming requirements. For objects of types NORM_OBJECT_FILE and NORM_OBJECT_DATA, these fields are unnecessary since the receiver can calculate the payload length and offset information from the &#34;fec_payload_id&#34; using the algorithm described in Section 5.1.1. The &#34;payload_reserved&#34; field is kept for anticipated future NORM stream control functions. When systematic FEC codes (e.g., &#34;fec_id&#34; = 129) are used, the &#34;payload_len&#34; and &#34;payload_offset&#34; fields contain actual length and offset values for the encapsulated application data segment for those NORM_DATA messages containing source data symbols. In NORM_DATA messages that contain parity information, these fields are not actual length or offset values, but instead are values computed from FEC encoding the &#34;payload_len&#34; and &#34;payload_offset&#34; fields of the _source_ data symbols of the corresponding applicable coding block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
*注：「payload_reserved」、「payload_len」と「payload_offset」フィールドは唯一のタイプのNORM_OBJECT_STREAMのオブジェクトのために存在しています。 「payload_len」および「payload_offset」フィールドは、送信者が任意ストリームのNORM_DATAペイロードセグメントのサイズを変更することを可能にします。これは、独自のストリーミング要件を満たすために、必要に応じて、アプリケーションが送信されたストリームをフラッシュすることができます。受信機は、セクション5.1.1で説明したアルゴリズムを使用して、ペイロード長を計算し、「fec_payload_id」からの情報をオフセットすることができるので種類NORM_OBJECT_FILEとNORM_OBJECT_DATAの目的のために、これらのフィールドは不要です。 「payload_reserved」フィールドは、予想される将来のNORMストリーム制御機能のために保たれています。システマティックFEC符号（例えば、「fec_id」= 129）が使用される場合、「payload_len」および「payload_offset」フィールドは、実際の長さを含み、ソースデータシンボルを含むものNORM_DATAメッセージのカプセル化されたアプリケーションデータセグメントのオフセット値。パリティ情報を含むNORM_DATAメッセージに、これらのフィールドは、実際の長さではないか、オフセット値を、その代わりに「payload_len」と対応する適用可能な符号化ブロックの_source_データシンボルの「payload_offset」フィールドを符号化するFECから計算された値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;version&#34;, &#34;type&#34;, &#34;hdr_len&#34;, &#34;sequence&#34;, and &#34;source_id&#34; fields form the NORM Common Message Header as described in Section 4.1. The value of the NORM_DATA &#34;type&#34; field is 2. The NORM_DATA _base_ &#34;hdr_len&#34; value is 4 (32-bit words) plus the size of the &#34;fec_payload_id&#34; field. The &#34;fec_payload_id&#34; field size depends upon the FEC encoding used for the referenced NormObject. The &#34;fec_id&#34; field is used to indicate the FEC coding type. For example, when small block, systematic codes are used, a &#34;fec_id&#34; value of 129 is indicated and the size of the &#34;fec_payload_id&#34; is two 32-bit words. In this case the NORM_DATA base &#34;hdr_len&#34; value is 6. The cumulative size of any header extensions applied is added into the &#34;hdr_len&#34; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション4.1で説明したように、「バージョン」、「タイプ」、「hdr_len」、「配列」、および「SOURCE_ID」フィールドは、NORM共通メッセージヘッダーを形成します。 NORM_DATA「タイプ」フィールドの値がNORM_DATA _base_「hdr_len」値は4（32ビットワード）プラス「fec_payload_id」フィールドのサイズである2です。 「fec_payload_id」フィールドのサイズは、参照NormObjectに使用FEC符号化に依存します。 「fec_id」フィールドは、FEC符号化タイプを示すために使用されます。小ブロック、系統的符号が使用される場合、例えば、129の「fec_id」値が示され、「fec_payload_id」の大きさは、2つの32ビットワードです。この場合NORM_DATA塩基「hdr_len」値が適用されたヘッダ拡張の前記累積サイズが「hdr_len」フィールドに追加されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;instance_id&#34; field contains a value generated by the sender to uniquely identify its current instance of participation in the NormSession. This allows receivers to detect when senders have perhaps left and rejoined a session in progress. When a sender (identified by its &#34;source_id&#34;) is detected to have a new &#34;instance_id&#34;, the NORM receivers SHOULD drop their previous state on the sender and begin reception anew.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「INSTANCE_ID」フィールドは、一意NormSessionの参加の現在のインスタンスを識別するために、送信者によって生成された値を含みます。これは、送信者が、おそらく左と進行中のセッションに復帰したときの受信機が検出することができます。 （その「SOURCE_ID」で識別される）送信者が新しい「INSTANCE_ID」を有すると検出された場合は、NORM受信機は、送信者に以前の状態を削除し、新たに受信を開始する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;grtt&#34; field contains a non-linear quantized representation of the sender&#39;s current estimate of group round-trip time (GRTT) (this is also referred to as R_max in [19]). This value is used to control timing of the NACK repair process and other aspects of protocol operation as described in this document. The algorithm for encoding and decoding this field is described in the RMT NORM Building Block document [4].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「GRTT」フィールドは、グループラウンドトリップ時間（GRTT）（これはまた、[19]にR_MAXと呼ぶ）の送信者の現在の推定値の非線形量子化された表現を含みます。この値は、この文書に記載されているようにNACK修復プロセスおよびプロトコル動作の他の態様のタイミングを制御するために使用されます。符号化およびこのフィールドを復号するためのアルゴリズムは、RMT NORMビルディングブロックの文書に記載されている[4]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;backoff&#34; field value is used by receivers to determine the maximum backoff timer value used in the timer-based NORM NACK feedback suppression. This 4-bit field supports values from 0-15 which is multiplied by the sender GRTT to determine the maximum backoff timeout. The &#34;backoff&#34; field informs the receiver set of the sender&#39;s backoff factor parameter &#34;Ksender&#34;. Recommended values and their use are described in the NORM receiver NACK procedure description in Section 5.3. The &#34;gsize&#34; field contains a representation of the sender&#39;s current estimate of group size. This 4-bit field can roughly represent values from ten to 500 million where the most significant bit value of 0 or 1 represents a mantissa of 1 or 5, respectively and the three least significant bits incremented by one represent a base 10 exponent (order of magnitude). For examples, a field value of &#34;0x0&#34; represents 1.0e+01 (10), a value of &#34;0x8&#34; represents 5.0e+01 (50), a value of &#34;0x1&#34; represents 1.0e+02 (100), and a value of &#34;0xf&#34; represents 5.0e+08. For NORM feedback suppression purposes, the group size does not need to be represented with a high degree of precision. The group size may even be estimated somewhat conservatively (i.e., overestimated) to maintain low levels of feedback traffic. A default group size estimate of 10,000 (&#34;gsize&#34; = 0x4) is recommended for general purpose reliable multicast applications using the NORM protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「バックオフ」フィールドの値は、タイマベースNORMのNACKフィードバック抑制に使用される最大のバックオフ・タイマ値を決定するために受信機によって使用されます。この4ビットのフィールドは、最大バックオフタイムアウトを決定するために、送信者GRTTを乗じて0~15の値をサポートします。 「バックオフ」フィールドには、送信者のバックオフ係数パラメータ「Ksender」の受信機のセットを通知します。推奨値およびそれらの使用はセクション5.3でNORM受信NACK手順の説明に記載されています。 「GSIZE」フィールドには、グループサイズの送信者の現在の推定値の表現が含まれています。この4ビットのフィールドは、およそ500 0又は1の最上位ビットの値は、それぞれ1または5の仮数を表す万人に10の値を表すことができ、インクリメント3つの最下位ビット（オーダーのベース10指数を表します大きさ）。例については、 &#34;は0x0&#34; のフィールド値が1.0E + 01（10）を表し、 &#34;0x8という&#34; の値が5.0E + 01（50）を表し、 &#34;0x1の&#34; の値は、1.0E + 02（100）を表し、そして&#34;0xFの&#34; の値が5.0E + 08を表しています。 NORMフィードバック抑制のために、グループの大きさは高精度で表現する必要はありません。グループサイズであっても、フィードバックトラフィックの低レベルを維持する（すなわち、過大評価）幾分控えめに推定することができます。万のデフォルト・グループのサイズ推定値は、（= 0x4の「GSIZE」）NORMプロトコルを使用して汎用信頼性の高いマルチキャストアプリケーションのために推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;flags&#34; field contains a number of different binary flags providing information and hints regarding how the receiver should handle the identified object. Defined flags in this field include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「フラグ」フィールドは、受信機が特定されたオブジェクトを処理する方法に関する情報やヒントを提供する異なるバイナリフラグの数が含まれています。この分野で定義されたフラグは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
+--------------------+-------+-----------------------------------------+
|        Flag        | Value |                 Purpose                 |
+--------------------+-------+-----------------------------------------+
|NORM_FLAG_REPAIR    | 0x01  | Indicates message is a repair           |
|                    |       | transmission                            |
+--------------------+-------+-----------------------------------------+
|NORM_FLAG_EXPLICIT  | 0x02  | Indicates a repair segment intended to  |
|                    |       | meet a specific receiver erasure, as    |
|                    |       | compared to parity segments provided by |
|                    |       | the sender for general purpose (with    |
|                    |       | respect to an FEC coding block) erasure |
|                    |       | filling.                                |
+--------------------+-------+-----------------------------------------+
|NORM_FLAG_INFO      | 0x04  | Indicates availability of NORM_INFO for |
|                    |       | object.                                 |
+--------------------+-------+-----------------------------------------+
|NORM_FLAG_UNRELIABLE| 0x08  | Indicates that repair transmissions for |
|                    |       | the specified object will be unavailable|
|                    |       | (One-shot, best effort transmission).   |
+--------------------+-------+-----------------------------------------+
|NORM_FLAG_FILE      | 0x10  | Indicates object is &#34;file-based&#34; data   |
|                    |       | (hint to use disk storage for           |
|                    |       | reception).                             |
+--------------------+-------+-----------------------------------------+
|NORM_FLAG_STREAM    | 0x20  | Indicates object is of type             |
|                    |       | NORM_OBJECT_STREAM.                     |
+--------------------+-------+-----------------------------------------+
|NORM_FLAG_MSG_START | 0x40  | Marks the first segment of application  |
|                    |       | messages embedded in                    |
|                    |       | NORM_OBJECT_STREAMs.                    |
+--------------------+-------+-----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_FLAG_REPAIR is set when the associated message is a repair transmission. This information can be used by receivers to help observe a join policy where it is desired that newly joining receivers only begin participating in the NACK process upon receipt of new (non-repair) data content. NORM_FLAG_EXPLICIT is used to mark repair messages sent when the data sender has exhausted its ability to provide &#34;fresh&#34; (previously untransmitted) parity segments as repair. This flag could possibly be used by intermediate systems implementing functionality to control sub-casting of repair content to different legs of a reliable multicast topology with disparate repair needs. NORM_FLAG_INFO is set only when optional NORM_INFO content is actually available for the associated object. Thus, receivers will NACK for retransmission of NORM_INFO only when it is available for a given object. NORM_FLAG_UNRELIABLE is set when the sender wishes to transmit an object with only &#34;best effort&#34; delivery and will not supply repair transmissions for the object. NORM receivers SHOULD NOT execute repair requests for objects marked with the NORM_FLAG_UNRELIABLE flag. Note that receivers may inadvertently request repair of such objects when all segments (or info content) for those objects are not received (i.e., a gap in the &#34;object_transport_id&#34; sequence is noted). In this case, the sender should invoke the NORM_CMD(SQUELCH) process as described in Section 4.2.3. NORM_FLAG_FILE can be set as a &#34;hint&#34; from the sender that the associated object should be stored in non-volatile storage. NORM_FLAG_STREAM is set when the identified object is of type NORM_OBJECT_STREAM. When NORM_FLAG_STREAM is set, the NORM_FLAG_MSG_START can be optionally used to mark the first data segments of application-layer messages transported within the NORM stream. This allows NORM receiver applications to &#34;synchronize&#34; with NORM senders and to be able to properly interpret application layer data when joining a NORM session already in progress. In practice, the NORM implementation MAY set this flag for the segment transmitted following an explicit &#34;flush&#34; of the stream by the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
関連メッセージが修復送信である場合NORM_FLAG_REPAIRが設定されています。この情報は、新たに参加する受信機が唯一の新しい（非修理）データ・コンテンツの受信時にNACKプロセスへの参加を開始することを希望する参加方針を観察支援するために受信機で使用することができます。 NORM_FLAG_EXPLICITは、データの送信者が修理として「新鮮」（以前に未送信）パリティセグメントを提供する能力を使い果たした時に送信され、修復メッセージをマークするために使用されます。このフラグは、おそらく異なる修復ニーズに信頼性の高いマルチキャストトポロジーの異なる脚に修復コンテンツのサブキャスティングを制御する機能を実装する中間システムで使用することができます。 NORM_FLAG_INFOは、オプションのNORM_INFOコンテンツは、関連するオブジェクトのために、実際に利用可能であるときにのみ設定されています。これにより、指定されたオブジェクトのために利用可能であるのみNORM_INFOの再送信のための受信機意志NACK。送信者が唯一「ベストエフォート」の配信を持つオブジェクトを送信したいとオブジェクトのための修理送信を供給しないときNORM_FLAG_UNRELIABLEが設定されています。 NORM受信機はNORM_FLAG_UNRELIABLEフラグでマークされたオブジェクトの修復要求を実行すべきではありません。これらのオブジェクトのすべてのセグメント（又は情報コンテンツ）が受信されない場合に受信機が誤って（すなわち、「object_transport_id」配列のギャップが注目されている）、このようなオブジェクトの修復を要求してもよいことに留意されたいです。この場合、送信者は、セクション4.2.3に記載したようにNORM_CMD（SQUELCH）プロセスを起動しなければなりません。 NORM_FLAG_FILEは、関連するオブジェクトは、不揮発性記憶装置に記憶されなければならない送信者からの「ヒント」として設定することができます。特定されたオブジェクトの型がNORM_OBJECT_STREAMであるときNORM_FLAG_STREAMが設定されています。 NORM_FLAG_STREAMが設定されている場合、NORM_FLAG_MSG_STARTは、必要に応じてNORMストリーム内輸送アプリケーション層メッセージの最初のデータセグメントをマークするために使用することができます。これは、NORMレシーバアプリケーションNORMの送信者と「同期」すると、既に進行中のNORMセッションに参加する際に適切にアプリケーション層のデータを解釈することができるようにすることができます。実際には、NORM実装は、アプリケーションによるストリームの明示的な「フラッシュ」以下送信セグメントに対して、このフラグを設定してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;fec_id&#34; field corresponds to the FEC Encoding Identifier described in the FEC Building Block document [5]. The &#34;fec_id&#34; value implies the format of the &#34;fec_payload_id&#34; field and, coupled with FEC Object Transmission Information, the procedures to decode FEC encoded content. Small block, systematic codes (&#34;fec_id&#34; = 129) are expected to be used for most NORM purposes and the NORM_OBJECT_STREAM requires systematic FEC codes for most efficient performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FEC符号化識別子は、FECビルディングブロック文献[5]に記載の「fec_id」フィールドは、対応しています。 「fec_id」値は、手順はFEC符号化コンテンツを復号するために、FECオブジェクト伝送情報と結合された「fec_payload_id」フィールドと、の形式を意味しています。小ブロック、システマティック符号（「fec_id」= 129）が最もNORM目的のために使用されることが期待とNORM_OBJECT_STREAMは、最も効率的なパフォーマンスのために系統的FECコードを必要としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;object_transport_id&#34; field is a monotonically and incrementally increasing value assigned by the sender to NormObjects being transmitted. Transmissions and repair requests related to that object use the same &#34;object_transport_id&#34; value. For sessions of very long or indefinite duration, the &#34;object_transport_id&#34; field may be repeated, but it is presumed that the 16-bit field size provides an adequate enough sequence space to avoid object confusion amongst receivers and sources (i.e., receivers SHOULD re-synchronize with a server when receiving object sequence identifiers sufficiently out-of-range with the current state kept for a given source). During the course of its transmission within a NORM session, an object is uniquely identified by the concatenation of the sender &#34;source_id&#34; and the given &#34;object_transport_id&#34;. Note that NORM_INFO messages associated with the identified object carry the same &#34;object_transport_id&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「object_transport_id」フィールドは、送信されるNormObjectsに送信者によって割り当てられた、単調と増分増加する値です。そのオブジェクトに関連したトランスミッション、修理依頼は、同じ「object_transport_id」の値を使用します。非常に長いまたは無期限のセッションでは、「object_transport_id」フィールドが繰り返されてもよいが、16ビットのフィールドのサイズは受信機とソースの間でのオブジェクトの混乱を避けるために十分な十分な配列スペースを提供していると推定される（すなわち、受信機は、再すべきです十分に範囲外の現在の状態が与えられたソースのために保持して）オブジェクトのシーケンス識別子を受信したときにサーバと同期。 NORMセッション内での伝送の過程で、オブジェクトは、一意の送信者「SOURCE_ID」と指定された「object_transport_id」の連結によって識別されます。識別されたオブジェクトに関連付けられたNORM_INFOメッセージは同じ「object_transport_id」値を運ぶことに留意されたいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;fec_payload_id&#34; identifies the attached NORM_DATA &#34;payload&#34; content. The size and format of the &#34;fec_payload_id&#34; field depends upon the FEC type indicated by the &#34;fec_id&#34; field. These formats are given in the FEC Building Block document [5] and any subsequent extensions of that document. As an example, the format of the &#34;fec_payload_id&#34; format small block, systematic codes (&#34;fec_id&#34; = 129) given here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「fec_payload_idは」添付NORM_DATA「ペイロード」コンテンツを識別する。 「fec_payload_id」フィールドのサイズと形式が「fec_id」フィールドによって示されるFECタイプに依存します。これらのフォーマットはFECビルディングブロック文献[5]及びその文書の任意の後続の拡張に記載されています。一例として、「fec_payload_id」形式小ブロック、ここで与えられた体系的コード（= 129「fec_id」）の形式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       source_block_number                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        source_block_len       |      encoding_symbol_id       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Small Block, Systematic Code (&#34;fec_id&#34; = 129) &#34;fec_payload_id&#34; Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スモールブロック、組織符号（ &#34;fec_id&#34; = 129） &#34;fec_payload_id&#34; フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The FEC payload identifier &#34;source_block_number&#34;, &#34;source_block_len&#34;, and &#34;encoding_symbol_id&#34; fields correspond to the &#34;Source Block Number&#34;, &#34;Source Block Length, and &#34;Encoding Symbol ID&#34; fields of the FEC Payload ID format given by the IETF FEC Building Block document [5]. The &#34;source_block_number&#34; identifies the coding block&#39;s relative position with a NormObject. Note that, for NormObjects of type NORM_OBJECT_STREAM, the &#34;source_block_number&#34; may wrap for very long lived sessions. The &#34;source_block_len&#34; indicates the number of user data segments in the identified coding block. Given the &#34;source_block_len&#34; information of how many symbols of application data are contained in the block, the receiver can determine whether the attached segment is data or parity content and treat it appropriately. The &#34;encoding_symbol_id&#34; identifies which specific symbol (segment) within the coding block the attached payload conveys. Depending upon the value of the &#34;encoding_symbol_id&#34; and the associated &#34;source_block_len&#34; parameters for the block, the symbol (segment) referenced may be a user data or an FEC parity segment. For systematic codes, encoding symbols numbered less than the source_block_len contain original application data while segments greater than or equal to source_block_len contain parity symbols calculated for the block. The concatenation of object_transport_id::fec_payload_id can be viewed as a unique transport protocol data unit identifier for the attached segment with respect to the NORM sender&#39;s instance within a session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FECペイロード識別子「source_block_number」、「source_block_len」、および「encoding_symbol_id」フィールドが「ソースブロック番号」に対応し、「ソースブロック長、及び 『IETF FECビルディングによって与えられるFECペイロードIDフォーマットの符号化シンボルID』フィールドブロック文献[5]。「source_block_number」はNormObject有する符号化ブロックの相対位置を特定する。型NORM_OBJECT_STREAMのNormObjectsため、「source_block_number」は非常に長寿命のセッションのために包むことができる、ということに注意してください。「source_block_len」は、ユーザの数を示します同定された符号化ブロック内のデータセグメント。アプリケーションデータのシンボルがブロックに含まれているどのように多くの「source_block_len」情報が与えられると、受信機は接続セグメントは、データまたはパリティコンテンツであるか否かを判断し、適切に処理することができる。「encoding_symbol_id」を特定添付のペイロードが搬送する符号化ブロック内のどの特定のシンボル（セグメント）。「encoding_symbol_id」の値と関連する依存ブロックの「source_block_len」パラメータは、参照シンボル（セグメント）は、ユーザデータまたはFECパリティセグメントであってもよいです。システマティックコードの場合、符号化シンボルは、以上のセグメントがブロックのために計算されたパリティシンボルを含むsource_block_lenするながらsource_block_lenは、元のアプリケーションデータを含む未満番号。 object_transport_id :: fec_payload_idの連結は、セッション内NORM送信者のインスタンスに対して接続されたセグメントの一意のトランスポートプロトコルデータユニット識別子とみなすことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additional FEC Object Transmission Information (as described in the FEC Building Block document [5]) is required to properly receive and decode NORM transport objects. This information MAY be provided as out-of-band session information. However, in some cases, it may be useful for the sender to include this information &#34;in band&#34; to facilitate receiver operation with minimal preconfiguration. For this purpose, the NORM FEC Object Transmission Information Header Extension (EXT_FTI) is defined. This header extension MAY be applied to NORM_DATA and NORM_INFO messages to provide this necessary information. The exact format of the extension depends upon the FEC code in use, but in general it SHOULD contain any required details on the FEC code in use (e.g., FEC Instance ID, etc.) and the byte size of the associated NormObject (For the NORM_OBJECT_STREAM type, this size corresponds to the stream buffer size maintained by the NORM sender). As an example, the format of the EXT_FTI for small block systematic codes (&#34;fec_id&#34; = 129) is given here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（FECビルディングブロック文献[5]に記載のように）追加のFECオブジェクト伝送情報が正しく受信およびデコードNORMのトランスポート・オブジェクトが要求されます。この情報は、アウトオブバンドセッション情報として提供することができます。送信者がこの情報を含むようにするためしかし、いくつかのケースでは、最小の事前設定を用いて受信動作を容易にするために、「帯域内」に有用であり得ます。この目的のために、NORM FECオブジェクト伝送情報ヘッダ拡張（EXT_FTI）が定義されています。このヘッダー拡張は、この必要な情報を提供するためにNORM_DATAとNORM_INFOメッセージに適用されてもよいです。拡張の正確なフォーマットは、使用中のFECコードに依存するが、一般的には（例えば、FECインスタンスID、等）は、使用中のFECコードと関連NormObjectのバイトサイズの任意の必要な詳細を（含むべきですNORM_OBJECT_STREAM型が、このサイズはNORM送信者によって維持ストリームバッファサイズ）に対応します。一例として、小さなブロックシステマティック符号（「fec_id」= 129）についてのEXT_FTIの形式は、ここで与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    het = 64   |    hel = 4    |      object_length (msb)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      object_length (lsb)                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       fec_instance_id         |          segment_size         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       fec_max_block_len       |         fec_num_parity        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
FEC Object Transmission Information Header Extension (EXT_FTI) for Small Block Systematic Codes (&#34;fec_id&#34; = 129)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
小ブロック組織符号のためのFECオブジェクト伝送情報ヘッダ拡張（EXT_FTI）（= 129「fec_id」）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The header extension type &#34;het&#34; field value for this header extension is 64. The header extension length &#34;hel&#34; depends upon the format of the FTI for FEC code type identified by the &#34;fec_id&#34; field. In this example (for &#34;fec_id&#34; = 129), the &#34;hel&#34; field value is 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このヘッダー拡張用ヘッダ拡張タイプ「HET」フィールドの値は、ヘッダ拡張長さ「HEL」が「fec_id」フィールドによって識別されるFECコードタイプのFTIのフォーマットに依存64です。この例では（ &#34;fec_id&#34; = 129の場合）、 &#34;HEL&#34; フィールドの値は4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The 48-bit &#34;object_length&#34; field indicates the total size of the object (in bytes) for the static object types of NORM_OBJECT_FILE and NORM_OBJECT_DATA. This information is used by receivers to determine storage requirements and/or allocate storage for the received object. Receivers with insufficient storage capability may wish to forego reliable reception (i.e., not NACK for) of the indicated object. In the case of objects of type NORM_OBJECT_STREAM, the &#34;object_length&#34; field is used by the sender to indicate the size of its stream buffer to the receiver group. In turn, the receivers SHOULD use this information to allocate a stream buffer for reception of corresponding size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
48ビットの「object_length」フィールドはNORM_OBJECT_FILEとNORM_OBJECT_DATAの静的オブジェクトタイプの（バイト単位）オブジェクトの合計サイズを示しています。この情報は、ストレージ要件を決定及び/又は受信されたオブジェクトのための記憶域を割り当てるために受信機によって使用されます。不十分な貯蔵能力を有する受信機は、指示されたオブジェクトの（即ちためではなく、NACK）信頼性の高い受信を放棄することを望むかもしれません。型NORM_OBJECT_STREAMのオブジェクトの場合には、「object_length」フィールドは、受信グループにそのストリームバッファのサイズを示すために送信側によって使用されます。次に、受信機は、対応するサイズの受信用ストリームバッファを割り当てるためにこの情報を使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;fec_instance_id&#34; corresponds to the &#34;FEC Instance ID&#34; described in the FEC Building Block document [5]. In this case, the &#34;fec_instance_id&#34; SHALL be a value corresponding to the particular type of Small Block Systematic Code being used (e.g., Reed-Solomon GF(2^8), Reed-Solomon GF(2^16), etc). The standardized assignment of FEC Instance ID values is described in [5]. The &#34;segment_size&#34; field indicates the sender&#39;s current setting for maximum message payload content (in bytes). This allows receivers to allocate appropriate buffering resources and to determine other information in order to properly process received data messaging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「fec_instance_id」はFECビルディングブロック文献[5]に記載の「FECインスタンスID」に対応します。この場合、「fec_instance_id」は（例えば、リード・ソロモンGF（2 ^ 8）、リード・ソロモンGF（2 ^ 16）、等）を使用して小ブロック組織符号の特定のタイプに対応する値でなければなりません。 FECインスタンスID値の標準化された割り当ては、[5]に記載されています。 「のsegment_size」フィールドは、バイト単位での最大メッセージ・ペイロードコンテンツの送信者の現在の設定を示しています。これは、受信機が適切なバッファリング資源を割り当てるために、適切に受信されたデータ・メッセージを処理するために他の情報を決定することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;fec_max_block_len&#34; indicates the current maximum number of user data segments per FEC coding block to be used by the sender during the session. This allows receivers to allocate appropriate buffer space for buffering blocks transmitted by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「fec_max_block_len」はFEC符号化ブロックごとのユーザデータセグメントの現在の最大数は、セッション中に送信者によって使用されることを示しています。これは、受信機が、送信者が送信したブロックをバッファリングするための適切なバッファ領域を割り当てることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;fec_num_parity&#34; corresponds to the &#34;maximum number of encoding symbols that can be generated for any source block&#34; as described in for FEC Object Transmission Information for Small Block Systematic Codes in the FEC Building Block document [5]. For example, Reed-Solomon codes may be arbitrarily shortened to create different code variations for a given block length. In the case of Reed-Solomon (GF(2^8) and GF(2^16)) codes, this value indicates the maximum number of parity segments available from the sender for the coding blocks. This field MAY be interpreted differently for other systematic codes as they are defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
FECビルディングブロック文書における小ブロック系統的コードについてFECオブジェクト伝送情報のために記載したように「fec_num_parity」は、[5]「は、任意のソースブロックに対して生成することができる符号化シンボルの最大数」に相当します。例えば、リードソロモン符号は、任意所与のブロック長に対して異なるコードのバリエーションを作成するために短縮することができます。リード・ソロモン（GF（2 ^ 8）及びGF（2 ^ 16））符号の場合には、この値は、符号化ブロックの送信者からのパリティ・セグメントの最大数は、利用可能示します。それらが定義されている通り、このフィールドは、他の組織符号のために異なって解釈されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The payload portion of NORM_DATA messages includes source data or FEC encoded application content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_DATAメッセージのペイロード部分は、ソース・データまたはFECコード化されたアプリケーションコンテンツを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;payload_reserved&#34;, &#34;payload_len&#34; and &#34;payload_offset&#34; fields are present ONLY for transport objects of type NORM_OBJECT_STREAM. These fields indicate the size and relative position (within the stream) of the application content represented by the message payload. For senders employing systematic FEC encoding, these fields contain _actual_ length and offset values (in bytes) for the payload of messages which contain original data source symbols. For NORM_DATA messages containing calculated parity content, these fields will actually contain values computed by FEC encoding of the &#34;payload_len&#34; and &#34;payload_offset&#34; values of the NORM_DATA data segments of the corresponding FEC coding block. Thus, the &#34;payload_len&#34; and &#34;payload_offset&#34; values of missing data content can be determined upon decoding a FEC coding block. Note that these fields do NOT contribute to the value of the NORM_DATA &#34;hdr_len&#34; field. These fields are NOT present when the &#34;flags&#34; portion of the NORM_DATA message indicate the transport object if of type NORM_OBJECT_FILE or NORM_OBJECT_DATA. In this case, the length and offset information can be calculated from the &#34;fec_payload_id&#34; using the methodology described in Section 5.1.1. Note that for long-lived streams, the &#34;payload_offset&#34; field can wrap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「payload_reserved」、「payload_len」と「payload_offset」フィールドはONLY型NORM_OBJECT_STREAMのトランスポート・オブジェクトのために存在しています。これらのフィールドは、メッセージペイロードで表されるアプリケーションのコンテンツのサイズと（ストリーム内）の相対位置を示します。システマティックFEC符号化を採用する送信者のために、これらのフィールドは_actual_長さを含み、元のデータソースシンボルを含むメッセージのペイロード（バイト単位）の値をオフセット。計算されたパリティコンテンツを含むNORM_DATAメッセージについて、これらのフィールドは、実際には「payload_len」と対応するFEC符号化ブロックのNORM_DATAデータセグメントの「payload_offset」値のFEC符号化によって計算された値を含むであろう。したがって、「payload_len」と欠落データコンテンツの「payload_offset」値は、FEC符号化ブロックを復号する際に決定することができます。これらのフィールドはNORM_DATA「hdr_len」フィールドの値には寄与しないことに注意してください。 NORM_DATAメッセージの「フラグ」部分は、IF型NORM_OBJECT_FILE又はNORM_OBJECT_DATAのトランスポート・オブジェクトを示す場合、これらのフィールドは存在しません。この場合、長さ及びオフセット情報が、セクション5.1.1に記載の方法を用いて、「fec_payload_id」から計算することができます。長寿命のストリームのために、「payload_offset」フィールドをラップすることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;payload_data&#34; field contains the original application source or parity content for the symbol identified by the &#34;fec_payload_id&#34;. The length of this field SHALL be limited to a maximum of the sender&#39;s NormSegmentSize bytes as given in the FTI for the object. Note the length of this field for messages containing parity content will always be of length NormSegmentSize. When encoding data segments of varying sizes, the FEC encoder SHALL assume ZERO value padding for data segments with length less than the NormSegmentSize. It is RECOMMENDED that a sender&#39;s NormSegmentSize generally be constant for the duration of a given sender&#39;s term of participation in the session, but may possibly vary on a per-object basis. The NormSegmentSize is expected to be configurable by the sender application prior to session participation as needed for network topology maximum transmission unit (MTU) considerations. For IPv6, MTU discovery may be possibly leveraged at session startup to perform this configuration. The &#34;payload_data&#34; content may be delivered directly to the application for source symbols (when systematic FEC encoding is used) or upon decoding of the FEC block. For NORM_OBJECT_FILE and NORM_OBJECT_STREAM objects, the data segment length and offset can be calculated using the algorithm described in Section 5.1.1. For NORM_OBJECT_STREAM objects, the length and offset is obtained from the segment&#39;s corresponding &#34;payload_len&#34; and &#34;payload_offset&#34; fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「payload_data」フィールドには、元のアプリケーションのソースまたは「fec_payload_id」で識別されるシンボルのパリティコンテンツが含まれています。オブジェクトのFTIに示すように、このフィールドの長さは、送信者のNormSegmentSizeバイトの最大値に制限されるもの。パリティコンテンツを含むメッセージのため、このフィールドの長さは常に長NormSegmentSizeであることに注意してください。様々なサイズのデータ​​セグメントを符号化する際に、FECエンコーダはNormSegmentSize未満の長さのデータセグメントのゼロ値のパディングを負います。送信者のNormSegmentSizeは、一般的にセッションへの参加の所与の送信者の用語の期間中一定であることが推奨されるが、おそらくオブジェクト単位で変化してもよいです。 NormSegmentSizeは、ネットワークトポロジの最大伝送単位（MTU）の考慮のために、必要に応じてセッション参加の前に送信側アプリケーションによって構成可能であることが期待されます。 IPv6の場合、MTUの発見は、おそらくこの構成を実行するために、セッションの起動時に活用することができます。 「payload_data」コンテンツは（FEC符号化が使用される系統的）ソースシンボルのためのアプリケーションまたはFECブロックの復号時に直接送達されてもよいです。 NORM_OBJECT_FILEとNORM_OBJECT_STREAMオブジェクトに対して、データセグメント長とオフセットは、セクション5.1.1に記載したアルゴリズムを用いて計算することができます。 NORM_OBJECT_STREAMオブジェクトの場合、長さ及びオフセットは、セグメントの対応する「payload_len」および「payload_offset」フィールドから取得されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. NORM_INFO Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2。 NORM_INFOメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_INFO message is used to convey OPTIONAL, application-defined, &#34;out-of-band&#34; context information for transmitted NormObjects. An example NORM_INFO use for bulk file transfer is to place MIME type information for the associated file, data, or stream object into the NORM_INFO payload. Receivers may use the NORM_INFO content to make a decision as whether to participate in reliable reception of the associated object. Each NormObject can have an independent unit of NORM_INFO associated with it. NORM_DATA messages contain a flag to indicate the availability of NORM_INFO for a given NormObject. NORM receivers may NACK for retransmission of NORM_INFO when they have not received it for a given NormObject. The size of the NORM_INFO content is limited to that of a single NormSegmentSize for the given sender. This atomic nature allows the NORM_INFO to be rapidly and efficiently repaired within the NORM reliable transmission process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_INFOメッセージが送信さNormObjectsためOPTIONAL、アプリケーションで定義され、「アウトオブバンド」のコンテキスト情報を伝えるために使用されます。 NORM_INFOバルクファイル転送に使用する例はNORM_INFOペイロードに関連付けられたファイル、データ、またはストリームオブジェクトのMIMEタイプ情報を配置することです。受信機は、関連するオブジェクトの信頼できる受信に参加するかどうかなど、判断を下すためにNORM_INFOのコンテンツを使用することができます。各NormObjectは、それに関連付けられたNORM_INFOの独立したユニットを持つことができます。 NORM_DATAメッセージが与えられたNormObjectためNORM_INFOの利用可能性を示すフラグが含まれています。 NORM受信機はNACK NORM_INFOの再送信のために、彼らは与えられたNormObjectのためにそれを受け取っていないことがあります。 NORM_INFOコンテンツの大きさは、所与の送信者の単一NormSegmentSizeのものに限定されるものです。この原子の性質はNORM_INFOが迅速かつ効率的NORM信頼性の高い伝送プロセス内で修復することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When NORM_INFO content is available for a NormObject, the NORM_FLAG_INFO flag SHALL be set in NORM_DATA messages for the corresponding &#34;object_transport_id&#34; and the NORM_INFO message shall be transmitted as the first message for the NormObject.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_INFOコンテンツがNormObjectために利用可能である場合、NORM_FLAG_INFOフラグがNormObjectための最初のメッセージとして送信しなければならない対応する「object_transport_id」とNORM_INFOメッセージのNORM_DATAメッセージに設定されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=1|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     flags     |     fec_id    |     object_transport_id       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                header_extensions (if applicable)              |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         payload_data                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_INFO Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_INFOメッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;version&#34;, &#34;type&#34;, &#34;hdr_len&#34;, &#34;sequence&#34;, and &#34;source_id&#34; fields form the NORM Common Message Header as described in Section 4.1. The value of &#34;hdr_len&#34; field when no header extensions are present is 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション4.1で説明したように、「バージョン」、「タイプ」、「hdr_len」、「配列」、および「SOURCE_ID」フィールドは、NORM共通メッセージヘッダーを形成します。全くヘッダ拡張が存在しない「hdr_len」フィールドの値は4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;instance_id&#34;, &#34;grtt&#34;, &#34;backoff&#34;, &#34;gsize&#34;, &#34;flags&#34;, &#34;fec_id&#34;, and &#34;object_transport_id&#34; fields carry the same information and serve the same purpose as with NORM_DATA messages. These values allow the receiver to prepare appropriate buffering, etc, for further transmissions from the sender when NORM_INFO is the first message received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「INSTANCE_ID」、「GRTT」、「バックオフ」、「GSIZE」、「フラグ」、「fec_id」、および「object_transport_id」フィールドには、同じ情報を運ぶとNORM_DATAメッセージと同じ目的を果たします。これらの値は、NORM_INFOが最初のメッセージが受信された送信者からのさらなる送信のために、など、受信機は、適切なバッファを準備することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As with NORM_DATA messages, the NORM FTI Header Extension (EXT_FTI) may be optionally applied to NORM_INFO messages. To conserve protocol overhead, some NORM implementations may wish to apply the EXT_FTI when used to NORM_INFO messages only and not to NORM_DATA messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_DATAメッセージと同様に、NORM FTIヘッダ拡張（EXT_FTI）は、必要に応じてメッセージをNORM_INFOに適用することができます。プロトコルのオーバーヘッドを節約するために、いくつかのNORMの実装だけでなくNORM_DATAメッセージにNORM_INFOメッセージに使用された場合EXT_FTIを適用することを望むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_INFO &#34;payload_data&#34; field contains sender application-defined content which can be used by receiver applications for various purposes as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_INFO「payload_data」フィールドは、上述のように様々な目的のために受信機アプリケーションで使用することができる送信側アプリケーション定義のコンテンツを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. NORM_CMD Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3。 NORM_CMDメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD messages are transmitted by senders to perform a number of different protocol functions. This includes functions such as round-trip timing collection, congestion control functions, synchronization of sender/receiver repair &#34;windows&#34;, and notification of sender status. A core set of NORM_CMD messages is enumerated. Additionally, a range of command types remain available for potential application-specific use. Some NORM_CMD types may have dynamic content attached. Any attached content will be limited to maximum length of the sender NormSegmentSize to retain the atomic nature of commands. All NORM_CMD messages begin with a common set of fields, after the usual NORM message common header. The standard NORM_CMD fields are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMDメッセージは、異なるプロトコルの多数の機能を実行するために送信者によって送信されます。これは、往復のタイミング収集、輻輳制御機能、送信側/受信側の修復「ウィンドウ」の同期、および送信者の状態の通知などの機能が含まれています。 NORM_CMDメッセージのコアセットが列挙されています。また、コマンドタイプの範囲は、潜在的なアプリケーション固有の使用のために利用可能なまま。いくつかのNORM_CMDのタイプは動的なコンテンツを結合していてもよいです。接続されているすべてのコンテンツは、コマンドの原子の性質を保持するために、送信者NormSegmentSizeの最大長に制限されます。すべてNORM_CMDのメッセージは、通常のNORMメッセージの共通ヘッダの後、フィールドの共通セットで始まります。標準NORM_CMDのフィールドは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=3|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     flavor    |                                               |
   +-+-+-+-+-+-+-+-+        NORM_CMD Content                       +
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD Standard Fields
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD標準フィールド
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;version&#34;, &#34;type&#34;, &#34;hdr_len&#34;, &#34;sequence&#34;, and &#34;source_id&#34; fields form the NORM Common Message Header as described in Section 4.1. The value of the &#34;hdr_len&#34; field for NORM_CMD messages without header extensions present depends upon the &#34;flavor&#34; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション4.1で説明したように、「バージョン」、「タイプ」、「hdr_len」、「配列」、および「SOURCE_ID」フィールドは、NORM共通メッセージヘッダーを形成します。本ヘッダ拡張せずNORM_CMDメッセージの「hdr_len」フィールドの値が「味」フィールドに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;instance_id&#34;, &#34;grtt&#34;, &#34;backoff&#34;, and &#34;gsize&#34; fields provide the same information and serve the same purpose as with NORM_DATA and NORM_INFO messages. The &#34;flavor&#34; field indicates the type of command to follow. The remainder of the NORM_CMD message is dependent upon the command type (&#34;flavor&#34;). NORM command flavors include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「INSTANCE_ID」、「GRTT」、「バックオフ」、および「GSIZE」フィールドには、同じ情報を提供し、NORM_DATAとNORM_INFOメッセージと同じ目的を果たします。 「味」フィールドには、フォローするコマンドの種類を示します。 NORM_CMDメッセージの残りの部分は、コマンドタイプ（「味」）に依存します。 NORMコマンドのフレーバーは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
+----------------------+-------------+---------------------------------+
|       Command        |Flavor Value |            Purpose              |
+----------------------+-------------+---------------------------------+
|NORM_CMD(FLUSH)       |      1      | Used to indicate sender         |
|                      |             | temporary end-of-transmission.  |
|                      |             | (Assists in robustly initiating |
|                      |             | outstanding repair requests from|
|                      |             | receivers).  May also be        |
|                      |             | optionally used to collect      |
|                      |             | positive acknowledgment of      |
|                      |             | reliable reception from subset  |
|                      |             | of receivers.                   |
+----------------------+-------------+---------------------------------+
|NORM_CMD(EOT)         |      2      | Used to indicate sender         |
|                      |             | permanent end-of-transmission.  |
+----------------------+-------------+---------------------------------+
|NORM_CMD(SQUELCH)     |      3      | Used to advertise sender&#39;s      |
|                      |             | current repair window in        |
|                      |             | response to out-of-range NACKs  |
|                      |             | from receivers.                 |
+----------------------+-------------+---------------------------------+
|NORM_CMD(CC)          |      4      | Used for GRTT measurement and   |
|                      |             | collection of congestion control|
|                      |             | feedback.                       |
+----------------------+-------------+---------------------------------+
|NORM_CMD(REPAIR_ADV)  |      5      | Used to advertise sender&#39;s      |
|                      |             | aggregated repair/feedback state|
|                      |             | for suppression of unicast      |
|                      |             | feedback from receivers.        |
+----------------------+-------------+---------------------------------+
|NORM_CMD(ACK_REQ)     |      6      | Used to request application-    |
|                      |             | defined positive acknowledgment |
|                      |             | from a list of receivers        |
|                      |             | (OPTIONAL).                     |
+----------------------+-------------+---------------------------------+
|NORM_CMD(APPLICATION) |      7      | Used for application-defined    |
|                      |             | purposes which may need to      |
|                      |             | temporarily preempt data        |
|                      |             | transmission (OPTIONAL).        |
+----------------------+-------------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.1. NORM_CMD(FLUSH) Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.1。 NORM_CMD（FLUSH）メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(FLUSH) command is sent when the sender reaches the end of all data content and pending repairs it has queued for transmission. This may indicate a temporary or permanent end of data transmission, but the sender is still willing to respond to repair requests. This command is repeated once per 2*GRTT to excite the receiver set for any outstanding repair requests up to and including the transmission point indicated within the NORM_CMD(FLUSH) message. The number of repeats is equal to NORM_ROBUST_FACTOR unless a list of receivers from which explicit positive acknowledgment is expected (&#34;acking_node_list&#34;) is given. In that case, the &#34;acking_node_list&#34; is updated as acknowledgments are received and the NORM_CMD(FLUSH) is repeated according to the mechanism described in Section 5.5.3. The greater the NORM_ROBUST_FACTOR, the greater the probability that all applicable receivers will be excited for acknowledgment or repair requests (NACKs) _and_ that the corresponding NACKs are delivered to the sender. If a NORM_NACK message interrupts the flush process, the sender will re-initiate the flush process after any resulting repair transmissions are completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者は、すべてのデータ内容とそれが送信のためにキューに入れられたペンディング修理の終わりに到達したときNORM_CMD（FLUSH）コマンドが送信されます。これは、データ送信の一時的または永久的な終わりを示している可能性がありますが、送信者は、まだ修理要求に応答していく所存です。このコマンドは、およびNORM_CMD（FLUSH）メッセージ内に示された送信点を含むまで未処理の修復要求を設定受信機を励起する2 * GRTT毎に一度繰り返されます。明示的な肯定応答が（「acking_node_list」）が期待された受信機のリストが与えられない限り、反復の数はNORM_ROBUST_FACTORに等しいです。セクション5.5.3で説明されたメカニズムに従って確認応答が受信され、NORM_CMD（FLUSH）が繰り返されるように、その場合には、「acking_node_list」が更新されます。適用されるすべての受信機が承認または修理要求（NACKの）_and_対応のNACKが送信者に配信されていることのために励起される確率も大きく、NORM_ROBUST_FACTOR大きいです。 NORM_NACKメッセージがフラッシュ処理を中断した場合、結果として生じるいかなる修理送信が完了した後、送信者は、フラッシュ処理を再び開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that receivers also employ a timeout mechanism to self-initiate NACKing (if there are outstanding repair needs) when no messages of any type are received from a sender. This inactivity timeout is related to 2*GRTT*NORM_ROBUST_FACTOR and will be discussed more later. With a sufficient NORM_ROBUST_FACTOR value, data content is delivered with a high assurance of reliability. The penalty of a large NORM_ROBUST_FACTOR value is potentially excess sender NORM_CMD(FLUSH) transmissions and a longer timeout for receivers to self-initiate the terminal NACK process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意のタイプのないメッセージが送信者から受信されない場合に受信機が自己開始NACKing（未処理の修復の必要がある場合）に、タイムアウト機構を使用することに留意されたいです。この無活動タイムアウトは2 * GRTT * NORM_ROBUST_FACTORに関連して、より後述します。十分NORM_ROBUST_FACTOR値と、データコンテンツは信頼性の高い保証を用いて送達されます。大NORM_ROBUST_FACTOR値のペナルティは、潜在的に過剰センダNORM_CMD（FLUSH）送信と自己開始端末NACKプロセスに受信するためのより長いタイムアウトです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For finite-size transport objects such as NORM_OBJECT_DATA and NORM_OBJECT_FILE, the flush process (if there are no further pending objects) occurs at the end of these objects. Thus, FEC repair information is always available for repairs in response to repair requests elicited by the flush command. However, for NORM_OBJECT_STREAM, the flush may occur at any time, including in the middle of an FEC coding block if systematic FEC codes are employed. In this case, the sender will not yet be able to provide FEC parity content as repair for the concurrent coding block and will be limited to explicitly repairing stream data content for that block. Applications that anticipate frequent flushing of stream content SHOULD be judicious in the selection of the FEC coding block size (i.e., do not use a very large coding block size if frequent flushing occurs). For example, a reliable multicast application transmitting an on-going series of intermittent, relatively small messaging content will need to trade-off using the NORM_OBJECT_DATA paradigm versus the NORM_OBJECT_STREAM paradigm with an appropriate FEC coding block size. This is analogous to application trade-offs for other transport protocols such as the selection of different TCP modes of operation such as &#34;no delay&#34;, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
例えばNORM_OBJECT_DATAとNORM_OBJECT_FILEとして、有限サイズのトランスポート・オブジェクトの場合、フラッシュ処理は、（保留中のオブジェクトがもはや存在しない場合）、これらのオブジェクトの終了時に発生します。このように、FECリペア情報は常にflushコマンドによって誘発された修理依頼に応じて、修理のために利用可能です。しかし、NORM_OBJECT_STREAMため、フラッシュがシステマティックFEC符号が使用される場合、FEC符号化ブロックの中央に含め、いつでも起こり得ます。この場合、送信者はまだ同時符号化ブロックのための修理などFECパリティコンテンツを提供することができなくなり、明示的にそのブロックのストリームデータの内容を修復するために制限されます。ストリームコンテンツの頻繁なフラッシングを予測アプリケーションは、（頻繁なフラッシングが発生した場合、すなわち、非常に大きな符号ブロックサイズを使用しない）FEC符号化ブロックサイズの選択に慎重であるべきです。例えば、間欠、比較的小さなメッセージコンテンツの信頼性の高いマルチキャストアプリケーション送信、進行シリーズはトレードオフするために、適切なFEC符号化ブロックサイズでNORM_OBJECT_STREAMパラダイムに対するNORM_OBJECT_DATAパラダイムを使用して必要になります。これは、等「遅延なし」としての動作の異なるTCPモードの選択のような他のトランスポートプロトコルのアプリケーションのトレードオフに類似しています
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=3|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   flavor = 1  |    fec_id     |      object_transport_id      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         fec_payload_id                        |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                acking_node_list (if applicable)               |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD(FLUSH) Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（FLUSH）メッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the NORM common message header and standard NORM_CMD fields, the NORM_CMD(FLUSH) message contains fields to identify the current status and logical transmit position of the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM共通メッセージヘッダと標準NORM_CMDフィールドに加えて、NORM_CMD（FLUSH）メッセージは、送信者の現在の状態と論理送信位置を特定するフィールドを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;fec_id&#34; field indicates the FEC type used for the flushing &#34;object_transport_id&#34; and implies the size and format of the &#34;fec_payload_id&#34; field. Note the &#34;hdr_len&#34; value for the NORM_CMD(FLUSH) message is 4 plus the size of the &#34;fec_payload_id&#34; field when no header extensions are present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「fec_id」フィールドはフラッシング「object_transport_id」ために使用されるFECタイプを示し、「fec_payload_id」フィールドのサイズと形式を意味しています。全くヘッダ拡張が存在しない場合NORM_CMD（FLUSH）メッセージの「hdr_len」値が「fec_payload_id」フィールドのサイズ+ 4であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;object_transport_id&#34; and &#34;fec_payload_id&#34; fields indicate the sender&#39;s current logical &#34;transmit position&#34;. These fields are interpreted in the same manner as in the NORM_DATA message type. Upon receipt of the NORM_CMD(FLUSH), receivers are expected to check their completion state _through_ (including) this transmission position. If receivers have outstanding repair needs in this range, they SHALL initiate the NORM NACK Repair Process as described in Section 5.3. If receivers have no outstanding repair needs, no response to the NORM_CMD(FLUSH) is generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「object_transport_id」と「fec_payload_id」フィールドには、送信者の現在の論理「送信位置」を示しています。これらのフィールドはNORM_DATAメッセージタイプと同様に解釈されます。 NORM_CMD（FLUSH）を受信すると、受信機は、（を含む）は完了状態_through_この送信位置を確認することが期待されます。受信機はこの範囲で優れた修理の必要がある場合は、セクション5.3で説明したように、彼らはNORMのNACKの修復プロセスを開始しなければなりません。受信機は、未解決の修理のニーズを持っていない場合は、NORM_CMD（FLUSH）への応答は生成されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For NORM_OBJECT_STREAM objects using systematic FEC codes, receivers MUST request &#34;explicit-only&#34; repair of the identified &#34;source_block_number&#34; if the given &#34;encoding_symbol_id&#34; is less than the &#34;source_block_len&#34;. This condition indicates the sender has not yet completed encoding the corresponding FEC block and parity content is not yet available. An &#34;explicit-only&#34; repair request consists of NACK content for the applicable &#34;source_block_number&#34; which does not include any requests for parity-based repair. This allows NORM sender applications to &#34;flush&#34; an ongoing stream of transmission when needed, even if in the middle of an FEC block. Once the sender resumes stream transmission and passes the end of the pending coding block, subsequent NACKs from receivers SHALL request parity-based repair as usual. Note that the use of a systematic FEC code is assumed here. Normal receiver NACK initiation and construction is discussed in detail in Section 5.3. The OPTIONAL &#34;acking_node_list&#34; field contains a list of NormNodeIds for receivers from which the sender is requesting explicit positive acknowledgment of reception up through the transmission point identified by the &#34;object_transport_id&#34; and &#34;fec_payload_id&#34; fields. The length of the list can be inferred from the length of the received NORM_CMD(FLUSH) message. When the &#34;acking_node_list&#34; is present, the lightweight positive acknowledgment process described in Section 5.5.3 SHALL be observed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
所与「encoding_symbol_id」が「source_block_len」未満であれば系統的なFEC符号を用いNORM_OBJECT_STREAMオブジェクトの場合、受信機は、識別された「source_block_number」の「明示的な専用」修復を要求しなければなりません。この条件は、送信者がまだ対応するFECブロックを符号化完了していないことを示し、パリティの内容はまだ利用できません。 「明示的な専用の」修理依頼は、パリティベースの修理のためのすべての要求が含まれていません該当する「source_block_number」のNACKの内容で構成されています。これはさえFECブロックの途中であれば、必要なときにNORM送信者アプリケーションは、送信の継続的な流れを「フラッシュ」することができます。送信側は、ストリーム伝送を再開し、保留中のコードブロックの終わりを通過すると、受信機からの後続のNACKはいつものように、パリティベースの修復を求めなければなりません。体系的FECコードの使用を想定していることに注意してください。通常の受信機NACK開始と建設は5.3節で詳しく説明されています。オプション「acking_node_list」フィールドには、送信者が「object_transport_id」と「fec_payload_id」フィールドで識別される伝送ポイントを介してアップフロントの明示的な肯定応答を要求された受信機のためのNormNodeIdsのリストが含まれています。リストの長さは、受信NORM_CMD（FLUSH）メッセージの長さから推測することができます。 「acking_node_list」が存在する場合、セクション5.5.3で説明した軽量肯定応答プロセスを観察するものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.2. NORM_CMD(EOT) Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.2。 NORM_CMD（EOT）メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(EOT) command is sent when the sender reaches permanent end-of-transmission with respect to the NormSession and will not respond to further repair requests. This allows receivers to gracefully reach closure of operation with this sender (without requiring any timeout) and free any resources that are no longer needed. The NORM_CMD(EOT) command SHOULD be sent with the same robust mechanism as used for NORM_CMD(FLUSH) commands to provide a high assurance of reception by the receiver set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（EOT）コマンドは、送信者がNormSessionに対する永久エンドの伝送に到達し、さらに修復要求に応答しないときに送信されます。これは、受信機が正常（任意のタイムアウトを必要とせずに）、この送信者に操作の閉鎖に到達し、不要になったすべてのリソースを解放することができます。 NORM_CMD（FLUSH）のために使用される受信機のセットによって受信の高い保証を提供するためのコマンドとしてNORM_CMD（EOT）コマンドが同じ堅牢な機構を送ってください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=3|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   flavor = 2  |                    reserved                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD(EOT) Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（EOT）メッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The value of the &#34;hdr_len&#34; field for NORM_CMD(EOT) messages without header extensions present is 4. The &#34;reserved&#34; field is reserved for future use and MUST be set to an all ZERO value. Receivers MUST ignore the &#34;reserved&#34; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本ヘッダ拡張せずNORM_CMD（EOT）メッセージのための「hdr_len」フィールドの値が「予約」フィールドは将来の使用のために予約され、すべてのゼロ値に設定しなければなりません4です。レシーバは、「予約」フィールドを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.3. NORM_CMD(SQUELCH) Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.3。 NORM_CMD（SQUELCH）メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(SQUELCH) command is transmitted in response to outdated or invalid NORM_NACK content received by the sender. Invalid NORM_NACK content consists of repair requests for NormObjects for which the sender is unable or unwilling to provide repair. This includes repair requests for outdated objects, aborted objects, or those objects which the sender previously transmitted marked with the NORM_FLAG_UNRELIABLE flag. This command indicates to receivers what content is available for repair, thus serving as a description of the sender&#39;s current &#34;repair window&#34;. Receivers SHALL not generate repair requests for content identified as invalid by a NORM_CMD(SQUELCH).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（SQUELCH）コマンドは、送信者によって受信された期限切れまたは無効NORM_NACKコンテンツに応答して送信されます。無効なNORM_NACKの内容は、送信者が修理を提供できないか、不本意であるためNormObjects修理依頼で構成されています。これは修理時代遅れのオブジェクトに対する要求、中止されたオブジェクト、または以前に送信送信者がNORM_FLAG_UNRELIABLEフラグでマークされたオブジェクトが含まれています。このコマンドは、このように、送信者の現在の「修理・ウィンドウ」の説明として、修理のために利用可能なもの、コンテンツ受信機に指示します。レシーバはNORM_CMD（SQUELCH）によって無効と識別されるコンテンツの修復要求を生成してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(SQUELCH) command is sent once per 2*GRTT at the most. The NORM_CMD(SQUELCH) advertises the current &#34;repair window&#34; of the sender by identifying the earliest (lowest) transmission point for which it will provide repair, along with an encoded list of objects from that point forward that are no longer valid for repair. This mechanism allows the sender application to cancel or abort transmission and/or repair of specific previously enqueued objects. The list also contains the identifiers for any objects within the repair window that were sent with the NORM_FLAG_UNRELIABLE flag set. In normal conditions, it is expected the NORM_CMD(SQUELCH) will be needed infrequently, and generally only to provide a reference repair window for receivers who have fallen &#34;out-of-sync&#34; with the sender due to extremely poor network conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（SQUELCH）コマンドは、最大で一回2 * GRTTごとに送信されます。 NORM_CMD（SQUELCH）は、もはや修復のために有効でないその時点からオブジェクトの符号化されたリストと共に、修理を提供する対象の最古の（最低の）送信点を識別することによって、送信者の現在の「修復ウィンドウ」をアドバタイズ。このメカニズムは、特定の以前にキューに入れられたオブジェクトの送信および/または修復をキャンセルするか、中止する送信側アプリケーションを可能にします。リストには、NORM_FLAG_UNRELIABLEフラグを設定して送信された修理・ウィンドウ内の任意のオブジェクトの識別子が含まれています。通常の状態では、NORM_CMD（SQUELCH）はまれにしか必要とされ、一般的にのみ起因する極めて悪いネットワーク条件に「非同期」の送信者と下落している受信機のための参照の修理窓を提供することが期待されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The starting point of the invalid NormObject list begins with the lowest invalid NormTransportId greater than the current &#34;repair window&#34; start from the invalid NACK(s) that prompted the generation of the squelch. The length of the list is limited by the sender&#39;s NormSegmentSize. This allows the receivers to learn the status of the sender&#39;s applicable object repair window with minimal transmission of NORM_CMD(SQUELCH) commands. The format of the NORM_CMD(SQUELCH) message is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
無効なNormObjectリストの出発点は、現在の「修理・ウィンドウ」スケルチの生成を促し、無効NACK（S）から開始より大きい最低無効NormTransportIdで始まります。リストの長さは、送信者のNormSegmentSizeによって制限されています。これは、受信機がNORM_CMD（SQUELCH）コマンドの最小限の送信と送信者の該当オブジェクトの修理ウィンドウの状態を知ることができます。 NORM_CMD（SQUELCH）メッセージの形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    version    |   type = 3    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  flavor = 3   |     fec_id    |      object_transport_id      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         fec_payload_id                        |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        invalid_object_list                    |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD(SQUELCH) Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（SQUELCH）メッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the NORM common message header and standard NORM_CMD fields, the NORM_CMD(SQUELCH) message contains fields to identify the earliest logical transmit position of the sender&#39;s current repair window and an &#34;invalid object list&#34; beginning with the index of the logically earliest invalid repair request from the offending NACK message which initiated the squelch transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM一般的なメッセージヘッダと標準NORM_CMDのフィールドに加えて、NORM_CMD（SQUELCH）メッセージが送信者の現在の修理・ウィンドウと「無効なオブジェクトリスト」の最古の論理的な送信位置を特定するためのフィールドが含まれて論理的に最も初期の無効の指標で始まりますスケルチ送信を開始し、問題のあるNACKメッセージからの修理依頼。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;object_transport_id&#34; and &#34;fec_payload_id&#34; fields are concatenated to indicate the beginning of the sender&#39;s current repair window (i.e., the logically earliest point in its transmission history for which the sender can provide repair). The &#34;fec_id&#34; field implies the size and format of the &#34;fec_payload_id&#34; field. This serves as an advertisement of a &#34;synchronization point&#34; for receivers to request repair. Note, that while an &#34;encoding_symbol_id&#34; may be included in the &#34;fec_payload_id&#34; field, the sender&#39;s repair window SHOULD be aligned on FEC coding block boundaries and thus the &#34;encoding_symbol_id&#34; SHOULD be zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「object_transport_id」と「fec_payload_id」フィールドは、送信者の現在の修理・ウィンドウ（送信者が修理を提供することができるために、その送信履歴で、すなわち、論理的に早い時点）の開始を示すために連結されています。 「fec_id」フィールドは、「fec_payload_id」フィールドのサイズと形式を意味します。これは、修理を要求する受信機のための「同期点」の広告として役立ちます。 「encoding_symbol_idは」「fec_payload_id」フィールドに含まれることができる一方で、送信者の修理ウィンドウがFEC符号化ブロック境界に配置する必要があることに注意してくださいので、「encoding_symbol_id」ゼロであるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;invalid_object_list&#34; is a list of 16-bit NormTransportIds that, although they are within the range of the sender&#39;s current repair window, are no longer available for repair from the sender. For example, a sender application may dequeue an out-of-date object even though it is still within the repair window. The total size of the &#34;invalid_object_list&#34; content is can be determined from the packet&#39;s payload length and is limited to a maximum of the NormSegmentSize of the sender. Thus, for very large repair windows, it is possible that a single NORM_CMD(SQUELCH) message may not be capable of listing the entire set of invalid objects in the repair window. In this case, the sender SHALL ensure that the list begins with a NormObjectId that is greater than or equal to the lowest ordinal invalid NormObjectId from the NACK message(s) that prompted the NORM_CMD(SQUELCH) generation. The NormObjectIds in the &#34;invalid_object_list&#34; MUST be greater than the &#34;object_transport_id&#34; marking the beginning of the sender&#39;s repair window. This insures convergence of the squelch process, even if multiple invalid NACK/ squelch iterations are required. This explicit description of invalid content within the sender&#39;s current window allows the sender application (most notably for discrete &#34;object&#34; based transport) to arbitrarily invalidate (i.e., dequeue) portions of enqueued content (e.g., certain objects) for which it no longer wishes to provide reliable transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「invalid_object_listは、」彼らは、送信者の現在の修理窓の範囲内にあるものの、もはや送信者からの修理のために利用可能な、16ビットNormTransportIdsのリストです。例えば、送信側アプリケーションは、それが修理・ウィンドウ内にあるにもかかわらず、期限切れのオブジェクトをデキューします。 「invalid_object_list」コンテンツの合計サイズは、パケットのペイロードの長さから決定することができるされ、送信者のNormSegmentSizeの最大値に制限されています。このように、非常に大規模な修復窓のため、単一NORM_CMD（SQUELCH）メッセージが修復ウィンドウに無効なオブジェクトのセット全体をリストすることができない可能性があります。この場合、送信者リストは以上NORM_CMD（SQUELCH）の生成を促しNACKメッセージ（単数または複数）から最低の順序無効NormObjectIdに等しいNormObjectId始まることを保証しなければなりません。 「invalid_object_list」のNormObjectIdsは、送信者の修理窓の始まりをマークする「object_transport_id」よりも大きくなければなりません。これは、複数の無効NACK /スケルチ反復が必要とされる場合でも、スケルチプロセスの収束を保証します。送信者の現在のウィンドウ内の無効なコンテンツのこの明示的な記述は、（特に離散「オブジェクト」のためのベースのトランスポート）送信側アプリケーション任意に無効にすることができます（つまり、デキュー）エンキューコンテンツ（例えば、特定のオブジェクト）の部分は、それはもはや要望について信頼性の高いトランスポートを提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.4. NORM_CMD(CC) Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.4。 NORM_CMD（CC）メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(CC) messages contains fields to enable sender-to-receiver group greatest round-trip time (GRTT) measurement and to excite the group for congestion control feedback. A baseline NORM congestion control scheme (NORM-CC), based on the TCP-Friendly Multicast Congestion Control (TFMCC) scheme of [19] is described in Section 5.5.2 of this document. The NORM_CMD(CC) message is usually transmitted as part of NORM-CC congestion control operation. A NORM header extension is defined below to be used with the NORM_CMD(CC) message to support NORM-CC operation. Different header extensions may be defined for the NORM_CMD(CC) (and/or other NORM messages as needed) to support alternative congestion control schemes in the future. If NORM is operated in a private network with congestion control operation disabled, the NORM_CMD(CC) message is then used for GRTT measurement only and may optionally be sent less frequently than with congestion control operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（CC）メッセージは、送信者・ツー・レシーバグループ最大のラウンドトリップ時間（GRTT）測定を可能にし、輻輳制御のフィードバックのためのグループを励起するためのフィールドが含まれています。 [19]のTCPフレンドリーマルチキャスト輻輳制御（TFMCC）方式に基づいて基準NORM輻輳制御方式（NORM-CC）は、このドキュメントのセクション5.5.2に記載されています。 NORM_CMD（CC）メッセージは、通常、NORM-CC輻輳制御動作の一部として送信されます。 NORMヘッダの拡張は、以下に定義されるNORM-CCの動作をサポートするNORM_CMD（CC）メッセージで使用します。異なるヘッダ拡張は、将来の代替的な輻輳制御方式をサポートするためにNORM_CMD（CC）（および/または必要に応じて他のNORMメッセージ）のために定義されてもよいです。 NORMが無効輻輳制御動作とプライベートネットワークで動作している場合、NORM_CMD（CC）メッセージのみGRTT測定のために使用され、必要に応じて輻輳制御動作よりも少ない頻度で送信されても​​よいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=3|    hdr_len    |            sequence           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   flavor = 4  |    reserved   |          cc_sequence          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         send_time_sec                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        send_time_usec                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               header extensions (if applicable)               |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  cc_node_list (if applicable)                 |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD(CC) Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（CC）メッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM common message header and standard NORM_CMD fields serve their usual purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM一般的なメッセージヘッダと標準NORM_CMDフィールドは通常の目的を果たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;reserved&#34; field is for potential future use and should be set to ZERO in this version of the NORM protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「予約」フィールドには、潜在的な将来の使用のためのもので、NORMプロトコルのこのバージョンでZEROに設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_sequence&#34; field is a sequence number applied by the sender. For NORM-CC operation, it is used to provide functionality equivalent to the &#34;feedback round number&#34; (fb_nr)described in [19]. The most recently received &#34;cc_sequence&#34; value is recorded by receivers and can be fed back to the sender in congestion control feedback generated by the receivers for that sender. The &#34;cc_sequence&#34; number can also be used in NORM implementations to assess how recently a receiver has received NORM_CMD(CC) probes from the sender. This can be useful instrumentation for complex or experimental multicast routing environments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_sequence」フィールドには、送信者によって適用されたシーケンス番号です。 NORM-CC動作のためには、「フィードバックラウンド数」[19]に記載の（fb_nr）と同等の機能を提供するために使用されます。最近受信した「cc_sequence」値は、受信機によって記録され、その送信者のための受信機によって生成された輻輳制御フィードバックに送信者に供給することができます。 「cc_sequence」数は、受信機が送信機からNORM_CMD（CC）プローブを受信したか、最近評価するNORM実装に使用することができます。これは、複雑なまたは実験マルチキャストルーティング環境に役立つ計測することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;send_time&#34; field is a timestamp indicating the time that the NORM_CMD(CC) message was transmitted. This consists of a 64-bit field containing 32-bits with the time in seconds (&#34;send_time_sec&#34;) and 32-bits with the time in microseconds (&#34;send_time_usec&#34;) since some reference time the source maintains (usually 00:00:00, 1 January 1970). The byte ordering of the fields is &#34;Big Endian&#34; network order. Receivers use this timestamp adjusted by the amount of delay from the time they received the NORM_CMD(CC) message to the time of their response as the &#34;grtt_response&#34; portion of NORM_ACK and NORM_NACK messages generated. This allows the sender to evaluate round-trip times to different receivers for congestion control and other (e.g., GRTT determination) purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「SEND_TIME」フィールドはNORM_CMD（CC）メッセージを送信した時間を示すタイムスタンプです。これは、ソースが保持いくつかの基準時間（通常00:00:00から秒単位の時間（「send_time_sec」）およびマイクロ秒の時間（「send_time_usec」）と32ビットと32ビットを含む64ビットのフィールドで構成されてい、1970年1月1日）。フィールドのバイト順序は、「ビッグエンディアン」ネットワーク順です。受信機は、それらがNORM_CMD（CC）メッセージを受信した時刻から生成NORM_ACKとNORM_NACKメッセージの「grtt_response」部分としてのそれらの応答の時間遅延の量によって調整このタイムスタンプを使用します。これは、送信者が輻輳制御と他の（例えば、GRTTの決意）目的のために異なる受信機へのラウンドトリップ時間を評価することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To facilitate the baseline NORM-CC scheme described in Section 5.5.2, a NORM-CC Rate header extension (EXT_RATE) is defined to inform the group of the sender&#39;s current transmission rate. This is used along with the loss detection &#34;sequence&#34; field of all NORM sender messages and the NORM_CMD(CC) GRTT collection process to support NORM-CC congestion control operation. The format of this header extension is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション5.5.2に記載基準NORM-CC方式を容易にするために、NORM-CCレートヘッダ拡張（EXT_RATE）は、送信者の現在の伝送速度のグループを知らせるために定義されています。これは、NORM-CC輻輳制御動作をサポートするために、すべてのNORMの送信者のメッセージとNORM_CMD（CC）GRTT収集プロセスのロス検出「シーケンス」フィールドと一緒に使用されています。次のようにこのヘッダー拡張の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    het = 128  |    reserved   |           send_rate           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM-CC Rate Header Extension Format (EXT_RATE)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM-CCレートヘッダー拡張フォーマット（EXT_RATE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;send_rate&#34; field indicates the sender&#39;s current transmission rate in bytes per second. The 16-bit &#34;send_rate&#34; field consists of 12 bits of mantissa in the most significant portion and 4 bits of base 10 exponent (order of magnitude) information in the least significant portion. The 12-bit mantissa portion of the field is scaled such that a floating point value of 0.0 corresponds to 0 and a floating point value of 10.0 corresponds to 4096. Thus:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「send_rate」フィールドには、秒あたりのバイト数で、送信者の現在の伝送速度を示しています。 16ビットの「send_rate」フィールドは、最も重要な部分で仮数の12ビットと最下位部分においてベース10指数（桁）の情報の4ビットから成ります。フィールドの12ビットの仮数部が0に0.0の浮動小数点値が一致するようにスケーリングされると10.0の浮動小数点値は、したがって4096に対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
send_rate = (((int)(Value_mantissa * 4096.0 / 10.0 + 0.5)) &lt;&lt; 4) | Value_exponent;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
send_rate =（（（INT）（Value_mantissa * 4096.0 / 10.0 + 0.5））&lt;&lt; 4）| Value_exponent;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For example, to represent a transmission rate of 256kbps (3.2e+04 bytes per second), the lower 4 bits of the 16-bit field contain a value of 0x04 to represent the exponent while the upper 12 bits contain a value of 0x51f as determined from the equation given above:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上位12ビットとして0x51fの値を含むながら、例えば、256kbps（毎秒3.2E + 04バイト）の伝送速度を表すために、16ビットのフィールドの下位4ビットは、指数を表すように0x04の値を含みます上記の式から決定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
send_rate = (((int)((3.2 * 4096.0 / 10.0) + 0.5)) &lt;&lt; 4) | 4;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
send_rate =（（（INT）（（3.2 * 4096.0 / 10.0）+ 0.5））&lt;&lt; 4）| 4;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
= (0x51f &lt;&lt; 4) | 0x4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
=（0x51f &lt;&lt; 4）| 0x4の
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
= 0x51f4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
= 0x51f4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To decode the &#34;send_rate&#34; field, the following equation can be used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「send_rate」フィールドをデコードするには、次の式を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
value = (send_rate &gt;&gt; 4) * 10.0 / 4096.0 * power(10.0, (send_rate &amp; x000f))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
値=（send_rate &gt;&gt; 4）* 10.0 / 4096.0 *パワー（10.0、（send_rate＆x000f））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note the maximum transmission rate that can be represented by this scheme is approximately 9.99e+15 bytes per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このスキームで表すことができる最大の伝送速度は、毎秒約9.99e + 15バイトであることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this extension is present, a &#34;cc_node_list&#34; may be attached as the payload of the NORM_CMD(CC) message. The presence of this header extension also implies that NORM receivers should respond according to the procedures described in Section 5.5.2. The &#34;cc_node_list&#34; consists of a list of NormNodeIds and their associated congestion control status. This includes the current limiting receiver (CLR) node, any potential limiting receiver (PLR) nodes that have been identified, and some number of receivers for which congestion control status is being provided, most notably including the receivers&#39; current RTT measurement. The maximum length of the &#34;cc_node_list&#34; provides for at least the CLR and one other receiver, but may be configurable for more timely feedback to the group. The list length can be inferred from the length of the NORM_CMD(CC) message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この拡張が存在する場合、「cc_node_list」はNORM_CMD（CC）メッセージのペイロードとして取り付けられてもよいです。このヘッダー拡張の存在はまた、NORM受信機は、セクション5.5.2に記載の手順に従って応答すべきであることを意味します。 「cc_node_listは」NormNodeIdsとそれに関連する輻輳制御状態のリストで構成されます。これは、電流制限レシーバ（CLR）ノード、同定された潜在的な限定受信（PLR）ノード、および輻輳制御状態が最も顕著に受信者の現在のRTTの測定を含む、提供されている受信機のいくつかの数を含みます。 「cc_node_list」の最大長さは、少なくともCLRとつの他の受信機を提供するが、グループへのよりタイムリーなフィードバックのための構成であってもよいです。リストの長さはNORM_CMD（CC）メッセージの長さから推測することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each item in the &#34;cc_node_list&#34; is in the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_node_list」の各項目は、次の形式になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          cc_node_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    cc_flags   |     cc_rtt    |            cc_rate            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Congestion Control Node List Item Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳制御ノードリストアイテムのフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_node_id&#34; is the NormNodeId of the receiver which the item represents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_node_id」はアイテムが表す受信機のNormNodeIdあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_flags&#34; field contains flags indicating the congestion control status of the indicated receiver. The following flags are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_flags」フィールドは、指定受信機の輻輳制御状態を示すフラグを含みます。次のフラグが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
+------------------+-------+------------------------------------------+
|      Flag        | Value |                 Purpose                  |
+------------------+-------+------------------------------------------+
|NORM_FLAG_CC_CLR  | 0x01  | Receiver is the current limiting         |
|                  |       | receiver (CLR).                          |
+------------------+-------+------------------------------------------+
|NORM_FLAG_CC_PLR  | 0x02  | Receiver is a potential limiting         |
|                  |       | receiver (PLR).                          |
+------------------+-------+------------------------------------------+
|NORM_FLAG_CC_RTT  | 0x04  | Receiver has measured RTT with respect   |
|                  |       | to sender.                               |
+------------------+-------+------------------------------------------+
|NORM_FLAG_CC_START| 0x08  | Sender/receiver is in &#34;slow start&#34; phase |
|                  |       | of congestion control operation (i.e.,   |
|                  |       | The receiver has not yet detected any    |
|                  |       | packet loss and the &#34;cc_rate&#34; field is   |
|                  |       | the receiver&#39;s actual measured receive   |
|                  |       | rate).                                   |
+------------------+-------+------------------------------------------+
|NORM_FLAG_CC_LEAVE| 0x10  | Receiver is imminently leaving the       |
|                  |       | session and its feedback should not be   |
|                  |       | considered in congestion control         |
|                  |       | operation.                               |
+------------------+-------+------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_rtt&#34; contains a quantized representation of the RTT as measured by the sender with respect to the indicated receiver. This field is valid only if the NORM_FLAG_CC_RTT flag is set in the &#34;cc_flags&#34; field. This one byte field is a quantized representation of the RTT using the algorithm described in the NORM Building Block document [4]. The &#34;cc_rate&#34; field contains a representation of the receiver&#39;s current calculated (during steady-state congestion control operation) or twice its measured (during the &#34;slow start&#34; phase) congestion control rate. This field is encoded and decoded using the same technique as described for the NORM_CMD(CC) &#34;send_rate&#34; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_rtt」が示され、受信機に対して送信者によって測定されたRTTの量子化された表現を含みます。このフィールドはNORM_FLAG_CC_RTTフラグが「cc_flags」フィールドに設定されている場合にのみ有効です。この1つのバイトのフィールドは、NORMビルディングブロック文献[4]に記載のアルゴリズムを用いてRTTの量子化された表現です。 「cc_rate」フィールドは（定常状態の輻輳制御動作時）受信機の現在の計算の表現を含むか、2倍の輻輳制御率（「スロースタート」フェーズ中に）測定しました。このフィールドは、符号化及びNORM_CMD（CC）「send_rate」フィールドについて記載したのと同じ技術を使用して復号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.5. NORM_CMD(REPAIR_ADV) Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.5。 NORM_CMD（REPAIR_ADV）メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(REPAIR_ADV) message is used by the sender to &#34;advertise&#34; its aggregated repair state from NORM_NACK messages accumulated during a repair cycle and/or congestion control feedback received. This message is sent only when the sender has received NORM_NACK and/or NORM_ACK(CC) (when congestion control is enabled) messages via unicast transmission instead of multicast. By &#34;echoing&#34; this information to the receiver set, suppression of feedback can be achieved even when receivers are unicasting that feedback instead of multicasting it among the group [13].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（REPAIR_ADV）メッセージが受信された修理サイクル及び/又は輻輳制御フィードバック中に蓄積NORM_NACKメッセージからその凝集修復状態を「宣伝」するために、送信者によって使用されます。このメッセージは、送信者が（輻輳制御が有効になっている）NORM_NACK及び/又はNORM_ACK（CC）ユニキャスト伝送の代わりに、マルチキャストを介してメッセージを受信した場合にのみ送信されます。受信機セットに、この情報を「エコー」によって、フィードバックの抑制は、受信機は、そのフィードバックをユニキャストの代わりにグループ[13]のうち、それをマルチキャストする場合であっても達成することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=3|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  flavor = 5   |     flags     |            reserved           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               header extensions (if applicable)               |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       repair_adv_payload                      |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD(REPAIR_ADV) Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（REPAIR_ADV）メッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;instance_id&#34;, &#34;grtt&#34;, &#34;backoff&#34;, &#34;gsize&#34;, and &#34;flavor&#34; fields serve the same purpose as in other NORM_CMD messages. The value of the &#34;hdr_len&#34; field when no extensions are present is 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「INSTANCE_ID」、「GRTT」、「バックオフ」、「GSIZE」、及び「香り」のフィールドは、他のNORM_CMDのメッセージと同じ目的を果たします。何の拡張子が存在しない「hdr_len」フィールドの値は4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;flags&#34; field provide information on the NORM_CMD(REPAIR_ADV) content. There is currently one NORM_CMD(REPAIR_ADV) flag defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「フラグ」フィールドはNORM_CMD（REPAIR_ADV）コンテンツに関する情報を提供します。定義された1 NORM_CMD（REPAIR_ADV）フラグは現在あり：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_REPAIR_ADV_FLAG_LIMIT = 0x01
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_REPAIR_ADV_FLAG_LIMIT = 0x01の
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This flag is set by the sender when it is unable to fit its full current repair state into a single NormSegmentSize. If this flag is set, receivers should limit their NACK response to generating NACK content only up through the maximum ordinal transmission position (objectId::fecPayloadId) included in the &#34;repair_adv_content&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
単一のNormSegmentSizeにその最大電流修理の状態に合わせてすることができないときに、このフラグは送信者によって設定されます。このフラグが設定されている場合、受信機は、最大順序送信位置（OBJECTID :: fecPayloadId）を介してのみアップNACKコンテンツを生成に対するNACK応答を制限すべきである「repair_adv_content」に含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When congestion control operation is enabled, a header extension may be applied to the NORM_CMD(REPAIR_ADV) representing the most limiting (in terms of congestion control feedback suppression) congestion control response. This allows the NORM_CMD(REPAIR_ADV) message to suppress receiver congestion control responses as well as NACK feedback messages. The field is defined as a header extension so that alternative congestion control schemes may be used with NORM without revision to this document. A NORM-CC Feedback Header Extension (EXT_CC) is defined to encapsulate congestion control feedback within NORM_NACK, NORM_ACK, and NORM_CMD(REPAIR_ADV) messages. If another congestion control technique (e.g., Pragmatic General Multicast Congestion Control (PGMCC) [20]) is used within a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳制御動作がイネーブルされると、ヘッダ拡張は、輻輳制御応答（輻輳制御フィードバック抑制の点で）最も制限を表すNORM_CMD（REPAIR_ADV）に適用してもよいです。これはNORM_CMD（REPAIR_ADV）メッセージが受信輻輳制御応答ならびにNACKフィードバックメッセージを抑制することを可能にします。代替的な輻輳制御方式は、この文書の改訂することなく、NORMで使用することができるように、フィールドは、ヘッダ拡張として定義されます。 NORM-CCフィードバックヘッダ拡張（EXT_CC）はNORM_NACK、NORM_ACK、及びNORM_CMD（REPAIR_ADV）メッセージ内の輻輳制御フィードバックをカプセル化するために定義されています。別の輻輳制御技術（例えば、実用的な一般的なマルチキャスト輻輳制御（PGMCC）[20]）内で使用される場合
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM implementation, an additional header extension MAY need to be defined to encapsulate any required feedback content. The NORM-CC Feedback Header Extension format is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMの実装では、追加のヘッダ拡張子は、任意の必要なフィードバックのコンテンツをカプセル化するために定義される必要があるかもしれません。 NORM-CCフィードバックヘッダーの拡張形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     het = 3   |    hel = 3    |          cc_sequence          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    cc_flags   |     cc_rtt    |            cc_loss            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            cc_rate            |          cc_reserved          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM-CC Feedback Header Extension (EXT_CC) Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM-CCフィードバックヘッダー拡張（EXT_CC）フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_sequence&#34; field contains the current greatest &#34;cc_sequence&#34; value receivers have received in NORM_CMD(CC) messages from the sender. This information assists the sender in congestion control operation by providing an indicator of how current (&#34;fresh&#34;) the receiver&#39;s round-trip measurement reference time is and whether the receiver has been successfully receiving recent congestion control probes. For example, if it is apparent the receiver has not been receiving recent congestion control probes (and thus possibly other messages from the sender), the sender may choose to take congestion avoidance measures. For NORM_CMD(REPAIR_ADV) messages, the sender SHALL set the &#34;cc_sequence&#34; field value to the value set in the last NORM_CMD(CC) message sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_sequence」フィールドには、現在の最大の「cc_sequence」値の受信機はNORM_CMD（CC）送信者からのメッセージで受信しているが含まれています。この情報は、受信側の往復の測定基準時間がどのように現在の（「フレッシュ」）の指標を提供することにより、及び受信機が正常に最近の輻輳制御プローブを受信したかどうかを輻輳制御動作中に、送信者を支援します。それが明らかである場合、例えば、受信機は（したがって、送信者からおそらく他のメッセージ）最近輻輳制御プローブを受信して​​おらず、送信側は、輻輳回避措置をとることを選択することができます。 NORM_CMD（REPAIR_ADV）メッセージの場合、送信者は送信され、最後のNORM_CMD（CC）メッセージに設定された値に「cc_sequence」フィールドの値を設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_flags&#34; field contains bits representing the receiver&#39;s state with respect to congestion control operation. The possible values for the &#34;cc_flags&#34; field are those specified for the NORM_CMD(CC) message node list item flags. These fields are used by receivers in controlling (suppressing as necessary) their congestion control feedback. For NORM_CMD(REPAIR_ADV) messages, the NORM_FLAG_CC_RTT should be set only when all feedback messages received by the sender have the flag set. Similarly, the NORM_FLAG_CC_CLR or NORM_FLAG_CC_PLR should be set only when no feedback has been received from non-CLR or non-PLR receivers. And the NORM_FLAG_CC_LEAVE should be set only when all feedback messages the sender has received have this flag set. These heuristics for setting the flags in NORM_CMD(REPAIR_ADV) ensure the most effective suppression of receivers providing unicast feedback messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_flags」フィールドは、輻輳制御動作に関して受信機の状態を表すビットを含みます。 「cc_flags」フィールドに指定可能な値はNORM_CMD（CC）メッセージノードリストアイテムフラグに指定されたものです。これらのフィールドを制御する際に受信機によって使用されるそれらの輻輳制御フィードバックを（必要に応じて抑制）。 NORM_CMD（REPAIR_ADV）メッセージの場合、NORM_FLAG_CC_RTTは、送信者が受信したすべてのフィードバックメッセージはフラグが設定されているときにのみ設定する必要があります。同様に、NORM_FLAG_CC_CLRまたはNORM_FLAG_CC_PLRにはフィードバックが非CLRまたは非PLR受信機から受信されていない場合にのみ設定されるべきです。そしてNORM_FLAG_CC_LEAVEは、送信者が受信したすべてのフィードバックメッセージは、このフラグが設定されているときにのみ設定する必要があります。 NORM_CMD（REPAIR_ADV）のフラグを設定するためのこれらの経験則は、ユニキャストフィードバックメッセージを提供する受信機の最も効果的な抑制を確保します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_rtt&#34; field SHALL be set to a default maximum value and the NORM_FLAG_CC_RTT flag SHALL be cleared when no receiver has yet received RTT measurement information. When a receiver has received RTT measurement information, it shall set the &#34;cc_rtt&#34; value accordingly and set the NORM_FLAG_CC_RTT flag in the &#34;cc_flags&#34; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_rtt」フィールドは、デフォルトの最大値に設定されるものと全く受信機がまだRTT測定情報を受信しなかった場合NORM_FLAG_CC_RTTフラグがクリアされSHALL。受信機は、RTT測定情報を受信したとき、それに応じて「cc_rtt」の値を設定し、「cc_flags」フィールドにNORM_FLAG_CC_RTTフラグを設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For NORM_CMD(REPAIR_ADV) messages, the sender SHALL set the &#34;cc_rtt&#34; field value to the largest non-CLR/non-PLR RTT it has measured from receivers for the current feedback round.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（REPAIR_ADV）メッセージの場合、送信者は、それが現在のフィードバックのラウンドのための受信機から測定した最大の非CLR /非PLR RTTに「cc_rtt」フィールドの値を設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_loss&#34; field represents the receiver&#39;s current packet loss fraction estimate for the indicated source. The loss fraction is a value from 0.0 to 1.0 corresponding to a range of zero to 100 percent packet loss. The 16-bit &#34;cc_loss&#34; value is calculated by the following formula:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_loss」フィールドは、示されたソースのための受信機の現在のパケット損失分率推定値を表します。損失分率はゼロから100％のパケット損失の範囲に対応する0.0から1.0までの値です。 16ビットの「cc_loss」値は、以下の式で計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;cc_loss&#34; = decimal_loss_fraction * 65535.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;cc_loss&#34; = decimal_loss_fraction * 65535.0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For NORM_CMD(REPAIR_ADV) messages, the sender SHALL set the &#34;cc_loss&#34; field value to the largest non-CLR/non-PLR loss estimate it has received from receivers for the current feedback round.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（REPAIR_ADV）メッセージの場合、送信者は、それが現在のフィードバックのラウンドのための受信機から受信した最大の非CLR /非PLR損失推定値に「cc_loss」フィールドの値を設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_rate&#34; field represents the receivers current local congestion control rate. During &#34;slow start&#34;, when the receiver has detected no loss, this value is set to twice the actual rate it has measured from the corresponding sender and the NORM_FLAG_CC_START is set in the &#34;cc_flags&#39; field. Otherwise, the receiver calculates a congestion control rate based on its loss measurement and RTT measurement information (even if default) for the &#34;cc_rate&#34; field. For NORM_CMD(REPAIR_ADV) messages, the sender SHALL set the &#34;cc_loss&#34; field value to the lowest non-CLR/non-PLR &#34;cc_rate&#34; report it has received from receivers for the current feedback round.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_rate」フィールドには、受信機の現在のローカル輻輳制御率を表しています。 「スロースタート」の間、受信機は損失を検出しなかった場合、この値は、それが、対応する送信者から測定している二倍実際の速度に設定され、NORM_FLAG_CC_STARTが「cc_flags&#39;フィールドに設定される。そうでない場合、受信機は、輻輳制御を演算します「cc_rate」フィールドにその損失測定とRTT計測情報（でも、デフォルトの場合）に基づいてレート。NORM_CMD（REPAIR_ADV）メッセージについては、送信者が「最低非CLR /非PLRに「cc_loss」フィールドの値を設定するものとしそれは現在のフィードバックのラウンドのための受信機から受信したcc_rate」レポート。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_reserved&#34; field is reserved for future NORM protocol use. Currently, senders SHALL set this field to ZERO, and receivers SHALL ignore the content of this field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_reserved」フィールドは、将来NORMプロトコルの使用のために予約されています。現在、送信者がこの欄に0を設定するものとし、受信機は、このフィールドの内容を無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;repair_adv_payload&#34; is in exactly the same form as the &#34;nack_content&#34; of NORM_NACK messages and can be processed by receivers for suppression purposes in the same manner, with the exception of the condition when the NORM_REPAIR_ADV_FLAG_LIMIT is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「repair_adv_payload」はNORM_NACKメッセージの「nack_content」と全く同じ形であり、NORM_REPAIR_ADV_FLAG_LIMITが設定された条件を除いて、同じ方法で抑制のために受信機によって処理することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.6. NORM_CMD(ACK_REQ) Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.6。 NORM_CMD（ACK_REQ）メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(ACK_REQ) message is used by the sender to request acknowledgment from a specified list of receivers. This message is used in providing a lightweight positive acknowledgment mechanism that is OPTIONAL for use by the reliable multicast application. A range of acknowledgment request types is provided for use at the application&#39;s discretion. Provision for application-defined, positively-acknowledged commands allows the application to automatically take advantage of transmission and round-trip timing information available to the NORM protocol. The details of the NORM positive acknowledgment process including transmission of the NORM_CMD(ACK_REQ) messages and the receiver response (NORM_ACK) are described in Section 5.5.3. The format of the NORM_CMD(ACK_REQ) message is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（ACK_REQ）メッセージが受信機の指定されたリストからの確認を要求するために送信者によって使用されます。このメッセージは、信頼性の高いマルチキャストアプリケーションで使用するためのオプションである軽量の肯定応答メカニズムを提供する際に使用されます。承認要求タイプの範囲は、アプリケーションの裁量で使用するために提供されています。アプリケーションで定義された、正に認めコマンド引当金は、アプリケーションが自動的に送信、NORMプロトコルが利用できる往復のタイミング情報を利用することができます。 NORM_CMD（ACK_REQ）メッセージの送信及び受信応答（NORM_ACK）を含むNORM肯定応答処理の詳細については、セクション5.5.3に記載されています。 NORM_CMD（ACK_REQ）メッセージの形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=3|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  flavor = 6   |    reserved   |    ack_type   |    ack_id     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       acking_node_list                        |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD(ACK_REQ) Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（ACK_REQ）メッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM common message header and standard NORM_CMD fields serve their usual purposes. The value of the &#34;hdr_len&#34; field for NORM_CMD(ACK_REQ) messages with no header extension present is 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM一般的なメッセージヘッダと標準NORM_CMDフィールドは通常の目的を果たします。無ヘッダ拡張存在とNORM_CMD（ACK_REQ）メッセージのための「hdr_len」フィールドの値は4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;ack_type&#34; field indicates the type of acknowledgment being requested and thus implies rules for how the receiver will treat this request. The following &#34;ack_type&#34; values are defined and are also used in NORM_ACK messages described later:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ack_type」フィールドには、要求されている承認のタイプを示し、したがって、受信機は、この要求を処理する方法のための規則を意味します。以下「ack_type」の値が定義され、また、後述するNORM_ACKメッセージで使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
+---------------------+--------+---------------------------------+
|      ACK Type       | Value  |            Purpose              |
+---------------------+--------+---------------------------------+
|NORM_ACK_CC          |      1 | Used to identify NORM_ACK       |
|                     |        | messages sent in response to    |
|                     |        | NORM_CMD(CC) messages.          |
+---------------------+--------+---------------------------------+
|NORM_ACK_FLUSH       |      2 | Used to identify NORM_ACK       |
|                     |        | messages sent in response to    |
|                     |        | NORM_CMD(FLUSH) messages.       |
+---------------------+--------+---------------------------------+
|NORM_ACK_RESERVED    |   3-15 | Reserved for possible future    |
|                     |        | NORM protocol use.              |
+---------------------+--------+---------------------------------+
|NORM_ACK_APPLICATION | 16-255 | Used at application&#39;s           |
|                     |        | discretion.                     |
+---------------------+--------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_ACK_CC value is provided for use only in NORM_ACKs generated in response to the NORM_CMD(CC) messages used in congestion control operation. Similarly, the NORM_ACK_FLUSH is provided for use only in NORM_ACKs generated in response to applicable NORM_CMD(FLUSH) messages. NORM_CMD(ACK_REQ) messages with &#34;ack_type&#34; of NORM_ACK_CC or NORM_ACK_FLUSH SHALL NOT be generated by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_ACK_CC値のみ輻輳制御動作で使用NORM_CMD（CC）メッセージに応答して生成NORM_ACKsに使用するために設けられています。同様に、NORM_ACK_FLUSHのみ適用NORM_CMD（FLUSH）メッセージに応答して生成NORM_ACKsに使用するために設けられています。 NORM_ACK_CCまたはNORM_ACK_FLUSHの「ack_type」とNORM_CMD（ACK_REQ）メッセージが送信者によって生成されないものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_ACK_RESERVED range of &#34;ack_type&#34; values is provided for possible future NORM protocol use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ack_type」値のNORM_ACK_RESERVED範囲は将来NORMプロトコルの使用のために提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_ACK_APPLICATION range of &#34;ack_type&#34; values is provided so that NORM applications may implement application-defined, positively-acknowledged commands that are able to leverage internal transmission and round-trip timing information available to the NORM protocol implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
そのNORMアプリケーションは内部伝送及びNORMプロトコルの実装に利用可能なタイミング情報を往復を活用することができるアプリケーション定義、正肯定応答コマンドを実装することができるように、「ack_type」値のNORM_ACK_APPLICATION範囲が提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;ack_id&#34; provides a sequenced identifier for the given NORM_CMD(ACK_REQ) message. This &#34;ack_id&#34; is returned in NORM_ACK messages generated by the receivers so that the sender may associate the response with its corresponding request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ack_id」は、所与NORM_CMD（ACK_REQ）メッセージのための配列決定の識別子を提供します。この「ack_idは、」送信者がその対応する要求と応答を関連付けることができるように、受信機によって生成されたNORM_ACKメッセージで返されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;reserved&#34; field is reserved for possible future protocol use and SHALL be set to ZERO by senders and ignored by receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「予約」フィールドは、将来のプロトコルの使用のために予約されており、送信者によってゼロに設定され、受信機によって無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;acking_node_list&#34; field contains the NormNodeIds of the current NORM receivers that are desired to provide positive acknowledge (NORM_ACK) to this request. The packet payload length implies the length of the &#34;acking_node_list&#34; and its length is limited to the sender NormSegmentSize. The individual NormNodeId items are listed in network (Big Endian) byte order. If a receiver&#39;s NormNodeId is included in the &#34;acking_node_list&#34;, it SHALL schedule transmission of a NORM_ACK message as described in Section 5.5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「acking_node_list」フィールドには、この要求に（NORM_ACKを）認めるポジティブ提供することが望まれている現在のNORM受信機のNormNodeIdsが含まれています。パケットペイロード長は「acking_node_list」の長さを意味し、その長さは、送信者NormSegmentSizeに制限されています。個々NormNodeId項目は、ネットワーク（ビッグエンディアン）のバイト順にリストされています。受信機のNormNodeIdが「acking_node_list」に含まれている場合、セクション5.5.3に記載したように、それはNORM_ACKメッセージの送信をスケジュールSHALL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.7. NORM_CMD(APPLICATION) Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3.7。 NORM_CMD（APPLICATION）メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This command allows the NORM application to robustly transmit application-defined commands. The command message preempts any ongoing data transmission and is repeated up to NORM_ROBUST_FACTOR times at a rate of once per 2*GRTT. This rate of repetition allows the application to observe any response (if that is the application&#39;s purpose for the command) before it is repeated. Possible responses may include initiation of data transmission, other NORM_CMD(APPLICATION) messages, or even application-defined, positively-acknowledge commands from other NormSession participants. The transmission of these commands will preempt data transmission when they are scheduled and may be multiplexed with ongoing data transmission. This type of robustly transmitted command allows NORM applications to define a complete set of session control mechanisms with less state than the transfer of FEC encoded reliable content requires while taking advantage of NORM transmission and round-trip timing information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このコマンドはNORMアプリケーションが確実にアプリケーション定義コマンドを送信することができます。コマンドメッセージは、進行中のデータ送信を先取りし、GRTT *一度2あたりの割合でNORM_ROBUST_FACTOR回まで繰り返されます。繰り返しのこの割合は、（そのコマンドのために、アプリケーションの目的であるならば）、それが繰り返される前に、アプリケーションが応答を観察することができます。可能な応答は、他のNormSession参加者からのコマンドを正確認、データ伝送、他のNORM_CMD（アプリケーション）メッセージ、あるいはアプリケーション定義の開始を含むことができます。それらが予定されていると継続的なデータ伝送を多重化することができるとき、これらのコマンドの送信は、データ送信を先取りします。ロバストに送信されたコマンドのこのタイプは、NORMアプリケーションがNORM送信及び往復タイミング情報を活用しながら、FECの転送が信頼性の高いコンテンツを必要と符号化されたよりも少ない状態でセッション制御メカニズムの完全なセットを定義することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=3|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          instance_id          |     grtt      |backoff| gsize |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  flavor = 7   |                    reserved                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Application-Defined Content                 |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD(APPLICATION) Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（APPLICATION）メッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM common message header and NORM_CMD fields are interpreted as previously described. The value of the NORM_CMD(APPLICATION) &#34;hdr_len&#34; field when no header extensions are present is 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM共通メッセージヘッダとNORM_CMDフィールドは、前述のように解釈されます。全くヘッダ拡張が存在しないNORM_CMD（アプリケーション）「hdr_len」フィールドの値は4です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;Application-Defined Content&#34; area contains information in a format at the discretion of the application. The size of this payload SHALL be limited to a maximum of the sender&#39;s NormSegmentSize setting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「アプリケーション定義の内容」エリアには、アプリケーションの裁量形式で情報が含まれています。このペイロードのサイズは、送信者のNormSegmentSize設定の最大値に限定されるものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Receiver Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3。レシーバメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM message types generated by participating receivers consist of NORM_NACK and NORM_ACK message types. NORM_NACK messages are sent to request repair of missing data content from sender transmission and NORM_ACK messages are generated in response to certain sender commands including NORM_CMD(CC) and NORM_CMD(ACK_REQ).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
参加する受信機によって生成されたNORMメッセージタイプはNORM_NACKとNORM_ACKメッセージタイプから成ります。 NORM_NACKメッセージは、送信者の送信から欠落データコンテンツの修復を要求するために送信され、NORM_ACKメッセージはNORM_CMD（CC）及びNORM_CMD（ACK_REQ）を含む特定の送信者コマンドに応答して生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. NORM_NACK Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1。 NORM_NACKメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The principal purpose of NORM_NACK messages is for receivers to request repair of sender content via selective, negative acknowledgment upon detection of incomplete data. NORM_NACK messages will be transmitted according to the rules of NORM_NACK generation and suppression described in Section 5.3. NORM_NACK messages also contain additional fields to provide feedback to the sender(s) for purposes of round-trip timing collection and congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機が、不完全なデータの検出時に選択的、否定応答を介して送信元コンテンツの修復を要求するためNORM_NACKメッセージの主な目的です。 NORM_NACKメッセージは、セクション5.3で説明NORM_NACK生成および抑制のルールに従って送信されます。 NORM_NACKメッセージも往復のタイミング収集と輻輳制御の目的のために、送信者（複数可）にフィードバックを提供するために追加のフィールドが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The payload of NORM_NACK messages contains one or more repair requests for different objects or portions of those objects. The NORM_NACK message format is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_NACKメッセージのペイロードは、異なるオブジェクトまたはこれらのオブジェクトの部分のための1つまたは複数の修理依頼が含まれています。次のようにNORM_NACKメッセージフォーマットは次のとおり
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=4|    hdr_len    |            sequence           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           server_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           instance_id         |            reserved           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       grtt_response_sec                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       grtt_response_usec                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               header extensions (if applicable)               |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          nack_payload                         |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_NACK Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_NACKメッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM common message header fields serve their usual purposes. The value of the &#34;hdr_len&#34; field for NORM_NACK messages without header extensions present is 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM一般的なメッセージヘッダーフィールドは通常の目的を果たします。本ヘッダ拡張せずNORM_NACKメッセージの「hdr_len」フィールドの値は6です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;server_id&#34; field identifies the NORM sender to which the NORM_NACK message is destined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「SERVER_ID」フィールドには、NORM_NACKメッセージが宛先であるNORMの送信者を特定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;instance_id&#34; field contains the current session identifier given by the sender identified by the &#34;server_id&#34; field in its sender messages. The sender SHOULD ignore feedback messages which contain an invalid &#34;instance_id&#34; value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「INSTANCE_ID」フィールドは、その送信者のメッセージに「SERVER_ID」フィールドで識別される送信者によって与えられた現在のセッション識別子が含まれています。送信者は無効「INSTANCE_ID」値が含まれているフィードバックメッセージを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;grtt_response&#34; fields contain an adjusted version of the timestamp from the most recently received NORM_CMD(CC) message for the indicated NORM sender. The format of the &#34;grtt_response&#34; is the same as the &#34;send_time&#34; field of the NORM_CMD(CC). The &#34;grtt_response&#34; value is _relative_ to the &#34;send_time&#34; the source provided with a corresponding NORM_CMD(CC) command. The receiver adjusts the source&#39;s NORM_CMD(CC) &#34;send_time&#34; timestamp by adding the time differential from when the receiver received the NORM_CMD(CC) to when the NORM_NACK is transmitted to calculate the value in the &#34;grtt_response&#34; field. This is the &#34;receive_to_response_differential&#34; value used in the following formula:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「grtt_response」フィールドが指示されたNORM送信者のための最も最近受け取っNORM_CMD（CC）メッセージからタイムスタンプの調整バージョンが含まれています。 「grtt_response」のフォーマットはNORM_CMD（CC）の「SEND_TIME」フィールドと同じです。 「grtt_response」値は「SEND_TIME」対応NORM_CMD（CC）コマンドで提供されたソースに_relative_あります。受信機は、受信機がNORM_NACKが「grtt_response」フィールドの値を計算するために送信される場合にNORM_CMD（CC）を受信したときからの時間差を加算することによりソースのNORM_CMD（CC）「SEND_TIME」のタイムスタンプを調整します。これは、次の式で使用される「receive_to_response_differential」値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;grtt_response&#34; = NORM_CMD(CC) &#34;send_time&#34; + receive_to_response_differential
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;grtt_response&#34; = NORM_CMD（CC） &#34;SEND_TIME&#34; + receive_to_response_differential
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The receiver SHALL set the &#34;grtt_response&#34; to a ZERO value, to indicate that it has not yet received a NORM_CMD(CC) message from the indicated sender and that the sender should ignore the &#34;grtt_response&#34; in this message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機は、それがまだ示さ送信者から送信者がこのメッセージで「grtt_response」を無視するべきであることをNORM_CMD（CC）メッセージを受信して​​いないことを示すために、ゼロ値に「grtt_response」を設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For NORM-CC operation, the NORM-CC Feedback Header Extension, as described in the NORM_CMD(REPAIR_ADV} message description, is added to NORM_NACK messages to provide feedback on the receivers current state with respect to congestion control operation. Note that alternative header extensions for congestion control feedback may be defined for alternative congestion control schemes for NORM use in the future.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM-CC動作、NORM-CCフィードバックヘッダ拡張のため、NORM_CMD（REPAIR_ADV}メッセージの説明に記載されているように、輻輳制御動作に対する受信現在の状態に関するフィードバックを提供するために、メッセージをNORM_NACKするために添加される。メモ代替ヘッダ拡張その輻輳制御のためのフィードバックは、将来におけるNORMの使用のための別の輻輳制御方式のために定義されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;reserved&#34; field is for potential future NORM use and SHALL be set to ZERO for this version of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「予約」フィールドには、潜在的な将来のNORMの使用のためのものであり、プロトコルのこのバージョンのためにゼロに設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;nack_content&#34; of the NORM_NACK message specifies the repair needs of the receiver with respect to the NORM sender indicated by the &#34;server_id&#34; field. The receiver constructs repair requests based on the NORM_DATA and/or NORM_INFO segments it requires from the sender in order to complete reliable reception up to the sender&#39;s transmission position at the moment the receiver initiates the NACK Procedure as described in Section 5.3. A single NORM Repair Request consists of a list of items, ranges, and/or FEC coding block erasure counts for needed NORM_DATA and/or NORM_INFO content. Multiple repair requests may be concatenated within the &#34;nack_payload&#34; field of a NORM_NACK message. Note that a single NORM Repair Request can possibly include multiple &#34;items&#34;, &#34;ranges&#34;, or &#34;erasure_counts&#34;. In turn, the &#34;nack_payload&#34; field may contain multiple repair requests. A single NORM Repair Request has the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「nack_content」NORM_NACKのメッセージは、「SERVER_ID」フィールドによって示さNORM送信者に対して、受信機の修理の必要性を指定します。受信機は、第5.3節で説明したように、受信機がNACK手順を開始する瞬間に、送信者の送信位置への確実な受信アップを完了するためにNORM_DATA及び/又はそれが送信者から必要NORM_INFOセグメントに基づいて、修復要求を構築します。単一NORMの修理依頼は、項目のリストで構成範囲、および/またはFEC符号化ブロックの消去が必要NORM_DATAおよび/またはNORM_INFOコンテンツにカウントされます。複数修復要求がNORM_NACKメッセージの「nack_payload」フィールド内に連結することができます。単一NORM修理要求はおそらく複数の「商品」、「範囲」、または「erasure_counts」を含むことができることに留意されたいです。ターンでは、「nack_payload」フィールドには、複数の修理依頼が含まれていてもよいです。単一NORMの修理依頼の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      form     |     flags     |             length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      repair_request_items                     |
   |                             ...                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM Repair Request Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM修理依頼フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;form&#34; field indicates the type of repair request items given in the &#34;repair_request_items&#34; list. Possible values for the &#34;form&#34; field include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「フォーム」フィールドは、「repair_request_items」リストで与えられた修理依頼アイテムの種類を示します。 「フォーム」フィールドに指定可能な値は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                Form          Value
         NORM_NACK_ITEMS        1
         NORM_NACK_RANGES       2
         NORM_NACK_ERASURES     3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A &#34;form&#34; value of NORM_NACK_ITEMS indicates each repair request item in the &#34;repair_request_items&#34; list is to be treated as an individual request. A value of NORM_NACK_RANGES indicates that the &#34;repair_request_items&#34; list consists of pairs of repair request items that correspond to inclusive ranges of repair needs. And the NORM_NACK_ERASURES &#34;form&#34; indicates that the repair request items are to be treated individually and that the &#34;encoding_symbol_id&#34; portion of the &#34;fec_payload_id&#34; field of the repair request item (see below) is to be interpreted as an &#34;erasure count&#34; for the FEC coding block identified by the repair request item&#39;s &#34;source_block_number&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_NACK_ITEMSの「形」の値は「repair_request_items」リスト内の各修理依頼項目は個々の要求として処理されるべきであることを示します。 NORM_NACK_RANGESの値が「repair_request_items」リストは、修復の必要性を含む範囲に対応する修理依頼アイテムのペアで構成されていることを示しています。そしてNORM_NACK_ERASURES「フォーム」が修理依頼項目を個別に処理すべきであり、修理依頼項目の「fec_payload_id」フィールドの「encoding_symbol_id」部分は（下記参照）ことが「消去回数」のように解釈されるべきであることを示し修理依頼項目の「source_block_number」で識別されるFEC符号化ブロック。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;flags&#34; field is currently used to indicate the level of data content for which the repair request items apply (i.e., an individual segment, entire FEC coding block, or entire transport object). Possible flag values include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「フラグ」フィールドは、現在修理依頼項目が適用されるデータ内容のレベルを示すために使用される（すなわち、個々のセグメント、全体FEC符号化ブロック、または全体のトランスポート・オブジェクト）。可能なフラグ値は、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
+------------------+-------+-----------------------------------------+
|      Flag        | Value |                 Purpose                 |
+------------------+-------+-----------------------------------------+
|NORM_NACK_SEGMENT | 0x01  | Indicates the listed segment(s) or range|
|                  |       | of segments are required as repair.     |
+------------------+-------+-----------------------------------------+
|NORM_NACK_BLOCK   | 0x02  | Indicates the listed block(s) or range  |
|                  |       | of blocks in entirety are required as   |
|                  |       | repair.                                 |
+------------------+-------+-----------------------------------------+
|NORM_NACK_INFO    | 0x04  | Indicates that NORM_INFO is required as |
|                  |       | repair for the listed object(s).        |
+------------------+-------+-----------------------------------------+
|NORM_NACK_OBJECT  | 0x08  | Indicates the listed object(s) or range |
|                  |       | of objects in entirety are required as  |
|                  |       | repair.                                 |
+------------------+-------+-----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the NORM_NACK_SEGMENT flag is set, the &#34;object_transport_id&#34; and &#34;fec_payload_id&#34; fields are used to determine which sets or ranges of individual NORM_DATA segments are needed to repair content at the receiver. When the NORM_NACK_BLOCK flag is set, this indicates the receiver is completely missing the indicated coding block(s) and requires transmissions sufficient to repair the indicated block(s) in their entirety. When the NORM_NACK_INFO flag is set, this indicates the receiver is missing the NORM_INFO segment for the indicated &#34;object_transport_id&#34;. Note the NORM_NACK_INFO may be set in combination with the NORM_NACK_BLOCK or NORM_NACK_SEGMENT flags, or may be set alone. When the NORM_NACK_OBJECT flag is set, this indicates the receiver is missing the entire NormTransportObject referenced by the &#34;object_transport_id&#34;. This also implicitly requests any available NORM_INFO for the NormObject, if applicable. The &#34;fec_payload_id&#34; field is ignored when the flag NORM_NACK_OBJECT is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_NACK_SEGMENTフラグが設定されている場合、「object_transport_id」および「fec_payload_id」フィールドが設定または個々NORM_DATAセグメントの範囲は、受信機においてコンテンツを修復するために必要とされるかを決定するために使用されます。 NORM_NACK_BLOCKフラグが設定されている場合、これは、受信機が完全に示された符号化ブロック（単数または複数）が欠落していることを示しかつその全体が示されているブロックを修復するのに十分な伝送を必要とします。 NORM_NACK_INFOフラグが設定されている場合、これは、受信機が示されている「object_transport_id」のNORM_INFOセグメントが欠落していることを示します。注NORM_NACK_INFOはNORM_NACK_BLOCK又はNORM_NACK_SEGMENTフラグと組み合わせて設定することができる、または単独で設定することができます。 NORM_NACK_OBJECTフラグが設定されている場合、これは、受信機が「object_transport_id」によって参照される全体NormTransportObjectが欠落していることを示します。該当する場合、これはまた、暗黙のうちに、NormObjectのために使用可能な任意のNORM_INFOを要求します。フラグNORM_NACK_OBJECTが設定されている場合、「fec_payload_id」フィールドは無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;length&#34; field value is the length in bytes of the &#34;repair_request_items&#34; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「長さ」フィールドの値が「repair_request_items」フィールドのバイト長です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;repair_request_items&#34; field consists of a list of individual or range pairs of transport data unit identifiers in the following format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「repair_request_items」フィールドは次の形式でトランスポートデータユニット識別子の個人または範囲ペアのリストで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     fec_id    |   reserved    |      object_transport_id      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        fec_payload_id                         |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM Repair Request Item Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMの修理依頼項目フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;fec_id&#34; indicates the FEC type and can be used to determine the format of the &#34;fec_payload_id&#34; field. The &#34;reserved&#34; field is kept for possible future use and SHALL be set to a ZERO value and ignored by NORM nodes processing NACK content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「fec_id」はFECタイプを示し、「fec_payload_id」フィールドのフォーマットを決定するために用いることができます。 「予約」フィールドは、将来の使用のために保持され、ゼロ値に設定され、NORMノード処理NACK内容によって無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;object_transport_id&#34; corresponds to the NormObject for which repair is being requested and the &#34;fec_payload_id&#34; identifies the specific FEC coding block and/or segment being requested. When the NORM_NACK_OBJECT flag is set, the value of the &#34;fec_payload_id&#34; field is ignored. When the NORM_NACK_BLOCK flag is set, only the FEC code block identifier portion of the &#34;fec_payload_id&#34; is to be interpreted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「object_transport_idは」修理が要求された、特定のFEC符号化ブロックを識別および/またはセグメントが要求されている「fec_payload_id」されているためNormObjectに相当します。 NORM_NACK_OBJECTフラグが設定されている場合は、「fec_payload_id」フィールドの値は無視されます。 NORM_NACK_BLOCKフラグが設定されている場合、「fec_payload_id」のみFECコードブロック識別子部分は、解釈されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The format of the &#34;fec_payload_id&#34; field depends upon the &#34;fec_id&#34; field value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「fec_payload_id」フィールドの形式は、「fec_id」フィールドの値に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the receiver&#39;s repair needs dictate that different forms (mixed ranges and/or individual items) or types (mixed specific segments and/or blocks or objects in entirety) are required to complete reliable transmission, multiple NORM Repair Requests with different &#34;form&#34; and or &#34;flags&#34; values can be concatenated within a single NORM_NACK message. Additionally, NORM receivers SHALL construct NORM_NACK messages with their repair requests in ordinal order with respect to &#34;object_transport_id&#34; and &#34;fec_payload_id&#34; values. The &#34;nack_payload&#34; size SHALL NOT exceed the NormSegmentSize for the sender to which the NORM_NACK is destined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機の修理の必要性は、異なる形態（混合範囲および/または個々のアイテム）またはタイプ（混合特定のセグメント及び/又は全体がブロックまたはオブジェクト）は信頼性の高い伝送を完了するために必要であることを指示する場合、異なる「形態」との複数NORM修理要求及び又は「フラグ」の値は、単一NORM_NACKメッセージ内で連結することができます。また、NORM受信機は、「object_transport_id」と「fec_payload_id」値に関して序ために、彼らの修理依頼でNORM_NACKメッセージを構築するものとします。 「nack_payload」サイズがNORM_NACKが運命づけられていると、送信者のためのNormSegmentSizeを超えてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_NACK Content Examples:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_NACKコンテンツの例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In these examples, a small block, systematic FEC code (&#34;fec_id&#34; = 129) is assumed with a user data block length of 32 segments. In Example 1, a list of individual NORM_NACK_ITEMS repair requests is given. In Example 2, a list of NORM_NACK_RANGES requests _and_ a single NORM_NACK_ITEMS request are concatenated to illustrate the possible content of a NORM_NACK message. Note that FEC coding block erasure counts could also be provided in each case. However, the erasure counts are not really necessary since the sender can easily determine the erasure count while processing the NACK content. However, the erasure count option may be useful for operation with other FEC codes or for intermediate system purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの例では、小ブロック、システマティックFEC符号（「fec_id」= 129）は32個のセグメントのユーザーデータブロックの長さと仮定されます。例1では、個々のNORM_NACK_ITEMS修理依頼のリストが与えられています。実施例2では、​​NORM_NACK_RANGES要求_and_単一NORM_NACK_ITEMS要求のリストはNORM_NACKメッセージの可能な内容を説明するために連結されます。 FEC符号化ブロックの消去回数は、各場合に提供することができることに注意してください。 NACKのコンテンツを処理している間に、送信者が簡単に消去回数を決定することができますので、消去カウントは本当に必要はありません。しかし、消去回数のオプションは、他のFEC符号と、または中間システムの目的のために操作するために有用であり得ます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example 1: NORM_NACK &#34;nack_payload&#34; for: Object 12, Coding Block 3, Segments 2,5,8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実施例1：のためNORM_NACK &#34;nack_payload&#34;：オブジェクト12、ブロック3のコードセグメント2,5,8-
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   form = 1    | flags = 0x01  |       length  = 36            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  fec_id = 129 |   reserved    |    object_transport_id = 12   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    source_block_number = 3                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    source_block_length = 32   |    encoding_symbol_id = 2     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  fec_id = 129 |   reserved    |    object_transport_id = 12   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    source_block_number = 3                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    source_block_length = 32   |    encoding_symbol_id = 5     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  fec_id = 129 |   reserved    |    object_transport_id = 12   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    source_block_number = 3                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    source_block_length = 32   |    encoding_symbol_id = 8     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Example 2: NORM_NACK &#34;nack_payload&#34; for: Object 18 Coding Block 6, Segments 5, 6, 7, 8, 9, 10; and Object 19 NORM_INFO and Coding Block 1, segment 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実施例2：NORM_NACK &#34;nack_payload&#34; の：ブロック6、セグメント5、6、7、8、9、10コーディングオブジェクト18。 19 NORM_INFOオブジェクトとブロック1、セグメント3コーディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   form = 2    | flags = 0x01  |       length  = 24            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  fec_id = 129 |   reserved    |    object_transport_id = 18   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    source_block_number = 6                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    source_block_length = 32   |    encoding_symbol_id = 5     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  fec_id = 129 |   reserved    |    object_transport_id = 18   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    source_block_number = 6                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    source_block_length = 32   |    encoding_symbol_id = 10    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   form = 1    | flags = 0x05  |       length  = 12            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  fec_id = 129 |   reserved    |    object_transport_id = 19   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    source_block_number = 1                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    source_block_length = 32   |    encoding_symbol_id = 3     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. NORM_ACK Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2。 NORM_ACKメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_ACK message is intended to be used primarily as part of NORM congestion control operation and round-trip timing measurement. As mentioned in the NORM_CMD(ACK_REQ) message description, the acknowledgment type NORM_ACK_CC is provided for this purpose. The generation of NORM_ACK(CC) messages for round-trip timing estimation and congestion-control operation is described in Sections 5.5.1 and 5.5.2, respectively. However, some multicast applications may benefit from some limited form of positive acknowledgment for certain functions. A simple, scalable positive acknowledgment scheme is defined in Section 5.5.3 that can be leveraged by protocol implementations when appropriate. The NORM_CMD(FLUSH) may be used for OPTIONAL collection of positive acknowledgment of reliable reception to a certain &#34;watermark&#34; transmission point from specific receivers using this mechanism. The NORM_ACK type NORM_ACK_FLUSH is provided for this purpose and the format of the &#34;nack_payload&#34; for this acknowledgment type is given below. Beyond that, a range of application-defined &#34;ack_type&#34; values is provided for use at the NORM application&#39;s discretion. Implementations making use of application-defined positive acknowledgments may also make use the &#34;nack_payload&#34; as needed, observing the constraint that the &#34;nack_payload&#34; field size be limited to a maximum of the NormSegmentSize for the sender to which the NORM_ACK is destined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_ACKメッセージはNORM輻輳制御動作と往復タイミング測定の一部として主に使用されることが意図されています。 NORM_CMD（ACK_REQ）メッセージの説明で述べたように、確認型NORM_ACK_CCは、この目的のために設けられています。 NORM_ACK（CC）の往復タイミング推定及び輻輳制御動作のためのメッセージの生成は、セクションそれぞれ5.5.1及び5.5.2に記載されています。しかし、いくつかのマルチキャストアプリケーションは、特定の機能のための肯定応答のいくつかの限定された形態から利益を得ることができます。単純な、スケーラブルな肯定応答方式は、適切なプロトコル実装によって活用することができ、セクション5.5.3で定義されています。 NORM_CMD（FLUSH）は、このメカニズムを使用して、特定の受信機から特定の「透かし」送信点への信頼できる受信の肯定応答の任意のコレクションのために使用することができます。 NORM_ACK型NORM_ACK_FLUSHは、この目的のために提供され、この肯定応答タイプの「nack_payload」のフォーマットは以下のとおりです。それを越えて、アプリケーション定義の「ack_type」の値の範囲は、NORMアプリケーションの裁量で使用するために提供されます。アプリケーション定義の肯定応答を利用した実装は、「nack_payload」フィールドサイズがNORM_ACKを宛先とするために送信者NormSegmentSizeの最大値に限定されるという制約を観察し、必要に応じて「nack_payload」を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |version| type=5|    hdr_len    |          sequence             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           source_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           server_id                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           instance_id         |    ack_type  |     ack_id     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       grtt_response_sec                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       grtt_response_usec                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               header extensions (if applicable)               |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   ack_payload (if applicable)                 |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_ACK Message Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_ACKメッセージフォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM common message header fields serve their usual purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM一般的なメッセージヘッダーフィールドは通常の目的を果たします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;server_id&#34;, &#34;instance_id&#34;, and &#34;grtt_response&#34; fields serve the same purpose as the corresponding fields in NORM_NACK messages. And header extensions may be applied to support congestion control feedback or other functions in the same manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「SERVER_ID」、「INSTANCE_ID」、および「grtt_response」フィールドはNORM_NACKメッセージの対応するフィールドと同じ目的を果たします。ヘッダ拡張は同様に輻輳制御フィードバックまたは他の機能をサポートするために適用されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;ack_type&#34; field indicates the nature of the NORM_ACK message. This directly corresponds to the &#34;ack_type&#34; field of the NORM_CMD(ACK_REQ) message to which this acknowledgment applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ack_type」フィールドには、NORM_ACKメッセージの性質を示します。これは、直接確認が適用されるNORM_CMD（ACK_REQ）メッセージの「ack_type」フィールドに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;ack_id&#34; field serves as a sequence number so that the sender can verify that a NORM_ACK message received actually applies to a current acknowledgment request. The &#34;ack_id&#34; field is not used in the case of the NORM_ACK_CC and NORM_ACK_FLUSH acknowledgment types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者がNORM_ACKメッセージが実際に受信された現在の応答要求に適用されることを確認できるように「ack_id」フィールドは、シーケンス番号として機能します。 「ack_id」フィールドがNORM_ACK_CCとNORM_ACK_FLUSH承認タイプの場合に使用されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;ack_payload&#34; format is a function of the &#34;ack_type&#34;. The NORM_ACK_CC message has no attached content. Only the NORM_ACK header applies. In the case of NORM_ACK_FLUSH, a specific &#34;ack_payload&#34; format is defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「ack_payload」形式は「ack_type」の関数です。 NORM_ACK_CCメッセージにはコンテンツが付属していません。のみNORM_ACKヘッダが適用されます。 NORM_ACK_FLUSHの場合には、特定の「ack_payload」フォーマットが定義されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     fec_id    |   reserved    |      object_transport_id      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        fec_payload_id                         |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_ACK_FLUSH &#34;ack_payload&#34; Format
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_ACK_FLUSH &#34;ack_payload&#34; フォーマット
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;object_transport_id&#34; and &#34;fec_payload_id&#34; are used by the receiver to acknowledge applicable NORM_CMD(FLUSH) messages transmitted by the sender identified by the &#34;server_id&#34; field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「object_transport_id」および「fec_payload_id」「SERVER_ID」フィールドによって識別される送信者によって送信された適用NORM_CMD（FLUSH）メッセージを確認するために受信機によって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;ack_payload&#34; of NORM_ACK messages for application-defined &#34;ack_type&#34; values is specific to the application but is limited in size to a maximum the NormSegmentSize of the sender referenced by the &#34;server_id&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アプリケーション定義の「ack_type」値についてNORM_ACKメッセージの「ack_payload」は、アプリケーションに特有であるが、最大「SERVER_ID」によって参照される送信者のNormSegmentSizeにサイズが制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. General Purpose Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4。汎用メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some additional message formats are defined for general purpose in NORM multicast sessions whether the participant is acting as a sender and/or receiver within the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの追加のメッセージフォーマットは、参加者がグループ内の送信者および/または受信機として機能しているか否かをNORMマルチキャストセッションで一般的な目的のために定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. NORM_REPORT Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1。 NORM_REPORTメッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is an optional message generated by NORM participants. This message could be used for periodic performance reports from receivers in experimental NORM implementations. The format of this message is currently undefined. Experimental NORM implementations may define NORM_REPORT formats as needed for test purposes. These report messages SHOULD be disabled for interoperability testing between different NORM implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、NORMの参加者によって生成されたオプションのメッセージです。このメッセージは、実験的なNORM実装で受信機からの定期的なパフォーマンスレポートを使用することができます。このメッセージのフォーマットは、現在定義されていません。テスト目的のために、必要に応じて実験的NORM実装はNORM_REPORTフォーマットを定義することができます。これらのレポートメッセージは異なるNORM実装間の相互運用性テストのために無効にする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Detailed Protocol Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.詳細なプロトコル動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes the detailed interactions of senders and receivers participating in a NORM session. A simple synopsis of protocol operation is given here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、NORMセッションに参加して送信者と受信者の詳細な相互作用を説明します。プロトコル操作の簡単な概要をここに与えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) The sender periodically transmits NORM_CMD(CC) messages as needed to initialize and collect roundtrip timing and congestion control feedback from the receiver set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）送信者は、定期的に初期化し、受信機のセットからの往復タイミングと輻輳制御フィードバックを収集するために、必要に応じてNORM_CMD（CC）メッセージを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) The sender transmits an ordinal set of NormObjects segmented in the form of NORM_DATA messages labeled with NormTransportIds and logically identified with FEC encoding block numbers and symbol identifiers. NORM_INFO messages may optionally precede the transmission of data content for NORM transport objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）送信側はFEC符号化ブロック番号及びシンボル識別子で識別論理NormTransportIdsで標識NORM_DATAメッセージの形で分割NormObjectsの順序セットを送信します。 NORM_INFOメッセージは、必要に応じてNORMトランスポートオブジェクトのデータコンテンツの送信に先行してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) As receivers detect missing content from the sender, they initiate repair requests with NORM_NACK messages. Note the receivers track the sender&#39;s most recent objectId::fecPayloadId transmit position and NACK _only_ for content ordinally prior to that transmit position. The receivers schedule random backoff timeouts before generating NORM_NACK messages and wait an appropriate amount of time before repeating the NORM_NACK if their repair request is not satisfied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3）受信機は、送信者から欠落しているコンテンツを検出すると、それらはNORM_NACKメッセージで修理依頼を開始します。受信機は、送信者の最新のOBJECTID :: fecPayloadIdがordinally前にその送信位置にコンテンツに位置し、NACKの_のみ_を送信追跡注意してください。レシーバはNORM_NACKメッセージを生成する前にランダムバックオフタイムアウトのスケジュールを設定し、その修理依頼が満たされない場合NORM_NACKを繰り返す前に、適切な時間を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4) The sender aggregates repair requests from the receivers and logically &#34;rewinds&#34; its transmit position to send appropriate repair messages. The sender sends repairs for the earliest ordinal transmit position first and maintains this ordinal repair transmission sequence. Previously untransmitted FEC parity content for the applicable FEC coding block is used for repair transmissions to the greatest extent possible. If the sender exhausts its available FEC parity content on multiple repair cycles for the same coding block, it resorts to an explicit repair strategy (possibly using parity content) to complete repairs. (The use of explicit repair is expected to be an exception in general protocol operation, but the possibility does exist for extreme conditions). The sender immediately assumes transmission of new content once it has sent pending repairs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4）送信者の集合体は、受信機からの要求を修復し、論理的に適切な修復メッセージを送信するために、その送信位置を「巻き戻し」。送信者は、最初の早い序の送信位置のための修理を送り、この序修理送信シーケンスを維持しています。該当するFEC符号化ブロックのために以前は未FECパリティのコンテンツは、可能な限り修理伝送に使用されます。送信者が同一の符号化ブロックに対して複数の補修サイクル上の利用可能FECパリティコンテンツを排出する場合は、修理を完了するために、（おそらくパリティコンテンツを使用して）明示的な補修戦略に頼っ。 （明示的な修復の使用は、一般的なプロトコルの動作に例外であると予想されるが、可能性は、極端な条件のために存在します）。それは保留中の修理を送信した後、送信者は、すぐに新しいコンテンツの伝送を前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5) The sender transmits NORM_CMD(FLUSH) messages when it reaches the end of enqueued transmit content and pending repairs. Receivers respond to the NORM_CMD(FLUSH) messages with NORM_NACK transmissions (following the same suppression backoff timeout strategy as for data) if they require further repair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5）送信者は、それがエンキュー送信コンテンツとペンディング修理の端部に到達NORM_CMD（FLUSH）メッセージを送信します。彼らはさらに、修理が必要な場合は、受信機はNORM_CMD（FLUSH）（データ用と同じ抑制バックオフタイムアウト戦略以下）NORM_NACK送信のメッセージに応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6) The sender transmissions are subject to rate control limits determined by congestion control mechanisms. In the baseline NORM-CC operation, each sender in a NormSession maintains its own independent congestion control state. Receivers provide congestion control feedback in NORM_NACK and NORM_ACK messages. NORM_ACK feedback for congestion control purposes is governed using a suppression mechanism similar to that for NORM_NACK messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
6）送信側の送信は、輻輳制御機構によって決定された制御限界を評価する対象となっています。ベースラインNORM-CC動作において、NormSession内の各送信者は、独自の独立した輻輳制御状態を維持します。レシーバはNORM_NACKとNORM_ACKメッセージに輻輳制御フィードバックを提供します。輻輳制御の目的のためにNORM_ACKフィードバックはNORM_NACKメッセージと同様の抑制機構を使用して管理されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While this overall concept is relatively simple, there are details to each of these aspects that need to be addressed for successful, efficient, robust, and scalable NORM protocol operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この全体的な概念は比較的簡単ですが、成功した効率的な、堅牢、かつスケーラブルなNORMプロトコル動作に対処する必要がこれらの側面のそれぞれに詳細があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Sender Initialization and Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。送信者の初期化と伝送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Upon startup, the NORM sender immediately begins sending NORM_CMD(CC) messages to collect round trip timing and other information from the potential group. If NORM-CC congestion control operation is enabled, the NORM-CC Rate header extension MUST be included in these messages. Congestion control operation SHALL be observed at all times when operating in the general Internet. Even if congestion control operation is disabled at the sender, it may be desirable to use the NORM_CMD(CC) messaging to collect feedback from the group using the baseline NORM-CC feedback mechanisms. This proactive feedback collection can be used to establish a GRTT estimate prior to data transmission and potential NACK operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
起動時に、NORMの送信者はすぐに潜在的なグループからの往復タイミングやその他の情報を収集するためにNORM_CMD（CC）メッセージの送信を開始します。 NORM-CC輻輳制御動作が有効になっている場合は、NORM-CC率ヘッダ拡張は、これらのメッセージに含まれなければなりません。一般的なインターネットでの動作時に輻輳制御動作を常時観察するものとします。輻輳制御動作を送信側で無効にされている場合でも、ベースラインNORM-CCのフィードバック機構を使用してグループからのフィードバックを収集するNORM_CMD（CC）メッセージを使用することが望ましい場合があります。この積極的なフィードバックの収集は、データ伝送および潜在的なNACKの動作に先立っGRTT推定値を確立するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In some cases, applications may wish for the sender to also proceed with data transmission immediately. In other cases, the sender may wish to defer data transmission until it has received some feedback or request from the receiver set indicating that receivers are indeed present. Note, in some applications (e.g., web push), this indication may come out-of-band with respect to the multicast session via other means. As noted, the periodic transmission of NORM_CMD(CC) messages may precede actual data transmission in order to have an initial GRTT estimate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかのケースでは、アプリケーションは、すぐにデータの伝送を続行するために、送信者のために望むことができます。他の場合には、送信者は、受信機が実際に存在していることを示す受信機セットからいくつかのフィードバックや要求を受信するまでデータ送信を延期することを望むかもしれません。ノートは、いくつかのアプリケーション（例えば、ウェブプッシュ）に、この指示は、他の手段を介してマルチキャストセッションに対してアウトオブバンド来るかもしれません。述べたように、NORM_CMD（CC）メッセージの周期的な送信は、初期GRTT推定値を得るために実際のデータ伝送に先行してもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With inclusion of the OPTIONAL NORM FEC Object Transmission Information Header Extension, the NORM protocol sender message headers can contain all information necessary to prepare receivers for subsequent reliable reception. This includes FEC coding parameters, the sender NormSegmentSize, and other information. If this header extension is not used, it is presumed that receivers have received the FEC Object Transmission Information via other means. Additionally, applications may leverage the use of NORM_INFO messages associated with the session data objects in the session to provide application-specific context information for the session and data being transmitted. These mechanisms allow for operation with minimal pre-coordination among the senders and receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OPTIONAL NORM FECオブジェクト伝送情報ヘッダ拡張を含めて、NORMプロトコル送信者メッセージヘッダは、後続の確実な受信のために受信機を準備するために必要なすべての情報を含むことができます。これは、FEC符号化パラメータ、送信者NormSegmentSize、およびその他の情報が含まれています。このヘッダー拡張を使用しない場合には、受信機が他の手段を介してFECオブジェクト伝送情報を受信したと推測されます。また、アプリケーションは、送信されるセッションおよびデータのアプリケーション固有コンテキスト情報を提供するために、セッション中のセッション・データ・オブジェクトに関連付けられたNORM_INFOメッセージの使用を利用することができます。これらの機構は、送信側と受信側の間で最小の事前配位での動作を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM sender begins segmenting application-enqueued data into NORM_DATA segments and transmitting it to the group. The segmentation algorithm is described in Section 5.1.1. The rate of transmission is controlled via congestion control mechanisms or is a fixed rate if desired for closed network operations. The receivers participating in the multicast group provide feedback to the sender as needed. When the sender reaches the end of data it has enqueued for transmission or any pending repairs, it transmits a series of NORM_CMD(FLUSH) messages at a rate of one per 2*GRTT. Receivers may respond to these NORM_CMD(FLUSH) messages with additional repair requests. A protocol parameter &#34;NORM_ROBUST_FACTOR&#34; determines the number of flush messages sent. If receivers request repair, the repair is provided and flushing occurs again at the end of repair transmission. The sender may attach an OPTIONAL &#34;acking_node_list&#34; to NORM_CMD(FLUSH) containing the NormNodeIds for receivers from which it expects explicit positive acknowledgment of reception. The NORM_CMD(FLUSH) message may be also used for this optional function any time prior to the end of data enqueued for transmission with the NORM_CMD(FLUSH) messages multiplexed with ongoing data transmissions. The OPTIONAL NORM positive acknowledgment procedure is described in Section 5.5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMの送信者はNORM_DATAセグメントにアプリケーション・エンキューデータをセグメント化してグループに送信を開始します。セグメンテーションアルゴリズムは、セクション5.1.1に記載されています。伝送速度は、輻輳制御機構を介して制御されるか、閉じたネットワーク動作のため、所望であれば、固定レートです。必要に応じて、マルチキャストグループに参加する受信機は、送信者にフィードバックを提供します。送信者は、それが送信または保留中の修理のために待ち行列に入れたデータの終わりに到達すると、それは2ごとに* GRTTの速度でNORM_CMD（FLUSH）一連のメッセージを送信します。レシーバは、追加の修理依頼でこれらNORM_CMD（FLUSH）メッセージに応答することができます。プロトコルパラメータ「NORM_ROBUST_FACTORは」送られたフラッシュメッセージの数を決定します。受信機は、修理を依頼した場合、修理を提供し、フラッシングは、修復送信の終了時に再び発生されます。送信者は、受信の明示的な肯定応答を期待し、そこから受信するためのNormNodeIdsを含むNORM_CMDにOPTIONAL「acking_node_list」（FLUSH）を取り付けることができます。 NORM_CMD（FLUSH）メッセージも、このオプション機能のための継続的なデータ伝送と多重NORM_CMD（FLUSH）メッセージの伝送のために待ち行列に入れたデータの終わりの前にいつでも使用することができます。オプションNORM肯定応答手順は、セクション5.5.3に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. Object Segmentation Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1。セグメンテーションアルゴリズムオブジェクト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM senders and receivers must use a common algorithm for logically segmenting transport data into FEC encoding blocks and symbols so that appropriate NACKs can be constructed to request repair of missing data. NORM FEC coding blocks are comprised of multi-byte symbols which are transmitted in the payload of NORM_DATA messages. Each NORM_DATA message contains one source or encoding symbol and the NormSegmentSize sender parameter defines the maximum symbol size in bytes. The FEC encoding type and associated parameters govern the source block size (number of source symbols per coding block). NORM senders and receivers use these FEC parameters, along with the NormSegmentSize and transport object size to compute the source block structure for transport objects. These parameters are provided in the FEC Transmission Information for each object. The algorithm given below is used to compute a source block structure such that all source blocks are as close to being equal length as possible. This helps avoid the performance disadvantages of &#34;short&#34; FEC blocks. Note this algorithm applies only to the statically-sized NORM_OBJECT_DATA and NORM_OBJECT_FILE transport object types where the object size is fixed and predetermined. For NORM_OBJECT_STREAM objects, the object is segmented according to the maximum source block length given in the FEC Transmission Information, unless the FEC Payload ID indicates an alternative size for a given block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMの送信者と受信者が適切なのNACKが欠落したデータの修復を要求するために構築することができるように、論理的にFEC符号化ブロックとシンボルへの輸送データをセグメント化するための共通のアルゴリズムを使用する必要があります。 NORM FEC符号化ブロックがNORM_DATAメッセージのペイロードで送信されるマルチバイトシンボルで構成されています。各NORM_DATAメッセージは一つのソースまたは符号化シンボルを含み、NormSegmentSize送信者パラメータがバイト単位で最大シンボルサイズを定義します。 FEC符号化タイプおよび関連するパラメータは、ソース・ブロック・サイズ（符号化ブロック当たりのソースシンボルの数）を支配します。 NORMの送信側と受信側は、トランスポートオブジェクトのソースブロック構造を計算するためにNormSegmentSize搬送オブジェクトのサイズと共に、これらのFECのパラメータを使用します。これらのパラメータは、各オブジェクトに対してFEC伝送情報で提供されています。以下に示すアルゴリズムは、すべてのソースブロックができるだけ等しい長さに近くなるように、ソースブロック構造を計算するために使用されます。これは、「短い」FECブロックのパフォーマンスの欠点を回避するのに役立ちます。このアルゴリズムは唯一のオブジェクトのサイズが固定され、予め定められている静的サイズNORM_OBJECT_DATAとNORM_OBJECT_FILEトランスポート・オブジェクト・タイプに適用されます。 FECペイロードIDは、所与のブロックのための代替的なサイズを示さない限りNORM_OBJECT_STREAMオブジェクトの場合、オブジェクトは、FEC送信情報で指定された最大ソースブロック長に応じて分割されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM block segmentation algorithm is defined as follows. For a transport object of a given length (L_obj) in bytes, a first number of FEC source blocks (N_large) is delineated of a larger block size (B_large), and a second number of source blocks (N_small) is delineated of a smaller block size (B_small). Given the maximum FEC source block size (B_max) and the sender&#39;s NormSegmentSize, the block segmentation for a given NORM transport object is determined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次のようにNORMブロックセグメンテーションアルゴリズムが定義されています。バイト単位で指定された長さ（L_obj）のトランスポート・オブジェクトのために、FECソースブロックの最初の数（N_large）が小さいから線引きされ、より大きなブロックサイズ（B_large）、及びソースブロックの第二の数（N_small）で描写されていますブロックサイズ（B_small）。次のように最大FECソースブロックサイズ（b_maxの）及びセンダのNormSegmentSize与えられ、与えられたNORMトランスポートオブジェクトのブロック分割が決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Inputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
入力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B_max = Maximum source block length (i.e., maximum number of source symbols per source block)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
b_maxの=最大ソースブロック長（すなわち、ソースブロック当たりのソースシンボルの最大数）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
L_sym = Encoding symbol length in bytes (i.e., NormSegmentSize)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト単位L_sym =エンコーディングシンボル長（すなわち、NormSegmentSize）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
L_obj = Object length in bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バイト単位L_obj =物体長
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Outputs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
N_total = The total number of source blocks into which the transport object is partitioned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
N_totalは、トランスポート・オブジェクトがパーティション化されているその中にソースブロックの総数=
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
N_large = Number of larger source blocks (first set of blocks)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
大きなソースブロックのN_large =数（ブロックの最初のセット）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B_large = Size (in encoding symbols) of the larger source blocks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
大きなソースブロックの（符号化シンボルにおける）B_large =サイズ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
N_small = Number of smaller source blocks (second set of blocks)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
小さいソースブロックのN_small =数（ブロックの第二のセット）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
B_small = Size (in encoding symbols) of the smaller source blocks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
小さいソースブロックの（符号化シンボルにおける）B_small =サイズ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
L_final = Length (in bytes) of the last source symbol of the last source block (All other symbols are of length L_sym).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最後のソースブロックの最後のソースシンボルのL_final =長さ（バイト単位）（他のすべての記号は長L_symのものです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Algorithm:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アルゴリズム：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) The total number of source symbols in the transport object is computed as: S_total = L_obj/L_sym [rounded up to the nearest integer]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）トランスポート・オブジェクト内のソースシンボルの総数は、以下のように計算される：S_total = L_obj / L_sym [最も近い整数に切り上げ]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) The transport object is partitioned into N_total source blocks, where: N_total = S_total/B_max [rounded up to the nearest integer]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）トランスポート・オブジェクトは、N_totalソースブロックに分割される：N_total = S_total / b_maxの[最も近い整数に切り上げ]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) The average length of a source block is computed as: B_ave = S_total/N_total (this may be non-integer)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（これは非整数であり得る）B_ave = S_total / N_total：3）、ソースブロックの平均の長さは次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4) The size of the first set of larger blocks is computed as: B_large = B_ave [rounded up to the nearest integer] (Note it will always be the case that B_large &lt;= B_max)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4）大きなブロックの第一のセットの大きさは次のように計算される：B_large = B_ave（[最も近い整数に切り上げ]は常にB_large &lt;= b_maxの）場合であろう注
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
5) The size of the second set of smaller blocks is computed as: B_small = B_ave [rounded down to the nearest integer] (Note if B_ave is an integer B_small = B_large; otherwise B_small = B_large - 1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
5）より小さなブロックの第二のセットの大きさは次のように計算される：B_small = B_ave B_ave整数B_small = B_largeされている場合は（[最も近い整数に切り捨て]、そうでない場合B_small = B_large  -  1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
6) The fractional part of B_ave is computed as: B_fraction = B_ave - B_small
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
B_small  -  B_fraction = B_ave：6）B_aveの小数部分は、以下のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
7) The number of larger source blocks is computed as: N_large = B_fraction * N_total (Note N_large is an integer in the range 0 through N_total - 1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
7）より大きなソースブロックの数は次のように計算される：N_large = B_fraction * N_total（N_largeがN_total介して範囲0の整数であることに注意してください -  1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
8) The number of smaller source blocks is computed as: N_small = N_total - N_large
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
N_large  -  N_small = N_total：8）より小さいソースブロックの数は次のように計算されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
9) Each of the first N_large source blocks consists of B_large source symbols. Each of the remaining N_small source blocks consists of B_small source symbols. All symbols are L_sym bytes in length except for the final source symbol of the final source block which is of length (in bytes): L_final = L_obj - (N_large*B_large + N_small*B_small - 1) * L_sym
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
9）第N_largeソースブロックの各々はB_largeのソースシンボルから成ります。残りN_smallソースブロックの各々はB_smallのソースシンボルから成ります。 （N_large * B_large + N_small * B_small  -   -  1）* L_sym L_final = L_obj：すべての記号はL_symは、長さ（バイト単位）であり、最終的なソースブロックの最終的なソースシンボルを除いた長さがバイト
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Receiver Initialization and Reception
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。受信機の初期化とレセプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM protocol is designed such that receivers may join and leave the group at will. However, some applications may be constrained such that receivers need to be members of the group prior to start of data transmission. NORM applications may use different policies to constrain the impact of new receivers joining the group in the middle of a session. For example, a useful implementation policy is for new receivers joining the group to limit or avoid repair requests for transport objects already in progress. The NORM sender implementation may wish to impose additional constraints to limit the ability of receivers to disrupt reliable multicast performance by joining, leaving, and rejoining the group often. Different receiver &#34;join policies&#34; may be appropriate for different applications and/or scenarios. For general purpose operation, default policy where receivers are allowed to request repair only for coding blocks with a NormTransportId and FEC coding block number greater than or equal to the first non-repair NORM_DATA or NORM_INFO message received upon joining the group is RECOMMENDED. For objects of type NORM_OBJECT_STREAM it is RECOMMENDED that the join policy constrain receivers to start reliable reception at the current FEC coding block for which non-repair content is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMプロトコルは、受信機が参加し、意志でグループを去ることができるように設計されます。しかし、一部のアプリケーションは、受信機がデータ送信の開始前にグループのメンバーである必要があるように制約されてもよいです。 NORMアプリケーションは、セッションの途中でグループに参加し、新たな受信機の影響を制限するために異なるポリシーを使用することができます。例えば、有用な実施方針を制限したり、すでに進行中のトランスポート・オブジェクトのための修理依頼を回避するためにグループに参加する新しい受信機のためです。 NORMの送信側の実装では、参加残し、多くの場合、グループを再結合することにより、信頼性の高いマルチキャストパフォーマンスを破壊する受信機の能力を制限するために追加の制約を課すことを望むかもしれません。異なる受信機は、異なるアプリケーションおよび/またはシナリオに適切かもしれない「方針を参加します」。汎用操作、受信機のみNormTransportId有するブロックよりも大きいか又は最初の非修復NORM_DATAに等しい又はFEC符号化ブロックの数を符号化するために修理を依頼することが許可されているデフォルトのポリシーNORM_INFOメッセージがグループに加わる際に受信するための推奨されます。型NORM_OBJECT_STREAMの目的のためには、加入ポリシーが非修復コンテンツが受信された現在のFEC符号化ブロックで信頼性の高い受信を開始するように受信機を制約することが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Receiver NACK Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。レシーバNACK手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the receiver detects it is missing data from a sender&#39;s NORM transmissions, it initiates its NACKing procedure. The NACKing procedure SHALL be initiated _only_ at FEC coding block boundaries, NormObject boundaries, and upon receipt of a NORM_CMD(FLUSH) message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機は、それが送信者のNORM送信からデータが欠落している検出すると、そのNACKing手順を開始します。 NACKing手順は、ブロック境界を符号化するFECで_のみ_、NormObject境界、及びNORM_CMD（FLUSH）メッセージの受信時に開始されるものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NACKing procedure begins with a random backoff timeout. The duration of the backoff timeout is chosen using the &#34;RandomBackoff&#34; algorithm described in the NORM Building Block document [4] using (Ksender*GRTTsender) for the &#34;maxTime&#34; parameter and the sender advertised group size (GSIZEsender) as the &#34;groupSize&#34; parameter. NORM senders provide values for GRTTsender, Ksender and GSIZEsender via the &#34;grtt&#34;, &#34;backoff&#34;, and &#34;gsize&#34; fields of transmitted messages. The GRTTsender value is determined by the sender based on feedback it has received from the group while the Ksender and GSIZEsender values may determined by application requirements and expectations or ancillary information. The backoff factor &#34;Ksender&#34; MUST be greater than one to provide for effective feedback suppression. A value of K = 4 is RECOMMENDED for the Any Source Multicast (ASM) model while a value of K = 6 is RECOMMENDED for Single Source Multicast (SSM) operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NACKing手順は、ランダムバックオフタイムアウトで始まります。バックオフタイムアウトの期間は「MAXTIME」パラメータと「GROUPSIZE」として送信者アドバタイズグループサイズ（GSIZEsender）ためNORMビルディングブロック文献[4]を用いて（Ksender * GRTTsender）に記載された「RandomBackoff」アルゴリズムを使用して選択されますパラメータ。 NORMの送信者は、「GRTT」、「バックオフ」、および送信されたメッセージの「GSIZE」フィールドを経てGRTTsender、KsenderとGSIZEsenderのための値を提供します。 GRTTsender値はKsenderとGSIZEsender値は、アプリケーションの要件と期待または補助情報によって決定されるかもしれないが、それはグループから受信したフィードバックに基づいて送信者によって決定されます。バックオフ因子「Ksenderは、」効果的なフィードバック抑制のために提供するものよりも大きくなければなりません。 K = 6の値はシングルソースマルチキャスト（SSM）動作のために推奨されながら、K = 4の値は、任意のソースマルチキャスト（ASM）モデルに推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thus:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_backoff = RandomBackoff(Ksender*GRTTsender, GSIZEsender)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_backoff = RandomBackoff（Ksender * GRTTsender、GSIZEsender）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To avoid the possibility of NACK implosion in the case of sender or network failure during SSM operation, the receiver SHALL automatically suppress its NACK and immediately enter the &#34;holdoff&#34; period described below when T_backoff is greater than (Ksender-1)*GRTTsender. Otherwise, the backoff period is entered and the receiver MUST accumulate external pending repair state from NORM_NACK messages and NORM_CMD(REPAIR_ADV) messages received. At the end of the backoff time, the receiver SHALL generate a NORM_NACK message only if the following conditions are met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
SSM動作中に送信者またはネットワークに障害が発生した場合にはNACK爆縮の可能性を回避するために、受信機は自動的にNACKを抑制し、直ちにT_backoffは（Ksender-1）よりも大きい場合に後述する「ホールドオフ」期間に入るものと* GRTTsender。そうでなければ、バックオフ期間が入力され、受信機はNORM_NACKメッセージから外部ペンディング修復状態を蓄積しなければならないとNORM_CMD（REPAIR_ADV）メッセージを受信しました。バックオフ時間の終わりに、受信機は、以下の条件が満たされる場合にのみNORM_NACKメッセージを生成しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) The sender&#39;s current transmit position (in terms of objectId::fecPayloadId) exceeds the earliest repair position of the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）OBJECTID :: fecPayloadIdの点で、送信者の現在の送信位置（）は、受信機の初期修復位置を越えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) The repair state accumulated from NORM_NACK and NORM_CMD(REPAIR_ADV) messages do not equal or supersede the receiver&#39;s repair needs up to the sender transmission position at the time the NACK procedure (backoff timeout) was initiated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）NORM_NACK及びNORM_CMD（REPAIR_ADV）メッセージからの累積修復状態が等しくない、または受信機の修理がNACK手順（バックオフタイムアウト）が開始された時点で送信元送信位置まで必要代わります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If these conditions are met, the receiver immediately generates a NORM_NACK message when the backoff timeout expires. Otherwise, the receiver&#39;s NACK is considered to be &#34;suppressed&#34; and the message is not sent. At this time, the receiver begins a &#34;holdoff&#34; period during which it constrains itself to not reinitiate the NACKing process. The purpose of this timeout is to allow the sender worst-case time to respond to the repair needs before the receiver requests repair again. The value of this &#34;holdoff&#34; timeout (T_rcvrHoldoff) as described in [4] is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの条件が満たされている場合、バックオフタイムアウトが満了すると、受信機は直ちにNORM_NACKメッセージを生成します。それ以外の場合は、受信者のNACKは「抑制」されると考えられ、メッセージは送信されません。このとき、受信機は、それがNACKingプロセスを再開しないように自分自身を制限している時に「ホールドオフ」期間を開始します。このタイムアウトの目的は、受信側の要求は再び修復する前に、送信者、最悪の場合の時間は修理ニーズに対応できるようにすることです。記載されているように、この「ホールドオフ」タイムアウト（T_rcvrHoldoff）の値は、[4]です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_rcvrHoldoff =(Ksender+2)*GRTTsender
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_rcvrHoldoff =（Ksender + 2）* GRTTsender
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_NACK message contains repair request content beginning with lowest ordinal repair position of the receiver up through the coding block prior to the most recently heard ordinal transmission position for the sender. If the size of the NORM_NACK content exceeds the sender&#39;s NormSegmentSize, the NACK content is truncated so that the receiver only generates a single NORM_NACK message per NACK cycle for a given sender. In summary, a single NACK message is generated containing the receiver&#39;s lowest ordinal repair needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_NACKメッセージは、前送信者のための最も最近聞い序送信位置にコーディングブロックを通じて受信機までの最低の順序修理位置から始まる修理依頼の内容が含まれています。 NORM_NACKコンテンツのサイズが、送信者のNormSegmentSizeを超えた場合、受信機のみ与えられた送信者のNACKサイクル当たり単一NORM_NACKメッセージを生成するように、NACKコンテンツが切り捨てられます。要約すると、単一のNACKメッセージは、受信者の最小順序修理の必要性を含むが生成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each partially-received FEC coding block requiring repair, the receiver SHALL, on its _first_ repair attempt for the block, request the parity portion of the FEC coding block beginning with the lowest ordinal _parity_ &#34;encoding_symbol_id&#34; (i.e., &#34;encoding_symbol_id&#34; = &#34;source_block_len&#34;) and request the number of FEC symbols corresponding to its data segment erasure count for the block. On _subsequent_ repair cycles for the same coding block, the receiver SHALL request only those repair symbols from the first set it has not yet received up to the remaining erasure count for that applicable coding block. Note that the sender may have provided other different, additional parity segments for other receivers that could also be used to satisfy the local receiver&#39;s erasure-filling needs. In the case where the erasure count for a partially-received FEC coding block exceeds the maximum number of parity symbols available from the sender for the block (as indicated by the NORM_DATA &#34;fec_num_parity&#34; field), the receiver SHALL request all available parity segments plus the ordinally highest missing data segments required to satisfy its total erasure needs for the block. The goal of this strategy is for the overall receiver set to request a lowest common denominator set of repair symbols for a given FEC coding block. This allows the sender to construct the most efficient repair transmission segment set and enables effective NACK suppression among the receivers even with uncorrelated packet loss. This approach also requires no synchronization among the receiver set in their repair requests for the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各部分的に受信されたFEC符号化ブロックが必要な修理のために、受信機は、ブロックのためにその_first_修復の試みで、最も低い順序_parity_「encoding_symbol_id」で始まる（すなわち、「encoding_symbol_id」= &#34;FEC符号化ブロックのパリティ部分を求めるものsource_block_len」）とは、ブロックのためにそのデータセグメント消去回数に対応するFEC記号の数を要求します。同じ符号化ブロックの_subsequent_修復サイクルで、受信機は、それがまだその該当コーディングブロックの残りの消去回数まで受信していない第一のセットからのみリペアシンボルを求めるもの。送信者が、ローカル受信機の消去充填ニーズを満たすために使用され得る他の受信機のために他の異なる、追加のパリティセグメントを提供していることに留意されたいです。部分的に受信されたFEC符号化ブロックの消去カウントが（NORM_DATA「fec_num_parity」フィールドによって示されるように）ブロックのため送信者から入手可能なパリティシンボルの最大数を超えた場合に、受信機は、利用可能なすべてのパリティ・セグメントを要求するものとプラスブロックの総消去ニーズを満たすために必要なordinally最高欠落しているデータ・セグメント。この戦略の目標は、与えられたFEC符号化ブロックについてリペアシンボルの最小公分母のセットを要求するように設定され、全​​体の受信機のためのものです。これは、送信者が最も効率的な修復の送信セグメントセットを構築することができ、さらに無相関パケット損失と受信機の間で効果的なNACKを抑制することができます。このアプローチでは、送信者のための彼らの修理依頼に設定された受信機間では、同期を必要としません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For FEC coding blocks or NormObjects missed in their entirety, the NORM receiver constructs repair requests with NORM_NACK_BLOCK or NORM_NACK_OBJECT flags set as appropriate. The request for retransmission of NORM_INFO is accomplished by setting the NORM_NACK_INFO flag in a corresponding repair request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
その全体を逃したFEC符号化ブロックまたはNormObjectsため、NORM受信機は適宜設定NORM_NACK_BLOCK又はNORM_NACK_OBJECTフラグを修復要求を構築します。 NORM_INFOの再送要求は、対応する修理依頼にNORM_NACK_INFOフラグを設定することによって達成されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Sender NACK Processing and Response
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。送信者NACK処理と応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The principle goal of the sender is to make forward progress in the transmission of data its application has enqueued. However, the sender must occasionally &#34;rewind&#34; its logical transmission point to satisfy the repair needs of receivers who have NACKed. Aggregation of multiple NACKs is used to determine an optimal repair strategy when a NACK event occurs. Since receivers initiate the NACK process on coding block or object boundaries, there is some loose degree of synchronization of the repair process even when receivers experience uncorrelated data loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者の原則の目的は、そのアプリケーションがキューに入れられたデータの伝送に前進を作ることです。ただし、送信者は時折、NACKされている受信機の修理のニーズを満たすために、その論理的な送信点を「巻き戻し」しなければなりません。複数NACKの凝集がNACKイベントが発生したときに、最適な修復戦略を決定するために使用されます。受信機は、ブロックまたはオブジェクトの境界をコーディングにNACKプロセスを開始するので、受信機は、無相関のデータの損失が発生するにも修復プロセスの同期のいくつかの緩い度があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.1. Sender Repair State Aggregation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.1。送信者の修復状態集計
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a sender is in its normal state of transmitting new data and receives a NACK, it begins a procedure to accumulate NACK repair state from NORM_NACK messages before beginning repair transmissions. Note that this period of aggregating repair state does _not_ interfere with its ongoing transmission of new data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者が新しいデータを送信し、その正常な状態にあり、NACKを受信すると、修理の送信を開始する前にNORM_NACKメッセージからNACK修復状態を蓄積するための手順を開始します。修理状態を集約するこの期間は_not_新しいデータの継続的な伝達に干渉しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described in [4], the period of time during which the sender aggregates NORM_NACK messages is equal to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
記載のように、[4]、送信者がNORM_NACKメッセージを集計する期間は、に等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_sndrAggregate = (Ksender+1)*GRTT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_sndrAggregate =（Ksender + 1）* GRTT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where &#34;Ksender&#34; is the same backoff scaling value used by the receivers, and &#34;GRTT&#34; is the sender&#39;s current estimate of the group&#39;s greatest round-trip time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「Ksenderは、」受信機で使用されるのと同じバックオフスケーリング値であり、ここで「GRTTは、」グループの最大のラウンドトリップ時間の送信者の現在の推定値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When this period ends, the sender &#34;rewinds&#34; by incorporating the accumulated repair state into its pending transmission state and begins transmitting repair messages. After pending repair transmissions are completed, the sender continues with new transmissions of any enqueued data. Also, at this point in time, the sender begins a &#34;holdoff&#34; timeout during which time the sender constrains itself from initiating a new repair aggregation cycle, even if NORM_NACK messages arrive. As described in [4], the value of this sender &#34;holdoff&#34; period is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
場合は、この期間が終了すると、送信者は、その保留中の送信状態に蓄積修理状態を組み込むことによって、「巻き戻し」と修理メッセージの送信を開始します。保留中の修理送信が完了した後、送信者は、任意のキューに入れられたデータの新しい送信を続行します。また、この時点で、送信者はNORM_NACKメッセージが到着しても、送信者が新しい修理集約サイクルを開始するから自分自身を拘束し、その間に「ホールドオフ」タイムアウトを開始します。 [4]で説明したように、この送信者「ホールドオフ」期間の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_sndrHoldoff = (1*GRTT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_sndrHoldoff =（1 * GRTT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If additional NORM_NACK messages are received during this sender &#34;holdoff&#34; period, the sender will immediately incorporate these &#34;late messages&#34; into its pending transmission state ONLY if the NACK content is ordinally greater than the sender&#39;s current transmission position. This &#34;holdoff&#34; time allows worst case time for the sender to propagate its current transmission sequence position to the group, thus avoiding redundant repair transmissions. After the holdoff timeout expires, a new NACK accumulation period can be begun (upon arrival of a NACK) in concert with the pending repair and new data transmission. Recall that receivers are not to initiate the NACK repair process until the sender&#39;s logical transmission position exceeds the lowest ordinal position of their repair needs. With the new NACK aggregation period, the sender repeats the same process of incorporating accumulated repair state into its transmission plan and subsequently &#34;rewinding&#34; to transmit the lowest ordinal repair data when the aggregation period expires. Again, this is conducted in concert with ongoing new data and/or pending repair transmissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
追加NORM_NACKメッセージがこの送信者「ホールドオフ」期間中に受信された場合、送信者はすぐにNACKコンテンツが送信者の現在の送信位置よりもordinally大きい場合にのみ、その保留中の送信状態にこれらの「後半メッセージ」を組み込む予定。この「ホールドオフ」の時間は、このように冗長救済送信を避け、グループに現在の送信シーケンス位置を伝播する送信者のための最悪の時間を確保できます。ホールドオフタイムアウトが満了した後、新しいNACK蓄積期間は、保留中の修理や新たなデータ伝送と協力して（NACKの到着時に）開始することができます。受信機は、送信者の論理的な伝送位置は、その修理ニーズの最低順序位置を超えるまでNACK修復プロセスを開始していないことを思い出してください。新しいNACKの集計期間で、送信者は、その透過計画に蓄積され、修復状態を組み込み、その後集計期間が満了したときに、最低順序リペアデータを送信するために、「巻き戻し」の同様の処理を繰り返します。繰り返しますが、これは現在進行中の新しいデータおよび/または保留中の修理トランスミッションと協調して実施されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.2. Sender FEC Repair Transmission Strategy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.2。送信者FECリペア伝送戦略
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM sender should leverage transmission of FEC parity content for repair to the greatest extent possible. Recall that the receivers use a strategy to request a lowest common denominator of explicit repair (including parity content) in the formation of their NORM_NACK messages. Before falling back to explicitly satisfying different receivers&#39; repair needs, the sender can make use of the general erasure-filling capability of FEC-generated parity segments. The sender can determine the maximum erasure filling needs for individual FEC coding blocks from the NORM_NACK messages received during the repair aggregation period. Then, if the sender has a sufficient number (less than or equal to the maximum erasure count) of previously unsent parity segments available for the applicable coding blocks, the sender can transmit these in lieu of the specific packets the receiver set has requested. Only after exhausting its supply of &#34;fresh&#34; (unsent) parity segments for a given coding block should the sender resort to explicit transmission of the receiver set&#39;s repair needs. In general, if a sufficiently powerful FEC code is used, the need for explicit repair will be an exception, and the fulfillment of reliable multicast can be accomplished quite efficiently. However, the ability to resort to explicit repair allows the protocol to be reliable under even very extreme circumstances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMの送信者は、可能な限り修復のためのFECパリティコンテンツの伝送を活用すべきです。受信機はそのNORM_NACKメッセージの形成（パリティコンテンツを含む）明示的な修理の最小公分母を要求するための戦略を使用することを思い出してください。明示的に別の受信者の修理のニーズを満たすにフォールバックする前に、送信者は、FEC-生成したパリティセグメントの一般的な消去充填機能を利用することができます。送信者は、修理集計期間中に受信NORM_NACKメッセージからの個々のFEC符号化ブロックのニーズを充填最大消去を決定することができます。送信者は、十分な数（以下、最大消去回数に等しい）該当コーディングブロックのために利用可能な以前に未送信パリティセグメントを有する場合、送信者は受信セットが要求した特定のパケットの代わりにこれらを送信することができます。唯一の受信機セットの修理ニーズの明示的な送信に与えられた符号化ブロックのための「新鮮な」（未）パリティセグメントのその供給すべき送信者のリゾートを排出した後。十分に強力なFECコードが使用されている場合、一般的には、明示的な修理の必要性は例外となり、かつ信頼性の高いマルチキャストの実現は非常に効率的に達成することができます。しかし、明示的な修理に頼るする機能は、プロトコルにも非常に極端な状況下で信頼性が高いことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_DATA messages sent as repair transmissions SHALL be flagged with the NORM_FLAG_REPAIR flag. This allows receivers to obey any policies that limit new receivers from joining the reliable transmission when only repair transmissions have been received. Additionally, the sender SHOULD additionally flag NORM_DATA transmissions sent as explicit repair with the NORM_FLAG_EXPLICIT flag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
修理トランスミッションとして送らNORM_DATAメッセージがNORM_FLAG_REPAIRフラグとフラグが設定されるものとします。これは、受信機が唯一の修理送信が受信された信頼性の高い伝送に参加する新しい受信機を限定するすべてのポリシーを遵守することができます。また、送信者はNORM_FLAG_EXPLICITフラグを明示的に修理として送られ、更にフラグNORM_DATA送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although NORM end system receivers do not make use of the NORM_FLAG_EXPLICIT flag, this message transmission status could be leveraged by intermediate systems wishing to &#34;assist&#34; NORM protocol performance. If such systems are properly positioned with respect to reciprocal reverse-path multicast routing, they need to sub-cast only a sufficient count of non-explicit parity repairs to satisfy a multicast routing sub-tree&#39;s erasure filling needs for a given FEC coding block. When the sender has resorted to explicit repair, then the intermediate systems should sub-cast all of the explicit repair packets to those portions of the routing tree still requiring repair for a given coding block. Note the intermediate systems will be required to conduct repair state accumulation for sub-routes in a manner similar to the sender&#39;s repair state accumulation in order to have sufficient information to perform the sub-casting. Additionally, the intermediate systems could perform additional NORM_NACK suppression/aggregation as it conducts this repair state accumulation for NORM repair cycles. The detail of this type of operation are beyond the scope of this document, but this information is provided for possible future consideration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMエンドシステム受信機がNORM_FLAG_EXPLICITフラグを利用しないが、このメッセージの伝送状態は、NORMプロトコルのパフォーマンスを「支援」することを望む中間システムによって活用することができます。このようなシステムが適切に相互のリバースパスマルチキャストルーティングに対して位置決めされている場合、それらは与えられたFECブロック符号化のためのマルチキャストルーティングサブツリーの消去充填ニーズを満たすために非明示的なパリティ修理のサブキャストだけの十分な数にする必要があります。送信者は、明示的な修復に頼った場合、その後の中間システムが依然として所定の符号化ブロックの修復を必要とするルーティングツリーの部分に明示的な修復パケットの全サブキャストすべきです。注中間システムは、サブキャスティングを実行するのに十分な情報を有するために、送信者の修理状態蓄積と同様に、サブ経路の修復状態蓄積を行うために必要とされるであろう。それはNORM修理サイクルのこの修理状態の蓄積を行うように加え、中間システムは、追加のNORM_NACK抑制/集約を実行することができます。この種の動作の詳細は、この文書の範囲を超えていますが、この情報は、将来の検討のために提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.3. Sender NORM_CMD(SQUELCH) Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.3。送信者NORM_CMD（SQUELCH）の生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the sender receives a NORM_NACK message for repair of data it is no longer supporting, the sender generates a NORM_CMD(SQUELCH) message to advertise its repair window and squelch any receivers from additional NACKing of invalid data. The transmission rate of NORM_CMD(SQUELCH) messages is limited to once per 2*GRTT. The &#34;invalid_object_list&#34; (if applicable) of the NORM_CMD(SQUELCH) message SHALL begin with the lowest &#34;object_transport_id&#34; from the invalid NORM_NACK messages received since the last NORM_CMD(SQUELCH) transmission. Lower ordinal invalid &#34;object_transport_ids&#34; should be included only while the NORM_CMD(SQUELCH) payload is less than the sender&#39;s NormSegmentSize parameter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者は、それはもはやサポートされたデータの修復のためNORM_NACKメッセージを受信した場合、送信者は、その修理・ウィンドウを宣伝し、無効なデータの追加NACKingから任意の受信機をスケルチするNORM_CMD（SQUELCH）メッセージを生成します。 NORM_CMD（SQUELCH）メッセージの伝送レートは、一度に* GRTT 2当たり制限されています。 NORM_CMD（SQUELCH）メッセージの「invalid_object_list」は（該当する場合）最後NORM_CMD（SQUELCH）送信から受信した無効NORM_NACKメッセージから最下位「object_transport_id」で始まるものとします。下の序無効「object_transport_ids」NORM_CMD（SQUELCH）ペイロードは、送信者のNormSegmentSizeパラメータ未満である間だけ含まれるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.4. Sender NORM_CMD(REPAIR_ADV) Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4.4。送信者NORM_CMD（REPAIR_ADV）の生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a NORM sender receives NORM_NACK messages from receivers via unicast transmission, it uses NORM_CMD(REPAIR_ADV) messages to advertise its accumulated repair state to the receiver set since the receiver set is not directly sharing their repair needs via multicast communication. The NORM_CMD(REPAIR_ADV) message is multicast to the receiver set by the sender. The payload portion of this message has content in the same format as the NORM_NACK receiver message payload. Receivers are then able to perform feedback suppression in the same manner as with NORM_NACK messages directly received from other receivers. Note the sender does not merely retransmit NACK content it receives, but instead transmits a representation of its aggregated repair state. The transmission of NORM_CMD(REPAIR_ADV) messages are subject to the sender transmit rate limit and NormSegmentSize limitation. When the NORM_CMD(REPAIR_ADV) message is of maximum size, receivers SHALL consider the maximum ordinal transmission position value embedded in the message as the senders &#34;current&#34; transmission position and implicitly suppress requests for ordinally higher repair. For congestion control operation, the sender may also need to provide information so that dynamic congestion control feedback can be suppressed as needed among receivers. This document specifies the NORM-CC Feedback Header Extension that is applied for baseline NORM-CC operation. If other congestion control mechanisms are used within a NORM implementation, other header extensions may be defined. Whatever content format is used for this purpose should ensure that maximum possible suppression state is conveyed to the receiver set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM送信者は、ユニキャスト送信を介して受信機からNORM_NACKメッセージを受信すると、受信機セットは直接マルチキャスト通信を介して、それらの修復ニーズを共有していないので、設定受信機にその蓄積修復状態をアドバタイズするNORM_CMD（REPAIR_ADV）メッセージを使用します。 NORM_CMD（REPAIR_ADV）メッセージは、送信者によって設定された受信機にマルチキャストされます。このメッセージのペイロード部分はNORM_NACK受信メッセージペイロードと同じフォーマットでコンテンツを有しています。受信機は、直接他の受信機から受信NORM_NACKメッセージと同様に、フィードバック抑制を行うことが可能です。単にそれが受信するNACKコンテンツを再送信しない送信者に注意し、その代わりに、その凝集修復状態の表現を送信します。 NORM_CMDの送信（REPAIR_ADV）メッセージは、送信者、送信レート制限とNormSegmentSize制限の対象となっています。 NORM_CMD（REPAIR_ADV）メッセージが最大サイズである場合、受信機は送信者「現在」の送信位置としてメッセージに埋め込まれた最大順序送信位置値を考慮し、暗黙ordinally高い修復のための要求を抑制するものとします。輻輳制御動作のために、送信者はまた、受信機の間で必要に応じて動的輻輳制御フィードバックを抑制することができるように情報を提供する必要があるかもしれません。この文書では、ベースラインNORM-CC動作に適用されるNORM-CCフィードバックヘッダー拡張子を指定します。他の輻輳制御メカニズムがNORMの実装内で使用される場合、他のヘッダ拡張を定義することができます。どのようなコンテンツフォーマットは、受信機セットに搬送される可能な最大抑制状態を確認する必要があり、この目的のために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Additional Protocol Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。追加議定書のメカニズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition to the principal function of data content transmission and repair, there are some other protocol mechanisms that help NORM to adapt to network conditions and play fairly with other coexistent protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
データコンテンツ伝送および修理の主要な機能に加えて、NORMは、ネットワーク条件に適応し、他の共存プロトコルとかなりプレイするために役立ついくつかの他のプロトコルメカニズムがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.1. Greatest Round-trip Time Collection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.1。最大ラウンドトリップタイムコレクション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For NORM receivers to appropriately scale backoff timeouts and the senders to use proper corresponding timeouts, the participants must agree on a common timeout basis. Each NORM sender monitors the round-trip time of active receivers and determines the group greatest round-trip time (GRTT). The sender advertises this GRTT estimate in every message it transmits so that receivers have this value available for scaling their timers. To measure the current GRTT, the sender periodically sends NORM_CMD(CC) messages that contain a locally generated timestamp. Receivers are expected to record this timestamp along with the time the NORM_CMD(CC) message is received. Then, when the receivers generate feedback messages to the sender, an adjusted version of the sender timestamp is embedded in the feedback message (NORM_NACK or NORM_ACK). The adjustment adds the amount of time the receiver held the timestamp before generating its response. Upon receipt of this adjusted timestamp, the sender is able to calculate the round-trip time to that receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM受信機は適切にバックオフタイムアウトと送信者が適切に対応するタイムアウトを使用するように拡張するために、参加者は、一般的なタイムアウト基づいて同意しなければなりません。各NORM送信者は、アクティブ受信機の往復時間を監視し、グループ最大ラウンドトリップ時間（GRTT）を決定します。送信者は受信者が自分のタイマーをスケーリングするための可能なこの値を持つようにそれを送信したすべてのメッセージで、このGRTT推定値をアドバタイズします。現在のGRTTを測定するために、送信者は、定期的にローカルで生成されたタイムスタンプが含まれているNORM_CMD（CC）メッセージを送信します。受信機はNORM_CMD（CC）メッセージを受信した時間とともに、このタイムスタンプを記録することが期待されます。受信機は送信者にフィードバックメッセージを生成するときに、送信者のタイムスタンプの調整されたバージョンは、フィードバックメッセージ（NORM_NACK又はNORM_ACK）に埋め込まれています。調整は、受信機がその応答を生成する前にタイムスタンプを保持する時間を加算します。この調整されたタイムスタンプを受信すると、送信者はその受信機へのラウンドトリップ時間を計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The round-trip time for each receiver is fed into an algorithm that weights and smoothes the values for a conservative estimate of the GRTT. The algorithm and methodology are described in the NORM Building Block document [4] in the section entitled &#34;One-to-Many Sender GRTT Measurement&#34;. A conservative estimate helps feedback suppression at a small cost in overall protocol repair delay. The sender&#39;s current estimate of GRTT is advertised in the &#34;grtt&#34; field found in all NORM sender messages. The advertised GRTT is also limited to a minimum of the nominal inter-packet transmission time given the sender&#39;s current transmission rate and system clock granularity. The reason for this additional limit is to keep the receiver somewhat &#34;event driven&#34; by making sure the sender has had adequate time to generate any response to repair requests from receivers given transmit rate limitations due to congestion control or configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各受信機のためのラウンドトリップ時間は、GRTTの保守的な推定値を平滑化する重み付けアルゴリズムに供給されます。アルゴリズム及び方法は、「一対多送信者GRTT測定」と題されたセクションにNORMビルディングブロック文献[4]に記載されています。控えめな見積もりでは、全体的なプロトコル修復遅延の小さなコストでフィードバック抑制に役立ちます。 GRTTの送信者の現在の推定値は、すべてのNORMの送信者のメッセージで見つかった「GRTT」フィールドにアドバタイズされます。宣伝GRTTも、送信者の現在の伝送速度とシステムクロックの細分与えられた名目上のパケット間の伝送時間の最小値に制限されています。この追加の制限の理由は、送信側が輻輳制御または構成による転送レートの限界与えられた受信機からの要求を修復するためにすべての応答を生成するための十分な時間があったことを確認することによって、やや「イベントドリブン」受信機を維持することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the NORM-CC Rate header extension is present in NORM_CMD(CC) messages, the receivers respond to NORM_CMD(CC) messages as described in Section 5.5.2, &#34;NORM Congestion Control Operation&#34;. The NORM_CMD(CC) messages are periodically generated by the sender as described for congestion control operation. This provides for proactive, but controlled, feedback from the group in the form of NORM_ACK messages. This provides for GRTT feedback even if no NORM_NACK messages are being sent. If operating without congestion control in a closed network, the NORM_CMD(CC) messages may be sent periodically without the NORM-CC Rate header extension. In this case, receivers will only provide GRTT measurement feedback when NORM_NACK messages are generated since no NORM_ACK messages are generated. In this case, the NORM_CMD(CC) messages may be sent less frequently, perhaps as little as once per minute, to conserve network capacity. Note that the NORM-CC Rate header extension may also be used proactively solicit RTT feedback from the receiver group per congestion control operation even though the sender may not be conducting congestion control rate adjustment. NORM operation without congestion control should be considered only in closed networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM-CCレートヘッダ拡張がNORM_CMD（CC）メッセージに存在する場合、セクション5.5.2、「NORM輻輳制御動作」で説明したように、受信機はNORM_CMD（CC）メッセージに応答します。輻輳制御動作について説明したようにNORM_CMD（CC）メッセージを定期的に送信者によって生成されます。これは、積極的なのために提供していますが、NORM_ACKメッセージの形式でグループから、フィードバックを制御しました。これは何のNORM_NACKメッセージが送信されていないされている場合でも、GRTTのフィードバックを提供します。閉じたネットワークの輻輳制御なしで動作する場合、NORM_CMD（CC）メッセージをNORM-CCレートヘッダ拡張なしに定期的に送信することができます。何NORM_ACKメッセージが生成されないのでNORM_NACKメッセージが生成されるとき、この場合、受信機は、GRTT測定フィードバックを提供します。この場合、NORM_CMD（CC）メッセージは、ネットワーク容量を節約するために、おそらくはわずか1分当たり、より少ない頻度で送信されても​​よいです。 NORM-CCレートヘッダ拡張も積極的に使用される送信者が輻輳制御速度調整を行ってもいなくても、輻輳制御動作ごとに受信グループからRTTフィードバックを求めることができることに留意されたいです。輻輳制御なしNORM操作は、閉じたネットワークで考慮されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2. NORM Congestion Control Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2。 NORM輻輳制御動作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes baseline congestion control operation for the NORM protocol (NORM-CC). The supporting NORM message formats and approach described here are an adaptation of the equation-based TCP-Friendly Multicast Congestion Control (TFMCC) approach described in [19]. This congestion control scheme is REQUIRED for operation within the general Internet unless the NORM implementation is adapted to use another IETF-sanctioned reliable multicast congestion control mechanism (e.g., PGMCC [20]). With this TFMCC-based approach, the transmissions of NORM senders are controlled in a rate-based manner as opposed to window-based congestion control algorithms as in TCP. However, it is possible that the NORM protocol message set may alternatively be used to support a window-based multicast congestion control scheme such as PGMCC. The details of that alternative may be described separately or in a future revision of this document. In either case (rate-based TFMCC or window-based PGMCC), successful control of sender transmission depends upon collection of sender-to-receiver packet loss estimates and RTTs to identify the congestion control bottleneck path(s) within the multicast topology and adjust the sender rate accordingly. The receiver with loss and RTT estimates that correspond to the lowest result transmission rate is identified as the &#34;current limiting receiver&#34; (CLR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、NORMプロトコル（NORM-CC）のベースライン輻輳制御動作を説明します。ここで説明する支持NORMメッセージフォーマットと手法は、[19]に記載の式ベースのTCPフレンドリーマルチキャスト輻輳制御（TFMCC）アプローチの適応です。 NORM実装は別のIETF公認信頼性マルチキャスト輻輳制御機構を使用するように適合されていない限り、この輻輳制御方式が一般的なインターネット内での動作のために必要とされる（例えば、PGMCC [20]）。 TCPのようなウィンドウベースの輻輳制御アルゴリズムとは対照的に、このTFMCCベースのアプローチを用いて、NORMの送信者の送信は、レートベースの方法で制御されます。しかし、NORMプロトコルメッセージセットは代替的PGMCCとしてウィンドウベースのマルチキャスト輻輳制御方式をサポートするために使用される可能性があります。その代替の詳細が別々にまたは本文書の将来の改訂で説明することができます。いずれの場合（レートベースTFMCCまたはウィンドウベースPGMCC）において、送信側の送信の成功した制御は、マルチキャストトポロジ内の輻輳制御ボトルネックパス（複数可）を識別し、調整するために、送信者 - 受信器パケット損失の推定値とのRTTの収集に依存しますそれに応じて、送信者の割合。損失と最小結果送信レートに対応するRTT推定値を用いて受信機は、「電流制限受信」（CLR）として識別されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As described in [21], a steady-state sender transmission rate, to be &#34;friendly&#34; with competing TCP flows can be calculated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[21]、定常状態の送信元送信レートに記載の競合TCPフローとの「友好的」であるとして計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                       S
Rsender = --------------------------------------------------------------
          tRTT * (sqrt((2/3)*p) + 12 * sqrt((3/8)*p) * p *
          (1 + 32*(p^2)))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
どこ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
S = Nominal transmitted packet size. (In NORM, the &#34;nominal&#34; packet size can be determined by the sender as an exponentially weighted moving average (EWMA) of transmitted packet sizes to account for variable message sizes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
S =公称送信するパケットのサイズ。 （NORMにおいて、「公称」パケット・サイズは次のように送信者によって決定することができ、指数関数的に可変メッセージサイズを考慮して送信パケットサイズの平均（EWMA）を移動重み付け）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
tRTT = The RTT estimate of the current &#34;current limiting receiver&#34; (CLR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
tRTTは、現在の「電流制限受信」（CLR）のRTT推定値を=。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
p = The loss event fraction of the CLR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
pはCLRの損失事象の割合を=。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To support congestion control feedback collection and operation, the NORM sender periodically transmits NORM_CMD(CC) command messages. NORM_CMD(CC) messages are multiplexed with NORM data and repair transmissions and serve several purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳制御フィードバックの収集と操作をサポートするために、NORMの送信者は、定期的にNORM_CMD（CC）コマンドメッセージを送信します。 NORM_CMD（CC）メッセージは、NORMデータおよび修理の送信と多重化し、いくつかの目的を果たすされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) Stimulate explicit feedback from the general receiver set to collect congestion control information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）輻輳制御情報を収集するように設定する一般的な受信機からの明示的フィードバックを刺激します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) Communicate state to the receiver set on the sender&#39;s current congestion control status including details of the CLR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）CLRの詳細を含め、送信者の現在の輻輳制御状態に設定された受信機に状況を伝えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) Initiate rapid (immediate) feedback from the CLR in order to closely track the dynamics of congestion control for that current &#34;worst path&#34; in the group multicast topology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3）密接にグループマルチキャストトポロジーにおけるその現在の「最悪の経路」の輻輳制御のダイナミクスを追跡するために、CLRからの迅速な（即時の）フィードバックを開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The format of the NORM_CMD(CC) message is describe in Section 4.2.3 of this document. The NORM_CMD(CC) message contains information to allow measurement of RTTs, to inform the group of the congestion control CLR, and to provide feedback of individual RTT measurements to the receivers in the group. The NORM_CMD(CC) also provides for exciting feedback from OPTIONAL &#34;potential limiting receiver&#34; (PLR) nodes that may be determined administratively or possibly algorithmically based on congestion control feedback. PLR nodes are receivers that have been identified to have potential for (perhaps soon) becoming the CLR and thus immediate, up-to-date feedback is beneficial for congestion control performance. The details of PLR selection are not discussed in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（CC）メッセージのフォーマットは、このドキュメントのセクション4.2.3に記載してあります。 NORM_CMD（CC）メッセージは、輻輳制御CLRのグループに知らせるために、グループ内の受信機に個々のRTT測定値のフィードバックを提供するために、のRTTの測定を可能にする情報を含みます。 NORM_CMD（CC）は、輻輳制御フィードバックに基づいて、アルゴリズム管理または場合によって決定されてもよいOPTIONAL「電位制限受信」（PLR）ノードからの励起のフィードバックを提供します。 PLRノードがCLRので、即時になってきて（おそらくもうすぐ）の可能性を持つことが確認されている受信機は、最新のフィードバックは、輻輳制御性能のために有益です。 PLRの選択の詳細は、このドキュメントで説明されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2.1. NORM_CMD(CC) Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2.1。 NORM_CMD（CC）の送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(CC) message is transmitted periodically by the sender along with its normal data transmission. Note that the repeated transmission of NORM_CMD(CC) messages may be initiated some time before transmission of user data content at session startup. This may be done to collect some estimation of the current state of the multicast topology with respect to group and individual RTT and congestion control state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（CC）メッセージは、その通常のデータ送信と共に送信者によって定期的に送信されます。 NORM_CMD（CC）メッセージの繰り返し送信がセッションの起動時にユーザデータコンテンツの送信前にいくつかの時間を開始することができることに注意してください。これは、マルチキャストグループに対して、個々のRTTとトポロジーと輻輳制御状態の現在の状態のいくつかの推定を収集するために行われてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A NORM_CMD(CC) message is immediately transmitted at sender startup. The interval of subsequent NORM_CMD(CC) message transmission is determined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（CC）メッセージはすぐに送信者の起動時に送信されます。次のように後続NORM_CMD（CC）メッセージ送信の間隔が決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) By default, the interval is set according to the current sender GRTT estimate. A startup GRTT of 0.5 seconds is recommended when no feedback has yet been received from the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）デフォルトでは、間隔は、現在の送信者GRTT推定値に応じて設定されます。何のフィードバックはまだグループから受信されていない場合0.5秒の起動GRTTが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) If a CLR has been identified (based on previous receiver feedback), the interval is the RTT between the sender and CLR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLR）は以前受信機からのフィードバックに基づいて（特定された場合2）、間隔は、送信者とCLR間のRTTです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) Additionally, if the interval of nominal data message transmission is greater than the GRTT or RTT_clr interval, the NORM_CMD(CC) interval is set to this greater value. This ensures that the transmission of this control message is not done to the exclusion of user data transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
名目上のデータメッセージ送信の間隔がGRTT又はRTT_clr間隔より大きい場合3）また、NORM_CMD（CC）の間隔は、この大きな値に設定されています。これは、この制御メッセージの送信は、ユーザデータの送信を除外して行われていないことを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM_CMD(CC) &#34;cc_sequence&#34; field is incremented with each transmission of a NORM_CMD(CC) command. The greatest &#34;cc_sequence&#34; recently received by receivers is included in their feedback to the sender. This allows the sender to determine the &#34;age&#34; of feedback to assist in congestion avoidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（CC）「cc_sequence」フィールドはNORM_CMD（CC）コマンドのそれぞれの送信でインクリメントされます。最近、受信機で受信した最大の「cc_sequenceは、」送信者へのフィードバックに含まれています。これは、送信者が輻輳回避を支援するためにフィードバックの「年齢」を決定することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM-CC Rate Header Extension is applied to the NORM_CMD(CC) message and the sender advertises its current transmission rate in the &#34;send_rate&#34; field. The rate information is used by receivers to initialize loss estimation during congestion control startup or restart.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM-CCレートヘッダー拡張がNORM_CMD（CC）メッセージに適用され、送信者が「send_rate」フィールドに、現在の伝送速度をアドバタイズします。レート情報は、輻輳制御の起動または再起動時に損失推定を初期化するために受信機によって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_node_list&#34; contains a list of entries identifying receivers and their current congestion control state (status &#34;flags&#34;, &#34;rtt&#34; and &#34;loss&#34; estimates). The list may be empty if the sender has not yet received any feedback from the group. If the sender has received feedback, the list will minimally contain an entry identifying the CLR. A NORM_FLAG_CC_CLR flag value is provided for the &#34;cc_flags&#34; field to identify the CLR entry. It is RECOMMENDED that the CLR entry be the first in the list for implementation efficiency. Additional entries in the list are used to provide sender-measured individual RTT estimates to receivers in the group. The number of additional entries in this list is dependent upon the percentage of control traffic the sender application is willing to send with respect to user data message transmissions. More entries in the list may allow the sender to be more responsive to congestion control dynamics. The length of the list may be dynamically determined according to the current transmission rate and scheduling of NORM_CMD(CC) messages. The maximum length of the list corresponds to the sender&#39;s NormSegmentSize parameter for the session. The inclusion of additional entries in the list based on receiver feedback are prioritized with following rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_node_list」は受信機と、現在の輻輳制御状態（ステータス「フラグ」、「RTT」と「損失」の推定値）を識別するエントリのリストを含みます。送信者がまだグループからのフィードバックを受け取っていない場合は、リストは空でもよいです。送信者がフィードバックを受信した場合、リストは最小限にCLRを特定するエントリが含まれています。 NORM_FLAG_CC_CLRフラグ値がCLRエントリを識別するために「cc_flags」フィールドのために提供されます。 CLRエントリが実装効率のためのリストの最初のすることをお勧めします。リスト内の追加のエントリは、RTTは、グループ内の受信者に推定し、送信者、個々の測定を提供するために使用されています。このリストの追加エントリの数は、送信側アプリケーションは、ユーザデータのメッセージ送信に関して送って喜んで制御トラフィックの割合に依存しています。リストに複数のエントリは、送信側が輻輳制御のダイナミクスにより応答することができるようにしてもよいです。リストの長さを動的NORM_CMD（CC）メッセージの現在の伝送レートとスケジューリングに応じて決定することができます。リストの最大長はセッションのために、送信者のNormSegmentSizeパラメータに対応します。受信機からのフィードバックに基づいてリストに追加エントリを含めることは、次のルールに優先順位付けされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) Receivers that have not yet been provided RTT feedback get first priority. Of these, those with the greatest loss fraction receive precedence for list inclusion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）まだRTTフィードバックを提供されていない受信機は、最初の優先順位を取得します。これらのうち、最大の損失割合のものが、リストの包含のための優先順位を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) Secondly, receivers that have previously been provided RTT are included with receivers yielding the lowest calculated congestion rate getting precedence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）第二に、以前にRTTを提供されている受信機は、受信機が最も低い計算された輻輳速度取得優先順位をもたらすに含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are &#34;cc_flag&#34; values in addition to NORM_FLAG_CC_CLR that are used for other congestion control functions. The NORM_FLAG_CC_PLR flag value is used to mark additional receivers from that the sender would like to have immediate, non-suppressed feedback. These may be receivers that the sender algorithmically identified as potential future CLRs or that have been pre-configured as potential congestion control points in the network. The NORM_FLAG_CC_RTT indicates the validity of the &#34;cc_rtt&#34; field for the associated receiver node. Normally, this flag will be set since the receivers in the list will typically be receivers from which the sender has received feedback. However, in the case that the NORM sender has been pre-configured with a set of PLR nodes, feedback from those receivers may not yet have been collected and thus the &#34;cc_rtt&#34; and &#34;cc_rate&#34; fields do not contain valid values when this flag is not set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
他の輻輳制御機能に使用されているNORM_FLAG_CC_CLRに加えて、「cc_flag」の値があります。 NORM_FLAG_CC_PLRフラグ値は送信者が即時、非抑制フィードバックしたいと思うことから、追加の受信機をマークするために使用されます。これらは、送信者がアルゴリズム将来のCLRとして同定又はネットワーク内の潜在的な輻輳制御ポイントとして事前に設定されていることことを受信機であってもよいです。 NORM_FLAG_CC_RTTは、関連する受信ノードのための「cc_rtt」フィールドの有効性を示しています。リスト内の受信機は、典型的には、送信者がフィードバックを受信し、そこから受信することになるので、通常、このフラグがセットされます。しかし、NORM送信者がPLRノードのセットと事前に設定された場合には、それらの受信機からのフィードバックはまだ収集されていないかもしれないとき、このフラグ従って「cc_rtt」および「cc_rate」フィールドは、有効な値が含まれていません設定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2.2. NORM_CMD(CC) Feedback Response
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2.2。 NORM_CMD（CC）フィードバック応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Receivers explicitly respond to NORM_CMD(CC) messages in the form of a NORM_ACK(RTT) message. The goal of the congestion control feedback is to determine the receivers with the lowest congestion control rates. Receivers that are marked as CLR or PLR nodes in the NORM_CMD(CC) &#34;cc_node_list&#34; immediately provide feedback in the form of a NORM_ACK to this message. When a NORM_CMD(CC) is received, non-CLR or non-PLR nodes initiate random feedback backoff timeouts similar to that used when the receiver initiates a repair cycle (see Section 5.3) in response to detection of data loss. The backoff timeout for the congestion control response is generated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レシーバは、明示的にNORM_ACK（RTT）メッセージの形でNORM_CMD（CC）メッセージに応答します。輻輳制御フィードバックの目標は、最低の輻輳制御率と受信機を決定することです。 NORM_CMD（CC）「cc_node_list」にCLRまたはPLRノードとしてマークされている受信機はすぐにこのメッセージにNORM_ACKの形でフィードバックを提供します。 NORM_CMD（CC）を受信したとき、非CLRまたは非PLRノードがランダム開始フィードバックバックオフは、データ損失の検出に応答して（セクション5.3を参照）受信機は修復サイクルを開始するときに使用されるものと同様のタイムアウト。次のように輻輳制御応答のためのバックオフタイムアウトが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_backoff = RandomBackoff(K*GRTTsender, GSIZEsender)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_backoff = RandomBackoff（K * GRTTsender、GSIZEsender）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;RandomBackoff()&#34; algorithm provides a truncated exponentially distributed random number and is described in the NORM Building Block document [4]. The same backoff factor K = Ksender MAY be used as with NORM_NACK suppression. However, in cases where the application purposefully specifies a very small Ksender backoff factor to minimize the NACK repair process latency (trading off group size scalability), it may still be desirable to maintain a larger backoff factor for congestion control feedback, since there may often be a larger volume of congestion control feedback than NACKs in many cases and congestion control feedback latency may be tolerable where reliable delivery latency is not. As previously noted, a backoff factor value of K = 4 is generally recommended for ASM operation and K = 6 for SSM operation. A receiver SHALL cancel the backoff timeout and thus its pending transmission of a NORM_ACK(RTT) message under the following conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「RandomBackoff（）」アルゴリズムは、切り捨てられた指数分布乱数を提供し、NORMビルディングブロックの文書に記載されている[4]。同一のバックオフファクタK = KsenderはNORM_NACK抑制有するとして使用することができます。しかし、アプリケーションが意図的に（グループサイズのスケーラビリティをトレードオフ）NACK修復プロセスの待ち時間を最小限に抑えるために、非常に小さなKsenderバックオフファクタを指定する場合には、まだ多くの場合、そこに可能性があるため、輻輳制御フィードバックのためのより大きなバックオフ因子を維持することが望ましいかもしれません信頼できる配信待ち時間がない場合、より大きな多くの場合のNACKより輻輳制御フィードバックの量と輻輳制御フィードバック待ち時間が許容することができること。先に述べたように、K = 4のバックオフファクタ値は、一般に、SSMの動作のためのASM動作及びK = 6のために推奨されています。受信機は、以下の条件でバックオフタイムアウトとNORM_ACK（RTT）のため、その保留中の送信メッセージをキャンセルしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) The receiver generates another feedback message (NORM_NACK or other NORM_ACK) before the congestion control feedback timeout expires,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）受信機は、輻輳制御フィードバックタイムアウトが満了する前に、別のフィードバックメッセージ（NORM_NACKまたは他のNORM_ACK）を生成します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) A NORM_CMD(CC) or other receiver feedback with an ordinally greater &#34;cc_sequence&#34; field value is received before the congestion control feedback timeout expires (this is similar to the TFMCC feedback round number),
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）A NORM_CMD（CC）又はordinally大きい「cc_sequence」フィールド値を有する他の受信機からのフィードバックは、（これはTFMCCフィードバックラウンド数と同様である）の輻輳制御フィードバックタイムアウトが満了する前に受信されます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) When the T_backoff is greater than 1*GRTT. This prevents NACK implosion in the event of sender or network failure,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3）T_backoff 1つの*のGRTTよりも大きい場合。これは、送信者またはネットワークに障害が発生した場合にNACK爆縮を防止し、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4) &#34;Suppressing&#34; congestion control feedback is heard from another receiver (in a NORM_ACK or NORM_NACK) or via a NORM_CMD(REPAIR_ADV) message from the sender. The local receiver&#39;s feedback is &#34;suppressed&#34; if the rate of the competing feedback (Rfb) is sufficiently close to or less than the local receiver&#39;s calculated rate (Rcalc). The local receiver&#39;s feedback is canceled when:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4）「抑制」輻輳制御フィードバックはNORM_ACK又はNORM_NACKにおける別の受信機（から）または送信者からNORM_CMD（REPAIR_ADV）メッセージを介して、聞こえます。競合フィードバック（Rfbを）の速度が十分に近い、またはローカル受信機の計算速度（Rcalc）未満である場合、ローカル受信機のフィードバックが「抑制」されています。ローカル受信者のフィードバックが解除され：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rcalc &gt; (0.9 * Rfb)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rcalc&gt;（0.9×Rfbを）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Also note receivers that have not yet received an RTT measurement from the sender are suppressed only by other receivers that have not yet measured RTT. Additionally, receivers whose RTT estimate has &#34;aged&#34; considerably (i.e., they haven&#39;t been included in the NORM_CMD(CC) &#34;cc_node_list&#34; in a long time) may wish to compete as a receiver with no prior RTT measurement after some expiration period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、まだのみまだRTTを測定していない他の受信機によって抑制されている送信者からのRTT測定値を受信して​​いない受信機に注意してください。持っている「高齢者が」かなり（すなわち、彼らは長い時間でNORM_CMD（CC）「cc_node_list」には含まれていない）また、そのRTT推定受信機は、いくつかの有効期限後に事前RTTの測定と受信機と競争することを望むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the backoff timer expires, the receiver SHALL generate a NORM_ACK(RTT) message to provide feedback to the sender and group. This message may be multicast to the group for most effective suppression in ASM topologies or unicast to the sender depending upon how the NORM protocol is deployed and configured.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バックオフタイマが満了すると、受信機は、送信者とグループにフィードバックを提供するNORM_ACK（RTT）メッセージを生成しなければなりません。このメッセージは、ASMトポロジ又はNORMプロトコルが展開され、構成されている方法に応じて、送信者へのユニキャストで最も効果的な抑制のためにグループにマルチキャストすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Whenever any feedback is generated (including this NORM_ACK(RTT) message), receivers include an adjusted version of the sender timestamp from the most recently received NORM_CMD(CC) message and the &#34;cc_sequence&#34; value from that command in the applicable NORM_ACK or NORM_NACK message fields. For NORM-CC operation, any generated feedback message SHALL also contain the NORM-CC Feedback header extension. The receiver provides its current &#34;cc_rate&#34; estimate, &#34;cc_loss&#34; estimate, &#34;cc_rtt&#34; if known, and any applicable &#34;cc_flags&#34; via this header extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
任意のフィードバックは（このNORM_ACK（RTT）メッセージを含む）が生成されるたびに、受信機は、最も最近適用NORM_ACK又はNORM_NACKメッセージにそのコマンドからNORM_CMD（CC）メッセージと「cc_sequence」値を受信から送信元のタイムスタンプの調整されたバージョンを含みますフィールド。 NORM-CC動作のために、任意の生成されたフィードバック・メッセージはまた、NORM-CCフィードバックヘッダ拡張を含まなければなりません。受信機は、このヘッダー拡張を介して現在の「cc_rate」推定既知の場合、「cc_loss」推定値「cc_rtt」、および該当する「cc_flags」を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
During slow start (when the receiver has not yet detected loss from the sender), the receiver uses a value equal to two times its measured rate from the sender in the &#34;cc_rate&#34; field. For steady-state congestion control operation, the receiver &#34;cc_rate&#34; value is from the equation-based value using its current loss event estimate and sender&lt;-&gt;receiver RTT information. (The GRTT is used when the receiver has not yet measured its individual RTT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
（受信機がまだ送信者からの損失を検出していない）スロースタート時、受信機は、「cc_rate」フィールドの送信者からの二度の測定速度に等しい値を使用します。 &lt; - &gt;受信RTT情報定常輻輳制御動作のために、受信機「cc_rate」値は、現在の損失事象推定値と送信者を使用して、方程式系の値です。 （受信機がまだその個々のRTTを測定していない場合GRTTが使用されます）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The &#34;cc_loss&#34; field value reflects the receiver&#39;s current loss event estimate with respect to the sender in question.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「cc_loss」フィールドの値は、問題の送信者に関する受信機の現在の損失事象の推定値を反映しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the receiver has a valid individual RTT measurement, it SHALL include this value in the &#34;cc_rtt&#34; field. The NORM_FLAG_CC_RTT MUST be set when the &#34;cc_rtt&#34; field is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
受信機が有効な個々のRTTの測定を持っているとき、それは「cc_rtt」フィールドにこの値を含まなければなりません。 「cc_rtt」フィールドが有効であるときNORM_FLAG_CC_RTTを設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
After a congestion control feedback message is generated or when the feedback is suppressed, a non-CLR receiver begins a &#34;holdoff&#34; timeout period during which it will restrain itself from providing congestion control feedback, even if NORM_CMD(CC) messages are received from the sender (unless the receive becomes marked as a CLR or PLR node). The value of this holdoff timeout (T_ccHoldoff) period is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
輻輳制御フィードバックメッセージが生成されるか、またはフィードバックが抑制される場合、非CLR受信機はNORM_CMD（CC）メッセージをから受信された場合でも、それが輻輳制御フィードバックを提供することから自分自身を抑制しますその間「ホールドオフ」タイムアウト期間を開始した後送信者（CLRまたはPLRノードとしてマークされてしまう受ける場合を除きます）。このホールドオフタイムアウト（T_ccHoldoff）期間の値です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_ccHoldoff = (K*GRTT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
T_ccHoldoff =（K * GRTT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Thus, non-CLR receivers are constrained to providing explicit congestion control feedback once per K*GRTT intervals. Note, however, that as the session progresses, different receivers will be responding to different NORM_CMD(CC) messages and there will be relatively continuous feedback of congestion control information while the sender is active.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
したがって、非CLR受信機は、K * GRTT間隔ごとに一度明示的輻輳制御フィードバックを提供することに制約されます。セッションが進行するにつれて、異なる受信機が異なるNORM_CMD（CC）メッセージに応答すると、送信者がアクティブである間輻輳制御情報の比較的連続的なフィードバックがあること、しかし、注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2.3. Congestion Control Rate Adjustment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.2.3。輻輳制御レート調整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
During steady-state operation, the sender will directly adjust its transmission rate to the rate indicated by the feedback from its currently selected CLR. As noted in [19], the estimation of parameters (loss and RTT) for the CLR will generally constrain the rate changes possible within acceptable bounds. For rate increases, the sender SHALL observe a maximum rate of increase of one packet per RTT at all times during steady-state operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
定常状態の動作時、送信側は、直接その現在選択されているCLRからのフィードバックによって示されるレートに対する伝送レートを調整します。 [19]で述べたように、CLRのパラメータ（損失とRTT）の推定は、一般的に許容される範囲内で可能な速度変化を抑制します。速度が増加するために、送信者は、定常状態動作中にすべての回でRTTごとに1つのパケットの増加の最大速度を遵守しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sender processes congestion control feedback from the receivers and selects the CLR based on the lowest rate receiver. Receiver rates are either determined directly from the slow start &#34;cc_rate&#34; provided by the receiver in the NORM-CC Feedback header extension or by performing the equation-based calculation using individual RTT and loss estimates (&#34;cc_loss&#34;) as feedback is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者は、受信機からの輻輳制御フィードバックを処理し、最低レート受信機に基づいてCLRを選択します。受信率がいずれかNORM-CCフィードバックヘッダ拡張またはフィードバックが受信されるように、個々のRTTおよび損失推定値を用いて、式ベースの計算（「cc_loss」）を行うことにより、受信機によって提供されるスロースタート「cc_rate」から直接決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sender can calculate a current RTT for a receiver (RTT_rcvrNew) using the &#34;grtt_response&#34; timestamp included in feedback messages. When the &#34;cc_rtt&#34; value in a response is not valid, the sender simply uses this RTT_rcvrNew value as the receiver&#39;s current RTT (RTT_rcvr). For non-CLR and non-PLR receivers, the sender can use the &#34;cc_rtt&#34; value provided in the NORM-CC Feedback header extension as the receiver&#39;s previous RTT measurement (RTT_rcvrPrev) to smooth according to:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信側はフィードバック・メッセージに含まれる「grtt_response」タイムスタンプを使用して、受信機（RTT_rcvrNew）の現在のRTTを算出することができます。応答で「cc_rtt」の値が有効でない場合は、送信者は、単に受信者の現在のRTT（RTT_rcvr）として、このRTT_rcvrNew値を使用しています。非CLRおよび非PLR受信機のために、送信者は、に応じて滑らかにするために受信機の前のRTT測定値（RTT_rcvrPrev）としてNORM-CCフィードバックヘッダ拡張内に設けられた「cc_rtt」値を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5 * RTT_rcvrNew
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5 * RTT_rcvrNew
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For CLR receivers where feedback is received more regularly, the sender SHOULD maintain a more smoothed RTT estimate upon new feedback from the CLR where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィードバックがより定期的に受信されたCLR受信機の場合、送信者はどこCLRから新しいフィードバックの際に、より平滑化RTT推定値を維持する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
&#34;RTT_clrNew&#34; is the new RTT calculated from the timestamp in the feedback message received from the CLR. The RTT_clr is initialized to RTT_clrNew on the first feedback message received. Note that the same procedure is observed by the sender for PLR receivers and that if a PLR is &#34;promoted&#34; to CLR status, the smoothed estimate can be continued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「RTT_clrNewは」CLRから受信したフィードバック・メッセージ中のタイムスタンプから計算された新たなRTTです。 RTT_clrは、受信した第1のフィードバックメッセージにRTT_clrNewに初期化されます。同じ手順がPLR受信機の送信者によって観察されることとPLRは、CLRのステータスに「昇格」されている場合、平滑化推定値は継続されることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are some additional periods besides steady-state operation that need to be considered in NORM-CC operation. These periods are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM-CCの操作で考慮する必要が定常状態動作のほかにいくつかの追加の期間があります。これらの期間は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) during session startup,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）セッションの起動時に、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) when no feedback is received from the CLR, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）は、フィードバックがCLRから受信されない場合、および
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) when the sender has a break in data transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
3）送信者は、データ伝送の中断がある場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
During session startup, the congestion control operation SHALL observe a &#34;slow start&#34; procedure to quickly approach its fair bandwidth share. An initial sender startup rate is assumed where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セッションの起動時には、輻輳制御動作が素早くその公平な帯域幅のシェアに近づくために、「スロースタート」の手順を遵守しなければなりません。最初の送信者の起動率が場合を想定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rinitial = MIN(NormSegmentSize / GRTT, NormSegmentSize) bytes/second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rinitial = MIN（NormSegmentSize / GRTT、NormSegmentSize）は、バイト/秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The rate is increased only when feedback is received from the receiver set. The &#34;slow start&#34; phase proceeds until any receiver provides feedback indicating that loss has occurred. Rate increase during slow start is applied as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
速度は、フィードバックは、受信機セットから受信された場合にのみ増加されます。 「スロースタート」位相進み任意の受信機までの損失が発生したことを示すフィードバックを提供します。スロースタート時のレートの増加は、次のように適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rnew = Rrecv_min
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Renno = Rishvmn
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
where &#34;Rrecv_min&#34; is the minimum reported receiver rate in the &#34;cc_rate&#34; field of congestion control feedback messages received from the group. Note that during &#34;slow start&#34;, receivers use two times their measured rate from the sender in the &#34;cc_rate&#34; field of their feedback. Rate increase adjustment is limited to once per GRTT during slow start.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「Rrecv_minは」輻輳制御フィードバックメッセージの「cc_rate」フィールド内の受信レートがグループから受信した最小値が報告されます。 「スロースタート」の間に、受信機は彼らのフィードバックの「cc_rate」フィールドの送信者からの2倍の測定レートを使用することに注意してください。レート増加調整はスロースタート時に一度GRTTごとに制限されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the CLR or any receiver intends to leave the group, it will set the NORM_FLAG_CC_LEAVE in its congestion control feedback message as an indication that the sender should not select it as the CLR. When the CLR changes to a lower rate receiver, the sender should immediately adjust to the new lower rate. The sender is limited to increasing its rate at one additional packet per RTT towards any new, higher CLR rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
CLRまたは任意の受信機がグループを離脱しようとする場合には、送信者がCLRとしてそれを選択しないことを示すものとして、その輻輳制御フィードバックメッセージにNORM_FLAG_CC_LEAVEを設定します。 CLRは、より低いレートの受信機に変更した場合、送信者はすぐに新しい、より低いレートに調整する必要があります。送信者は、新しい、より高CLR率の方RTTごとに追加のパケットでその速度を上げるに制限されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The sender should also track the &#34;age&#34; of the feedback it has received from the CLR by comparing its current &#34;cc_sequence&#34; value (Seq_sender) to the last &#34;cc_sequence&#34; value received from the CLR (Seq_clr). As the &#34;age&#34; of the CLR feedback increases with no new feedback, the sender SHALL begin reducing its rate once per RTT_clr as a congestion avoidance measure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者はまた、CLR（Seq_clr）から受信した最後の「cc_sequence」の値に、現在の「cc_sequence」値（Seq_sender）を比較することにより、CLRから受け取ったフィードバックの「年齢」を追跡する必要があります。 CLRのフィードバックの「年齢」は新しいフィードバックを増加すると、送信者は輻輳回避策として、一度RTT_clrあたりの速度を低下させる始めるものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The following algorithm is used to determine the decrease in sender rate (Rsender bytes/sec) as the CLR feedback, unexpectedly, excessively ages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
以下のアルゴリズムは、CLRのフィードバック、予期せず、過度の年齢として送信者率の低下（Rsenderバイト/秒）を決定するために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Age = Seq_sender - Seq_clr;
   if (Age &gt; 4) Rsender = Rsender * 0.5;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This rate reduction is limited to the lower bound on NORM transmission rate. After NORM_ROBUST_FACTOR consecutive NORM_CMD(CC) rounds without any feedback from the CLR, the sender SHOULD assume the CLR has left the group and pick the receiver with the next lowest rate as the new CLR. Note this assumes that the sender does not have explicit knowledge that the CLR intentionally left the group. If no receiver feedback is received, the sender MAY wish to withhold further transmissions of NORM_DATA segments and maintain NORM_CMD(CC) transmissions only until feedback is detected. After such a CLR timeout, the sender will be transmitting with a minimal rate and should return to slow start as described here for a break in data transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このレートの減少は、NORMの伝送速度の下限に制限されています。 NORM_ROBUST_FACTOR連続NORM_CMD（CC）は、CLRからのフィードバックなしラウンド後、送信者は、CLRがグループを離脱したと仮定して、新しいCLRなどの次に低いレートで受信機を選ぶべきです。これは送信者はCLRが意図的にグループを去ったことを明示的な知識を持っていないことを前提としています。全く受信フィードバックが受信されない場合、送信者はNORM_DATAセグメントの更なる送信を保留し、フィードバックが検出されるまでの間だけNORM_CMD（CC）の送信を維持することを望むかもしれません。このようCLRタイムアウトの後、送信者は最小限のレートで送信され、データ伝送の中断のために、ここで説明するように、開始を遅らせるために返す必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When the sender has a break in its data transmission, it can continue to probe the group with NORM_CMD(CC) messages to maintain RTT collection from the group. This will enable the sender to quickly determine an appropriate CLR upon data transmission restart. However, the sender should exponentially reduce its target rate to be used for transmission restart as time since the break elapses. The target rate SHOULD be recalculated once per RTT_clr as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
送信者はそのデータ伝送の中断を持っている場合は、グループからRTTコレクションを維持するためにNORM_CMD（CC）メッセージを持つグループを探査し続けることができます。これはすぐにデータ送信再開時に適切なCLRを決定するために、送信者が有効になります。しかし、指数関数的にその目標レートを減らす必要があり、送信者は、休憩の経過からの時間として送信再開に使用します。目標レートはRTT_clr一回として再計算する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rsender = Rsender * 0.5;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Rsender = Rsender * 0.5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the minimum NORM rate is reached, the sender should set the NORM_FLAG_START flag in its NORM_CMD(CC) messages upon restart and the group should observer &#34;slow start&#34; congestion control procedures until any receiver experiences a new loss event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
最小NORM率に達している場合は任意の受信機は、新たな損失事象を経験するまで、送信者は、再起動し、グループべきオブザーバ「スロースタート」輻輳制御手順時にそのNORM_CMD（CC）メッセージにNORM_FLAG_STARTフラグを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.3. NORM Positive Acknowledgment Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.3。 NORM肯定応答手順
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM provides options for the source application to request positive acknowledgment (ACK) of NORM_CMD(FLUSH) and NORM_CMD(ACK_REQ) messages from members of the group. There are some specific acknowledgment requests defined for the NORM protocol and a range of acknowledgment request types that are left to be defined by the application. One predefined acknowledgment type is the NORM_ACK_FLUSH type. This acknowledgment is used to determine if receivers have achieved completion of reliable reception up through a specific logical transmission point with respect to the sender&#39;s sequence of transmission. The NORM_ACK_FLUSH acknowledgment may be used to assist in application flow control when the sender has information on a portion of the receiver set. Another predefined acknowledgment type is NORM_ACK(CC), which is used to explicitly provide congestion control feedback in response to NORM_CMD(CC) messages transmitted by the sender for NORM-CC operation. Note the NORM_ACK(CC) response does NOT follow the positive acknowledgment procedure described here. The NORM_CMD(ACK_REQ) and NORM_ACK messages contain an &#34;ack_type&#34; field to identify the type of acknowledgment requested and provided. A range of &#34;ack_type&#34; values is provided for application-defined use. While the application is responsible for initiating the acknowledgment request and interprets application-defined &#34;ack_type&#34; values, the acknowledgment procedure
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMは、グループのメンバーからNORM_CMD（FLUSH）とNORM_CMD（ACK_REQ）メッセージの肯定応答（ACK）を要求するソース・アプリケーションのためのオプションを提供します。 NORMプロトコルおよびアプリケーションによって定義されるように残っている承認要求タイプの範囲に対して定義されたいくつかの特定の承認要求があります。一つの定義済みの承認タイプはNORM_ACK_FLUSHタイプです。この肯定応答は受信機がアップ送信の送信者の配列に対して特定の論理伝送ポイントを介して信頼性の高い受信が完了したことを達成しているかどうかを決定するために使用されます。送信者が受信機のセットの部分に関する情報を有する場合NORM_ACK_FLUSH確認は、アプリケーションフロー制御を支援するために使用されてもよいです。別の事前定義された承認タイプは、明示的NORM-CC動作のために送信者によって送信さNORM_CMD（CC）メッセージに応答して、輻輳制御フィードバックを提供するために使用されるNORM_ACK（CC）、です。 NORM_ACK（CC）レスポンスは、ここで説明した肯定応答手順に従っていません。 NORM_CMD（ACK_REQ）とNORM_ACKメッセージが確認応答要求と提供の種類を識別するために、「ack_type」フィールドが含まれています。 「ack_type」の値の範囲は、アプリケーション定義の使用のために提供されます。アプリケーションが承認要求を開始する責任があるとアプリケーションで定義された「ack_type」値、承認手続きを解釈しながら、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
SHOULD be conducted within the protocol implementation to take advantage of timing and transmission scheduling information available to the NORM transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM輸送に利用可能なタイミング及び送信スケジューリング情報を利用するために、プロトコルの実装内で行われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The NORM positive acknowledgment procedure uses polling by the sender to query the receiver group for response. Note this polling procedure is not intended to scale to very large receiver groups, but could be used in large group setting to query a critical subset of the group. Either the NORM_CMD(ACK_REQ), or when applicable, the NORM_CMD(FLUSH) message is used for polling and contains a list of NormNodeIds for receivers that should respond to the command. The list of receivers providing acknowledgment is determined by the source application with &#34;a priori&#34; knowledge of participating nodes or via some other application-level mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM肯定応答手順は、応答を受信グループを照会するために送信者によってポーリングを使用しています。このポーリング手順を注意してください非常に大規模な受信機のグループに拡大するものではありませんが、グループの重要なサブセットを照会するために大規模なグループ設定に使用することができます。どちらのNORM_CMD（ACK_REQ）、または該当する場合は、NORM_CMD（FLUSH）メッセージをポーリングするために使用して、コマンドに応答すべき受信機のためのNormNodeIdsのリストが含まれています。肯定応答を提供する受信機のリストは、参加ノードの「先験的」知識で、または他の何らかのアプリケーションレベルのメカニズムを介してソースアプリケーションによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ACK process is initiated by the sender that generates NORM_CMD(FLUSH) or NORM_CMD(ACK_REQ) messages in periodic &#34;rounds&#34;. For NORM_ACK_FLUSH requests, the NORM_CMD(FLUSH) contain a &#34;object_transport_id&#34; and &#34;fec_payload_id&#34; denoting the watermark transmission point for which acknowledgment is requested. This watermark transmission point is &#34;echoed&#34; in the corresponding fields of the NORM_ACK(FLUSH) message sent by the receiver in response. NORM_CMD(ACK_REQ) messages contain an &#34;ack_id&#34; field which is similarly &#34;echoed&#34; in response so that the sender may match the response to the appropriate request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACKプロセスはNORM_CMD（FLUSH）またはNORM_CMD（ACK_REQ）定期的な「ラウンド」でメッセージを生成し、送信者によって開始されます。 NORM_ACK_FLUSH要求に対して、NORM_CMD（FLUSH）は、肯定応答が要求された透かしの送信点を示す「object_transport_id」および「fec_payload_id」を含みます。この透かし伝送ポイントが応答して、受信機によって送信されたNORM_ACK（FLUSH）メッセージの対応するフィールドに「エコー」されています。 NORM_CMD（ACK_REQ）メッセージは、送信者が適切な要求に対する応答を一致させることができるように対応して「エコー」と同様である「ack_id」フィールドを含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In response to the NORM_CMD(ACK_REQ), the listed receivers randomly spread NORM_ACK messages uniformly in time over a window of (1*GRTT). These NORM_ACK messages are typically unicast to the sender. (Note that NORM_ACK(CC) messages SHALL be multicast or unicast in the same manner as NORM_NACK messages).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM_CMD（ACK_REQ）に応答して、リストされている受信機は、ランダム（1 * GRTT）のウィンドウにわたって時間的に均一NORM_ACKメッセージを広めます。これらのNORM_ACKのメッセージは通常、送信者にユニキャストされています。 （NORM_ACK（CC）メッセージはNORM_NACKメッセージと同様に、マルチキャストまたはユニキャストされなければならないことに留意されたいです）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The ACK process is self-limiting and avoids ACK implosion in that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ACKプロセスは自己制限であり、その中にACK内部破裂を回避します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) Only a single NORM_CMD(ACK_REQ) message is generated once per (2*GRTT), and,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）のみを単一NORM_CMD（ACK_REQ）メッセージは、一度2 * GRTT）（あたりに生成され、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) The size of the &#34;acking_node_list&#34; of NormNodeIds from which acknowledgment is requested is limited to a maximum of the sender NormSegmentSize setting per round of the positive acknowledgment process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2）確認応答が要求されたNormNodeIdsの「acking_node_list」のサイズは、肯定応答プロセスのラウンドあたりの送信元NormSegmentSize設定の最大値に制限されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because the size of the included list is limited to the sender&#39;s NormSegmentSize setting, multiple NORM_CMD(ACK_REQ) rounds may be required to achieve responses from all receivers specified. The content of the attached NormNodeId list will be dynamically updated as this process progresses and NORM_ACK responses are received from the specified receiver set. As the sender receives valid responses (i.e., matching watermark point or &#34;ack_id&#34;) from receivers, it SHALL eliminate those receivers from the subsequent NORM_CMD(ACK_REQ) message &#34;acking_node_list&#34; and add in any pending receiver NormNodeIds while keeping within the NormSegmentSize limitation of the list size. Each receiver is queried a maximum number of times (NORM_ROBUST_FACTOR, by default). Receivers not responding within this number of repeated requests are removed from the payload list to make room for other potential receivers pending acknowledgment. The transmission of the NORM_CMD(ACK_REQ) is repeated until no further responses are required or until the repeat threshold is exceeded for all pending receivers. The transmission of NORM_CMD(ACK_REQ) or NORM_CMD(FLUSH) messages to conduct the positive acknowledgment process is multiplexed with ongoing sender data transmissions. However, the NORM_CMD(FLUSH) positive acknowledgment process may be interrupted in response to negative acknowledgment repair requests (NACKs) received from receivers during the acknowledgment period. The NORM_CMD(FLUSH) positive acknowledgment process is restarted for receivers pending acknowledgment once any the repairs have been transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付属リストのサイズは、送信者のNormSegmentSize設定に制限されているため、複数のNORM_CMD（ACK_REQ）のラウンドは、指定されたすべての受信機からの応答を達成するために必要とすることができます。添付NormNodeIdリストの内容は、このプロセスが進むにつれて動的に更新され、NORM_ACK応答は、指定された受信機のセットから受信されています。送信者が受信機から有効な応答（すなわち、一致する透かしポイントまたは「ack_id」）を受信すると、それ以降のNORM_CMD（ACK_REQ）メッセージ「acking_node_list」からの受信機を排除SHALLとのNormSegmentSize制限内に保ちながら、保留中の受信機NormNodeIdsに追加しますリストのサイズ。各受信機は、（デフォルトでは、NORM_ROBUST_FACTOR）最大回数を照会されます。再三の要求のこの数の中に応答しない受信機は承認保留中の他の潜在的な受信機のための余地を作るために、ペイロードリストから削除されます。 NORM_CMD（ACK_REQ）の送信は、さらなる応答が必要とされなくなるまで、または反復しきい値はすべての保留中の受信機のために超過するまで繰り返されます。肯定応答処理を行うNORM_CMD（ACK_REQ）またはNORM_CMD（FLUSH）メッセージの送信が進行中の送信側データ伝送と多重化されます。しかしながら、肯定応答プロセスが否定応答修復要求（NACK信号）に応答して中断されていてもよいNORM_CMD（FLUSH）は、確認応答期間中に受信機から受信しました。 NORM_CMD（FLUSH）肯定応答プロセスは、任意の修理が送信された後、承認を保留中の受信機のために再起動されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In the case of NORM_CMD(FLUSH) commands with an attached &#34;acking_node_list&#34;, receivers will not ACK until they have received complete transmission of all data up to and including the given watermark transmission point. All receivers SHALL interpret the watermark point provided in the request NACK for repairs if needed as for NORM_CMD(FLUSH) commands with no attached &#34;acking_node_list&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
彼らはまでのすべてのデータの完全な送信を受信し、指定された透かしの送信点を含むまでNORM_CMD（FLUSH）の場合には受信機がACKず、添付の「acking_node_list」と指示します。すべてのレシーバはNORM_CMD（FLUSH）用として必要に応じて、修理のために要求NACKで提供透かしポイントなし添付の「acking_node_list」とコマンドを解釈するものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.4. Group Size Estimate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5.4。グループサイズの見積もり
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORM sender messages contain a &#34;gsize&#34; field that is a representation of the group size and is used in scaling random backoff timer ranges. The use of the group size estimate within the NORM protocol does not require a precise estimation and works reasonably well if the estimate is within an order of magnitude of the actual group size. By default, the NORM sender group size estimate may be administratively configured. Also, given the expected scalability of the NORM protocol for general use, a default value of 10,000 is recommended for use as the group size estimate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NORMの送信者のメッセージには、グループサイズの表現であり、ランダムバックオフタイマー範囲をスケーリングで使用される「GSIZE」フィールドが含まれています。 NORMプロトコル内グループサイズ推定値の使用は、正確な推定を必要とし、推定値が実際のグループサイズの大きさのオーダー以内であれば合理的にうまく機能しません。デフォルトでは、NORM送信者グループのサイズ推定値は管理上設定することができます。また、一般的な使用のためのNORMプロトコルの期待スケーラビリティを与え、万のデフォルト値は、グループサイズの推定値として使用することをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is possible that group size may be algorithmically approximated from the volume of congestion control feedback messages which follow the exponentially weighted random backoff. However, the specification of such an algorithm is currently beyond the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
グループのサイズはアルゴリズム指数的に重み付けされたランダムバックオフをたどる輻輳制御フィードバックメッセージの量から近似することができる可能性があります。しかし、このようなアルゴリズムの仕様は、現在、このドキュメントの範囲を超えています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same security considerations that apply to the NORM, and FEC Building Blocks also apply to the NORM protocol. In addition to vulnerabilities that any IP and IP multicast protocol implementation may be generally subject to, the NACK-based feedback of NORM may be exploited by replay attacks which force the NORM sender to unnecessarily transmit repair information. This MAY be addressed by network layer IP security implementations that guard against this potential security exploitation. It is RECOMMENDED that such IP security mechanisms be used when available. Another possible approach is for NORM senders to use the &#34;sequence&#34; field from the NORM Common Message Header to detect replay attacks. This can be accomplished if the NORM packets are cryptographically protected and the sender is willing to maintain state on receivers which are NACKing. A cache of receiver state may provide some protection against replay attacks. Note that the &#34;sequence&#34; field of NORM messages should be incremented with independent values for different destinations (e.g., group-addressed versus unicast-addressed messages versus &#34;receiver&#34; messages). Thus, the congestion control loss estimation function of the &#34;sequence&#34; field can be preserved for sender messages when receiver messages are unicast to the sender. The NORM protocol is compatible with the use of the IP security (IPsec) architecture described in [22]. It is important to note that while NORM does leverage FEC-based repair for scalability, this does not alone guarantee integrity of received data. Application-level integrity-checking of data content is highly RECOMMENDED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じNORMに適用されるセキュリティ上の考慮事項、およびFECビルディングブロックはまた、NORMプロトコルに適用されます。任意のIPおよびIPマルチキャストプロトコル実装は、一般的に受けることができる脆弱性に加えて、NORMのNACKベースのフィードバックが不必要に修復情報を送信するNORM送信者を強制リプレイ攻撃によって利用されてもよいです。これは、この潜在的なセキュリティの搾取から守るネットワーク層のIPセキュリティの実装によって対処することができます。可能な場合、このようなIPセキュリティ・メカニズムを使用することをお勧めします。 NORMの送信者は、リプレイ攻撃を検出するために、NORM一般的なメッセージヘッダから「順序」フィールドを使用するための別の可能なアプローチです。 NORMパケットが暗号で保護されている場合、これは達成することができ、送信者はNACKingされている受信機に状態を維持していく所存です。受信状態のキャッシュは、リプレイ攻撃に対する何らかの保護を提供することができます。 NORMメッセージの「配列」フィールド（例えば、「受信」メッセージに対するユニキャスト・アドレス・メッセージに対するグループ宛）、異なる都市に独立した値でインクリメントされるべきであることに留意されたいです。受信メッセージは送信者へのユニキャストされたときにこのように、「配列」フィールドの輻輳制御損失推定機能は、送信者のメッセージのために保存することができます。 NORMプロトコルは[22]に記載のIPセキュリティ（IPsec）アーキテクチャの使用と互換性があります。 NORMは、スケーラビリティのためのFECベースの修理を活用しながら、これは、受信したデータの単独の保証の整合性はないことに注意してください。データ内容のアプリケーションレベルの整合性チェックが強く推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
No information in this specification is currently subject to IANA registration. However, several Header Extensions are defined within this document. If/when additional Header Extensions are developed, the first RFC MUST establish an IANA registry for them, with a &#34;Specification Required&#34; policy [6] and all Header Extensions, including those in the present document, MUST be registered thereafter. Additionally, building blocks components used by NORM may introduce additional IANA considerations. In particular, the FEC Building Block used by NORM does require IANA registration of the FEC codecs used. The registration instructions for FEC codecs are provided in [5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本明細書中の情報は、IANA登録に現在の対象ではありません。しかし、いくつかのヘッダ拡張は、この文書内で定義されています。追加のヘッダ拡張が開発されている場合/場合は、最初のRFCは、「仕様が必要である」というポリシーで、彼らのためにIANAレジストリを確立しなければならない[6]そして本ガイドに記載されているものを含むすべてのヘッダ拡張、その後は登録しなければなりません。また、NORMで使用されるビルディングブロックコンポーネントは、追加のIANAの考慮を導入することができます。特に、NORMで使用されるFECビルディングブロックを使用FECコーデックのIANA登録が必要です。 FECコーデックの登録手順は、[5]で提供されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Suggested Use
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.ご使用の目安
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The present NORM protocol is seen as useful tool for the reliable data transfer over generic IP multicast services. It is not the intention of the authors to suggest it is suitable for supporting all envisioned multicast reliability requirements. NORM provides a simple and flexible framework for multicast applications with a degree of concern for network traffic implosion and protocol overhead efficiency. NORM-like protocols have been successfully demonstrated within the MBone for bulk data dissemination applications, including weather satellite compressed imagery updates servicing a large group of receivers and a generic web content reliable &#34;push&#34; application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在NORMプロトコルは、一般的なIPマルチキャストサービス経由信頼性の高いデータ転送のための便利なツールとして見られています。すべての想定マルチキャスト信頼性要件を支持するのに適している示唆して作者の意図ではありません。 NORMは、ネットワークトラフィック内破およびプロトコルオーバーヘッド効率のために関心の度合いにマルチキャストアプリケーションのための簡単で柔軟なフレームワークを提供します。 NORM-のようなプロトコルが正常に受信機の大規模なグループにサービスを提供する気象衛星圧縮画像の更新と、一般的なWebコンテンツの信頼性の高い「プッシュ」アプリケーションを含め、バルクデータ配布アプリケーションのためにあるMBone内実証されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, this framework approach has some design features making it attractive for bulk transfer in asymmetric and wireless internetwork applications. NORM is capable of successfully operating independent of network structure and in environments with high packet loss, delay, and misordering. Hybrid proactive/reactive FEC-based repairing improve protocol performance in some multicast scenarios. A sender-only repair approach often makes additional engineering sense in asymmetric networks. NORM&#39;s unicast feedback capability may be suitable for use in asymmetric networks or in networks where only unidirectional multicast routing/delivery service exists. Asymmetric architectures supporting multicast delivery are likely to make up an important portion of the future Internet structure (e.g., DBS/cable/PSTN hybrids) and efficient, reliable bulk data transfer will be an important capability for servicing large groups of subscribed receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、このフレームワークのアプローチは、非対称および無線インターネットアプリケーションにおけるバルク転送のために、それは魅力的ないくつかの設計上の機能を備えています。 NORM正常高いパケット損失、遅延、および誤った順序でネットワーク構造の独立した環境で動作することが可能です。ハイブリッド積極的/反応FECベースのいくつかのマルチキャストのシナリオにおけるプロトコルのパフォーマンスを向上させる修復。送信者のみの修理アプローチは、多くの場合、非対称ネットワークに追加エンジニアリング理にかなっています。 NORMのユニキャストフィードバック機能は、非対称ネットワークでのみ一方向マルチキャストルーティング/配信サービスが存在するネットワークでの使用に適しています。マルチキャスト配信をサポートする非対称アーキテクチャは将来のインターネット構造の重要な部分を構成する可能性がある（例えば、DBS /ケーブル/ PSTNハイブリッド）及び効率的で信頼性の高いバルクデータ転送は加入受信機の大きなグループにサービスを提供するための重要な機能であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Acknowledgments (and these are not Negative)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.謝辞（これらはマイナスではありません）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The authors would like to thank Rick Jones, Vincent Roca, Rod Walsh, Toni Paila, Michael Luby, and Joerg Widmer for their valuable input and comments on this document. The authors would also like to thank the RMT working group chairs, Roger Kermode and Lorenzo Vicisano, for their support in development of this specification, and Sally Floyd for her early input into this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
作者はこのドキュメントの彼らの貴重な入力とコメントのためのリック・ジョーンズ、ヴィンセントロカ、ロッド・ウォルシュ、トニPaila、マイケル・ルビー、そしてイェルクウィドマーに感謝したいと思います。著者らはまた、この文書に彼女の初期の入力のためにRMTワーキンググループチェア、ロジャーKermodeとロレンツォVicisano、この仕様の開発で彼らのサポートのために、とサリーフロイドに感謝したいと思います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1。引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Kermode, R. and L. Vicisano, &#34;Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents&#34;, RFC 3269, April 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Kermode、R.とL. Vicisano、RFC 3269、2002年4月 &#34;信頼できるマルチキャストトランスポート（RMT）ビルディングブロックとプロトコルのインスタンス文書の作者のガイドライン&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の &#34;RFCsにおける使用のためのレベルを示すために&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3] Deering, S., &#34;Host Extensions for IP Multicasting&#34;, STD 5, RFC 1112, August 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3]デアリング、S.、 &#34;IPマルチキャスティングのためのホスト拡大&#34;、STD 5、RFC 1112、1989年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4] Adamson, B., Bormann, C., Handley, M., and J. Macker, &#34;Negative-Acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Building Blocks&#34;, RFC 3941, November 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4]アダムソン、B.、ボルマン、C.、ハンドレー、M.、およびJ. Macker、 &#34;否定応答（NACK）配向高信頼マルチキャスト（NORM）ビルディングブロック&#34;、RFC 3941、2004年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &#34;Forward Error Correction (FEC) Building Block&#34;, RFC 3452, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5]ルビー、M.、Vicisano、L.、Gemmell、J.、リゾー、L.、ハンドレー、M.、およびJ.クロウクロフト、 &#34;前方誤り訂正（FEC）ビルディングブロック&#34;、RFC 3452、2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 2434, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6] Narten氏、T.とH. Alvestrand、 &#34;RFCsにIANA問題部に書くためのガイドライン&#34;、BCP 26、RFC 2434、1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2。参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[7] Handley, M. and V. Jacobson, &#34;SDP: Session Description Protocol&#34;, RFC 2327, April 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[7]ハンドレー、M.およびV. Jacobsonの &#34;SDP：セッション記述プロトコル&#34;、RFC 2327、1998年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[8] Handley, M., Perkins, C., and E. Whelan, &#34;Session Announcement Protocol&#34;, RFC 2974, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[8]ハンドレー、M.、パーキンス、C.、およびE.ウィーラン、 &#34;セッション告知プロトコル&#34;、RFC 2974、2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[9] S. Pingali, D. Towsley, J. Kurose, &#34;A Comparison of Sender-Initiated and Receiver-Initiated Reliable Multicast Protocols&#34;, In Proc. INFOCOM, San Francisco CA, October 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[9] S. Pingali、D. Towsley、J.黒瀬、「送信者開始の比較及び受信器で開始高信頼マルチキャストプロトコル」PROCでは、。インフォコム、カ​​リフォルニア州サンフランシスコ、1993年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[10] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &#34;The Use of Forward Error Correction (FEC) in Reliable Multicast&#34;, RFC 3453, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[10]ルビー、M.、Vicisano、L.、Gemmell、J.、リゾー、L.、ハンドレー、M.、およびJ.クロウクロフト、 &#34;信頼できるマルチキャストの前方誤り訂正（FEC）の使用&#34;、RFC 3453 、2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[11] Macker, J. and B. Adamson, &#34;The Multicast Dissemination Protocol (MDP) Toolkit&#34;, Proc. IEEE MILCOM 99, October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[11] Macker、J.及びB.アダムソン、 &#34;マルチキャスト普及プロトコル（MDP）ツールキット&#34;、PROC。 IEEE MILCOM 99、1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[12] Nonnenmacher, J. and E. Biersack, &#34;Optimal Multicast Feedback&#34;, Proc. IEEE INFOCOMM, p. 964, March/April 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[12] Nonnenmacher、J.及びE. Biersack、 &#34;最適マルチキャストフィードバック&#34;、PROC。 IEEEインフォコム、P。 964年3月/ 1998年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[13] J. Macker, B. Adamson, &#34;Quantitative Prediction of Nack Oriented Reliable Multicast (NORM) Feedback&#34;, Proc. IEEE MILCOM 2002, October 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[13] J. Macker、B.アダムソン、 &#34;指向NACKを定量予測高信頼マルチキャスト（NORM）フィードバック&#34;、PROC。 IEEE MILCOM 2002、2002年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[14] H.W. Holbrook, &#34;A Channel Model for Multicast&#34;, Ph.D. Dissertation, Stanford University, Department of Computer Science, Stanford, California, August 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[14] H。W.ホルブルック、「マルチキャスト用チャネルモデル」、博士論文、スタンフォード大学、コンピュータサイエンス学部、スタンフォード大学、カリフォルニア州、2001年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[15] D. Gossink, J. Macker, &#34;Reliable Multicast and Integrated Parity Retransmission with Channel Estimation&#34;, IEEE GLOBECOMM 98&#39;, September 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[15] D. Gossink、J. Macker、 &#34;チャネル推定を用いた高信頼マルチキャストおよび統合されたパリティ再送信&#34;、IEEE GLOBECOMM 98&#39; 、1998年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[16] Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &#34;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer&#34;, RFC 3048, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[16] Whetten、B.、Vicisano、L.、Kermode、R.、ハンドレー、M.、フロイド、S.、およびM.ルビー、 &#34;信頼できるマルチキャストトランスポート・ビルディング・ブロック一対多バルクデータ転送のための&#34; 、RFC 3048、2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[17] Mankin, A., Romanow, A., Bradner, S., and V. Paxson, &#34;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols&#34;, RFC 2357, June 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[17]マンキン、A.、Romanow、A.、ブラドナーの、S.、およびV.パクソン、 &#34;信頼性の高いマルチキャストトランスポートとアプリケーションプロトコルを評価するためのIETF基準&#34;、RFC 2357、1998年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[18] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, STD 64, RFC 3550, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[18] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 &#34;RTP：リアルタイムアプリケーションのためのトランスポートプロトコル&#34;、STD 64、RFC 3550、2003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[19] J. Widmer and M. Handley, &#34;Extending Equation-Based Congestion Control to Multicast Applications&#34;, Proc ACM SIGCOMM 2001, San Diego, August 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[19] J.ウィトマーとM.ハンドリー、「マルチキャストアプリケーションへの方程式ベースの輻輳制御の拡張」、PROC ACMのSIGCOMM 2001、サンディエゴ、2001年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[20] L. Rizzo, &#34;pgmcc: A TCP-Friendly Single-Rate Multicast Congestion Control Scheme&#34;, Proc ACM SIGCOMM 2000, Stockholm, August 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[20] L.リゾー、 &#34;pgmcc：TCPフレンドリーシングルレートマルチキャスト輻輳制御方式&#34;、PROC ACMのSIGCOMM 2000、ストックホルム、2000年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[21] J. Padhye, V. Firoiu, D. Towsley, and J. Kurose, &#34;Modeling TCP Throughput: A Simple Model and its Empirical Validation&#34;, Proc ACM SIGCOMM 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[21] J. Padhye、V. Firoiu、D. Towsley、及びJ.黒瀬、 &#34;モデルTCPスループット：簡単なモデルとその実証的検証&#34;、PROCのACM SIGCOMM 1998。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[22] Kent, S. and R. Atkinson, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[22]ケント、S.とR.アトキンソン、 &#34;インターネットプロトコルのためのセキュリティー体系&#34;、RFC 2401、1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.著者のアドレス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Brian Adamson Naval Research Laboratory Washington, DC, USA, 20375
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ブライアン・アダムソン海軍研究所ワシントンD.C.、USA、20375
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: adamson@itd.nrl.navy.mil
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：adamson@itd.nrl.navy.mil
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Carsten Bormann Universitaet Bremen TZI Postfach 330440 D-28334 Bremen, Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
カルステンボルマンUniversitaetブレーメンTZI POSTFACH 330440 D-28334ブレーメン、ドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: cabo@tzi.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：cabo@tzi.org
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Mark Handley Department of Computer Science University College London Gower Street London WC1E 6BT UK
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
コンピュータサイエンス大学ロンドンガウアーストリートロンドンWC1E 6BT英国のマーク・ハンドリー部門
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: M.Handley@cs.ucl.ac.uk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：M.Handley@cs.ucl.ac.uk
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Joe Macker Naval Research Laboratory Washington, DC, USA, 20375
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ジョーMacker海軍研究所ワシントンD.C.、USA、20375
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
EMail: macker@itd.nrl.navy.mil
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メールアドレス：macker@itd.nrl.navy.mil
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (2004).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（2004）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
知的財産
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the IETF&#39;s procedures with respect to rights in IETF Documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 IETF文書の権利に関するIETFの手続きの情報は、BCP 78およびBCP 79に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
了承
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC Editor機能のための基金は現在、インターネット協会によって提供されます。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
