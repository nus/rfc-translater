<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 8473 - Token Binding over HTTP 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8473</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 8473 - Token Binding over HTTP 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc8473">
              https://tools.ietf.org/html/rfc8473
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 8473 - HTTPを介したトークンバインディング</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                          A. Popov
Request for Comments: 8473                                   M. Nystroem
Category: Standards Track                                Microsoft Corp.
ISSN: 2070-1721                                          D. Balfanz, Ed.
                                                               N. Harper
                                                             Google Inc.
                                                               J. Hodges
                                                  Kings Mountain Systems
                                                            October 2018
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                        Token Binding over HTTP
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes a collection of mechanisms that allow HTTP servers to cryptographically bind security tokens (such as cookies and OAuth tokens) to TLS connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントでは、HTTPサーバーがセキュリティトークン（CookieやOAuthトークンなど）をTLS接続に暗号でバインドできるようにするメカニズムのコレクションについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We describe both first-party and federated scenarios. In a first-party scenario, an HTTP server is able to cryptographically bind the security tokens that it issues to a client -- and that the client subsequently returns to the server -- to the TLS connection between the client and the server. Such bound security tokens are protected from misuse, since the server can generally detect if they are replayed inappropriately, e.g., over other TLS connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファーストパーティシナリオとフェデレーションシナリオの両方について説明します。 ファーストパーティシナリオでは、HTTPサーバーは、クライアントに発行するセキュリティトークン（およびクライアントがその後サーバーに戻るセキュリティトークン）を、クライアントとサーバー間のTLS接続に暗号的にバインドできます。 このようなバインドされたセキュリティトークンは、他のTLS接続などで不適切に再生されているかどうかをサーバーが一般に検出できるため、誤用から保護されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Federated Token Bindings, on the other hand, allow servers to cryptographically bind security tokens to a TLS connection that the client has with a different server than the one issuing the token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方、フェデレーショントークンバインディングを使用すると、サーバーはセキュリティトークンを、クライアントがトークンを発行したサーバーとは異なるサーバーとのTLS接続に暗号的にバインドできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a companion document to &#34;The Token Binding Protocol Version 1.0&#34; (RFC 8471).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、「The Token Binding Protocol Version 1.0」（RFC 8471）の関連ドキュメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはインターネット標準化過程の文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8473.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在のステータス、エラータ、およびフィードバックに関する情報は、https：//www.rfc-editor.org/info/rfc8473で入手できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2018 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright（c）2018 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、BCP 78と、この文書の公開日に有効なIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   3
   2.  The Sec-Token-Binding HTTP Request Header Field . . . . . . .   4
     2.1.  HTTPS Token Binding Key-Pair Scoping  . . . . . . . . . .   5
   3.  TLS Renegotiation . . . . . . . . . . . . . . . . . . . . . .   6
   4.  First-Party Use Cases . . . . . . . . . . . . . . . . . . . .   7
   5.  Federation Use Cases  . . . . . . . . . . . . . . . . . . . .   7
     5.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .   7
     5.2.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .   8
     5.3.  HTTP Redirects  . . . . . . . . . . . . . . . . . . . . .  10
     5.4.  Negotiated Key Parameters . . . . . . . . . . . . . . . .  12
     5.5.  Federation Example  . . . . . . . . . . . . . . . . . . .  13
   6.  Implementation Considerations . . . . . . . . . . . . . . . .  15
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  16
     7.1.  Security Token Replay . . . . . . . . . . . . . . . . . .  16
     7.2.  Sensitivity of the Sec-Token-Binding Header . . . . . . .  16
     7.3.  Securing Federated Sign-On Protocols  . . . . . . . . . .  17
   8.  Privacy Considerations  . . . . . . . . . . . . . . . . . . .  20
     8.1.  Scoping of Token Binding Key Pairs  . . . . . . . . . . .  20
     8.2.  Lifetime of Token Binding Key Pairs . . . . . . . . . . .  20
     8.3.  Correlation . . . . . . . . . . . . . . . . . . . . . . .  21
   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  22
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  22
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  22
     10.2.  Informative References . . . . . . . . . . . . . . . . .  23
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  25
   Authors&#39; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  25
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Token Binding protocol [RFC8471] defines a Token Binding ID for a TLS connection between a client and a server. The Token Binding ID of a TLS connection is constructed using the public key of a private-public key pair. The client proves possession of the corresponding private key. This Token Binding key pair is long-lived. That is, subsequent TLS connections between the same client and server have the same Token Binding ID, unless specifically reset, e.g., by the user. When issuing a security token (e.g., an HTTP cookie or an OAuth token [RFC6749]) to a client, the server can include the Token Binding ID in the token, thus cryptographically binding the token to TLS connections between that particular client and server, and inoculating the token against abuse (reuse, attempted impersonation, etc.) by attackers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンバインディングプロトコル[RFC8471]は、クライアントとサーバー間のTLS接続のトークンバインディングIDを定義します。 TLS接続のトークンバインディングIDは、秘密と公開キーのペアの公開キーを使用して構築されます。 クライアントは、対応する秘密鍵の所有を証明します。 このトークンバインディングキーペアは長寿命です。 つまり、たとえばユーザーによって特にリセットされない限り、同じクライアントとサーバー間の後続のTLS接続は同じトークンバインディングIDを持ちます。 セキュリティトークン（たとえば、HTTP CookieまたはOAuthトークン[RFC6749]）をクライアントに発行する場合、サーバーはトークンバインドIDをトークンに含めることができます。したがって、特定のクライアントとサーバー間のTLS接続にトークンを暗号的にバインドします。 攻撃者による不正使用（再利用、なりすましの試みなど）に対してトークンを接種します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the Token Binding protocol [RFC8471] defines a message format for establishing a Token Binding ID, it does not specify how this message is embedded in higher-level protocols. The purpose of this specification is to define how TokenBindingMessages are embedded in HTTP (both versions 1.1 [RFC7230] and 2 [RFC7540]). Note that TokenBindingMessages are only defined if the underlying transport uses TLS. This means that Token Binding over HTTP is only defined when HTTP is layered on top of TLS (commonly referred to as HTTPS [RFC2818]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンバインディングプロトコル[RFC8471]は、トークンバインディングIDを確立するためのメッセージフォーマットを定義しますが、このメッセージが上位プロトコルにどのように埋め込まれるかを指定しません。 この仕様の目的は、TokenBindingMessagesをHTTPに埋め込む方法を定義することです（バージョン1.1 [RFC7230]および2 [RFC7540]の両方）。 TokenBindingMessagesは、基になるトランスポートがTLSを使用する場合にのみ定義されることに注意してください。 これは、HTTPを介したトークンバインディングが、HTTPがTLS（一般にHTTPS [RFC2818]と呼ばれる）の上に階層化されている場合にのみ定義されることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP clients establish a Token Binding ID with a server by including a special HTTP header field in HTTP requests. The HTTP header field value is a base64url-encoded TokenBindingMessage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPクライアントは、HTTP要求に特別なHTTPヘッダーフィールドを含めることにより、サーバーとのトークンバインディングIDを確立します。 HTTPヘッダーフィールドの値は、base64urlエンコードされたTokenBindingMessageです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TokenBindingMessage allows a client to establish multiple Token Binding IDs with the server by including multiple TokenBinding structures. By default, a client will establish a Provided Token Binding ID with the server, indicating a Token Binding ID that the client will persistently use with the server. Under certain conditions, the client can also include a Referred Token Binding ID in the TokenBindingMessage, indicating a Token Binding ID that the client is using with a different server than the one that the TokenBindingMessage is sent to. This is useful in federation scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TokenBindingMessageを使用すると、クライアントは、複数のTokenBinding構造を含めることにより、サーバーで複数のトークンバインディングIDを確立できます。 デフォルトでは、クライアントはサーバーで提供されたトークンバインディングIDを確立し、クライアントがサーバーで永続的に使用するトークンバインディングIDを示します。 特定の条件下では、クライアントはTokenBindingMessageに参照されたトークンバインディングIDを含めることもできます。これは、TokenBindingMessageの送信先とは異なるサーバーでクライアントが使用しているトークンバインディングIDを示します。 これは、フェデレーションシナリオで役立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1。 要件言語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、および「OPTIONAL」 この文書の「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すようにすべての大文字で表示される場合にのみ解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. The Sec-Token-Binding HTTP Request Header Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Sec-Token-Binding HTTP要求ヘッダーフィールド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a client and server have negotiated the Token Binding protocol with HTTP/1.1 or HTTP/2 (see [RFC8471] and [RFC8472]), clients MUST include a Sec-Token-Binding header field in their HTTP requests and MUST include only one such header field per HTTP request. Also, the Sec-Token-Binding header field MUST NOT be included in HTTP responses. The ABNF of the Sec-Token-Binding header field is (per the style of [RFC7230]; see also Section 8.3 of [RFC7231]):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーがToken BindingプロトコルをHTTP / 1.1またはHTTP / 2とネゴシエートしたら（[RFC8471]および[RFC8472]を参照）、クライアントはHTTPリクエストにSec-Token-Bindingヘッダーフィールドを含める必要があり、1つのみを含める必要があります HTTPリクエストごとのこのようなヘッダーフィールド。 また、Sec-Token-BindingヘッダーフィールドをHTTP応答に含めることはできません。 Sec-Token-BindingヘッダーフィールドのABNFは（[RFC7230]のスタイルごと。[RFC7231]のセクション] 8.3も参照）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Sec-Token-Binding = EncodedTokenBindingMessage
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Sec-Token-Binding = EncodedTokenBindingMessage
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The header field name is Sec-Token-Binding, and its single value, EncodedTokenBindingMessage, is a base64url encoding of a single TokenBindingMessage, as defined in [RFC8471]. The base64url encoding uses the URL and filename safe character set described in Section 5 of [RFC4648], with all trailing padding characters (i.e., &#34;=&#34;) omitted and without the inclusion of any line breaks, whitespace, or other additional characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールド名はSec-Token-Bindingで、その単一の値であるEncodedTokenBindingMessageは、[RFC8471]で定義されているように、単一のTokenBindingMessageのbase64urlエンコードです。 base64urlエンコードは、[RFC4648]のセクション5で説明されているURLとファイル名の安全な文字セットを使用します。すべての末尾のパディング文字（つまり、「=」）は省略され、改行、空白、またはその他の追加文字は含まれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
Sec-Token-Binding: AIkAAgBBQFzK4_bhAqLDwRQxqJWte33d7hZ0hZWHwk-miKPg4E\ 9fcgs7gBPoz-9RfuDfN9WCw6keHEw1ZPQMGs9CxpuHm-YAQM_j\ aOwwej6a-cQBGU7CJpUHOvXG4VvjNq8jDsvta9Y8_bPEPj25Gg\ mKiPjhJEtZA6mJ_9SNifLvVBTi7fR9wSAAAA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
SEC-トークンバインディング：AIkAAgBBQFzK4_bhAqLDwRQxqJWte33d7hZ0hZWHwk-miKPg4E\9fcgs7gBPoz-9RfuDfN9WCw6keHEw1ZPQMGs9CxpuHm-YAQM_j\ aOwwej6a-cQBGU7CJpUHOvXG4VvjNq8jDsvta9Y8_bPEPj25Gg\ mKiPjhJEtZA6mJ_9SNifLvVBTi7fR9wSAAAA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note that the backslashes and line breaks are provided to ease readability; they are not part of the actual encoded message.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（バックスラッシュと改行は読みやすくするために提供されていることに注意してください。これらは実際のエンコードされたメッセージの一部ではありません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the server receives more than one Sec-Token-Binding header field in an HTTP request, then the server MUST reject the message with a 400 (Bad Request) HTTP status code. Additionally, the Sec-Token-Binding header field:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーがHTTP要求で複数のSec-Token-Bindingヘッダーフィールドを受信する場合、サーバーは400（Bad Request）HTTPステータスコードでメッセージを拒否する必要があります。 さらに、Sec-Token-Bindingヘッダーフィールド：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHOULD NOT be stored by origin servers on PUT requests,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oオリジンサーバーによってPUTリクエストに保存されるべきではない、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MAY be listed by a server in a Vary response header field, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oサーバーによってVary応答ヘッダーフィールドにリストされる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MUST NOT be used in HTTP trailers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o HTTPトレーラーでは使用しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TokenBindingMessage MUST contain exactly one TokenBinding structure with a TokenBindingType value of provided_token_binding, which MUST be signed with the Token Binding private key used by the client for connections between itself and the server that the HTTP request is sent to (clients use different Token Binding key pairs for different servers; see Section 2.1 below). The Token Binding ID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TokenBindingMessageには、提供されるTokenBindingType値が1つだけのTokenBinding構造が含まれている必要があります。これは、HTTPリクエストが送信されるサーバーとクライアント間の接続にクライアントが使用するToken Bindingプライベートキーで署名する必要があります（クライアントは異なるトークンバインディングキーを使用します 異なるサーバーのペア。以下のセクション2.1を参照してください。 トークンバインディングID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
established by this TokenBinding is called a &#34;Provided Token Binding ID&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このTokenBindingによって確立されたものは、「提供されたトークンバインディングID」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TokenBindingMessage MAY also contain exactly one TokenBinding structure with a TokenBindingType value of referred_token_binding, as specified in Section 5.3. In addition to the latter, or rather than the latter, the TokenBindingMessage MAY contain other TokenBinding structures. This is specific to the use case in question; such use cases are outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TokenBindingMessageには、セクション5.3で指定されているように、refered_token_bindingのTokenBindingType値を持つTokenBinding構造を1つだけ含めることもできます。 後者に加えて、または後者ではなく、TokenBindingMessageには他のTokenBinding構造を含めることができます。 これは、問題のユースケースに固有です。 このような使用例は、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TokenBindingMessage is validated by the server as described in Section 4.2 (&#34;Server Processing Rules&#34;) of [RFC8471]. If validation fails and a Token Binding is rejected, any associated bound tokens MUST also be rejected by the server. HTTP requests containing invalid tokens MUST be rejected. In this case, the server application MAY return HTTP status code 400 (Bad Request) or proceed with an application-specific &#34;invalid token&#34; response (e.g., directing the client to re-authenticate and present a different token), or terminate the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8471]のセクション4.2（「サーバー処理ルール」）で説明されているように、TokenBindingMessageはサーバーによって検証されます。 検証が失敗し、トークンバインディングが拒否された場合、関連するバインドされたトークンもサーバーによって拒否されなければなりません。 無効なトークンを含むHTTP要求は拒否する必要があります。 この場合、サーバーアプリケーションはHTTPステータスコード400（Bad Request）を返すか、アプリケーション固有の「無効なトークン」応答（たとえば、クライアントに別のトークンを再認証して提示するよう指示する）を続行するか、接続を終了することができます 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In HTTP/2, the client SHOULD use header compression [RFC7541] to avoid the overhead of repeating the same header field in subsequent HTTP requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 2では、クライアントはヘッダー圧縮[RFC7541]を使用して、後続のHTTP要求で同じヘッダーフィールドを繰り返すオーバーヘッドを回避する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. HTTPS Token Binding Key-Pair Scoping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1。 HTTPSトークンバインディングキーペアスコープ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPS is used in conjunction with various application protocols and application contexts, in various ways. For example, general-purpose web browsing is one such HTTP-based application context. Within that context, HTTP cookies [RFC6265] are typically utilized for state management, including client authentication. A related, though distinct, example of other HTTP-based application contexts is where OAuth tokens [RFC6749] are utilized to manage authorization for third-party application access to resources. The token-scoping rules of these two examples can differ: the scoping rules for cookies are concisely specified in [RFC6265], whereas OAuth is a framework and defines various token types with various scopings, some of which are determined by the encompassing application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPSは、さまざまな方法で、さまざまなアプリケーションプロトコルおよびアプリケーションコンテキストと組み合わせて使用されます。 たとえば、汎用Webブラウジングは、そのようなHTTPベースのアプリケーションコンテキストの1つです。 そのコンテキスト内で、HTTP Cookie [RFC6265]は通常、クライアント認証を含む状態管理に利用されます。 他のHTTPベースのアプリケーションコンテキストの関連する別個の例は、OAuthトークン[RFC6749]を使用して、リソースへのサードパーティアプリケーションアクセスの承認を管理する場合です。 これら2つの例のトークンスコープルールは異なる場合があります。Cookieのスコープルールは[RFC6265]で簡潔に指定されていますが、OAuthはフレームワークであり、さまざまなスコープを持つさまざまなトークンタイプを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scoping of Token Binding key pairs generated by web browsers for the purpose of binding HTTP cookies MUST be no wider than the granularity of a &#34;registered domain&#34; (also known as &#34;effective top-level domain + 1&#34;, or &#34;eTLD+1&#34;). An origin&#39;s &#34;registered domain&#34; is the origin&#39;s host&#39;s public suffix plus the label to its left (where the term &#34;public suffix&#34; is defined in the &#34;NOTE:&#34; paragraph in Section 5.3 of [RFC6265] as &#34;a domain that is controlled by a public registry&#34;). For example, for &#34;https://www.example.com&#34;, the public suffix (eTLD) is &#34;com&#34;, and the registered domain (eTLD+1) is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP Cookieをバインドする目的でWebブラウザによって生成されたトークンバインドキーペアのスコープは、「登録済みドメイン」（「有効なトップレベルドメイン+ 1」または「eTLD + 1」とも呼ばれる）の粒度よりも広くてはなりません。 &#34;）。 オリジンの「登録ドメイン」とは、オリジンのホストのパブリックサフィックスにその左側のラベルを加えたものです（「パブリックサフィックス」という用語は、[RFC6265]のセクション5.3の「NOTE：」段落で「 公開レジストリ」）。 たとえば、「https://www.example.com」の場合、パブリックサフィックス（eTLD）は「com」であり、登録済みドメイン（eTLD + 1）は
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;example.com&#34;. User Agents SHOULD use an up-to-date public suffix list, such as the one maintained by Mozilla [PSL].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「example.com」。 ユーザーエージェントは、Mozilla [PSL]が管理しているような最新のパブリックサフィックスリストを使用すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This means that in practice the scope of a Token Binding key pair is no larger than the scope of a cookie allowed by a web browser. If a web browser restricts cookies to a narrower scope than registered domains, the scope of Token Binding key pairs MAY also be narrower. This applies to the use of Token Binding key pairs in first-party use cases, as well as in federation use cases defined in this specification (Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
つまり、実際には、トークンバインディングキーペアの範囲は、Webブラウザで許可されているCookieの範囲よりも大きくありません。 WebブラウザがCookieを登録済みドメインよりも狭い範囲に制限している場合、トークンバインドキーペアの範囲も狭くなる場合があります。 これは、この仕様（セクション5）で定義されているフェデレーションのユースケースだけでなく、ファーストパーティのユースケースでのトークンバインディングキーペアの使用にも適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key pairs used to bind other application tokens, such as OAuth tokens or &#34;OpenID Connect&#34; ID Tokens [OpenID.Core], SHOULD adhere to the above eTLD+1 scoping requirement for those tokens being employed in first-party or federation scenarios. Applications other than web browsers MAY use different key-pair scoping rules. See also Section 8.1 below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OAuthトークンや「OpenID Connect」IDトークン[OpenID.Core]など、他のアプリケーショントークンをバインドするために使用されるキーペアは、ファーストパーティまたはフェデレーションシナリオで使用されるトークンの上記eTLD + 1スコープ要件に従う必要があります。 Webブラウザ以外のアプリケーションは、異なるキーペアのスコープルールを使用する場合があります。 以下のセクション8.1も参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Scoping rules for other HTTP-based application contexts are outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
他のHTTPベースのアプリケーションコンテキストのスコープ規則は、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. TLS Renegotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. TLS再ネゴシエーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Token Binding over HTTP/1.1 [RFC7230] can be performed in combination with TLS renegotiation. In this case, renegotiation MUST only occur between a client&#39;s HTTP request and the server&#39;s response, the client MUST NOT send any pipelined requests, and the client MUST NOT initiate renegotiation. (That is, the client may only send a renegotiation ClientHello in response to the server&#39;s HelloRequest.) These conditions ensure that both the client and the server can clearly identify which TLS Exported Keying Material value [RFC5705] to use when generating or verifying the TokenBindingMessage. This also prevents a TokenBindingMessage from being split across TLS renegotiation boundaries due to TLS message fragmentation; see Section 6.2.1 of [RFC5246].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP / 1.1 [RFC7230]を介したトークンバインディングは、TLS再ネゴシエーションと組み合わせて実行できます。 この場合、再ネゴシエーションはクライアントのHTTPリクエストとサーバーの応答の間でのみ発生し、クライアントはパイプライン化されたリクエストを送信してはならず、クライアントは再ネゴシエーションを開始してはなりません。 （つまり、クライアントは、サーバーのHelloRequestへの応答として再ネゴシエーションClientHelloのみを送信できます。）これらの条件により、クライアントとサーバーの両方が、TokenBindingMessageの生成または検証時に使用するTLSエクスポートキーイングマテリアル値[RFC5705]を明確に識別できます。 。 これにより、TLSBindingがTLSメッセージの断片化によりTLS再ネゴシエーションの境界を越えて分割されることも防止されます。 [RFC5246]のセクション6.2.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note: This document deals with TLS 1.2 and therefore refers to RFC 5246 (which has been obsoleted by RFC 8446); [TOKENBIND-TLS13] addresses Token Binding in TLS 1.3.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（注：このドキュメントはTLS 1.2を扱っているため、RFC 5246（RFC 8446で廃止されています）を参照しています。[TOKENBIND-TLS13]はTLS 1.3のトークンバインディングに対応しています。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. First-Party Use Cases
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.ファーストパーティの使用例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a first-party use case (also known as a &#34;same-site&#34; use case), an HTTP server issues a security token such as a cookie (or similar) to a client and expects the client to return the security token at a later time, e.g., in order to authenticate. Binding the security token to the TLS connection between the client and the server protects the security token from misuse, since the server can detect if the security token is replayed inappropriately, e.g., over other TLS connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ファーストパーティのユースケース（「同じサイト」のユースケースとも呼ばれます）では、HTTPサーバーはCookie（または同様の）などのセキュリティトークンをクライアントに発行し、クライアントがセキュリティトークンを 後で、例えば認証するために。 クライアントとサーバー間のTLS接続にセキュリティトークンをバインドすると、セキュリティトークンが不正に再生されているかどうかをサーバーが検出できるため（たとえば、他のTLS接続を介して）、セキュリティトークンが誤用から保護されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Section 5 of [RFC8471] for general guidance regarding the binding of security tokens and their subsequent validation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セキュリティトークンのバインドとその後の検証に関する一般的なガイダンスについては、[RFC8471]のセクション5を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Federation Use Cases
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.フェデレーションの使用例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1。 前書き
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For privacy reasons, clients use different Token Binding key pairs to establish Provided Token Binding IDs with different servers. As a result, a server cannot bind a security token (such as an OAuth token or an OpenID Connect ID Token [OpenID.Core]) to a TLS connection that the client has with a different server. This is, however, a common requirement in federation scenarios: for example, an Identity Provider may wish to issue an identity token to a client and cryptographically bind that token to the TLS connection between the client and a Relying Party.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プライバシー上の理由から、クライアントは異なるトークンバインディングキーペアを使用して、提供されたトークンバインディングIDを異なるサーバーと確立します。 その結果、サーバーは、セキュリティトークン（OAuthトークンやOpenID Connect IDトークン[OpenID.Core]など）を、クライアントが別のサーバーと持っているTLS接続にバインドできません。 ただし、これはフェデレーションシナリオの一般的な要件です。たとえば、IDプロバイダーはIDトークンをクライアントに発行し、そのトークンをクライアントと証明書利用者間のTLS接続に暗号的にバインドすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, we describe mechanisms to achieve this. The common idea among these mechanisms is that a server (called the &#34;Token Consumer&#34; in this document) signals to the client that it should reveal the Provided Token Binding ID that is used between the client and itself to another server (called the &#34;Token Provider&#34; in this document). Also common across the mechanisms is how the Token Binding ID is revealed to the Token Provider: the client uses the Token Binding protocol [RFC8471] and includes a TokenBinding structure in the Sec-Token-Binding HTTP header field defined above. What differs between the various mechanisms is how the Token Consumer signals to the client that it should reveal the Token Binding ID to the Token Provider. Below, we specify one such mechanism, which is suitable for redirect-based interactions between Token Consumers and Token Providers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、これを実現するメカニズムについて説明します。 これらのメカニズムの一般的な考え方は、サーバー（このドキュメントでは「トークンコンシューマ」と呼ばれます）が、クライアントと他のサーバー（「トークン」と呼ばれる このドキュメントの「プロバイダ」をご覧ください）。 また、メカニズム全体で共通しているのは、トークンバインディングIDがトークンプロバイダーに公開される方法です。クライアントはトークンバインディングプロトコル[RFC8471]を使用し、上記で定義したSec-Token-Binding HTTPヘッダーフィールドにTokenBinding構造を含めます。 さまざまなメカニズムで異なるのは、トークンコンシューマがトークンプロバイダにトークンバインディングIDを明らかにする必要があることをクライアントに通知する方法です。 以下に、トークンコンシューマとトークンプロバイダ間のリダイレクトベースの相互作用に適したそのようなメカニズムを1つ指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Client                        Token Consumer         Token Provider
   +--------+                        +----+                +-----+
   | Client |                        | TC |                | TP  |
   +--------+                        +----+                +-----+
       |                               |                      |
       |                               |                      |
       |                               |                      |
       | Client interacts w/TC         |                      |
       | using TokenBindingID TBID1:   |                      |
       | TBMSG[[provided_token_binding,|                      |
       |        TBID1, signature]]     |                      |
       |------------------------------&gt;|                      |
       |                               |                      |
       | Client interacts w/TP                                |
       | using TokenBindingID TBID2:                          |
       | TBMSG[[provided_token_binding,                       |
       |        TBID2, signature]]                            |
       |-----------------------------------------------------&gt;|
       |                                                      |
       |                               |                      |
       | TC signals permission to      |                      |
       | reveal TBID1 to TP            |                      |
       |&lt;------------------------------|                      |
       |                               |                      |
       |                                                      |
       | Client interacts w/TP                                |
       | using TokenBindingID TBID1 and TBID2:                |
       | TBMSG[[provided_token_binding,                       |
       |        TBID2, signature],                            |
       |       [referred_token_binding,                       |
       |        TBID1, signature]]                            |
       |-----------------------------------------------------&gt;|
       |                                                      |
       |                               |                      |
       |                               |                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2。 概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a federated sign-on protocol, an Identity Provider issues an identity token to a client, which sends the identity token to a Relying Party to authenticate itself. Examples of this include OpenID Connect (in which the identity token is called an &#34;ID Token&#34;) and the Security Assertion Markup Language (SAML) [OASIS.saml-core-2.0-os] (in which the identity token is a SAML assertion).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フェデレーションサインオンプロトコルでは、IDプロバイダーはIDトークンをクライアントに発行し、クライアントはIDトークンを証明書利用者に送信して自身を認証します。 この例には、OpenID Connect（IDトークンは「IDトークン」と呼ばれます）およびSecurity Assertion Markup Language（SAML）[OASIS.saml-core-2.0-os]（IDトークンはSAMLアサーションです）が含まれます ）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To better protect the security of the identity token, the Identity Provider may wish to bind the identity token to the TLS connection between the client and the Relying Party, thus ensuring that only said client can use the identity token. The Relying Party will compare the Token Binding ID (or a cryptographic hash of it) in the identity token with the Token Binding ID (or a hash thereof) of the TLS connection between this Relying Party and the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IDトークンのセキュリティを保護するために、IDプロバイダーは、クライアントと証明書利用者間のTLS接続にIDトークンをバインドし、そのクライアントのみがIDトークンを使用できるようにすることができます。 依拠当事者は、IDトークンのトークンバインディングID（またはその暗号化ハッシュ）と、この依拠当事者とクライアント間のTLS接続のトークンバインディングID（またはそのハッシュ）を比較します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an example of a federation scenario, which more generally can be described as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これはフェデレーションシナリオの例であり、より一般的には次のように説明できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A Token Consumer causes the client to issue a token request to the Token Provider. The goal is for the client to obtain a token and then use it with the Token Consumer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oトークンコンシューマーにより、クライアントはトークンプロバイダーにトークン要求を発行します。 目標は、クライアントがトークンを取得し、それをトークンコンシューマで使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client delivers the token request to the Token Provider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oクライアントはトークンリクエストをトークンプロバイダーに配信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Token Provider issues the token. The token is issued for the specific Token Consumer who requested it (thus preventing malicious Token Consumers from using tokens with other Token Consumers). The token is, however, typically a bearer token, meaning that any client can use it with the Token Consumer -- not just the client to which it was issued.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oトークンプロバイダーはトークンを発行します。 トークンは、それを要求した特定のトークンコンシューマーに対して発行されます（したがって、悪意のあるトークンコンシューマーが他のトークンコンシューマーでトークンを使用することを防ぎます）。 ただし、トークンは通常、ベアラトークンです。つまり、発行されたクライアントだけでなく、すべてのクライアントがトークンコンシューマでトークンを使用できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Therefore, in the previous step, the Token Provider may want to include in the token the Token Binding ID (or a cryptographic hash of it) that the client uses when communicating with the Token Consumer, thus binding the token to the client&#39;s Token Binding key pair. The client proves possession of the private key when communicating with the Token Consumer through the Token Binding protocol [RFC8471] and uses the corresponding public key of this key pair as a component of the Token Binding ID. Comparing the Token Binding ID from the token to the Token Binding ID established with the client allows the Token Consumer to verify that the token was sent to it by the legitimate client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oしたがって、前の手順で、トークンプロバイダーは、クライアントがトークンコンシューマーと通信するときに使用するトークンバインディングID（またはその暗号化ハッシュ）をトークンに含めることで、トークンをクライアントのトークンバインディングにバインドすることができます キーペア。 クライアントは、トークンバインディングプロトコル[RFC8471]を介してトークンコンシューマーと通信するときに秘密キーの所有を証明し、このキーペアの対応する公開キーをトークンバインディングIDのコンポーネントとして使用します。 トークンバインディングIDをトークンからクライアントで確立されたトークンバインディングIDと比較することにより、トークンコンシューマはトークンが正当なクライアントによって送信されたことを確認できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To allow the Token Provider to include the Token Binding ID in the token, the Token Binding ID between the client and the Token Consumer must therefore be communicated to the Token Provider along with the token request. Communicating a Token Binding ID involves proving possession of a private key and is described in the Token Binding protocol [RFC8471].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oトークンプロバイダーがトークンバインディングIDをトークンに含めることを許可するには、クライアントとトークンコンシューマー間のトークンバインディングIDをトークンリクエストと共にトークンプロバイダーに伝達する必要があります。 トークンバインディングIDの通信には、秘密鍵の所有の証明が含まれ、トークンバインディングプロトコル[RFC8471]で説明されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client will perform this last operation only if the Token Consumer requests the client to do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、トークンコンシューマがクライアントにそうするように要求した場合にのみ、この最後の操作を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below, we specify how Token Consumers can signal this request in redirect-based federation protocols. Note that this assumes that the federated sign-on flow starts at the Token Consumer or, at the very least, includes a redirect from the Token Consumer to the Token Provider. It is outside the scope of this document to specify similar mechanisms for flows that do not include such redirects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に、トークンコンシューマがリダイレクトベースのフェデレーションプロトコルでこのリクエストを通知する方法を指定します。 これは、フェデレーションサインオンフローがトークンコンシューマーで開始されるか、少なくともトークンコンシューマーからトークンプロバイダーへのリダイレクトを含むことを前提としていることに注意してください。 このようなリダイレクトを含まないフローに同様のメカニズムを指定することは、このドキュメントの範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. HTTP Redirects
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3。 HTTPリダイレクト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a Token Consumer redirects the client to a Token Provider as a means to deliver the token request, it SHOULD include an Include-Referred-Token-Binding-ID HTTP response header field in its HTTP response. The ABNF of the Include-Referred-Token-Binding-ID header is (per the style of [RFC7230]; see also Section 8.3 of [RFC7231]):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンコンシューマは、トークンリクエストを配信する手段としてクライアントをトークンプロバイダーにリダイレクトする場合、HTTP応答にInclude-Referred-Token-Binding-ID HTTP応答ヘッダーフィールドを含める必要があります。 Include-Referred-Token-Binding-IDヘッダーのABNFは（[RFC7230]のスタイルごと。[RFC7231]のセクション8.3も参照）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Include-Referred-Token-Binding-ID = &#34;true&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Include-Referred-Token-Binding-ID = &#34;true&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the header field name is &#34;Include-Referred-Token-Binding-ID&#34; and the field value of &#34;true&#34; is case insensitive. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ヘッダーフィールド名が「Include-Referred-Token-Binding-ID」であり、フィールド値「true」では大文字と小文字が区別されません。 例えば：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Include-Referred-Token-Binding-ID: true
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Include-Referred-Token-Binding-ID：true
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Including this response header field signals to the client that it should reveal, to the Token Provider, the Token Binding ID used between itself and the Token Consumer. In the absence of this response header field, the client will not disclose any information about the Token Binding used between the client and the Token Consumer to the Token Provider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この応答ヘッダーフィールドを含めると、クライアントに、トークンプロバイダーに、それ自体とトークンコンシューマーの間で使用されるトークンバインディングIDを明らかにする必要があることを通知します。 この応答ヘッダーフィールドがない場合、クライアントは、クライアントとトークンコンシューマの間で使用されるトークンバインディングに関する情報をトークンプロバイダーに開示しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As illustrated in Section 5.5, when a client receives this header field, it should take the TokenBindingID [RFC8471] of the provided TokenBinding from the referrer and create a referred TokenBinding with it to include in the TokenBindingMessage in the redirect request. In other words, the Token Binding message in the redirect request to the Token Provider now includes one provided binding and one referred binding, the latter constructed from the binding between the client and the Token Consumer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション5.5に示すように、クライアントはこのヘッダーフィールドを受け取ると、リファラーから提供されたTokenBindingのTokenBindingID [RFC8471]を取得し、リダイレクトリクエストのTokenBindingMessageに含めるために参照されるTokenBindingを作成する必要があります。 つまり、トークンプロバイダーへのリダイレクトリクエストのトークンバインディングメッセージには、提供されたバインディングと参照されたバインディングが含まれます。後者は、クライアントとトークンコンシューマ間のバインディングから構築されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client receives the Include-Referred-Token-Binding-ID header, it includes the referred Token Binding even if both the Token Provider and the Token Consumer fall under the same eTLD+1 and the provided and Referred Token Binding IDs are the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがInclude-Referred-Token-Binding-IDヘッダーを受信すると、トークンプロバイダーとトークンコンシューマーの両方が同じeTLD + 1に該当し、提供および参照されるトークンバインディングIDが同じ場合でも、参照されるトークンバインディングが含まれます 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The referred Token Binding is sent only in the initial request resulting from the HTTP response that included the Include-Referred-Token-Binding-ID header. Should the response to that initial request be a further redirect, the original referred
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参照されたトークンバインディングは、Include-Referred-Token-Binding-IDヘッダーを含むHTTP応答の結果の初期リクエストでのみ送信されます。 その最初のリクエストへの応答がさらにリダイレクトされる場合、元の
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Token Binding is no longer included in subsequent requests. (A new referred Token Binding may be included if the redirecting endpoint itself responded with an Include-Referred-Token-Binding-ID response header.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンバインディングは、以降のリクエストに含まれなくなりました。 （リダイレクトエンドポイント自体がInclude-Referred-Token-Binding-ID応答ヘッダーで応答した場合、新しい参照トークンバインディングが含まれることがあります。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Include-Referred-Token-Binding-ID header field is received in response to a request that did not include the Sec-Token-Binding header field, the client MUST ignore the Include-Referred-Token-Binding-ID header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sec-Token-Bindingヘッダーフィールドが含まれていない要求に応答してInclude-Referred-Token-Binding-IDヘッダーフィールドを受信した場合、クライアントはInclude-Referred-Token-Binding-IDヘッダーフィールドを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header field only has meaning if the HTTP status code is a redirection code (300-399) and MUST be ignored by the client for any other status codes. As described in Section 2, if the client supports the Token Binding protocol and has negotiated the Token Binding protocol with both the Token Consumer and the Token Provider, it sends the Sec-Token-Binding header field to the Token Provider with each HTTP request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このヘッダーフィールドは、HTTPステータスコードがリダイレクトコード（300-399）であり、他のステータスコードについてはクライアントによって無視されなければならない場合にのみ意味を持ちます。 セクション2で説明したように、クライアントがトークンバインディングプロトコルをサポートし、トークンコンシューマとトークンプロバイダーの両方とトークンバインディングプロトコルをネゴシエートしている場合、各HTTP要求でSec-Token-Bindingヘッダーフィールドをトークンプロバイダーに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TokenBindingMessage included in the redirect request to the Token Provider SHOULD contain a TokenBinding with a TokenBindingType value of referred_token_binding. If included, this TokenBinding MUST be signed with the Token Binding private key used by the client for connections between itself and the Token Consumer (more specifically, the server that issued the Include-Referred-Token-Binding-ID response header field). The Token Binding ID established by this TokenBinding is called a &#34;Referred Token Binding ID&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンプロバイダーへのリダイレクトリクエストに含まれるTokenBindingMessageには、TokenBindingType値がrefered_token_bindingのTokenBindingを含める必要があります。 含まれる場合、このTokenBindingは、それ自体とトークンコンシューマ（より具体的には、Include-Referred-Token-Binding-ID応答ヘッダーフィールドを発行したサーバー）の接続にクライアントが使用するToken Bindingプライベートキーで署名する必要があります。 このTokenBindingによって確立されたトークンバインディングIDは、「参照トークンバインディングID」と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described above, the TokenBindingMessage MUST additionally contain a Provided Token Binding ID, i.e., a TokenBinding structure with a TokenBindingType value of provided_token_binding, which MUST be signed with the Token Binding private key used by the client for connections between itself and the Token Provider (more specifically, the server that the token request is being sent to).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記で説明したように、TokenBindingMessageには、提供されたトークンバインディングID、つまり、provided_token_bindingのTokenBindingType値を持つTokenBinding構造を追加して含める必要があります。 より具体的には、トークン要求の送信先のサーバー）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If, for some deployment-specific reason, the initial Token Provider (&#34;TP1&#34;) needs to redirect the client to another Token Provider (&#34;TP2&#34;) rather than directly back to the Token Consumer, it can be accommodated using the header fields defined in this specification in the following fashion (&#34;the redirect-chain approach&#34;):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何らかの展開固有の理由により、最初のトークンプロバイダー（ &#34;TP1&#34;）がクライアントを直接トークンコンシューマーに戻すのではなく、別のトークンプロバイダー（ &#34;TP2&#34;）にリダイレクトする必要がある場合、定義済みのヘッダーフィールドを使用して対応できます この仕様では、次の方法で（「リダイレクトチェーンアプローチ」）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Initially, the client is redirected to TP1 by the Token Consumer (&#34;TC&#34;), as described above. Upon receiving a client&#39;s request that contains a TokenBindingMessage that in turn contains both provided and referred TokenBindings (for TP1 and TC, respectively), TP1 responds to the client with a redirect response that (1) contains the Include-Referred-Token-Binding-ID header field and (2) directs the client to send a request to TP2. This causes the client to follow the same pattern and send a request containing a TokenBindingMessage that contains both provided and referred TokenBindings (for TP2 and TP1, respectively) to TP2. Note that this pattern can continue to additional Token Providers. In this case, TP2 issues a security token, bound to the client&#39;s TokenBinding with TP1, and sends a redirect response to the client pointing to TP1. TP1 in turn constructs a security token for the Token Consumer, bound to the TC&#39;s referred TokenBinding that had been conveyed earlier, and sends a redirect response pointing to the TC, containing the bound security token, to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
最初に、クライアントは、前述のように、トークンコンシューマ（「TC」）によってTP1にリダイレクトされます。提供されたTokenBindingsと参照されたTokenBindings（それぞれTP1およびTC）の両方を含むTokenBindingMessageを含むクライアントの要求を受信すると、TP1は（1）Include-Referred-Token-Binding-を含むリダイレクト応答でクライアントに応答しますIDヘッダーフィールド、および（2）TP2に要求を送信するようにクライアントに指示します。これにより、クライアントは同じパターンに従い、提供されたTokenBindingsと参照されたTokenBindings（それぞれTP2およびTP1）の両方を含むTokenBindingMessageを含む要求をTP2に送信します。このパターンは、追加のトークンプロバイダーに継続できることに注意してください。この場合、TP2はセキュリティトークンを発行し、TP1を使用してクライアントのTokenBindingにバインドし、TP1を指すクライアントにリダイレクト応答を送信します。 TP1は、トークンコンシューマ用のセキュリティトークンを構築し、以前に伝達されたTCの参照されたTokenBindingにバインドし、バインドされたセキュリティトークンを含むTCを指すリダイレクト応答をクライアントに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above is intended as only a non-normative example. Details are specific to deployment contexts. Other approaches are possible but are outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上記は非規範的な例としてのみ意図されています。 詳細は展開コンテキストに固有です。 他のアプローチも可能ですが、この仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Negotiated Key Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4。 交渉された主要なパラメーター
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS extension for Token Binding protocol negotiation [RFC8472] allows the server and client to negotiate the parameters (signature algorithm, length) of the Token Binding key pair. It is possible that the Token Binding ID used between the client and the Token Consumer, and the Token Binding ID used between the client and the Token Provider, use different key parameters. The client MUST use the key parameters negotiated with the Token Consumer in the referred_token_binding TokenBinding of the TokenBindingMessage, even if those key parameters are different from the ones negotiated with the server that the header field is sent to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンバインディングプロトコルネゴシエーション[RFC8472]のTLS拡張により、サーバーとクライアントはトークンバインディングキーペアのパラメーター（署名アルゴリズム、長さ）をネゴシエートできます。 クライアントとトークンコンシューマの間で使用されるトークンバインディングID、およびクライアントとトークンプロバイダーの間で使用されるトークンバインディングIDは、異なるキーパラメータを使用する可能性があります。 クライアントは、ヘッダーフィールドが送信されるサーバーとネゴシエートされたキーパラメーターと異なる場合でも、TokenBindingMessageのrefered_token_binding TokenBindingでトークンコンシューマーとネゴシエートされたキーパラメーターを使用する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Token Providers SHOULD support all the Token Binding key parameters specified in [RFC8471]. If a Token Provider does not support the key parameters specified in the referred_token_binding TokenBinding in the TokenBindingMessage, it MUST NOT issue a bound token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンプロバイダーは、[RFC8471]で指定されたすべてのトークンバインディングキーパラメーターをサポートする必要があります。 トークンプロバイダが、TokenBindingMessageのrefered_token_binding TokenBindingで指定されたキーパラメータをサポートしない場合、バインドされたトークンを発行してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Federation Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5。 フェデレーションの例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The diagram below shows a typical HTTP redirect-based web browser single sign-on (SSO) profile (Section 4.1 of [OASIS.saml-prof-2.0-os]) (no artifact, no callbacks), featuring the binding of, for example, a TLS Token Binding ID into an OpenID Connect ID Token.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の図は、一般的なHTTPリダイレクトベースのWebブラウザーシングルサインオン（SSO）プロファイル（[OASIS.saml-prof-2.0-os]のセクション4.1）（アーチファクトなし、コールバックなし）を示しています。 例：OpenID Connect IDトークンへのTLSトークンバインディングID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
Legend:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-34">
伝説：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +------------+------------------------------------------------------+
   | EKM:       | TLS Exported Keying Material [RFC5705]               |
   |            |                                                      |
   | {EKMn}Ksm: | EKM for server &#34;n&#34;, signed by the private key of     |
   |            | TBID &#34;m&#34;, where &#34;n&#34; must represent the server        |
   |            | receiving the ETBMSG.  If a conveyed TB&#39;s type is    |
   |            | provided_token_binding, then m = n, else if TB&#39;s     |
   |            | type is referred_token_binding, then m != n.  For    |
   |            | example, see step 1b in the diagram below.           |
   |            |                                                      |
   | ETBMSG:    | &#34;Sec-Token-Binding&#34; HTTP header field conveying an   |
   |            | EncodedTokenBindingMessage, in turn conveying        |
   |            | TokenBinding (TB)struct(s), e.g., ETBMSG[[TB]] or    |
   |            | ETBMSG[[TB1],[TB2]]                                  |
   |            |                                                      |
   | ID Token:  | the ID Token in OpenID Connect.  It is the semantic  |
   |            | equivalent of a SAML &#34;authentication assertion&#34;.     |
   |            | &#34;ID Token w/TBIDn&#34; denotes a &#34;token bound&#34; ID Token  |
   |            | containing TBIDn.                                    |
   |            |                                                      |
   | Ks and Kp: | private (aka secret) key and public key,             |
   |            | respectively, of the client-side Token Binding key   |
   |            | pair                                                 |
   |            |                                                      |
   | OIDC:      | OpenID Connect                                       |
   |            |                                                      |
   | TB:        | TokenBinding struct containing a signed EKM, TBID,   |
   |            | and TB type, e.g.,                                   |
   |            | [{EKM1}Ks1,TBID1,provided_token_binding]             |
   |            |                                                      |
   | TBIDn:     | Token Binding ID for client and server n&#39;s token-    |
   |            | bound TLS association.  TBIDn contains Kpn.          |
   +------------+------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Client, aka                Token Consumer, aka    Token Provider, aka
User Agent                 OpenID Client,         OpenID Provider,
                           OIDC Relying Party,    OIDC Provider,
                           SAML Relying Party     SAML Identity Provider
                           [ server &#34;1&#34; ]         [ server &#34;2&#34; ]
+--------+                       +----+                 +-----+
| Client |                       | TC |                 | TP  |
+--------+                       +----+                 +-----+
    |                               |                      |
    |                               |                      |
    |                               |                      |
    | 0. Client interacts w/TC      |                      |
    | over HTTPS, establishes Ks1 and Kp1, TBID1           |
    | ETBMSG[[{EKM1}Ks1,TBID1,provided_token_binding]]     |
    |------------------------------&gt;|                      |
    |                               |                      |
    |                               |                      |
    |                               |                      |
    | 1a. OIDC ID Token request, aka|                      |
    | &#34;Authentication Request&#34;, conveyed with              |
    | an HTTP response header field of                     |
    | Include-Referred-Token-Binding-ID:true.              |
    | Any security-relevant cookies |                      |
    | should contain TBID1.         |                      |
  +&lt;- - - - - - - - - - - - - - - - |                      |
  . | (redirect to TP via 301, 302, |                      |
  . |  303, 307, or 308)            |                      |
  . |                               |                      |
  +-------------------------------------------------------&gt;|
    | 1b. opens HTTPS w/TP,                                |
    | establishes Ks2, Kp2, TBID2;                         |
    | sends a GET or POST with                             |
    | ETBMSG[[{EKM2}Ks2,TBID2,provided_token_binding],     |
    |        [{EKM2}Ks1,TBID1,referred_token_binding]]     |
    | as well as the ID Token request                      |
    |                               |                      |
    |                               |                      |
    |                               |                      |
    | 2. user authentication (if applicable;               |
    |    methods vary; particulars are out of scope)       |
    |&lt;====================================================&gt;|
    | (TP generates ID Token for TC containing TBID1; may  |
    |  also set cookie(s) containing TBID2 and/or TBID1;   |
    |  details vary; particulars are out of scope)         |
    |                               |                      |
    |                               |                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    |                               |                      |
    | 3a. ID Token containing Kp1, issued for TC,          |
    |    conveyed via OIDC &#34;Authentication Response&#34;       |
  +&lt;- - - - - - - - - - - - - - - - - - - - - - - - - - - -|
  . |   (redirect to TC)            |                      |
  . |                               |                      |
  . |                               |                      |
  +--------------------------------&gt;|                      |
    | 3b. HTTPS GET or POST with                           |
    | ETBMSG[[{EKM1}Ks1,TBID1,provided_token_binding]]     |
    | conveying an Authentication Response containing      |
    | an ID Token w/TBID1, issued for TC                   |
    |                               |                      |
    |                               |                      |
    |                               |                      |
    | 4. user is signed on; any security-relevant cookie(s)|
    | that is set SHOULD contain TBID1                     |
    |&lt;------------------------------|                      |
    |                               |                      |
    |                               |                      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Implementation Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.実装に関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPS-based applications may have multi-party use cases other than, or in addition to, the HTTP redirect-based signaling and conveyance of referred Token Bindings, as presented above in Section 5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTPSベースのアプリケーションには、上記のセクション5.3で示したように、HTTPリダイレクトベースのシグナリングおよび参照トークンバインディングの伝達以外の、またはそれに加えて、マルチパーティのユースケースがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, Token Binding implementations should provide APIs for such applications to generate Token Binding messages containing Token Binding IDs of various application-specified Token Binding types, to be conveyed by the Sec-Token-Binding header field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、トークンバインディングの実装は、Sec-Token-Bindingヘッダーフィールドによって伝達される、さまざまなアプリケーション指定のトークンバインディングタイプのトークンバインディングIDを含むトークンバインディングメッセージを生成するために、そのようなアプリケーションのAPIを提供する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, Token Binding implementations MUST only convey Token Binding IDs to servers if signaled to do so by an application. Signaling mechanisms other than the Include-Referred-Token-Binding-ID HTTP response header field are possible, but these mechanisms are outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ただし、トークンバインディングの実装は、アプリケーションからそうするように指示された場合にのみ、トークンバインディングIDをサーバーに伝達する必要があります。 Include-Referred-Token-Binding-ID HTTP応答ヘッダーフィールド以外のシグナリングメカニズムも可能ですが、これらのメカニズムはこの仕様の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE: See Section 8 (&#34;Privacy Considerations&#34;) for privacy guidance regarding the use of this functionality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：この機能の使用に関するプライバシーガイダンスについては、セクション8（「プライバシーに関する考慮事項」）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.セキュリティに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Security Token Replay
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1。 セキュリティトークンリプレイ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal of the federated Token Binding mechanisms is to prevent attackers from exporting and replaying tokens used in protocols between the client and the Token Consumer, thereby impersonating legitimate users and gaining access to protected resources. Although bound tokens can still be replayed by any malware present in clients (which may be undetectable to a server), in order to export bound tokens to other machines and successfully replay them, attackers also need to export the corresponding Token Binding private keys. Token Binding private keys are therefore high-value assets and SHOULD be strongly protected, ideally by generating them in a hardware security module that prevents key export.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フェデレーテッドトークンバインディングメカニズムの目的は、攻撃者がクライアントとトークンコンシューマ間のプロトコルで使用されるトークンをエクスポートおよびリプレイすることを防止し、それにより正当なユーザーになりすまし、保護されたリソースにアクセスすることです。 バインドされたトークンは、クライアントに存在するマルウェア（サーバーでは検出できない可能性があります）で再生できますが、バインドされたトークンを他のマシンにエクスポートして正常に再生するには、攻撃者は対応するトークンバインド秘密キーもエクスポートする必要があります。 したがって、トークンバインド秘密キーは価値の高い資産であり、理想的にはキーのエクスポートを防ぐハードウェアセキュリティモジュールで生成することにより、強力に保護する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This consideration is a special case of the scenario described in Section 7.1 (&#34;Security Token Replay&#34;) of [RFC8471].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この考慮事項は、[RFC8471]のセクション7.1（「セキュリティトークンリプレイ」）で説明されているシナリオの特殊なケースです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Sensitivity of the Sec-Token-Binding Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2。 Sec-Token-Bindingヘッダーの感度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the Token Binding protocol is to convince the server that the client that initiated the TLS connection controls a certain key pair. For the server to correctly draw this conclusion after processing the Sec-Token-Binding header field, certain secrecy and integrity requirements must be met.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Token Bindingプロトコルの目的は、TLS接続を開始したクライアントが特定のキーペアを制御することをサーバーに確信させることです。 サーバーがSec-Token-Bindingヘッダーフィールドを処理した後にこの結論を正しく引き出すには、特定の機密性と整合性の要件を満たす必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, the client must keep its Token Binding private key secret. If the private key is not secret, then another actor in the system could create a valid Token Binding header field and thereby impersonate the client. This can render the main purpose of the protocol -- to bind bearer tokens to certain clients -- moot. Consider, for example, an attacker who obtained (perhaps through a network intrusion) an authentication cookie that a client uses with a certain server. Consider further that the server bound that cookie to the client&#39;s Token Binding ID precisely to thwart misuse of the cookie. If the attacker were to come into possession of the client&#39;s private key, they could then establish a TLS connection with the server and craft a Sec-Token-Binding header field that matches the binding present in the cookie, thus successfully authenticating as the client and gaining access to the client&#39;s data at the server. The Token Binding protocol, in this case, did not successfully bind the cookie to the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
たとえば、クライアントは、トークンバインド秘密キーを秘密にする必要があります。秘密鍵が秘密でない場合、システム内の別のアクターが有効なトークンバインディングヘッダーフィールドを作成し、それによりクライアントになりすますことができます。これにより、プロトコルの主な目的（特定のクライアントにベアラートークンをバインドすること）が不要になります。たとえば、クライアントが特定のサーバーで使用する認証Cookieを（おそらくネットワーク侵入を介して）取得した攻撃者を考えてみましょう。さらに、サーバーがそのCookieをクライアントのToken Binding IDにバインドして、Cookieの誤用を阻止することを考慮してください。攻撃者がクライアントの秘密鍵を手に入れた場合、サーバーとのTLS接続を確立し、Cookieに存在するバインディングと一致するSec-Token-Bindingヘッダーフィールドを作成して、クライアントとして正常に認証し、サーバーでクライアントのデータにアクセスする。この場合、トークンバインディングプロトコルは、Cookieをクライアントに正常にバインドしませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Likewise, we need integrity protection of the Sec-Token-Binding header field. A client should not be tricked into sending to a server a Sec-Token-Binding header field that contains Token Bindings signed with any Token Binding keys that the client does not control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同様に、Sec-Token-Bindingヘッダーフィールドの整合性保護が必要です。 クライアントは、クライアントが制御しないトークンバインディングキーで署名されたトークンバインディングを含むSec-Token-Bindingヘッダーフィールドをサーバーに送信するようにだまされるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider an attacker A that somehow has knowledge of the Exported Keying Material (EKM) for a TLS connection between a client C and a server S. (While that is somewhat unlikely, it is also not entirely out of the question, since the client might not treat the EKM as a secret -- after all, a pre-image-resistant hash function has been applied to the TLS master secret, making it impossible for someone knowing the EKM to recover the TLS master secret. Such considerations might lead some clients to not treat the EKM as a secret.) Such an attacker A could craft a Sec-Token-Binding header field with A&#39;s key pair over C&#39;s EKM. If the attacker could now trick C into sending such a header field to S, it would appear to S as if C controls a certain key pair, when in fact it does not (the attacker A controls the key pair).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントCとサーバーSの間のTLS接続のExported Keying Material（EKM）を何らかの方法で知っている攻撃者Aを考えてみてください（これはややありそうにありませんが、クライアントが EKMをシークレットとして扱わない-結局、TLSマスターシークレットにプリイメージ耐性ハッシュ関数が適用されているため、EKMを知っている人がTLSマスターシークレットを回復することはできません。 このような攻撃者Aは、CのEKM上でAのキーペアを使用してSec-Token-Bindingヘッダーフィールドを作成できます。 攻撃者がCをtrickしてそのようなヘッダーフィールドをSに送信させることができる場合、実際にはCが特定のキーペアを制御していないように見えます（攻撃者Aはキーペアを制御します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If A has a pre-existing relationship with S (e.g., perhaps has an account on S), it now appears to the server S as if A is connecting to it, even though it is really C. (If the server S does not simply use Token Binding IDs to identify clients but also uses bound authentication cookies, then A would also have to trick C into sending one of A&#39;s cookies to S, which it can do through a variety of means -- inserting cookies through JavaScript APIs, setting cookies through related-domain attacks, etc.) In other words, in this scenario, A can trick C into logging into A&#39;s account on S. This could lead to a loss of privacy for C, since A presumably has some other way to also access the account and can thus indirectly observe C&#39;s behavior (for example, if S has a feature that lets account holders see their activity history on S).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AがSと既存の関係を持っている場合（たとえば、Sにアカウントがある場合）、サーバーSには、実際にはCであっても、Aが接続しているように見えます（サーバーSが トークンバインディングIDを使用してクライアントを識別するだけでなく、バインドされた認証Cookieも使用します。Aは、CをtrickしてAのCookieの1つをSに送信する必要があります。 言い換えると、このシナリオでは、AがCをtrickしてSのAのアカウントにログインさせる可能性があります。Aには他にも何らかの方法があるため、Cのプライバシーが失われる可能性があります アカウントにアクセスし、Cの動作を間接的に監視できます（たとえば、Sにアカウント所有者がSのアクティビティ履歴を表示できる機能がある場合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, we need to protect the integrity of the Sec-Token-Binding header field. One eTLD+1 should not be able to set the Sec-Token-Binding header field (through a Document Object Model (DOM) API [W3C.REC-DOM-Level-3-Core-20040407] or otherwise) that the User Agent uses with another eTLD+1. Employing the &#34;Sec-&#34; header field prefix helps to meet this requirement by denoting the header field name as a &#34;forbidden header name&#34;; see [fetch-spec].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、Sec-Token-Bindingヘッダーフィールドの整合性を保護する必要があります。 1つのeTLD + 1は、ユーザーエージェントが（ドキュメントオブジェクトモデル（DOM）API [W3C.REC-DOM-Level-3-Core-20040407]などを介して）Sec-Token-Bindingヘッダーフィールドを設定できないようにする必要があります。 別のeTLD + 1で使用します。 「Sec-」ヘッダーフィールドプレフィックスを使用すると、ヘッダーフィールド名を「禁止ヘッダー名」として示すことにより、この要件を満たすのに役立ちます。 [fetch-spec]を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Securing Federated Sign-On Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3。 フェデレーションサインオンプロトコルの保護
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As explained above, in a federated sign-on scenario, a client will prove possession of two different Token Binding private keys to a Token Provider: one private key corresponds to the &#34;provided&#34; Token Binding ID (which the client normally uses with the Token Provider), and the other is the Token Binding private key corresponding to the &#34;referred&#34; Token Binding ID (which the client normally uses with the Token Consumer). The Token Provider is expected to issue a token that is bound to the Referred Token Binding ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上で説明したように、フェデレーションサインオンシナリオでは、クライアントは2つの異なるトークンバインドプライベートキーをトークンプロバイダーに所有していることを証明します。1つのプライベートキーは「提供された」トークンバインドID（クライアントは通常、 プロバイダ）、もう1つは「参照」トークンバインディングID（クライアントが通常トークンコンシューマで使用する）に対応するトークンバインディング秘密キーです。 トークンプロバイダーは、参照されたトークンバインディングIDにバインドされたトークンを発行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both proofs (that of the provided Token Binding private key and that of the referred Token Binding private key) are necessary. To show this, consider the following scenario:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
両方の証明（提供されたトークンバインディングプライベートキーの証明と、参照されたトークンバインディングプライベートキーの証明）が必要です。 これを示すために、次のシナリオを検討してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client has an authentication token with the Token Provider that is bound to the client&#39;s Token Binding ID used with that Token Provider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oクライアントには、そのトークンプロバイダーで使用されるクライアントのトークンバインディングIDにバインドされたトークンプロバイダーを持つ認証トークンがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The client wants to establish a secure (i.e., free of men-in-the-middle) authenticated session with the Token Consumer but has not yet done so (in other words, we are about to run the federated sign-on protocol).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oクライアントは、トークンコンシューマーとの安全な（つまり中間者のいない）認証済みセッションを確立したいが、まだ確立していない（つまり、フェデレーションサインオンプロトコルを実行しようとしている） 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A man-in-the-middle is allowed to intercept the connection between the client and the Token Consumer or between the client and the Token Provider (or both).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o中間者は、クライアントとトークンコンシューマーの間、またはクライアントとトークンプロバイダーの間（または両方）の接続をインターセプトできます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal is to detect the presence of the man-in-the-middle in these scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目標は、これらのシナリオで中間者の存在を検出することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, consider a man-in-the-middle between the client and the Token Provider. Recall that we assume that the client possesses a bound authentication token (e.g., cookie) for the Token Provider. The man-in-the-middle can intercept and modify any message sent by the client to the Token Provider and any message sent by the Token Provider to the client. (This means, among other things, that the man-in-the-middle controls the JavaScript running at the client in the origin of the Token Provider.) It is not, however, in possession of the client&#39;s Token Binding private key. Therefore, it can choose to either (1) replace the Token Binding ID in requests from the client to the Token Provider and create a Sec-Token-Binding header field that matches the TLS connection between the man-in-the-middle and the Token Provider or (2) leave the Sec-Token-Binding header field unchanged. If it chooses the latter, the signature in the Token Binding message (created by the original client on the EKM for the connection between the client and the man-in-the-middle) will not match a signature on the EKM between the man-in-the-middle and the Token Provider. If it chooses the former (and creates its own signature, using its own Token Binding private key, over the EKM for the connection between itself, the man-in-the-middle, and the Token Provider), then the Token Binding message will match the connection between the man-in-the-middle and the Token Provider, but the Token Binding ID in the message will not match the Token Binding ID that the client&#39;s authentication token is bound to. Either way, the man-in-the-middle is detected by the Token Provider, but only if the proof of possession of the provided Token Binding private key is required in the protocol (as is done above).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
まず、クライアントとトークンプロバイダーの間の中間者について考えます。クライアントがトークンプロバイダーのバインドされた認証トークン（例：Cookie）を所有していると想定していることを思い出してください。中間者は、クライアントからトークンプロバイダーに送信されるメッセージ、およびトークンプロバイダーからクライアントに送信されるメッセージをインターセプトおよび変更できます。 （これは、とりわけ、中間者がトークンプロバイダーの発信元でクライアントで実行されているJavaScriptを制御することを意味します。）ただし、クライアントのトークンバインド秘密キーは所有していません。したがって、（1）クライアントからトークンプロバイダーへの要求のトークンバインディングIDを置き換え、中間者とTLS接続の間のTLS接続に一致するSec-Token-Bindingヘッダーフィールドを作成することを選択できます。トークンプロバイダー、または（2）Sec-Token-Bindingヘッダーフィールドを変更しないままにします。後者を選択した場合、トークンバインディングメッセージの署名（クライアントと中間者の間の接続のためにEKMで元のクライアントによって作成された）は、ユーザー間のEKMの署名と一致しません。中間およびトークンプロバイダー。前者を選択した場合（および、独自のトークンバインディング秘密キーを使用して、自身、中間者、およびトークンプロバイダー間の接続のEKMを介して独自の署名を作成した場合）、トークンバインディングメッセージはman-in-the-middleとToken Provider間の接続は一致しますが、メッセージ内のトークンバインディングIDは、クライアントの認証トークンがバインドされているトークンバインディングIDと一致しません。いずれにしても、man-in-the-middleはトークンプロバイダーによって検出されますが、提供されたToken Bindingプライベートキーの所有の証明がプロトコルで必要な場合にのみ（上記のように）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Next, consider the presence of a man-in-the-middle between the client and the Token Consumer. That man-in-the-middle can intercept and modify any message sent by the client to the Token Consumer and any message sent by the Token Consumer to the client. The Token Consumer is the party that redirects the client to the Token Provider. In this case, the man-in-the-middle controls the redirect URL and can tamper with any redirect URL issued by the Token Consumer (as well as with any JavaScript running in the origin of the Token Consumer). The goal of the man-in-the-middle is to trick the Token Provider into issuing a token bound to its Token Binding ID and not to the Token Binding ID of the legitimate client. To thwart this goal of the man-in-the-middle, the client&#39;s Referred Token Binding ID must be communicated to the Token Provider in a manner that cannot be affected by the man-in-the-middle (who, as mentioned above, can modify redirect URLs and JavaScript at the client). Including the referred TokenBinding structure in the Sec-Token-Binding header field (as opposed to, say, including the Referred Token Binding ID in an application-level message as part of the redirect URL) is one way to assure that the man-in-the-middle between the client and the Token Consumer cannot affect the communication of the Referred Token Binding ID to the Token Provider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次に、クライアントとトークンコンシューマの間の中間者の存在を検討します。その中間者は、クライアントからトークンコンシューマに送信されたメッセージ、およびトークンコンシューマからクライアントに送信されたメッセージをインターセプトおよび変更できます。トークンコンシューマは、クライアントをトークンプロバイダーにリダイレクトするパーティです。この場合、中間者がリダイレクトURLを制御し、トークンコンシューマーによって発行されたリダイレクトURL（およびトークンコンシューマーのオリジンで実行されているJavaScript）を改ざんできます。中間者の目標は、トークンプロバイダーをだまして、正当なクライアントのトークンバインディングIDではなく、トークンバインディングIDにバインドされたトークンを発行させることです。中間者のこの目標を阻止するには、中間者（前述のとおり、この中間者の影響を受けない方法で、クライアントの参照トークンバインディングIDをトークンプロバイダーに伝達する必要があります。クライアントでリダイレクトURLとJavaScriptを変更できます）。参照されたTokenBinding構造をSec-Token-Bindingヘッダーフィールドに含める（たとえば、リダイレクトURLの一部としてアプリケーションレベルのメッセージにReferred Token Binding IDを含めるのではなく）ことは、マンイン-クライアントとトークンコンシューマの間の中間は、参照されたトークンバインディングIDのトークンプロバイダーへの通信に影響しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, the Sec-Token-Binding header field in the federated sign-on use case contains both a proof of possession of the provided Token Binding key and a proof of possession of the referred Token Binding key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、フェデレーションサインオンユースケースのSec-Token-Bindingヘッダーフィールドには、提供されたトークンバインディングキーの所有の証明と、参照されたトークンバインディングキーの所有の証明の両方が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the presence of Token Binding does not relieve the Token Provider and Token Consumer from performing various checks to ensure the security of clients during the use of federated sign-on protocols. These include the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンバインディングが存在しても、フェデレーションサインオンプロトコルの使用中にクライアントのセキュリティを確保するために、トークンプロバイダーとトークンコンシューマーがさまざまなチェックを実行することはありません。 これらには次のものが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Token Provider should not issue tokens to Token Consumers that have been shown to act maliciously. To aid in this, the federation protocol should identify the Token Consumer to the Token Provider (e.g., through OAuth client IDs or similar mechanisms), and the Token Provider should ensure that tokens are indeed issued to the Token Consumer identified in the token request (e.g., by verifying that the redirect URI is associated with the OAuth client ID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oトークンプロバイダーは、悪意を持って行動することが示されているトークンコンシューマーにトークンを発行しないでください。 これを支援するために、フェデレーションプロトコルは、トークンプロバイダーに対してトークンコンシューマーを識別し（たとえば、OAuthクライアントIDまたは同様のメカニズムを通じて）、トークンプロバイダーは、トークンリクエストで識別されたトークンコンシューマーにトークンが実際に発行されることを確認する必要があります（ たとえば、リダイレクトURIがOAuthクライアントIDに関連付けられていることを確認することにより）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Token Consumer should verify that the tokens were issued for it and not for some other Token Consumer. To aid in this, the federation protocol should include an audience parameter in the token response or apply equivalent mechanisms (the implicit OAuth flow requires Token Consumers to identify themselves when they exchange OAuth authorization codes for OAuth refresh tokens, leaving it up to the Token Provider to verify that the OAuth authorization was delivered to the correct Token Consumer).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oトークンコンシューマーは、トークンが他のトークンコンシューマーに対してではなく、トークントークンに対して発行されたことを確認する必要があります。 これを支援するために、フェデレーションプロトコルは、トークン応答にオーディエンスパラメーターを含めるか、同等のメカニズムを適用する必要があります（暗黙のOAuthフローでは、トークンプロバイダーがOAuth更新トークンのOAuth承認コードを交換するときに自身を識別する必要があります） OAuth認証が正しいトークンコンシューマに配信されたことを確認します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Privacy Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.プライバシーに関する考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Scoping of Token Binding Key Pairs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1。 トークンバインディングキーペアのスコープ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients use different Token Binding key pairs for different servers, so as to not allow Token Binding to become a tracking tool across different servers. However, the scoping of the Token Binding key pairs to servers varies according to the scoping rules of the application protocol (Section 4.1 of [RFC8471]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、異なるサーバー間で異なるトークンバインドキーペアを使用して、異なるサーバー間でトークンバインドが追跡ツールにならないようにします。 ただし、サーバーへのトークンバインディングキーペアのスコープは、アプリケーションプロトコルのスコープルールに従って異なります（[RFC8471]のセクション4.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of HTTP cookies, servers may use Token Binding to secure their cookies. These cookies can be attached to any subdomain of effective top-level domains (eTLDs), and clients therefore should use the same Token Binding key pair across such subdomains. This will ensure that any server capable of receiving the cookie will see the same Token Binding ID from the client and thus be able to verify the Token Binding of the cookie. See Section 2.1 above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HTTP Cookieの場合、サーバーはToken Bindingを使用してCookieを保護できます。 これらのCookieは、有効なトップレベルドメイン（eTLD）の任意のサブドメインに添付できるため、クライアントはそのようなサブドメイン全体で同じトークンバインディングキーペアを使用する必要があります。 これにより、Cookieを受信できるすべてのサーバーがクライアントから同じトークンバインディングIDを参照できるようになり、Cookieのトークンバインディングを確認できるようになります。 上記のセクション2.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client application is not a web browser, it may have additional knowledge about the relationship between different servers. For example, the client application might be aware of the fact that two servers play the roles of Relying Party and Identity Provider, respectively, in a federated sign-on protocol and that they therefore share the identity of the user. In such cases, it is permissible to use different Token Binding key-pair scoping rules, such as using the same Token Binding key pair for both the Relying Party and the Identity Provider. Absent such special knowledge, conservative key-pair scoping rules should be used, assuring that clients use different Token Binding key pairs with different servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントアプリケーションがWebブラウザーではない場合、異なるサーバー間の関係に関する追加の知識を持っている可能性があります。 たとえば、クライアントアプリケーションは、フェデレーションサインオンプロトコルで2つのサーバーがそれぞれ証明書利用者とIDプロバイダーの役割を果たしているため、ユーザーのIDを共有しているという事実を認識している場合があります。 そのような場合、依拠当事者とアイデンティティプロバイダーの両方に同じトークンバインディングキーペアを使用するなど、異なるトークンバインディングキーペアスコープルールを使用することができます。 このような特別な知識がない場合は、保守的なキーペアスコープルールを使用して、クライアントが異なるサーバーで異なるトークンバインディングキーペアを使用するようにします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Lifetime of Token Binding Key Pairs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2。 トークンバインディングキーペアの寿命
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Token Binding key pairs do not have an expiration time. This means that they can potentially be used by a server to track a user for an extended period of time (similar to a long-lived cookie). HTTPS clients such as web User Agents SHOULD therefore provide a user interface for discarding Token Binding key pairs (similar to the controls provided for deleting cookies).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トークンバインディングキーペアには有効期限はありません。 これは、サーバーが潜在的にそれらを使用して、長期間にわたってユーザーを追跡できることを意味します（長寿命のCookieと同様）。 したがって、WebユーザーエージェントなどのHTTPSクライアントは、トークンバインディングキーペアを破棄するためのユーザーインターフェイスを提供する必要があります（Cookieを削除するために提供されるコントロールと同様）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a User Agent provides modes such as private browsing mode in which the user is promised that browsing state such as cookies are discarded after the session is over, the User Agent MUST also discard Token Binding key pairs from such modes after the session is over. Generally speaking, users should be given the same level of control over the lifetime of Token Binding key pairs as they have over cookies or other potential tracking mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーエージェントがプライベートブラウジングモードなどのモードを提供し、ユーザーがセッションの終了後にクッキーなどのブラウジング状態が破棄されると約束されている場合、ユーザーエージェントはセッションが終了した後にそのようなモードからトークンバインディングキーペアも破棄しなければなりません（MUST）。 一般的に、ユーザーは、Cookieまたは他の潜在的な追跡メカニズムを使用しているのと同じように、トークンバインディングキーペアの存続期間にわたって同じレベルの制御を与える必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Correlation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3。 相関
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application&#39;s various communicating endpoints that receive Token Binding IDs for TLS connections other than their own obtain information about the application&#39;s other TLS connections. (In this context, &#34;an application&#34; is a combination of client-side and server-side components, communicating over HTTPS, where the client side may be web-browser-based, native-application-based, or both.) These other Token Binding IDs can serve as correlation handles for the endpoints of the other connections. If the receiving endpoints are otherwise aware of these other connections, then no additional information is being exposed. For instance, if in a redirect-based federation protocol the Identity Provider and Relying Party already possess URLs for one another, then also having Token Binding IDs for these connections does not provide additional correlation information. If not, by providing the other Token Binding IDs, additional information is then exposed that can be used to correlate the other endpoints. In such cases, a privacy analysis of enabled correlations and their potential privacy impacts should be performed as part of the application design decisions of how, and whether, to utilize Token Binding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS接続用のトークンバインディングIDを受信する、アプリケーションのさまざまな通信エンドポイントは、アプリケーション自身のTLS接続に関する情報を取得します。 （このコンテキストでは、「アプリケーション」はクライアント側とサーバー側のコンポーネントの組み合わせであり、HTTPSを介して通信します。クライアント側はWebブラウザーベース、ネイティブアプリケーションベース、またはその両方です。）トークンバインディングIDは、他の接続のエンドポイントの相関ハンドルとして機能できます。受信側のエンドポイントがこれらの他の接続を認識していない場合、追加情報は公開されません。たとえば、リダイレクトベースのフェデレーションプロトコルでアイデンティティプロバイダーと依存パーティが既に相互にURLを所有している場合、これらの接続のトークンバインディングIDを使用しても追加の相関情報は提供されません。そうでない場合は、他のトークンバインディングIDを提供することにより、他のエンドポイントの相関に使用できる追加情報が公開されます。そのような場合、有効化された相関関係とその潜在的なプライバシーへの影響のプライバシー分析は、トークンバインディングをどのように、どのように使用するかを決定するアプリケーション設計の一環として実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, Token Binding implementations must take care to only reveal Token Binding IDs to other endpoints if signaled to do so by the application associated with a Token Binding ID; see Section 6 (&#34;Implementation Considerations&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、トークンバインディングの実装は、トークンバインディングIDに関連付けられたアプリケーションからそうするように指示された場合にのみ、トークンバインディングIDを他のエンドポイントに公開するように注意する必要があります。 セクション6（「実装に関する考慮事項」）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, care should be taken to ensure that unrelated applications do not obtain information about each other&#39;s Token Bindings. For instance, a Token Binding implementation shared between multiple applications on a given system should prevent unrelated applications from obtaining each other&#39;s Token Binding information. This may be accomplished by using techniques such as application isolation and key segregation, depending upon system capabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最後に、無関係なアプリケーションが互いのトークンバインディングに関する情報を取得しないように注意する必要があります。 たとえば、特定のシステム上の複数のアプリケーション間で共有されるトークンバインディング実装は、無関係なアプリケーションが互いのトークンバインディング情報を取得することを防ぐ必要があります。 これは、システムの機能に応じて、アプリケーションの分離やキーの分離などの手法を使用して実現できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below is the Internet Assigned Numbers Authority (IANA) &#34;Permanent Message Header Field Names&#34; registration information per [RFC3864].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、[RFC3864]ごとのインターネット割り当て番号局（IANA）の「永続メッセージヘッダーフィールド名」登録情報です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Header Field name: Sec-Token-Binding Protocol: HTTP Status: standard Reference: This document
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ヘッダーフィールド名：Sec-Token-Bindingプロトコル：HTTPステータス：標準参照：このドキュメント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Header Field name: Include-Referred-Token-Binding-ID Protocol: HTTP Status: standard Reference: This document
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ヘッダーフィールド名：Include-Referred-Token-Binding-IDプロトコル：HTTPステータス：標準参照：このドキュメント
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.参照
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1。 規範的参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PSL] Mozilla, &#34;Public Suffix List&#34;, &lt;https://publicsuffix.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PSL] Mozilla、「Public Suffix List」、&lt;https://publicsuffix.org/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;https://www.rfc-editor.org/info/ rfc2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818] Rescorla, E., &#34;HTTP Over TLS&#34;, RFC 2818, DOI 10.17487/RFC2818, May 2000, &lt;https://www.rfc-editor.org/info/rfc2818&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818] Rescorla、E。、「HTTP Over TLS」、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、&lt;https://www.rfc-editor.org/info/rfc2818&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3864] Klyne, G., Nottingham, M., and J. Mogul, &#34;Registration Procedures for Message Header Fields&#34;, BCP 90, RFC 3864, DOI 10.17487/RFC3864, September 2004, &lt;https://www.rfc-editor.org/info/rfc3864&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3864]クライン、G。、ノッティンガム、M。、およびJ.モーグル、「メッセージヘッダーフィールドの登録手順」、BCP 90、RFC 3864、DOI 10.17487 / RFC3864、2004年9月、&lt;https：//www.rfc- editor.org/info/rfc3864&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson, S., &#34;The Base16, Base32, and Base64 Data Encodings&#34;, RFC 4648, DOI 10.17487/RFC4648, October 2006, &lt;https://www.rfc-editor.org/info/rfc4648&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64 Data Encodings」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、&lt;https://www.rfc-editor.org/info/rfc4648&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, DOI 10.17487/RFC5246, August 2008, &lt;https://www.rfc-editor.org/info/rfc5246&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks、T。およびE. Rescorla、「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、&lt;https://www.rfc-editor.org/info / rfc5246&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5705] Rescorla, E., &#34;Keying Material Exporters for Transport Layer Security (TLS)&#34;, RFC 5705, DOI 10.17487/RFC5705, March 2010, &lt;https://www.rfc-editor.org/info/rfc5705&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5705] Rescorla、E。、「Transport Layer Security（TLS）のキーイングマテリアルエクスポーター」、RFC 5705、DOI 10.17487 / RFC5705、2010年3月、&lt;https://www.rfc-editor.org/info/rfc5705&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6265] Barth, A., &#34;HTTP State Management Mechanism&#34;, RFC 6265, DOI 10.17487/RFC6265, April 2011, &lt;https://www.rfc-editor.org/info/rfc6265&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6265] Barth、A。、「HTTP状態管理メカニズム」、RFC 6265、DOI 10.17487 / RFC6265、2011年4月、&lt;https://www.rfc-editor.org/info/rfc6265&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&#34;, RFC 7230, DOI 10.17487/RFC7230, June 2014, &lt;https://www.rfc-editor.org/info/rfc7230&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230]フィールディング、R。、エド。 およびJ. Reschke、Ed。、「ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文とルーティング」、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、&lt;https://www.rfc-editor.org/info/ rfc7230&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content&#34;, RFC 7231, DOI 10.17487/RFC7231, June 2014, &lt;https://www.rfc-editor.org/info/rfc7231&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7231]フィールディング、R。、エド。 およびJ. Reschke、Ed。、「ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスとコンテンツ」、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、&lt;https://www.rfc-editor.org/info/rfc7231 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7541] Peon, R. and H. Ruellan, &#34;HPACK: Header Compression for HTTP/2&#34;, RFC 7541, DOI 10.17487/RFC7541, May 2015, &lt;https://www.rfc-editor.org/info/rfc7541&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7541] Peon、R.およびH. Ruellan、「HPACK：HTTP / 2のヘッダー圧縮」、RFC 7541、DOI 10.17487 / RFC7541、2015年5月、&lt;https://www.rfc-editor.org/info/rfc7541 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、&lt;https://www.rfc-editor.org/info/ rfc8174&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8471] Popov, A., Ed., Nystroem, M., Balfanz, D., and J. Hodges, &#34;The Token Binding Protocol Version 1.0&#34;, RFC 8471, DOI 10.17487/RFC8471, October 2018, &lt;https://www.rfc-editor.org/info/rfc8471&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8471] Popov、A.、Ed。、Nystroem、M.、Balfanz、D。、およびJ. Hodges、「Token Binding Protocol Version 1.0」、RFC 8471、DOI 10.17487 / RFC8471、2018年10月、&lt;https：/ /www.rfc-editor.org/info/rfc8471&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8472] Popov, A., Ed., Nystroem, M., and D. Balfanz, &#34;Transport Layer Security (TLS) Extension for Token Binding Protocol Negotiation&#34;, RFC 8472, DOI 10.17487/RFC8472, October 2018, &lt;https://www.rfc-editor.org/info/rfc8472&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8472] Popov、A.、Ed。、Nystroem、M。、およびD. Balfanz、「トークンバインディングプロトコルネゴシエーション用のトランスポート層セキュリティ（TLS）拡張」、RFC 8472、DOI 10.17487 / RFC8472、2018年10月、&lt;https： //www.rfc-editor.org/info/rfc8472&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2。 参考資料
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[fetch-spec] WhatWG, &#34;Fetch&#34;, Living Standard, &lt;https://fetch.spec.whatwg.org/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[fetch-spec] WhatWG、 &#34;Fetch&#34;、Living Standard、&lt;https://fetch.spec.whatwg.org/&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OASIS.saml-core-2.0-os] Cantor, S., Kemp, J., Philpott, R., and E. Maler, &#34;Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0&#34;, OASIS Standard saml-core-2.0-os, March 2005, &lt;http://docs.oasis-open.org/ security/saml/v2.0/saml-core-2.0-os.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OASIS.saml-core-2.0-os] Cantor、S.、Kemp、J.、Philpott、R。、およびE. Maler、「OASISセキュリティアサーションマークアップ言語（SAML）V2.0のアサーションおよびプロトコル」、 OASIS標準saml-core-2.0-os、2005年3月、&lt;http://docs.oasis-open.org/ security / saml / v2.0 / saml-core-2.0-os.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OASIS.saml-prof-2.0-os] Hughes, J., Ed., Cantor, S., Ed., Hodges, J., Ed., Hirsch, F., Ed., Mishra, P., Ed., Philpott, R., Ed., and E. Maler, Ed., &#34;Profiles for the OASIS Security Assertion Markup Language (SAML) V2.0&#34;, OASIS Standard OASIS.saml-profiles-2.0-os, March 2005, &lt;http://docs.oasis-open.org/security/ saml/v2.0/saml-profiles-2.0-os.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OASIS.saml-prof-2.0-os] Hughes、J.、Ed。、Cantor、S.、Ed。、Hodges、J.、Ed。、Hirsch、F.、Ed。、Mishra、P.、Ed。 、Philpott、R.、Ed。、およびE. Maler、Ed。、「OASISセキュリティアサーションマークアップ言語（SAML）V2.0のプロファイル」、OASIS標準OASIS.saml-profiles-2.0-os、2005年3月、&lt; http://docs.oasis-open.org/security/ saml / v2.0 / saml-profiles-2.0-os.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OpenID.Core] Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, &#34;OpenID Connect Core 1.0 incorporating errata set 1&#34;, November 2014, &lt;http://openid.net/specs/openid-connect-core-1_0.html&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OpenID.Core] Sakimura、N.、Bradley、J.、Jones、M.、de Medeiros、B。、およびC. Mortimore、「エラータセット1を組み込んだOpenID Connect Core 1.0」、2014年11月、&lt;http：// openid.net/specs/openid-connect-core-1_0.html&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6749] Hardt, D., Ed., &#34;The OAuth 2.0 Authorization Framework&#34;, RFC 6749, DOI 10.17487/RFC6749, October 2012, &lt;https://www.rfc-editor.org/info/rfc6749&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6749] Hardt、D.、Ed。、「OAuth 2.0認可フレームワーク」、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、&lt;https://www.rfc-editor.org/info/rfc6749&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7540] Belshe, M., Peon, R., and M. Thomson, Ed., &#34;Hypertext Transfer Protocol Version 2 (HTTP/2)&#34;, RFC 7540, DOI 10.17487/RFC7540, May 2015, &lt;https://www.rfc-editor.org/info/rfc7540&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7540] Belshe、M.、Peon、R.、およびM. Thomson、Ed。、「ハイパーテキスト転送プロトコルバージョン2（HTTP / 2）」、RFC 7540、DOI 10.17487 / RFC7540、2015年5月、&lt;https：// www.rfc-editor.org/info/rfc7540&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TOKENBIND-TLS13] Harper, N., &#34;Token Binding for Transport Layer Security (TLS) Version 1.3 Connections&#34;, Work in Progress, draft-ietf-tokbind-tls13-01, May 2018.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TOKENBIND-TLS13] Harper、N。、「トランスポート層セキュリティ（TLS）バージョン1.3接続のトークンバインディング」、Work in Progress、draft-ietf-tokbind-tls13-01、2018年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.REC-DOM-Level-3-Core-20040407] Le Hors, A., Ed., Le Hegaret, P., Ed., Wood, L., Ed., Nicol, G., Ed., Robie, J., Ed., Champion, M., Ed., and S. Byrne, Ed., &#34;Document Object Model (DOM) Level 3 Core Specification&#34;, World Wide Web Consortium Recommendation REC-DOM-Level-3-Core-20040407, April 2004, &lt;https://www.w3.org/TR/2004/ REC-DOM-Level-3-Core-20040407&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.REC-DOM-Level-3-Core-20040407] Le Hors、A.、Ed。、Le Hegaret、P.、Ed。、Wood、L.、Ed。、Nicol、G.、Ed。、Robie 、J.、Ed。、Champion、M.、Ed。、およびS. Byrne、Ed。、「Document Object Model（DOM）Level 3 Core Specification」、World Wide Web Consortium Recommendation REC-DOM-Level-3-Core -20040407、2004年4月、&lt;https://www.w3.org/TR/2004/ REC-DOM-Level-3-Core-20040407&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document incorporates comments and suggestions offered by Eric Rescorla, Gabriel Montenegro, Martin Thomson, Vinod Anupam, Anthony Nadalin, Michael B. Jones, Bill Cox, Brian Campbell, and others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントには、Eric Rescorla、Gabriel Montenegro、Martin Thomson、Vinod Anupam、Anthony Nadalin、Michael B. Jones、Bill Cox、Brian Campbellなどが提供するコメントと提案が組み込まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document was produced under the chairmanship of John Bradley and Leif Johansson. The area directors included Eric Rescorla, Kathleen Moriarty, and Stephen Farrell.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、ジョン・ブラッドリーとレイフ・ヨハンソンの議長の下で作成されました。 エリアディレクターには、エリックレスコーラ、キャスリーンモリアーティ、スティーブンファレルが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andrei Popov Microsoft Corp. United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アンドレイポポフマイクロソフトコーポレーションアメリカ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: andreipo@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：andreipo@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Magnus Nystroem Microsoft Corp. United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Magnus Nystroem Microsoft Corp.アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: mnystrom@microsoft.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：mnystrom@microsoft.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dirk Balfanz (editor) Google Inc. United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dirk Balfanz（編集者）Google Inc.アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: balfanz@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：balfanz@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nick Harper Google Inc. United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nick Harper Google Inc.アメリカ合衆国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: nharper@google.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：nharper@google.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jeff Hodges Kings Mountain Systems United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ジェフホッジスキングスマウンテンシステムズアメリカ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Email: Jeff.Hodges@KingsMountain.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メール：Jeff.Hodges@KingsMountain.com
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
