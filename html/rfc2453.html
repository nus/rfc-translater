<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 2453 - RIP Version 2 日本語訳</title>

  
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
    <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2453 - RIP Version 2 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc2453">
              https://tools.ietf.org/html/rfc2453
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 2453 - RIPバージョン2</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Network Working Group                                          G. Malkin
Request for Comments: 2453                                  Bay Networks
Obsoletes: 1723, 1388                                      November 1998
STD: 56
Category: Standards Track
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             RIP Version 2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このメモの位置付け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（1998）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document specifies an extension of the Routing Information Protocol (RIP), as defined in [1], to expand the amount of useful information carried in RIP messages and to add a measure of security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPメッセージで運ばれた有用な情報の量を拡大し、セキュリティ対策を追加する、[1]で定義されるように、この文書は、ルーティング情報プロトコル（RIP）の拡張を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A companion document will define the SNMP MIB objects for RIP-2 [2]. An additional document will define cryptographic security improvements for RIP-2 [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
仲間ドキュメントはRIP-2のためのSNMP MIBオブジェクトを定義する[2]。追加のドキュメントは、[3] RIP-2の暗号化セキュリティの向上を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
I would like to thank the IETF RIP Working Group for their help in improving the RIP-2 protocol. Much of the text for the background discussions about distance vector protocols and some of the descriptions of the operation of RIP were taken from &#34;Routing Information Protocol&#34; by C. Hedrick [1]. Some of the final editing on the document was done by Scott Bradner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私は、RIP-2プロトコルの改善に彼らの助けのためにIETF RIPワーキンググループに感謝したいと思います。背景の距離ベクトルプロトコルに関する議論やRIPの動作の説明のいくつかのテキストの多くは、[1] C.ヘドリックによって、「ルーティング情報プロトコル」から取られました。文書の最終的な編集の一部は、スコット・ブラッドナーによって行われました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Justification  . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Current RIP  . . . . . . . . . . . . . . . . . . . . . . . . .  3
   3.  Basic Protocol . . . . . . . . . . . . . . . . . . . . . . . .  3
   3.1   Introduction   . . . . . . . . . . . . . . . . . . . . . . .  3
   3.2   Limitations of the Protocol  . . . . . . . . . . . . . . . .  5
   3.3.  Organization of this document  . . . . . . . . . . . . . . .  6
   3.4   Distance Vector Algorithms . . . . . . . . . . . . . . . . .  6
   3.4.1    Dealing with changes in topology  . . . . . . . . . . . . 12
   3.4.2    Preventing instability  . . . . . . . . . . . . . . . . . 13
   3.4.3    Split horizon . . . . . . . . . . . . . . . . . . . . . . 15
   3.4.4    Triggered updates . . . . . . . . . . . . . . . . . . . . 17
   3.5   Protocol Specification   . . . . . . . . . . . . . . . . . . 18
   3.6   Message Format . . . . . . . . . . . . . . . . . . . . . . . 20
   3.7   Addressing Considerations  . . . . . . . . . . . . . . . . . 22
   3.8   Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
   3.9   Input Processing . . . . . . . . . . . . . . . . . . . . . . 25
   3.9.1    Request Messages  . . . . . . . . . . . . . . . . . . . . 25
   3.9.2    Response Messages . . . . . . . . . . . . . . . . . . . . 26
   3.10  Output Processing  . . . . . . . . . . . . . . . . . . . . . 28
   3.10.1   Triggered Updates . . . . . . . . . . . . . . . . . . . . 29
   3.10.2   Generating Response Messages. . . . . . . . . . . . . . . 30
   4.  Protocol Extensions  . . . . . . . . . . . . . . . . . . . . . 31
   4.1   Authentication . . . . . . . . . . . . . . . . . . . . . . . 31
   4.2   Route Tag  . . . . . . . . . . . . . . . . . . . . . . . . . 32
   4.3   Subnet Mask  . . . . . . . . . . . . . . . . . . . . . . . . 32
   4.4   Next Hop . . . . . . . . . . . . . . . . . . . . . . . . . . 33
   4.5   Multicasting . . . . . . . . . . . . . . . . . . . . . . . . 33
   4.6   Queries  . . . . . . . . . . . . . . . . . . . . . . . . . . 33
   5.  Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . 34
   5.1   Compatibility Switch . . . . . . . . . . . . . . . . . . . . 34
   5.2   Authentication . . . . . . . . . . . . . . . . . . . . . . . 34
   5.3   Larger Infinity  . . . . . . . . . . . . . . . . . . . . . . 35
   5.4   Addressless Links  . . . . . . . . . . . . . . . . . . . . . 35
   6.  Interaction between version 1 and version 2  . . . . . . . . . 35
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 36
   Appendices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
   References . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
   Author&#39;s Address . . . . . . . . . . . . . . . . . . . . . . . . . 38
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 39
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Justification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.正当化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
With the advent of OSPF and IS-IS, there are those who believe that RIP is obsolete. While it is true that the newer IGP routing protocols are far superior to RIP, RIP does have some advantages. Primarily, in a small network, RIP has very little overhead in terms of bandwidth used and configuration and management time. RIP is also very easy to implement, especially in relation to the newer IGPs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
OSPFやIS-ISの出現により、そのRIPが時代遅れであると考えている人々があります。それは新しいIGPルーティングプロトコルはRIPよりもはるかに優れていることは事実ですが、RIPはいくつかの利点を持っています。主に、小規模なネットワークでは、RIPは、帯域幅を使用して設定および管理時間の点で非常にわずかなオーバーヘッドを持っています。 RIPは、特に新しいのIGPに関連して、また、実装するのは非常に簡単です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Additionally, there are many, many more RIP implementations in the field than OSPF and IS-IS combined. It is likely to remain that way for some years yet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、OSPFより多くの分野で、より多くのRIPの実装があるとIS-IS組み合わせます。まだいくつかの年のためにそのように残りやすいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Given that RIP will be useful in many environments for some period of time, it is reasonable to increase RIP&#39;s usefulness. This is especially true since the gain is far greater than the expense of the change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPは、しばらくの間、多くの環境で有用であろうことを考えると、RIPの有用性を高めるために合理的です。ゲインが変更の費用よりもはるかに大きいので、これは特にそうです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Current RIP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.現在のRIP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current RIP-1 message contains the minimal amount of information necessary for routers to route messages through a network. It also contains a large amount of unused space, owing to its origins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在のRIP-1メッセージは、ネットワークを介してメッセージをルーティングするためにルータに必要な情報の最小量を含有します。また、その起源のために、未使用のスペースを大量に含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The current RIP-1 protocol does not consider autonomous systems and IGP/EGP interactions, subnetting [11], and authentication since implementations of these postdate RIP-1. The lack of subnet masks is a particularly serious problem for routers since they need a subnet mask to know how to determine a route. If a RIP-1 route is a network route (all non-network bits 0), the subnet mask equals the network mask. However, if some of the non-network bits are set, the router cannot determine the subnet mask. Worse still, the router cannot determine if the RIP-1 route is a subnet route or a host route. Currently, some routers simply choose the subnet mask of the interface over which the route was learned and determine the route type from that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらの実装はRIP-1 POSTDATEため現在RIP-1プロトコルは、自律システムとIGP / EGP相互作用、サブネット[11]、および認証を考慮していません。彼らはルートを決定する方法を知っているサブネットマスクを必要とするので、サブネットマスクの欠如は、ルータのために特に深刻な問題です。 RIP-1経路は、ネットワーク経路（すべての非ネットワークビット0）である場合、サブネットマスクはネットワークマスクに等しいです。非ネットワークビットの一部が設定されている場合は、ルータは、サブネットマスクを決定することができません。 RIP-1のルートは、サブネットルートまたはホストルートの場合はさらに悪いことに、ルータが判断することはできません。現在、一部のルータは、単純にルートが学習された上でのインターフェイスのサブネットマスクを選択し、そのからルートタイプを決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Basic Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.基本的なプロトコル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP is a routing protocol based on the Bellman-Ford (or distance vector) algorithm. This algorithm has been used for routing computations in computer networks since the early days of the ARPANET. The particular packet formats and protocol described here are based on the program &#34;routed,&#34; which is included with the Berkeley distribution of Unix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPは、ベルマン・フォード（または距離ベクトル）アルゴリズムに基づいたルーティングプロトコルです。このアルゴリズムは、ARPANETの初期の頃からコンピュータネットワークにおける計算をルーティングするために使用されてきました。ここに記載された特定のパケットフォーマットとプロトコルは、UNIXのバークレーのディストリビューションに含まれている「ルーティングされ、」プログラムに基づいています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In an international network, such as the Internet, it is very unlikely that a single routing protocol will used for the entire network. Rather, the network will be organized as a collection of Autonomous Systems (AS), each of which will, in general, be administered by a single entity. Each AS will have its own routing technology, which may differ among AS&#39;s. The routing protocol used within an AS is referred to as an Interior Gateway Protocol (IGP). A separate protocol, called an Exterior Gateway Protocol (EGP), is used to transfer routing information among the AS&#39;s. RIP was designed to work as an IGP in moderate-size AS&#39;s. It is not intended for use in more complex environments. For information on the context into which RIP-1 is expected to fit, see Braden and Postel [6].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
国際的なネットワークでは、インターネットのような、単一のルーティングプロトコルは、ネットワーク全体のために使用することは非常に考えにくいです。むしろ、ネットワークは、一般的に、単一のエンティティによって投与されるそれぞれが自律システム（AS）の集合として編成されます。各ASはASの間で異なる可能性があり、独自のルーティング技術を、持っています。 AS内で使用されるルーティングプロトコルは、内部ゲートウェイプロトコル（IGP）と呼ばれます。外部ゲートウェイプロトコル（EGP）と呼ばれる別のプロトコルは、ASの間でルーティング情報を転送するために使用されます。 RIPは、適度なサイズASの中IGPとして動作するように設計されました。これは、より複雑な環境での使用のために意図されていません。 RIP-1はブレーデンとポステルを参照し、適合することが期待されるに文脈上の情報のための[6]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP uses one of a class of routing algorithms known as Distance Vector algorithms. The earliest description of this class of algorithms known to the author is in Ford and Fulkerson [8]. Because of this, they are sometimes known as Ford-Fulkerson algorithms. The term Bellman-Ford is also used, and derives from the fact that the formulation is based on Bellman&#39;s equation [4]. The presentation in this document is closely based on [5]. This document contains a protocol specification. For an introduction to the mathematics of routing algorithms, see [1]. The basic algorithms used by this protocol were used in computer routing as early as 1969 in the ARPANET. However, the specific ancestry of this protocol is within the Xerox network protocols. The PUP protocols [7] used the Gateway Information Protocol to exchange routing information. A somewhat updated version of this protocol was adopted for the Xerox Network Systems (XNS) architecture, with the name Routing Information Protocol [9]. Berkeley&#39;s routed is largely the same as the Routing Information Protocol, with XNS addresses replaced by a more general address format capable of handling IPv4 and other types of address, and with routing updates limited to one every 30 seconds. Because of this similarity, the term Routing Information Protocol (or just RIP) is used to refer to both the XNS protocol and the protocol used by routed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPは、距離ベクトルアルゴリズムとして知られているルーティングアルゴリズムのクラスのいずれかを使用します。作成者に知られているアルゴリズムのこのクラスの最も初期の説明は、Fordとフルカーソン[8]です。このため、彼らは時々フォード - フルカーソンアルゴリズムとして知られています。用語ベルマン・フォードも使用され、製剤がベルマンの式[4]に基づいているという事実に由来します。このドキュメントのプレゼンテーションは密接に[5]に基づいています。この文書では、プロトコル仕様が含まれています。ルーティングアルゴリズムの数学への導入のために、[1]を参照。このプロトコルによって使用される基本的なアルゴリズムは、ARPANETのコンピュータルーティング早くも1969年に使用しました。しかし、このプロトコルの特定の祖先は、Xeroxネットワークプロトコルの範囲内です。 PUPプロトコル[7]ルーティング情報を交換するためにゲートウェイ情報プロトコルを使用します。このプロトコルの幾分更新されたバージョンは、名前ルーティング情報プロトコルを用いて、ゼロックスネットワークシステム（XNS）アーキテクチャを採用した[9]。バークレーのルーティングは、IPv4とアドレスの他の種類を扱うことができる、より一般的なアドレス形式に置き換えXNSアドレスを持つと、1、30秒ごとに制限ルーティングアップデートで、主にルーティング情報プロトコルと同じです。このため、類似性という用語は、ルーティング情報プロトコル（又は単にRIP）XNSプロトコルとルーティングによって使用されるプロトコルの両方を指すために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP is intended for use within the IP-based Internet. The Internet is organized into a number of networks connected by special purpose gateways known as routers. The networks may be either point-to-point links or more complex networks such as Ethernet or token ring. Hosts and routers are presented with IP datagrams addressed to some host. Routing is the method by which the host or router decides where to send the datagram. It may be able to send the datagram directly to the destination, if that destination is on one of the networks that are directly connected to the host or router. However, the interesting case is when the destination is not directly reachable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPはIPベースのインターネット内で使用するためのものです。インターネットは、ルータと呼ばれる特別な目的のゲートウェイによって接続されたネットワークの数に編成されます。ネットワークは、ポイントツーポイントリンク、または、イーサネット（登録商標）またはトークンリングなどのより複雑なネットワークのいずれであってもよいです。ホストとルータは、いくつかのホスト宛のIPデータグラムを提示しています。ルーティングは、ホストまたはルータがデータグラムを送信することを決定する方法です。その宛先が直接ホストまたはルータに接続されているネットワークの一つである場合、宛先に直接データグラムを送信することができるかもしれません。宛先が直接到達可能でない場合しかし、興味深いケースです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In this case, the host or router attempts to send the datagram to a router that is nearer the destination. The goal of a routing protocol is very simple: It is to supply the information that is needed to do routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この場合には、ホストまたはルータが宛先により近いルータにデータグラムを送信しようと試みます。ルーティングプロトコルの目標は非常に簡単です：それは、ルーティングを行うために必要な情報を提供することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Limitations of the Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
議定書の3.2制限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This protocol does not solve every possible routing problem. As mentioned above, it is primary intended for use as an IGP in networks of moderate size. In addition, the following specific limitations are be mentioned:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このプロトコルは、すべての可能なルーティングの問題を解決しません。上述したように、それは適度なサイズのネットワークでIGPとしての使用を意図主要あります。また、以下の具体的な制限を挙げることがされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The protocol is limited to networks whose longest path (the network&#39;s diameter) is 15 hops. The designers believe that the basic protocol design is inappropriate for larger networks. Note that this statement of the limit assumes that a cost of 1 is used for each network. This is the way RIP is normally configured. If the system administrator chooses to use larger costs, the upper bound of 15 can easily become a problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロトコルは、その最長経路（ネットワークの直径）15回のホップであるネットワークに制限されています。設計者は、基本的なプロトコルの設計は、大規模なネットワークには不適切であると信じています。リミットのこの文は、1のコストは、各ネットワークのために使用されていることを前提としています。これは、RIPが正常に設定されている方法です。システム管理者は、より大きなコストを使用することを選択した場合、15の上限は、簡単に問題になることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The protocol depends upon &#34;counting to infinity&#34; to resolve certain unusual situations. (This will be explained in the next section.) If the system of networks has several hundred networks, and a routing loop was formed involving all of them, the resolution of the loop would require either much time (if the frequency of routing updates were limited) or bandwidth (if updates were sent whenever changes were detected). Such a loop would consume a large amount of network bandwidth before the loop was corrected. We believe that in realistic cases, this will not be a problem except on slow lines. Even then, the problem will be fairly unusual, since various precautions are taken that should prevent these problems in most cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - プロトコルは、ある特殊な状況を解決するために、「無限カウント」に依存します。ルーティングアップデートの頻度であった場合（これは次のセクションで説明する。）ネットワークのシステムは、それらの全てを含む数百のネットワークを有しており、ルーティングループが形成されている場合、ループの解像度は、（多くの時間のいずれかを必要とするであろう制限された）または帯域幅（変化が検出されたときはいつでも更新が送られた場合）。ループが修正される前にこのようなループは、ネットワーク帯域幅を大量に消費することになります。私たちは、現実的な例では、これは遅い回線を除いて問題になることはないと信じています。それでも、問題は様々な予防策はほとんどの場合、これらの問題を防ぐべきである取られているので、かなり珍しいだろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- This protocol uses fixed &#34;metrics&#34; to compare alternative routes. It is not appropriate for situations where routes need to be chosen based on real-time parameters such a measured delay, reliability, or load. The obvious extensions to allow metrics of this type are likely to introduce instabilities of a sort that the protocol is not designed to handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - このプロトコルは代替経路を比較するために、固定「指標」を使用します。これは、ルートが、そのような測定された遅延、信頼性、または負荷リアルタイムのパラメータに基づいて選択する必要がある状況には適していません。このタイプのメトリックを許可する明白な拡張は、プロトコルが処理するように設計されていない種類の不安定性を導入する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Organization of this document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3。このドキュメントの組織
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The main body of this document is organized into two parts, which occupy the next two sections:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このドキュメントの本体は、次の2つのセクションを占める二つの部分、で構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        A conceptual development and justification of distance vector
        algorithms in general.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The actual protocol description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実際のプロトコル記述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each of these two sections can largely stand on its own. Section 3.4 attempts to give an informal presentation of the mathematical underpinnings of the algorithm. Note that the presentation follows a &#34;spiral&#34; method. An initial, fairly simple algorithm is described. Then refinements are added to it in successive sections. Section 3.5 is the actual protocol description. Except where specific references are made to section 3.4, it should be possible to implement RIP entirely from the specifications given in section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これら二つの部分のそれぞれは、主に、独自の上に立つことができます。 3.4節の試みは、アルゴリズムの数学的基盤の非公式のプレゼンテーションを得ました。プレゼンテーションは、「スパイラル」の方法を以下のことに注意してください。最初の、かなり単純なアルゴリズムが記述されています。その後、改良は、連続するセクションで、それに追加されます。 3.5節では、実際のプロトコルの説明です。具体的な言及はセクション3.4に作られている場合を除き、セクション3.5で与えられた仕様から完全にRIPを実装することが可能でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 Distance Vector Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4距離ベクトルアルゴリズム
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Routing is the task of finding a path from a sender to a desired destination. In the IP &#34;Internet model&#34; this reduces primarily to a matter of finding a series of routers between the source and destination networks. As long as a message or datagram remains on a single network or subnet, any forwarding problems are the responsibility of technology that is specific to the network. For example, Ethernet and the ARPANET each define a way in which any sender can talk to any specified destination within that one network. IP routing comes in primarily when messages must go from a sender on one network to a destination on a different one. In that case, the message must pass through one or more routers connecting the networks. If the networks are not adjacent, the message may pass through several intervening networks, and the routers connecting them. Once the message gets to a router that is on the same network as the destination, that network&#39;s own technology is used to get to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルーティングは、所望の目的地への送信者からのパスを発見するタスクです。 IP「インターネットモデル」で、これは主に、送信元と宛先ネットワーク間のルータのシリーズを見つけるの問題に帰着します。限り、メッセージまたはデータグラムが単一のネットワークまたはサブネット上に残っているとして、任意の転送の問題は、ネットワークに固有の技術の責任です。例えば、イーサネットとARPANETはそれぞれ、任意の送信者は、1つのネットワーク内の任意の指定された宛先に話すことができる方法を定義します。メッセージは異なるものの先にあるネットワーク上の送信者から行かなければならないとき、IPルーティングは、主に来ます。その場合、メッセージは、ネットワークを接続する1つまたは複数のルータを通過しなければなりません。ネットワークが隣接していない場合、メッセージは、いくつかの介在するネットワークを通過し、及びそれらを接続するルータできます。メッセージが送信先と同じネットワーク上にあるルータに到達したら、そのネットワークの独自技術は、宛先に到達するために使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Throughout this section, the term &#34;network&#34; is used generically to cover a single broadcast network (e.g., an Ethernet), a point to point line, or the ARPANET. The critical point is that a network is treated as a single entity by IP. Either no forwarding decision is necessary (as with a point to point line), or that forwarding is done in a manner that is transparent to IP, allowing IP to treat the entire network as a single fully-connected system (as with an Ethernet or the ARPANET). Note that the term &#34;network&#34; is used in a somewhat different way in discussions of IP addressing. We are using the term &#34;network&#34; here to refer to subnets in cases where subnet addressing is in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクション全体を通して、用語「ネットワーク」は、単一のブロードキャストネットワーク（例えば、イーサネット（登録商標））、ポイントラインにポイント、またはARPANETをカバーするために一般的に使用されます。重要な点は、ネットワークがIPによって単一のエンティティとして扱われていることです。いかなる転送の決定は、（ポイントラインをポイントと同様に）必要でない、又はその転送は、IP、イーサネットと又は（単一完全に接続されたシステムなどのネットワーク全体を治療することができ、IPに対して透過的な方法で行われますかARPANET）。用語「ネットワーク」は、IPアドレッシングの議論にやや異なる方法で使用されていることに注意してください。私たちは、サブネットのアドレス指定が使用されている場合にサブネットを参照するために、ここで用語「ネットワーク」を使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A number of different approaches for finding routes between networks are possible. One useful way of categorizing these approaches is on the basis of the type of information the routers need to exchange in order to be able to find routes. Distance vector algorithms are based on the exchange of only a small amount of information. Each entity (router or host) that participates in the routing protocol is assumed to keep information about all of the destinations within the system. Generally, information about all entities connected to one network is summarized by a single entry, which describes the route to all destinations on that network. This summarization is possible because as far as IP is concerned, routing within a network is invisible. Each entry in this routing database includes the next router to which datagrams destined for the entity should be sent. In addition, it includes a &#34;metric&#34; measuring the total distance to the entity. Distance is a somewhat generalized concept, which may cover the time delay in getting messages to the entity, the dollar cost of sending messages to it, etc. Distance vector algorithms get their name from the fact that it is possible to compute optimal routes when the only information exchanged is the list of these distances. Furthermore, information is only exchanged among entities that are adjacent, that is, entities that share a common network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワーク間のルートを見つけるための多くの異なるアプローチが可能です。これらのアプローチを分類する1つの有用な方法は、ルータがルートを見つけることができるようにするために交換する必要がある情報の種類に基づいています。距離ベクトルアルゴリズムは、少量の情報だけの交換に基づいています。ルーティングプロトコルに参加する各エンティティ（ルータまたはホスト）は、システム内の目的地のすべての情報を保持するものとします。一般的に、一つのネットワークに接続されたすべてのエンティティに関する情報は、そのネットワーク上のすべての宛先への経路を説明する単一のエントリによって要約されています。限りIPに関しては、ネットワーク内のルーティングは見えないので、この要約が可能です。このルーティングデータベース内の各エントリは、送信されるべきエンティティ宛てのデータグラムする次のルータを含みます。また、「メトリック」は、エンティティへの総距離を測定することを含みます。距離はエンティティへのメッセージを得ることに時間遅れをカバーすることができる、やや一般概念である、それへのメッセージを送信するのドルコストは、などの距離ベクトルアルゴリズムは、最適なルートを計算することが可能であるという事実から自分の名前を取得します交換された情報だけでは、これらの距離のリストです。さらに、情報は、つまり、共通ネットワークを共有するエンティティ隣接するエンティティ間で交換されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Although routing is most commonly based on information about networks, it is sometimes necessary to keep track of the routes to individual hosts. The RIP protocol makes no formal distinction between networks and hosts. It simply describes exchange of information about destinations, which may be either networks or hosts. (Note however, that it is possible for an implementor to choose not to support host routes. See section 3.2.) In fact, the mathematical developments are most conveniently thought of in terms of routes from one host or router to another. When discussing the algorithm in abstract terms, it is best to think of a routing entry for a network as an abbreviation for routing entries for all of the entities connected to that network. This sort of abbreviation makes sense only because we think of networks as having no internal structure that is visible at the IP level. Thus, we will generally assign the same distance to every entity in a given network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルーティングは、最も一般的にネットワークに関する情報に基づいているが、個々のホストへの経路を追跡することが必要な場合があります。 RIPプロトコルは、ネットワークとホストの間に正式な区別を行いません。それは単にネットワークまたはホストのいずれかであり得る目的地に関する情報の交換を説明しています。 （実装者がホストルートをサポートしないことを選択することが可能であること、しかし、注意してください。セクション3.2を参照してください。）実際には、数学の発展は、最も好都合に別のホストまたはルータからのルートの面で考えられています。抽象的にアルゴリズムを議論する際には、そのネットワークに接続されたエンティティのすべてのエントリをルーティングするための省略形としてのネットワークのためのルーティングエントリを考えるのがベストです。略語のこの種は、我々はIPレベルで可視では内部構造を持たないようなネットワークを考えるだけの理由で理にかなっています。したがって、我々は、一般的に与えられたネットワーク内のすべてのエンティティに同じ距離を割り当てます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
We said above that each entity keeps a routing database with one entry for every possible destination in the system. An actual implementation is likely to need to keep the following information about each destination:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
我々は、各エンティティは、システム内のすべての可能な宛先のための1つのエントリとルーティングデータベースを維持することは、上記述べました。実際の実装は、各宛先に関する以下の情報を保持する必要がありそうです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- address: in IP implementations of these algorithms, this will be the IP address of the host or network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - アドレス：これらのアルゴリズムのIP実装では、これはホストまたはネットワークのIPアドレスになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- router: the first router along the route to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ルータ：目的地へのルートに沿って第1のルータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- interface: the physical network which must be used to reach the first router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - インターフェース：最初のルータに到達するために使用されなければならない物理的なネットワーク。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- metric: a number, indicating the distance to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - メトリック：目的地までの距離を示す数値、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- timer: the amount of time since the entry was last updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - タイマー：エントリが最後に更新されてからの時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In addition, various flags and other internal information will probably be included. This database is initialized with a description of the entities that are directly connected to the system. It is updated according to information received in messages from neighboring routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
また、各種フラグや他の内部情報は、おそらく含まれます。このデータベースは、システムに直接接続されているエンティティの記述で初期化されます。これは、近接ルータからのメッセージで受信した情報に基づいて更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The most important information exchanged by the hosts and routers is carried in update messages. Each entity that participates in the routing scheme sends update messages that describe the routing database as it currently exists in that entity. It is possible to maintain optimal routes for the entire system by using only information obtained from neighboring entities. The algorithm used for that will be described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストとルータによって交換される最も重要な情報が更新メッセージで運ばれます。ルーティング・スキームに参加する各エンティティは、現在そのエンティティに存在するルーティングデータベースを記述する更新メッセージを送信します。隣接するエンティティから得られた情報のみを使用して、システム全体の最適ルートを維持することができます。そのために使用されるアルゴリズムは、次のセクションで説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As we mentioned above, the purpose of routing is to find a way to get datagrams to their ultimate destinations. Distance vector algorithms are based on a table in each router listing the best route to every destination in the system. Of course, in order to define which route is best, we have to have some way of measuring goodness. This is referred to as the &#34;metric&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
我々は前述したように、ルーティングの目的は、彼らの究極の目的地にデータグラムを取得する方法を見つけることです。距離ベクトルアルゴリズムは、システム内のすべての目的地までの最適なルートをリスト各ルータ内のテーブルに基づいています。もちろん、最適なルートを定義するために、我々は良さを測定するいくつかの方法を持っている必要があります。これは、「メトリック」と呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In simple networks, it is common to use a metric that simply counts how many routers a message must go through. In more complex networks, a metric is chosen to represent the total amount of delay that the message suffers, the cost of sending it, or some other quantity which may be minimized. The main requirement is that it must be possible to represent the metric as a sum of &#34;costs&#34; for individual hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
シンプルなネットワークでは、単にメッセージが通過しなければならないどのように多くのルーターをカウントメトリックを使用するのが一般的です。より複雑なネットワークでは、メトリックはメッセージが被る遅延の合計量は、それを送信するコスト、または最小化することができるいくつかの他の量を表すように選択されます。主な要件は、個々のホップのための「コスト」の合計としてメトリックを表すことが可能でなければならないということです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Formally, if it is possible to get from entity i to entity j directly (i.e., without passing through another router between), then a cost, d(i,j), is associated with the hop between i and j. In the normal case where all entities on a given network are considered to be the same, d(i,j) is the same for all destinations on a given network, and represents the cost of using that network. To get the metric of a complete route, one just adds up the costs of the individual hops that make up the route. For the purposes of this memo, we assume that the costs are positive integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それはコスト、D（i、j）は、次いで、（すなわち、間に別のルータを介さずに）直接エンティティjにエンティティからIを得ることが可能であれば正式に、iとjの間のホップに関連しています。所与のネットワーク上のすべてのエンティティが同じであると考えられている通常の場合には、D（i、j）が所定のネットワーク上のすべての宛先に対して同じであり、そのネットワークを使用するコストを表します。完全なルートのメトリックを取得するためには、単にルートを構成する個々のホップのコストを加算します。このメモの目的のために、私たちはコストが正の整数であることを前提としています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let D(i,j) represent the metric of the best route from entity i to entity j. It should be defined for every pair of entities. d(i,j) represents the costs of the individual steps. Formally, let d(i,j) represent the cost of going directly from entity i to entity j. It is infinite if i and j are not immediate neighbors. (Note that d(i,i) is infinite. That is, we don&#39;t consider there to be a direct connection from a node to itself.) Since costs are additive, it is easy to show that the best metric must be described by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D（i、j）はIエンティティjへのエンティティから最適なルートのメトリックを表してみましょう。これは、エンティティの各ペアのために定義する必要があります。 D（i、j）が、個々のステップのコストを表しています。正式には、D（i、j）はiのエンティティjにエンティティから直接行くのコストを表してみましょう。 i、jはすぐ隣でない場合は無限です。 （i）が無限である、そのD（私に注意してください。つまり、我々は、それ自体へのノードからの直接接続があるように考えていません。）コストは加法的であるので、最良のメトリックを説明しなければならないことを示すのは容易です沿って
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
 D(i,i) = 0, all i D(i,j) = min [d(i,k) + D(k,j)], otherwise k and that the best routes start by going from i to those neighbors k for which d(i,k) + D(k,j) has the minimum value. (These things can be shown by induction on the number of steps in the routes.) Note that we can limit the second equation to k&#39;s that are immediate neighbors of i. For the others, d(i,k) is infinite, so the term involving them can never be the minimum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D（I、I）= 0、全てのI D（i、j）は=分[D（I、K）+ D（kは、jは）]、そうでなければk及び最適なルートがそれらの近隣に私から行くことによって開始することこれは、D（I、K）に対するK + D（K、J）が最小値を有します。 （これらのものはルートのステップ数の誘導によって示すことができる。）私たちは私のすぐ隣ですさんをkに第2式を制限できることに注意してください。他の人のために、D（I、k）が無限であるので、それらを含む用語が最小になることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It turns out that one can compute the metric by a simple algorithm based on this. Entity i gets its neighbors k to send it their estimates of their distances to the destination j. When i gets the estimates from k, it adds d(i,k) to each of the numbers. This is simply the cost of traversing the network between i and k. Now and then i compares the values from all of its neighbors and picks the smallest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、1つは、これに基づいて、単純なアルゴリズムでメトリックを計算することができることが判明しました。エンティティiは、その隣人が先jにそれを彼らの距離の彼らの見積もりを送信するためにkを取得します。私はkから見積もりを取得すると、それは数字のそれぞれにD（I、k）を追加します。これは単にiとkとのネットワークを通過するコストです。さて、その後、私はその隣人のすべての値を比較し、最小を選びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A proof is given in [2] that this algorithm will converge to the correct estimates of D(i,j) in finite time in the absence of topology changes. The authors make very few assumptions about the order in which the entities send each other their information, or when the min is recomputed. Basically, entities just can&#39;t stop sending updates or recomputing metrics, and the networks can&#39;t delay messages forever. (Crash of a routing entity is a topology change.) Also, their proof does not make any assumptions about the initial estimates of D(i,j), except that they must be non-negative. The fact that these fairly weak assumptions are good enough is important. Because we don&#39;t have to make assumptions about when updates are sent, it is safe to run the algorithm asynchronously. That is, each entity can send updates according to its own clock. Updates can be dropped by the network, as long as they don&#39;t all get dropped. Because we don&#39;t have to make assumptions about the starting condition, the algorithm can handle changes. When the system changes, the routing algorithm starts moving to a new equilibrium, using the old one as its starting point. It is important that the algorithm will converge in finite time no matter what the starting point. Otherwise certain kinds of changes might lead to non-convergent behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
証拠は、このアルゴリズムが、トポロジの変更が存在しない場合に有限の時間でD（i、j）の正確な推定値に収束すること[2]に示されています。著者は、エンティティがお互いに情報を送ったり、分が再計算されたときにどの順序について非常に少数の仮定を行います。基本的には、エンティティはちょうど更新や再計算メトリックの送信を停止することはできません、とのネットワークは永遠にメッセージを遅らせることはできません。 （ルーティングエンティティのクラッシュがトポロジー変更である。）また、その証拠は、彼らは非負でなければならないことを除いて、D（i、j）の初期推定値についての仮定をしていません。これらのかなり弱い仮定が十分であるという事実は重要です。我々は更新が送信された場合についての仮定を行う必要はありませんので、非同期にアルゴリズムを実行しても安全です。つまり、各エンティティは、自身のクロックに応じて更新を送信することができます。更新は限り彼らはすべてが削除されませんよう、ネットワークによってドロップすることができます。私たちは開始条件についての仮定を行う必要はありませんので、アルゴリズムが変更を処理することができます。ときにシステムの変更、ルーティングアルゴリズムは、その出発点として、古いものを使用して、新しい均衡に移動を開始します。アルゴリズムがどんな出発点有限時間に収束しないことが重要です。それ以外の場合は、変更の特定の種類の非収束動作につながる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The statement of the algorithm given above (and the proof) assumes that each entity keeps copies of the estimates that come from each of its neighbors, and now and then does a min over all of the neighbors. In fact real implementations don&#39;t necessarily do that. They simply remember the best metric seen so far, and the identity of the neighbor that sent it. They replace this information whenever they see a better (smaller) metric. This allows them to compute the minimum incrementally, without having to store data from all of the neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記のアルゴリズム（プルーフ）の文は、各エンティティが、今その隣のそれぞれから来て、推定値のコピーを保持し、その後、隣人のすべての分かけをしていることを前提としています。実際には、実際の実装は、必ずしもそれをしないでください。彼らは、単にこれまで見最良のメトリック、およびそれを送った隣人のアイデンティティを覚えています。彼らはより良い（より小さい）メトリックを見るたびに彼らは、この情報を交換してください。これは、彼らは隣人のすべてのデータを保存することなく、インクリメンタル最小を計算することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There is one other difference between the algorithm as described in texts and those used in real protocols such as RIP: the description above would have each entity include an entry for itself, showing a distance of zero. In fact this is not generally done. Recall that all entities on a network are normally summarized by a single entry for the network. Consider the situation of a host or router G that is connected to network A. C represents the cost of using network A (usually a metric of one). (Recall that we are assuming that the internal structure of a network is not visible to IP, and thus the cost of going between any two entities on it is the same.) In principle, G should get a message from every other entity H on network A, showing a cost of 0 to get from that entity to itself. G would then compute C + 0 as the distance to H. Rather than having G look at all of these identical messages, it simply starts out by making an entry for network A in its table, and assigning it a metric of C. This entry for network A should be thought of as summarizing the entries for all other entities on network A. The only entity on A that can&#39;t be summarized by that common entry is G itself, since the cost of going from G to G is 0, not C. But since we never need those 0 entries, we can safely get along with just the single entry for network A. Note one other implication of this strategy: because we don&#39;t need to use the 0 entries for anything, hosts that do not function as routers don&#39;t need to send any update messages. Clearly hosts that don&#39;t function as routers (i.e., hosts that are connected to only one network) can have no useful information to contribute other than their own entry D(i,i) = 0. As they have only the one interface, it is easy to see that a route to any other network through them will simply go in that interface and then come right back out it. Thus the cost of such a route will be greater than the best cost by at least C. Since we don&#39;t need the 0 entries, non-routers need not participate in the routing protocol at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
テキストおよびRIPなどの実際のプロトコルで使用されるものに記載されるようなアルゴリズムとの間の1つの他の相違点がある：上記の説明は、各エンティティがゼロの距離を示し、それ自体のためのエントリを含むであろう。実際には、これは一般的に行われていません。ネットワーク上のすべてのエンティティは、通常、ネットワークのための単一のエントリによって要約されていることを思い出してください。ネットワークA. Cに接続されたホストまたはルータGの状況を考慮し、ネットワークA（一方の通常メトリック）を使用するコストを表します。原理的に（我々は、ネットワークの内部構造はIPには見えないので、その上の任意の2つのエンティティ間に行くのコストが同じであると仮定されている。リコール）、Gは、他のすべてのエンティティH上からメッセージを取得する必要がありますネットワークAは、0のコストを示すことは、それ自体にそのエンティティから取得します。 Gが、これらの同じメッセージの全てのGの外観を有するよりH.むしろまでの距離としてC + 0を計算するであろう、それは単に、そのテーブル内のネットワークAのためのエントリを作成し、それをC.このエントリのメトリックを割り当てることによって開始しますネットワークのAは、GからGへ行くのコストが0であるため、共通エントリによって要約することができない上にのみエンティティが、G自体はネットワークA上の他のすべてのエンティティのためのエントリをまとめたと考えなければなりませんないC.しかし、我々はそれらの0エントリは必要ありませんから、私たちは安全にネットワークA.注この戦略の一つの他の含意のためだけの単一のエントリと一緒に取得することができます。私たちは何のために0エントリを使用する必要がないため、ホストのことルータは任意の更新メッセージを送信する必要がないと機能しません。それらは唯一つのインタフェースを有するように明確ルータとして機能しないホスト（すなわち、唯一のネットワークに接続されているホスト）（I、I）= 0を自分のエントリD以外に貢献する有用な情報を持つことはできません、それらを介して他のネットワークへのルートは、単にそのインターフェイスに行き、その後、すぐに戻って出てくることを確認することは容易です。我々は、非ルータは全くルーティングプロトコルに参加する必要はありません0エントリは必要ありませんので、このようなルートのコストは、少なくともCで最高のコストよりも大きくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Let us summarize what a host or router G does. For each destination in the system, G will keep a current estimate of the metric for that destination (i.e., the total cost of getting to it) and the identity of the neighboring router on whose data that metric is based. If the destination is on a network that is directly connected to G, then G simply uses an entry that shows the cost of using the network, and the fact that no router is needed to get to the destination. It is easy to show that once the computation has converged to the correct metrics, the neighbor that is recorded by this technique is in fact the first router on the path to the destination. (If there are several equally good paths, it is the first router on one of them.) This combination of destination, metric, and router is typically referred to as a route to the destination with that metric, using that router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは、ホストまたはルータGが何をするかまとめてみましょう。システム内の各宛先に対して、Gはその宛先に対するメトリックの現在の推定値を維持する（すなわち、それに得るための総コスト）とメトリックが基づいていること、そのデータに隣接ルータの識別。宛先が直接Gに接続されたネットワーク上にある場合、Gは、単にネットワークを使用するコストを示したエントリを使用し、何のルータが宛先に到達するために必要とされていないという事実。計算が正しいメトリックに収束した後は、この技術によって記録されたネイバーが実際に目的地への経路上の最初のルータであることを示すのは容易です。 （いくつかの等しく良好なパスがある場合、それはそれらのいずれかの最初のルータである。）先の組み合わせ、メトリック、およびルータは、典型的には、そのルータを使用して、そのメトリックと目的地までの経路と呼ばれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.ne The method so far only has a way to lower the metric, as the existing metric is kept until a smaller one shows up. It is possible that the initial estimate might be too low. Thus, there must be a way to increase the metric. It turns out to be sufficient to use the following rule: suppose the current route to a destination has metric D and uses router G. If a new set of information arrived from some source other than G, only update the route if the new metric is better than D. But if a new set of information arrives from G itself, always update D to the new value. It is easy to show that with this rule, the incremental update process produces the same routes as a calculation that remembers the latest information from all the neighbors and does an explicit minimum. (Note that the discussion so far assumes that the network configuration is static. It does not allow for the possibility that a system might fail.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
4.ne方法は、これまでのところ唯一の既存のメトリックが維持されるように小さい方が表示されるまで、メトリックを低下させる方法を有しています。初期推定値が低すぎるかもしれないことは可能です。このように、メトリックを増加する方法がなければなりません。これは、次のルールを使用するのに十分であることが判明：宛先への現在のルートメトリックDを有しており、情報の新しいセットがG以外のソースから到着した場合、新しいメトリックがある場合、唯一のルートを更新ルータG.を使用すると仮定しますD.より良いしかし、情報の新しいセットは、G自身から到着した場合、常に新しい値にDを更新します。この規則で、増分更新プロセスは、すべてのネイバーから最新の情報を記憶し、明示的な最小を行い、計算と同じルートを生成することを示すのは容易です。 （議論はこれまでに、ネットワーク構成が静的であることを前提としています。それは、システムが失敗するかもしれないという可能性を考慮しません。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To summarize, here is the basic distance vector algorithm as it has been developed so far. (Note that this is not a statement of the RIP protocol. There are several refinements still to be added.) The following procedure is carried out by every entity that participates in the routing protocol. This must include all of the routers in the system. Hosts that are not routers may participate as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それがこれまでに開発されているように要約すると、ここでは基本的な距離ベクトルアルゴリズムがあります。 （これはRIPプロトコルの声明ではないことに注意してください。まだ追加されるいくつかの改良があります。）以下の手順は、ルーティングプロトコルに参加するすべてのエンティティによって行われます。これは、システム内のすべてのルータを含める必要があります。ルータされていないホストも同様に参加することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Keep a table with an entry for every possible destination in the system. The entry contains the distance D to the destination, and the first router G on the route to that network. Conceptually, there should be an entry for the entity itself, with metric 0, but this is not actually included.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - システム内のすべての可能な送信先のエントリを持つテーブルを保管してください。エントリは、目的地までの距離D、及びそのネットワークへのルート上の最初のルータGを含んでいます。概念的には、メトリック0を持つエンティティ自身のエントリがあるはずですが、これは実際には含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Periodically, send a routing update to every neighbor. The update is a set of messages that contain all of the information from the routing table. It contains an entry for each destination, with the distance shown to that destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 定期的に、すべての隣人へのルーティングアップデートを送信します。更新は、ルーティングテーブルからの情報の全てを含むメッセージの集合です。その先に示した距離と、各宛先に対するエントリを含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- When a routing update arrives from a neighbor G&#39;, add the cost associated with the network that is shared with G&#39;. (This should be the network over which the update arrived.) Call the resulting distance D&#39;. Compare the resulting distances with the current routing table entries. If the new distance D&#39; for N is smaller than the existing value D, adopt the new route. That is, change the table entry for N to have metric D&#39; and router G&#39;. If G&#39; is the router from which the existing route came, i.e., G&#39; = G, then use the new metric even if it is larger than the old one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ルーティングアップデートが隣接Gから到着すると「Gと共有されるネットワークに関連するコストを追加します」。 （これは、更新が到着れるネットワークであるべきである。）、得られた距離D」呼び出します。現在のルーティングテーブルのエントリを有する得られた距離を比較してください。 Nのための新しい距離D」が既存の値Dよりも小さい場合には、新たなルートを採用します。すなわち、メトリックD「とルータG」を有するようにNのテーブルエントリを変更しています。 Gが= G「すなわち、G、既存のルートが来たルータである」の場合、それは古いものよりも大きい場合であっても、新たなメトリックを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1 Dealing with changes in topology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
トポロジの変化への対応3.4.1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The discussion above assumes that the topology of the network is fixed. In practice, routers and lines often fail and come back up. To handle this possibility, we need to modify the algorithm slightly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の議論は、ネットワークのトポロジーが固定されていることを前提としています。実際には、ルータや線は、多くの場合、失敗とまで戻ってきます。この可能性に対処するために、我々は少しのアルゴリズムを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The theoretical version of the algorithm involved a minimum over all immediate neighbors. If the topology changes, the set of neighbors changes. Therefore, the next time the calculation is done, the change will be reflected. However, as mentioned above, actual implementations use an incremental version of the minimization. Only the best route to any given destination is remembered. If the router involved in that route should crash, or the network connection to it break, the calculation might never reflect the change. The algorithm as shown so far depends upon a router notifying its neighbors if its metrics change. If the router crashes, then it has no way of notifying neighbors of a change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アルゴリズムの理論的なバージョンは、全てのすぐ隣を超える最小の関与しました。トポロジが変更された場合、隣人のセットが変更されます。したがって、計算が行われ、次回は、変更が反映されます。しかしながら、上述したように、実際の実装では、最小の増分バージョンを使用します。唯一の任意の宛先への最適なルートを覚えています。その経路に関与ルータがクラッシュした、またはそれへのネットワーク接続が中断した場合、計算は、変更を反映することはありませんかもしれません。これまでに示されているようなアルゴリズムは、そのメトリックが変更された場合、その隣人に通知するルータに依存します。ルータがクラッシュした場合、それは変更の隣人を通知する方法はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to handle problems of this kind, distance vector protocols must make some provision for timing out routes. The details depend upon the specific protocol. As an example, in RIP every router that participates in routing sends an update message to all its neighbors once every 30 seconds. Suppose the current route for network N uses router G. If we don&#39;t hear from G for 180 seconds, we can assume that either the router has crashed or the network connecting us to it has become unusable. Thus, we mark the route as invalid. When we hear from another neighbor that has a valid route to N, the valid route will replace the invalid one. Note that we wait for 180 seconds before timing out a route even though we expect to hear from each neighbor every 30 seconds. Unfortunately, messages are occasionally lost by networks. Thus, it is probably not a good idea to invalidate a route based on a single missed message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この種の問題を処理するためには、距離ベクトルプロトコルは、ルートをタイムアウトするためのいくつかの準備をしなければなりません。詳細は、特定のプロトコルに依存しています。例として、RIPでのルーティングに参加するすべてのルータは、一度、すべての隣国、30秒ごとに更新メッセージを送信します。私たちは180秒間Gから聞こえない場合はNがルータG.を使用するネットワークの現在のルートを仮定し、我々はルータのどちらかがクラッシュしたか、それに私たちを接続するネットワークが使用不能になったと仮定することができます。したがって、私たちは無効とルートをマーク。我々はNへの有効な経路を持つ別の隣人から聞くと、有効なルートは無効1を交換します。私たちは、各ネイバーから30秒ごとに聞くことを期待していても、ルートをタイムアウトするまで180秒間待つことに注意してください。残念ながら、メッセージは時折ネットワークによって失われています。したがって、おそらく、単一逃したメッセージに基づいてルートを無効にするのは良い考えではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As we will see below, it is useful to have a way to notify neighbors that there currently isn&#39;t a valid route to some network. RIP, along with several other protocols of this class, does this through a normal update message, by marking that network as unreachable. A specific metric value is chosen to indicate an unreachable destination; that metric value is larger than the largest valid metric that we expect to see. In the existing implementation of RIP, 16 is used. This value is normally referred to as &#34;infinity&#34;, since it is larger than the largest valid metric. 16 may look like a surprisingly small number. It is chosen to be this small for reasons that we will see shortly. In most implementations, the same convention is used internally to flag a route as invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
私たちは以下を参照するように、現在、いくつかのネットワークへの有効なルートがないことを隣人に通知する方法があると便利です。このクラスのいくつかの他のプロトコルと一緒にRIPは、到達不能としてそのネットワークをマーキングすることによって、通常の更新メッセージを介してこれを行います。特定のメトリック値は、到達不能な目的地を示すために選択されます。そのメトリック値は、我々が見ることを期待有効な最大のメトリックよりも大きくなっています。 RIPの既存の実装では、16が使用されています。それは有効な最大のメトリックよりも大きいので、この値は、通常、「無限大」と呼ばれています。 16は驚くほど少ないように見えることがあります。私たちがすぐに表示されます理由のために、この小さななるように選択されます。ほとんどの実装では、同じ規則を無効として経路フラグを内部的に使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2 Preventing instability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2の防止不安定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The algorithm as presented up to this point will always allow a host or router to calculate a correct routing table. However, that is still not quite enough to make it useful in practice. The proofs referred to above only show that the routing tables will converge to the correct values in finite time. They do not guarantee that this time will be small enough to be useful, nor do they say what will happen to the metrics for networks that become inaccessible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この時点までに提示されるアルゴリズムは常にホストやルータが正しいルーティングテーブルを計算することができます。しかし、それはまだ実際にそれが有用なものとすることは非常に十分ではありません。だけ先に言及証明は、ルーティングテーブルが有限時間内に正しい値に収束することを示します。彼らは、この時間は有用であるために十分に小さくなることを保証するものではありません、また彼らはアクセスできなくなるネットワークのメトリックに何が起こるか言います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
It is easy enough to extend the mathematics to handle routes becoming inaccessible. The convention suggested above will do that. We choose a large metric value to represent &#34;infinity&#34;. This value must be large enough that no real metric would ever get that large. For the purposes of this example, we will use the value 16. Suppose a network becomes inaccessible. All of the immediately neighboring routers time out and set the metric for that network to 16. For purposes of analysis, we can assume that all the neighboring routers have gotten a new piece of hardware that connects them directly to the vanished network, with a cost of 16. Since that is the only connection to the vanished network, all the other routers in the system will converge to new routes that go through one of those routers. It is easy to see that once convergence has happened, all the routers will have metrics of at least 16 for the vanished network. Routers one hop away from the original neighbors would end up with metrics of at least 17; routers two hops away would end up with at least 18, etc. As these metrics are larger than the maximum metric value, they are all set to 16. It is obvious that the system will now converge to a metric of 16 for the vanished network at all routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アクセスできなくなってきてルートを処理するために数学を拡張するために十分に簡単です。大会はそれを行います上記示唆しました。私たちは「無限大」を表すために大きなメトリック値を選択してください。この値には、実際のメトリックが今までその大きな入手ないことを十分に大きくなければなりません。この例の目的のために、我々は値16を使用するネットワークにアクセスできなくなったとします。すぐ隣のルータの時間のすべてのうち、分析の目的のために16に、そのネットワークのメトリックを設定し、我々はすべての隣接ルータは、コストと、消えてネットワークに直接接続し、それらを新しいハードウェアを得ていることを前提とすることができますそれが消えて、ネットワークへの接続だけなので16の、システム内の他のすべてのルータは、これらのルータの1つを通過する新しいルートに収束します。収束が起こった後、すべてのルータが消滅したネットワークのための少なくとも16のメトリックを持っていることを確認するために簡単です。 1つのホップの元隣人が少なくとも17のメトリックで終わるだろうからルータ。ルータは、2ホップ離れてこれらのメトリックは、最大メトリック値よりも大きくなるように、それらはすべて16に設定され、システムは現在消滅ネットワークの16のメトリックに収束することは明らかである少なくとも18、等で終わるであろうすべてのルータで。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unfortunately, the question of how long convergence will take is not amenable to quite so simple an answer. Before going any further, it will be useful to look at an example (taken from [2]). Note that what we are about to show will not happen with a correct implementation of RIP. We are trying to show why certain features are needed. In the following example the letters correspond to routers, and the lines to networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
残念ながら、かかる時間収束の問題はそれほど単純な答えに従順ではありません。先に進む前に、（[2]から取られた）の例を見てすることが有用であろう。私たちが示してしようとしていることはRIPの正しい実装では発生しないことに注意してください。私たちは、特定の機能が必要な理由を示そうとしています。次の例では文字は、ルータ、およびネットワークへのラインに対応します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
     A-----B
      \   / \
       \ /  |
        C  /    all networks have cost 1, except
        | /     for the direct link from C to D, which
        |/      has cost 10
        D
        |&lt;=== target network
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each router will have a table showing a route to each network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ルータは、各ネットワークへのルートを示す表を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
However, for purposes of this illustration, we show only the routes from each router to the network marked at the bottom of the diagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
しかし、この説明の目的のために、我々は図の下部にマークされたネットワークへの各ルータからのルートだけを表示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           D:  directly connected, metric 1
           B:  route via D, metric 2
           C:  route via B, metric 3
           A:  route via B, metric 3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Now suppose that the link from B to D fails. The routes should now adjust to use the link from C to D. Unfortunately, it will take a while for this to this to happen. The routing changes start when B notices that the route to D is no longer usable. For simplicity, the chart below assumes that all routers send updates at the same time. The chart shows the metric for the target network, as it appears in the routing table at each router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
今、BからDへのリンクが失敗したとします。ルートは今残念ながら、それが起こることをこれに、このためにしばらく時間がかかるだろうCからDにリンクを使用するように調整する必要があります。 Bは、Dへのルートがもはや使用可能であることを通知しない場合、ルーティングの変更が開始します。簡単にするために、以下のチャートは、すべてのルータが同時に更新を送信することを前提としています。それは、各ルータにおけるルーティングテーブルに表示されるグラフは、ターゲット・ネットワークのためのメトリックを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       time ------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
D: dir, 1 dir, 1 dir, 1 dir, 1 ... dir, 1 dir, 1 B: unreach C, 4 C, 5 C, 6 C, 11 C, 12 C: B, 3 A, 4 A, 5 A, 6 A, 11 D, 11 A: B, 3 C, 4 C, 5 C, 6 C, 11 C, 12
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
D：もし、あなた1 1〜1：1 ...もし、あなた1、B 1：UNREACH C、4℃、5℃、6 C、11 C、12 C：B、3 A、4 A 、5 A、6 A、11 D、11 A、B、C 3、C 4、C 5、C 6、11 C、12
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
dir = directly connected unreach = unreachable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
DIR =直接接続UNREACH =到達不能
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Here&#39;s the problem: B is able to get rid of its failed route using a timeout mechanism, but vestiges of that route persist in the system for a long time. Initially, A and C still think they can get to D via B. So, they keep sending updates listing metrics of 3. In the next iteration, B will then claim that it can get to D via either A or C. Of course, it can&#39;t. The routes being claimed by A and C are now gone, but they have no way of knowing that yet. And even when they discover that their routes via B have gone away, they each think there is a route available via the other. Eventually the system converges, as all the mathematics claims it must. But it can take some time to do so. The worst case is when a network becomes completely inaccessible from some part of the system. In that case, the metrics may increase slowly in a pattern like the one above until they finally reach infinity. For this reason, the problem is called &#34;counting to infinity&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ここで問題です：Bはタイムアウトメカニズムを使用して、その失敗したルートを取り除くことが可能ですが、そのルートの痕跡は、長い時間のためにシステムに固執します。当初は、AとCは、まだ彼らはそうBを介してDに取得することができ、彼らは次の反復では3のメトリックをリスト更新を送り続けると思いますが、Bは、それはもちろん、AまたはCのいずれかを介してDに得ることができることを主張します、それはできません。 AとCが主張されているルートは今なくなっているが、彼らはまだいることを知る方法はありません。彼らはBを経由して、そのルートがなくなっていることを発見した場合でも、彼らはそれぞれ、他の経由で使用可能なルートがあると思います。すべての数学は、それがなければならないと主張して最終的にシステムは、収束します。しかし、それはそうする時間がかかることがあります。ネットワークは、システムのいくつかの部分から完全にアクセス不能になった場合、最悪のケースです。その場合には、メトリックは、彼らが最終的に無限大に達するまで、上記のようなパターンでゆっくりと増加することができます。このため、問題は「無限カウント」と呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
You should now see why &#34;infinity&#34; is chosen to be as small as possible. If a network becomes completely inaccessible, we want counting to infinity to be stopped as soon as possible. Infinity must be large enough that no real route is that big. But it shouldn&#39;t be any bigger than required. Thus the choice of infinity is a tradeoff between network size and speed of convergence in case counting to infinity happens. The designers of RIP believed that the protocol was unlikely to be practical for networks with a diameter larger than 15.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
「無限大」ができるだけ小さくなるように選択された理由あなたは今見るべきです。ネットワークが完全にアクセス不能になった場合、我々はできるだけ早く停止する無限カウントします。インフィニティは、本当のルートが大きいということではないことを十分に大きくなければなりません。しかし、それは必要以上に任意の大きなすべきではありません。従って無限の選択は無限が発生する場合計数におけるネットワークのサイズ及び収束の速度とのトレードオフがあります。 RIPの設計者は、プロトコルが15よりも大きい直径を有するネットワークのための実用的である可能性が低いと信じていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are several things that can be done to prevent problems like this. The ones used by RIP are called &#34;split horizon with poisoned reverse&#34;, and &#34;triggered updates&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このような問題を防ぐために行うことができますいくつかのものがあります。 RIPによって使用されるものは、「ポイズンリバースとともにスプリットホライズン」と呼ばれ、「更新をトリガー」されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.3 Split horizon
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.3スプリットホライズン
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that some of the problem above is caused by the fact that A and C are engaged in a pattern of mutual deception. Each claims to be able to get to D via the other. This can be prevented by being a bit more careful about where information is sent. In particular, it is never useful to claim reachability for a destination network to the neighbor(s) from which the route was learned. &#34;Split horizon&#34; is a scheme for avoiding problems caused by including routes in updates sent to the router from which they were learned. The &#34;simple split horizon&#34; scheme omits routes learned from one neighbor in updates sent to that neighbor. &#34;Split horizon with poisoned reverse&#34; includes such routes in updates, but sets their metrics to infinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
問題の一部は、上記A及びCが相互詐欺のパターンに従事していることに起因することに留意されたいです。それぞれが他を経由してDに到達することができると主張しています。これは、情報が送信される場所についてもう少し慎重であることによって防ぐことができます。特に、経路が学習された隣接（複数可）に宛先ネットワークの到達可能性を主張することが有用になることはありません。 「スプリットホライズンは、」彼らが学習されたからルータに送信されたアップデート内のルートを含めによる問題を回避するための仕組みです。 「シンプルなスプリットホライズン」方式では、その隣人に送られたアップデート内の1つのネイバーから学習したルートを省略します。 「ポイズンリバースとともにスプリットホライズンは、」アップデート中にそのような経路を含むが、無限にそのメトリックを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If A thinks it can get to D via C, its messages to C should indicate that D is unreachable. If the route through C is real, then C either has a direct connection to D, or a connection through some other router. C&#39;s route can&#39;t possibly go back to A, since that forms a loop. By telling C that D is unreachable, A simply guards against the possibility that C might get confused and believe that there is a route through A. This is obvious for a point to point line. But consider the possibility that A and C are connected by a broadcast network such as an Ethernet, and there are other routers on that network. If A has a route through C, it should indicate that D is unreachable when talking to any other router on that network. The other routers on the network can get to C themselves. They would never need to get to C via A. If A&#39;s best route is really through C, no other router on that network needs to know that A can reach D. This is fortunate, because it means that the same update message that is used for C can be used for all other routers on the same network. Thus, update messages can be sent by broadcast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
Aは、それがCを経由してDに到達できると考えた場合、Cへのメッセージは、Dが到達不能であることを示す必要があります。 Cを通る経路が実数である場合、CはDに直接接続している、またはいくつかの他のルータを介して接続のいずれか。それがループを形成するのでCのルートは、おそらく、バックAに行くことはできません。 Dが到達不能であるCを伝えることで、単にCは混乱とポイントが行指すようにするためにこれは明らかであるA.を通るルートがあることを信じているかもしれないという可能性を保護します。しかし、AとCがイーサネットなどの放送ネットワークで接続されている可能性を考慮し、そのネットワーク上の他のルータが存在します。 AがCを通るルートを有する場合、そのネットワーク上の他のルータに話すときDが到達不能であることを示すべきです。ネットワーク上の他のルータは、C自身に得ることができます。彼らはAの最適なルートがCを通じて本当にあるならばAを介してCに到達する必要はありませんでしょう、そのネットワーク上の他のルータは、それが意味するので、これは、幸運であるD.に達することができることを知っている必要はありませんが使用されているのと同じアップデートメッセージCのために、同じネットワーク上の他のすべてのルータのために使用することができます。このように、更新メッセージはブロードキャストで送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In general, split horizon with poisoned reverse is safer than simple split horizon. If two routers have routes pointing at each other, advertising reverse routes with a metric of 16 will break the loop immediately. If the reverse routes are simply not advertised, the erroneous routes will have to be eliminated by waiting for a timeout. However, poisoned reverse does have a disadvantage: it increases the size of the routing messages. Consider the case of a campus backbone connecting a number of different buildings. In each building, there is a router connecting the backbone to a local network. Consider what routing updates those routers should broadcast on the backbone network. All that the rest of the network really needs to know about each router is what local networks it is connected to. Using simple split horizon, only those routes would appear in update messages sent by the router to the backbone network. If split horizon with poisoned reverse is used, the router must mention all routes that it learns from the backbone, with metrics of 16. If the system is large, this can result in a large update message, almost all of whose entries indicate unreachable networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
一般的に、ポイズンリバースとともにスプリットホライズンは、単純なスプリットホライズンよりも安全です。 2つのルータがお互いを指してのルートを持っている場合は、16のメトリックと逆のルートを宣伝することは、すぐにループを中断します。逆ルートが単純に宣伝されていない場合は、誤ったルートは、タイムアウトを待つことによって解消する必要があります。しかし、毒逆に欠点を持っている：それは、ルーティングメッセージのサイズを増大させます。別の建物の数を結ぶキャンパスバックボーンのケースを考えてみましょう。各建物には、ローカルネットワークにバックボーンに接続するルータがあります。これらのルータは、バックボーンネットワークで放送すべき更新何ルーティング考えてみましょう。ネットワークの残りの部分は、実際に各ルータについて知る必要があるすべては、それが接続されているものをローカルネットワークです。シンプルなスプリットホライズンを使用して、唯一のそれらのルートは、バックボーンネットワークにルータによって送信された更新メッセージに表示されます。ポイズンリバースとともにスプリットホライズンが使用されている場合は、システムが大きい場合、ルータは16の評価指標で、それはバックボーンから学習したすべてのルートを言及する必要があり、これは大規模な更新メッセージにつながることができ、ほぼすべてのそのエントリのは、到達不能なネットワークを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In a static sense, advertising reverse routes with a metric of 16 provides no additional information. If there are many routers on one broadcast network, these extra entries can use significant bandwidth. The reason they are there is to improve dynamic behavior. When topology changes, mentioning routes that should not go through the router as well as those that should can speed up convergence. However, in some situations, network managers may prefer to accept somewhat slower convergence in order to minimize routing overhead. Thus implementors may at their option implement simple split horizon rather than split horizon with poisoned reverse, or they may provide a configuration option that allows the network manager to choose which behavior to use. It is also permissible to implement hybrid schemes that advertise some reverse routes with a metric of 16 and omit others. An example of such a scheme would be to use a metric of 16 for reverse routes for a certain period of time after routing changes involving them, and thereafter omitting them from updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
静的な意味では、16のメトリックと逆のルートをアドバタイズする追加情報を提供しません。 1つのブロードキャストネットワーク上の多くのルータが存在する場合、これらの余分なエントリは重要な帯域幅を使用することができます。彼らはそこにある理由は、動的挙動を改善することです。トポロジの変更は、収束をスピードアップすることができなければならないものとしてだけでなく、ルータを経由してはならないルートを言及するとき。しかし、いくつかの状況では、ネットワーク管理者は、ルーティングオーバーヘッドを最小にするために幾分遅い収束を受け入れることを好むことができます。したがって、実装者は、そのオプションで、単純なスプリットホライズンではなく、ポイズンリバースとともにスプリットホライズンを実装することができ、またはそれらはネットワーク管理者が使用する行動を選択することを可能にする設定オプションを提供することができます。 16のメトリックのいくつかの逆ルートをアドバタイズし、他を省略したハイブリッド方式を実装することも許容されます。そのようなスキームの例は、それらに関係する変更をルーティングし、その後の更新からそれらを省略した後一定時間逆経路16のメトリックを使用することであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The router requirements RFC [11] specifies that all implementation of RIP must use split horizon and should also use split horizon with poisoned reverse, although there may be a knob to disable poisoned reverse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータ要件RFC [11] RIPの全ての実装はスプリットホライズンを使用する必要があり、毒逆を無効にするノブがあってもよいが、また、毒逆でスプリットホライズンを使用するように指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.4 Triggered updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.4トリガー更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Split horizon with poisoned reverse will prevent any routing loops that involve only two routers. However, it is still possible to end up with patterns in which three routers are engaged in mutual deception. For example, A may believe it has a route through B, B through C, and C through A. Split horizon cannot stop such a loop. This loop will only be resolved when the metric reaches infinity and the network involved is then declared unreachable. Triggered updates are an attempt to speed up this convergence. To get triggered updates, we simply add a rule that whenever a router changes the metric for a route, it is required to send update messages almost immediately, even if it is not yet time for one of the regular update message. (The timing details will differ from protocol to protocol. Some distance vector protocols, including RIP, specify a small time delay, in order to avoid having triggered updates generate excessive network traffic.) Note how this combines with the rules for computing new metrics. Suppose a router&#39;s route to destination N goes through router G. If an update arrives from G itself, the receiving router is required to believe the new information, whether the new metric is higher or lower than the old one. If the result is a change in metric, then the receiving router will send triggered updates to all the hosts and routers directly connected to it. They in turn may each send updates to their neighbors. The result is a cascade of triggered updates. It is easy to show which routers and hosts are involved in the cascade. Suppose a router G times out a route to destination N. G will send triggered updates to all of its neighbors. However, the only neighbors who will believe the new information are those whose routes for N go through G. The other routers and hosts will see this as information about a new route that is worse than the one they are already using, and ignore it. The neighbors whose routes go through G will update their metrics and send triggered updates to all of their neighbors. Again, only those neighbors whose routes go through them will pay attention. Thus, the triggered updates will propagate backwards along all paths leading to router G, updating the metrics to infinity. This propagation will stop as soon as it reaches a portion of the network whose route to destination N takes some other path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ポイズンリバースとともにスプリットホライズンは2つだけのルーターを必要とする任意のルーティングループを防止します。しかし、3つのルータが相互詐欺に従事されているパターンで終わることは可能です。例えば、Aは、Cを介してBを通るルート、Bを有していると信じていてもよく、C Aを介してスプリットホライズンは、このようなループを止めることはできません。このループは、メトリックが無限に達したときにのみ解決されると関わるネットワークが到達不能と宣言されます。トリガー更新は、この収束をスピードアップしようとしています。トリガ更新を取得するには、我々は単にルータがルートのメトリックを変更するたびに、それはまだ定期的な更新メッセージの1の時間でない場合でも、ほとんど即座に更新メッセージを送信するために必要であることをルールを追加します。 （タイミングの詳細はプロトコルにプロトコルとは異なるであろう。いくつかの距離ベクトルプロトコルを、RIPを含む、トリガ更新が過度のネットワークトラフィックを生成するのを避けるために、小さな遅延時間を指定する。）この新しいメトリックを計算するための規則と結合する方法に注意してください。更新がG自身から到着した場合、宛先NまでのルータのルートがルータG.を通過すると仮定し、受信ルータは、新しいメトリックが古いものよりも高いか低いか、新しい情報を信じることが必要です。結果は、メトリックの変化がある場合には、受信側ルータは、直接に接続されたすべてのホストとルータにトリガ更新を送信します。彼らは順番に、それぞれが自分の隣人への更新を送信することができます。結果は、トリガ更新のカスケードです。カスケードに関与しているルータとホストを示すのは容易です。その隣人の全てにトリガ更新を送信する先N. Gへのルート外のルータG倍と仮定する。しかし、新しい情報を信じるだけの隣人は、そのルートNのために他のルータとホストは、彼らがすでに使用しているものよりも悪化している新しいルートに関する情報として、これを見て、それを無視しますG.通過したものです。そのルートGを通過隣人はそのメトリックを更新し、隣人のすべてにトリガ更新を送信します。ここでも、そのルートそれらを介して行くのみ隣人は注意を払うだろう。このように、トリガアップデートは無限にメトリックを更新し、ルータGにつながるすべての経路に沿って逆方向に伝播します。この伝播は、すぐにそれがルート先にNは、いくつかの他の経路をとるネットワークの一部に達すると停止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the system could be made to sit still while the cascade of triggered updates happens, it would be possible to prove that counting to infinity will never happen. Bad routes would always be removed immediately, and so no routing loops could form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
システムがまだ座って作ることができる場合にトリガ更新のカスケードが発生している間、無限にカウントすることは決して起こらないことを証明することが可能であろう。悪いルートは常にすぐに削除されるだろう、とそう何ルーティングループが形成されない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Unfortunately, things are not so nice. While the triggered updates are being sent, regular updates may be happening at the same time. Routers that haven&#39;t received the triggered update yet will still be sending out information based on the route that no longer exists. It is possible that after the triggered update has gone through a router, it might receive a normal update from one of these routers that hasn&#39;t yet gotten the word. This could reestablish an orphaned remnant of the faulty route. If triggered updates happen quickly enough, this is very unlikely. However, counting to infinity is still possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
残念ながら、物事はとても素敵ではありません。トリガ更新が送信されている間、定期的なアップデートが同時に起こっていてもよいです。まだトリガー更新を受け取っていないルータは、まだ存在しなくなった経路に基づいて情報を送信します。トリガ更新がルータを通過した後に、それはまだ言葉をもらっていないこれらのルータのいずれかから通常の更新を受け取る可能性があることも可能です。これは、障害のあるルートの孤立した残骸を再確立することができます。トリガ更新が十分急速に起こる場合、これは非常に低いです。しかし、無限カウントすることも可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The router requirements RFC [11] specifies that all implementation of RIP must implement triggered update for deleted routes and may implement triggered updates for new routes or change of routes. RIP implementations must also limit the rate which of triggered updates may be trandmitted. (see section 3.10.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータ要件RFC [11]はRIPの全ての実装が削除されたルートのトリガー更新を実装する必要がありますし、新しいルートやルートの変更のためのトリガ更新を実装することができることを指定します。 RIP実装もtrandmittedことができるトリガー更新の速度を制限しなければなりません。 （セクション3.10.1を参照してください）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5 Protocol Specification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5プロトコル仕様
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP is intended to allow routers to exchange information for computing routes through an IPv4-based network. Any router that uses RIP is assumed to have interfaces to one or more networks, otherwise it isn&#39;t really a router. These are referred to as its directly-connected networks. The protocol relies on access to certain information about each of these networks, the most important of which is its metric. The RIP metric of a network is an integer between 1 and 15, inclusive. It is set in some manner not specified in this protocol; however, given the maximum path limit of 15, a value of 1 is usually used. Implementations should allow the system administrator to set the metric of each network. In addition to the metric, each network will have an IPv4 destination address and subnet mask associated with it. These are to be set by the system administrator in a manner not specified in this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPは、ルータは、IPv4ベースのネットワークを介して経路を計算するための情報を交換することを可能にすることを意図しています。 RIPを使用するすべてのルータは、それ以外の場合は本当にルータではない、1つまたは複数のネットワークとのインタフェースを有しているものとします。これらは、その直接接続されたネットワークと呼ばれます。プロトコルは、そのメトリックで最も重要なのこれらのネットワークのそれぞれについての特定の情報へのアクセスに依存しています。ネットワークのRIPメトリックは1から15までの整数です。これは、このプロトコルで指定されていないいくつかの方法で設定されています。しかし、15の最大パス制限を与えられ、1の値は、通常使用されます。実装は、システム管理者は、各ネットワークのメトリックを設定できるようにする必要があります。メトリックに加えて、各ネットワークは、それに関連付けられたIPv4宛先アドレスとサブネットマスクを有することになります。これらは、このプロトコルで指定されていない方法でシステム管理者によって設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any host that uses RIP is assumed to have interfaces to one or more networks. These are referred to as its &#34;directly-connected networks&#34;. The protocol relies on access to certain information about each of these networks. The most important is its metric or &#34;cost&#34;. The metric of a network is an integer between 1 and 15 inclusive. It is set in some manner not specified in this protocol. Most existing implementations always use a metric of 1. New implementations should allow the system administrator to set the cost of each network. In addition to the cost, each network will have an IPv4 network number and a subnet mask associated with it. These are to be set by the system administrator in a manner not specified in this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPを使用するすべてのホストは、一つ以上のネットワークへのインターフェースを有することが想定されます。これらは、その「直接接続されたネットワーク」と呼ばれています。プロトコルは、これらのネットワークのそれぞれについての特定の情報へのアクセスに依存しています。最も重要なのは、そのメトリックまたは「コスト」です。ネットワークのメトリックは、1から15までの整数です。これは、このプロトコルで指定されていないいくつかの方法で設定されています。ほとんどの既存の実装は、常にシステム管理者は、各ネットワークのコストを設定できるようにする必要があります。1.新しい実装のメトリックを使用します。コストに加えて、各ネットワークは、IPv4ネットワーク番号とそれに関連付けられたサブネットマスクを有するであろう。これらは、このプロトコルで指定されていない方法でシステム管理者によって設定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that the rules specified in section 3.7 assume that there is a single subnet mask applying to each IPv4 network, and that only the subnet masks for directly-connected networks are known. There may be systems that use different subnet masks for different subnets within a single network. There may also be instances where it is desirable for a system to know the subnets masks of distant networks. Network-wide distribution of routing information which contains different subnet masks is permitted if all routers in the network are running the extensions presented in this document. However, if all routers in the network are not running these extensions distribution of routing information containing different subnet masks must be limited to avoid interoperability problems. See sections 3.7 and 4.3 for the rules governing subnet distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション3.7で指定された規則は、各IPv4ネットワークに適用する単一のサブネットマスクが存在すること、および直接接続されたネットワークのための唯一のサブネットマスクが知られていると仮定することに注意してください。単一のネットワーク内の異なるサブネットの異なるサブネットマスクを使用するシステムがあるかもしれません。また、システムは、遠方のネットワークのサブネットマスクを知ることが望ましい事例があるかもしれません。ネットワーク内のすべてのルータがこの文書の拡張を実行している場合、別のサブネットマスクが含まれているルーティング情報のネットワーク全体の分布が許可されています。ネットワーク内のすべてのルータが異なるサブネットマスクを含むルーティング情報のこれらの拡張機能の配布を実行していない場合は、相互運用性の問題を避けるために制限されなければなりません。セクションにサブネット分布を規則については3.7と4.3を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Each router that implements RIP is assumed to have a routing table. This table has one entry for every destination that is reachable throughout the system operating RIP. Each entry contains at least the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPを実装する各ルータは、ルーティングテーブルを有するものとします。この表は、システム動作RIPを通じて到達可能なすべての宛先に対して1つのエントリがあります。各エントリには、少なくとも次の情報が含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The IPv4 address of the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 先のIPv4アドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A metric, which represents the total cost of getting a datagram from the router to that destination. This metric is the sum of the costs associated with the networks that would be traversed to get to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - その宛先へのルータからデータグラムを得るための総コストを表すメトリック。このメトリックは、宛先に到達するために横断されるだろうネットワークに関連するコストの合計です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The IPv4 address of the next router along the path to the destination (i.e., the next hop). If the destination is on one of the directly-connected networks, this item is not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 宛先（すなわち、ネクストホップ）へのパスに沿って次のルータのIPv4アドレス。宛先が直接接続されたネットワークの一つである場合、この項目は必要ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- A flag to indicate that information about the route has changed recently. This will be referred to as the &#34;route change flag.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - フラグは、ルートに関する情報が最近変更されたことを示します。これはと呼ばれる「ルート変更フラグ。」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Various timers associated with the route. See section 3.6 for more details on timers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ルートに関連する様々なタイマー。タイマーの詳細については、セクション3.6を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The entries for the directly-connected networks are set up by the router using information gathered by means not specified in this protocol. The metric for a directly-connected network is set to the cost of that network. As mentioned, 1 is the usual cost. In that case, the RIP metric reduces to a simple hop-count. More complex metrics may be used when it is desirable to show preference for some networks over others (e.g., to indicate of differences in bandwidth or reliability).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
直接接続されたネットワークのエントリは、このプロトコルで指定されていない手段によって収集されたルータ使用情報によって設定されています。直接接続されたネットワークのメトリックは、そのネットワークのコストに設定されています。前述のように、1は通常のコストです。その場合には、RIPメトリックは、単純なホップ数を削減します。他のものよりいくつかのネットワークに対する選好を示すことが望ましい場合、より複雑な指標（例えば、帯域幅や信頼性の違いのために示す）を使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To support the extensions detailed in this document, each entry must additionally contain a subnet mask. The subnet mask allows the router (along with the IPv4 address of the destination) to identify the different subnets within a single network as well as the subnets masks of distant networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
本書で詳述拡張をサポートするために、各エントリはさらにサブネットマスクが含まれている必要があります。サブネットマスクは、（先のIPv4アドレスと共に）ルータは、単一のネットワーク内の異なるサブネットならびに遠隔ネットワークのサブネットマスクを識別することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Implementors may also choose to allow the system administrator to enter additional routes. These would most likely be routes to hosts or networks outside the scope of the routing system. They are referred to as &#34;static routes.&#34; Entries for destinations other than these initial ones are added and updated by the algorithms described in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
実装者は、システム管理者は、追加のルートを入力できるようにすることもできます。これらは、最も可能性の高いルーティングシステムの範囲外のホストまたはネットワークへの経路であろう。彼らはと呼ばれ、「スタティックルート。」これらの初期のもの以外の宛先のエントリは、次のセクションで説明したアルゴリズムによって追加され、更新されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order for the protocol to provide complete information on routing, every router in the AS must participate in the protocol. In cases where multiple IGPs are in use, there must be at least one router which can leak routing information between the protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルーティングに関する完全な情報を提供するプロトコルのためには、AS内のすべてのルータは、プロトコルに参加しなければなりません。複数のIGPを使用している場合には、プロトコル間のルーティング情報を漏洩することができる少なくとも1つのルータが存在しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6 Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6メッセージの形式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP is a UDP-based protocol. Each router that uses RIP has a routing process that sends and receives datagrams on UDP port number 520, the RIP-1/RIP-2 port. All communications intended for another routers&#39;s RIP process are sent to the RIP port. All routing update messages are sent from the RIP port. Unsolicited routing update messages have both the source and destination port equal to the RIP port. Update messages sent in response to a request are sent to the port from which the request came. Specific queries may be sent from ports other than the RIP port, but they must be directed to the RIP port on the target machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPはUDPベースのプロトコルです。 RIPを使用する各ルータは、送信及びUDPポート番号520、RIP-1 / RIP-2のポートでデータグラムを受信したルーティングプロセスを有しています。別のルータのRIPプロセスを対象とし、すべての通信はRIPポートに送信されます。すべてのルーティングアップデートメッセージは、RIPポートから送信されます。迷惑ルーティング更新メッセージは、RIPポートに等しい送信元および宛先ポートの両方を有します。要求に応じて送信された更新メッセージは、要求が来たポートに送信されます。特定クエリはRIPポート以外のポートから送信されても​​よいが、それらはターゲットマシン上のRIPポートに向けられなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The RIP packet format is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIPパケットのフォーマットは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  command (1)  |  version (1)  |       must be zero (2)        |
      +---------------+---------------+-------------------------------+
      |                                                               |
      ~                         RIP Entry (20)                        ~
      |                                                               |
      +---------------+---------------+---------------+---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There may be between 1 and 25 (inclusive) RIP entries. A RIP-1 entry has the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1〜25（包括的）RIPエントリがあるかもしれません。 RIP-1のエントリは、次の形式を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | address family identifier (2) |      must be zero (2)         |
      +-------------------------------+-------------------------------+
      |                        IPv4 address (4)                       |
      +---------------------------------------------------------------+
      |                        must be zero (4)                       |
      +---------------------------------------------------------------+
      |                        must be zero (4)                       |
      +---------------------------------------------------------------+
      |                           metric (4)                          |
      +---------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Field sizes are given in octets. Unless otherwise specified, fields contain binary integers, in network byte order, with the most-significant octet first (big-endian). Each tick mark represents one bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
フィールドのサイズはオクテットで与えられています。特に指定しない限り、フィールドは最初の最上位オクテット（ビッグエンディアン）で、ネットワークバイト順で、進整数が含まれています。各目盛りは1ビットを表しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Every message contains a RIP header which consists of a command and a version number. This section of the document describes version 1 of the protocol; section 4 describes the version 2 extensions. The command field is used to specify the purpose of this message. The commands implemented in version 1 and 2 are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
すべてのメッセージは、コマンドとバージョン番号から成るRIPヘッダーを含んでいます。文書のこのセクションでは、プロトコルのバージョン1を記述する。セクション4はバージョン2の拡張機能について説明します。コマンドフィールドは、このメッセージの目的を指定するために使用されます。バージョン1および2に実装されたコマンドは、次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1 - request A request for the responding system to send all or part of its routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1  - ルーティングテーブルのすべてまたは一部を送信する応答システムに対する要求を要求します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2 - response A message containing all or part of the sender&#39;s routing table. This message may be sent in response to a request, or it may be an unsolicited routing update generated by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
2  - 応答送信者のルーティングテーブルのすべてまたは一部を含むメッセージ。このメッセージは、要求に応じて送信することができる、またはそれは、送信者によって生成された迷惑ルーティング更新であってもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For each of these message types, in version 1, the remainder of the datagram contains a list of Route Entries (RTEs). Each RTE in this list contains an Address Family Identifier (AFI), destination IPv4 address, and the cost to reach that destination (metric).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これらのメッセージタイプのそれぞれについて、バージョン1で、データグラムの残りはルートエントリ（のRTE）のリストを含みます。このリスト内の各RTEは、アドレスファミリ識別子（AFI）、宛先IPv4アドレス、および（メトリック）その目的地に到達するためのコストが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The AFI is the type of address. For RIP-1, only AF_INET (2) is generally supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
AFIはアドレスのタイプです。 RIP-1について、（2）のみAF_INETは、一般的に支持されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The metric field contains a value between 1 and 15 (inclusive) which specifies the current metric for the destination; or the value 16 (infinity), which indicates that the destination is not reachable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メトリックフィールドは、送信先の現在のメトリックを指定する（含む）1と15の間の値を含みます。宛先が到達可能でないことを示すか、値16（無限大）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7 Addressing Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7アドレッシングの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Distance vector routing can be used to describe routes to individual hosts or to networks. The RIP protocol allows either of these possibilities. The destinations appearing in request and response messages can be networks, hosts, or a special code used to indicate a default address. In general, the kinds of routes actually used will depend upon the routing strategy used for the particular network. Many networks are set up so that routing information for individual hosts is not needed. If every node on a given network or subnet is accessible through the same routers, then there is no reason to mention individual hosts in the routing tables. However, networks that include point-to-point lines sometimes require routers to keep track of routes to certain nodes. Whether this feature is required depends upon the addressing and routing approach used in the system. Thus, some implementations may choose not to support host routes. If host routes are not supported, they are to be dropped when they are received in response messages (see section 3.7.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
距離ベクトルルーティングは、個々のホストまたはネットワークへのルートを記述するために使用することができます。 RIPプロトコルは、これらの可能性のいずれかを可能にします。要求メッセージと応答メッセージに表れる宛先はネットワーク、ホスト、またはデフォルトのアドレスを示すために使用される特殊なコードすることができます。一般的に、実際に使用される経路の種類は、特定のネットワークのために使用されるルーティング戦略に依存するであろう。個々のホストのルーティング情報が必要とされないように、多くのネットワークが設定されています。特定のネットワークまたはサブネット上のすべてのノードが同じルーターを介してアクセス可能である場合には、ルーティングテーブル内の個々のホストについて言及する理由はありません。しかし、ポイント・ツー・ポイント回線を含むネットワークは、時々、特定のノードへの経路を追跡するためにルータを必要とします。この機能が必要かどうかは、システムで使用されるアドレス指定およびルーティングアプローチに依存します。このように、いくつかの実装は、ホストルートをサポートしないこともできます。ホストルートがサポートされていない場合、彼らは応答メッセージ（セクション3.7.2を参照）で受信されたときにドロップすることがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The RIP-1 packet format does not distinguish among various types of address. Fields that are labeled &#34;address&#34; can contain any of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP-1パケットフォーマットは、アドレスのさまざまな種類を区別しません。 「アドレス」と表示されているフィールドは、次のいずれかを含めることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
host address subnet number network number zero (default route)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ホストアドレスサブネット番号ネットワーク番号ゼロ（デフォルトルート）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Entities which use RIP-1 are assumed to use the most specific information available when routing a datagram. That is, when routing a datagram, its destination address must first be checked against the list of node addresses. Then it must be checked to see whether it matches any known subnet or network number. Finally, if none of these match, the default route is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP-1を使用するエンティティは、データグラムをルーティングする際に利用可能な最も具体的な情報を使用することが想定されます。データグラムをルーティングするときには、その宛先アドレスは、最初のノードアドレスのリストと照合する必要がありますされています。そして、任意の既知のサブネットまたはネットワーク番号と一致するかどうかをチェックする必要があります。最後に、これらの試合のいずれも場合は、デフォルトルートが使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a node evaluates information that it receives via RIP-1, its interpretation of an address depends upon whether it knows the subnet mask that applies to the net. If so, then it is possible to determine the meaning of the address. For example, consider net 128.6. It has a subnet mask of 255.255.255.0. Thus 128.6.0.0 is a network number, 128.6.4.0 is a subnet number, and 128.6.4.1 is a node address. However, if the node does not know the subnet mask, evaluation of an address may be ambiguous. If there is a non-zero node part, there is no clear way to determine whether the address represents a subnet number or a node address. As a subnet number would be useless without the subnet mask, addresses are assumed to represent nodes in this situation. In order to avoid this sort of ambiguity, when using version 1, nodes must not send subnet routes to nodes that cannot be expected to know the appropriate subnet mask. Normally hosts only know the subnet masks for directly-connected networks. Therefore, unless special provisions have been made, routes to a subnet must not be sent outside the network of which the subnet is a part. RIP-2 (see section 4) eliminates the subnet/host ambiguity by including the subnet mask in the routing entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ノードは、それがRIP-1を介して受信した情報を評価する場合、アドレスの解釈は、それがネットに適用されるサブネットマスクを知っているかどうかに依存します。もしそうなら、アドレスの意味を決定することが可能です。例えば、ネット128.6考えます。これは、255.255.255.0のサブネットマスクを持っています。したがって128.6.0.0がネットワーク番号であり、128.6.4.0は、サブネット番号、128.6.4.1は、ノードアドレスです。ノードがサブネットマスクを知らない場合は、アドレスの評価が曖昧かもしれません。非ゼロのノードの部分がある場合、アドレスは、サブネット番号またはノードアドレスを表すかどうかを決定するための明確な方法はありません。サブネット番号は、サブネットマスクなしで役に立たないであろうように、アドレスは、この状況でノードを表すものとします。バージョン1を使用する際にあいまいさのこの種のを避けるために、ノードは、適切なサブネットマスクを知っていることは期待できないノードへのサブネットルートを送信してはなりません。通常、唯一の直接接続されたネットワークのサブネットマスクを知っているホスト。特別な規定がなされていない限りそのため、サブネットへのルートは、サブネットがその一部であるネットワークの外部に送信されてはなりません。 RIP-2（セクション4を参照）、ルーティングエントリのサブネットマスクを含むことによって、サブネット/ホストのあいまいさを排除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This &#34;subnet filtering&#34; is carried out by the routers at the &#34;border&#34; of the subnetted network. These are routers which connect that network with some other network. Within the subnetted network, each subnet is treated as an individual network. Routing entries for each subnet are circulated by RIP. However, border routers send only a single entry for the network as a whole to nodes in other networks. This means that a border router will send different information to different neighbors. For neighbors connected to the subnetted network, it generates a list of all subnets to which it is directly connected, using the subnet number. For neighbors connected to other networks, it makes a single entry for the network as a whole, showing the metric associated with that network. This metric would normally be the smallest metric for the subnets to which the router is attached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この「サブネットフィルタリングは、」サブネットネットワークの「国境」でルータによって行われます。これらは、いくつかの他のネットワークとそのネットワークを接続するルータです。サブネットネットワーク内で、各サブネットは、個々のネットワークとして扱われます。各サブネットのルーティングエントリは、RIPによって循環されています。しかし、境界ルータは、他のネットワーク内のノードにネットワーク全体のための単一のエントリのみを送信します。これは、境界ルータが別の隣人に異なる情報を送信することを意味します。サブネットネットワークに接続されたネイバーの場合は、サブネット番号を使用して、それが直接接続されているすべてのサブネットのリストを生成します。他のネットワークに接続された隣人のためには、そのネットワークに関連付けられているメトリックを示し、全体としてのネットワークのための単一のエントリを作ります。このメトリックは、通常、ルータが接続されているサブネットの最小メトリックになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Similarly, border routers must not mention host routes for nodes within one of the directly-connected networks in messages to other networks. Those routes will be subsumed by the single entry for the network as a whole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同様に、境界ルータは、他のネットワークへのメッセージに直接接続されたネットワークの一つ内のノード用のホストルートを言及してはなりません。これらのルートは、ネットワーク全体のための単一のエントリによって包含されるであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The router requirements RFC [11] specifies that all implementation of RIP should support host routes but if they do not then they must ignore any received host routes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルータ要件RFC [11]はRIPの全ての実装はホストルートをサポートする必要がありますが、そうでないならば、彼らは任意のホストルートを受け取っ無視しなければならないことを指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The special address 0.0.0.0 is used to describe a default route. A default route is used when it is not convenient to list every possible network in the RIP updates, and when one or more closely-connected routers in the system are prepared to handle traffic to the networks that are not listed explicitly. These routers should create RIP entries for the address 0.0.0.0, just as if it were a network to which they are connected. The decision as to how routers create entries for 0.0.0.0 is left to the implementor. Most commonly, the system administrator will be provided with a way to specify which routers should create entries for 0.0.0.0; however, other mechanisms are possible. For example, an implementor might decide that any router which speaks BGP should be declared to be a default router. It may be useful to allow the network administrator to choose the metric to be used in these entries. If there is more than one default router, this will make it possible to express a preference for one over the other. The entries for 0.0.0.0 are handled by RIP in exactly the same manner as if there were an actual network with this address. System administrators should take care to make sure that routes to 0.0.0.0 do not propagate further than is intended. Generally, each autonomous system has its own preferred default router. Thus, routes involving 0.0.0.0 should generally not leave the boundary of an autonomous system. The mechanisms for enforcing this are not specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
特別なアドレス0.0.0.0はデフォルトルートを記述するために使用されます。 RIPアップデートでは、すべての可能なネットワークの一覧を表示するのに便利ではないときにデフォルトルートが使用され、システム内の1つまたは複数の密接に接続されたルータは、明示的にリストされていないネットワークへのトラフィックを処理する用意があるとき。これらのルータは、それは彼らが接続されているネットワークであるかのように、アドレス0.0.0.0のRIPエントリを作成する必要があります。ルータが0.0.0.0のエントリを作成する方法についての決定は、実装者に任されています。最も一般的には、システム管理者は、0.0.0.0のエントリを作成する必要のあるルーター指定する方法が提供されます。しかし、他のメカニズムが可能です。例えば、実装は、BGPを話す任意のルータがデフォルトルータであると宣言しなければならないことを決めるかもしれません。ネットワーク管理者は、これらのエントリで使用するメトリックを選択することができるようにすることが有用です。複数のデフォルトのルータがある場合は、このため、他の上で1つの優先を表現するようになります。このアドレスと、実際のネットワークがあったかのように0.0.0.0のエントリは、全く同様にRIPによって処理されます。システム管理者は、0.0.0.0へのルートが意図されているよりもさらに伝播しないことを確認するために世話をする必要があります。一般的に、各自律システムには独自の好ましいデフォルトルータを持っています。このように、0.0.0.0を含むルートは、一般的に自律システムの境界を残すべきではありません。これを強制するためのメカニズムは、この文書で指定されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8 Timers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8タイマー
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes all events that are triggered by timers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、タイマーによってトリガーされたすべてのイベントについて説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Every 30 seconds, the RIP process is awakened to send an unsolicited Response message containing the complete routing table (see section 3.9 on Split Horizon) to every neighboring router. When there are many routers on a single network, there is a tendency for them to synchronize with each other such that they all issue updates at the same time. This can happen whenever the 30 second timer is affected by the processing load on the system. It is undesirable for the update messages to become synchronized, since it can lead to unnecessary collisions on broadcast networks. Therefore, implementations are required to take one of two precautions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
30秒ごとに、RIPプロセスは、すべての隣接ルータに完全なルーティングテーブルを（スプリットホライズンのセクション3.9を参照）を含む未承諾応答メッセージを送信するために起こされます。単一のネットワーク上の多くのルータがある場合、そこに彼らはお互いなどと同期するための傾向である彼らと同時に、すべての問題を更新。 30秒タイマーは、システムの処理負荷に影響されるたびに発生することがあります。更新メッセージが同期になってすることがブロードキャストネットワーク上の不必要な衝突につながることができますので、それは、望ましくありません。そのため、実装は2つの予防策のいずれかを実行するために必要とされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The 30-second updates are triggered by a clock whose rate is not affected by system load or the time required to service the previous update timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  30秒の更新は、その速度、システム負荷、または前回の更新タイマーをサービスするのに必要な時間に影響されないクロックによってトリガされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The 30-second timer is offset by a small random time (+/- 0 to 5 seconds) each time it is set. (Implementors may wish to consider even larger variation in the light of recent research results [10])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  30秒タイマが小さいランダムな時間（+/- 0〜5秒）が設定されるたびにより相殺されます。 （実装者は、最近の研究結果に照らしてさらに大きな変動を考慮することを望むかもしれない[10]）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
There are two timers associated with each route, a &#34;timeout&#34; and a &#34;garbage-collection&#34; time. Upon expiration of the timeout, the route is no longer valid; however, it is retained in the routing table for a short time so that neighbors can be notified that the route has been dropped. Upon expiration of the garbage-collection timer, the route is finally removed from the routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
各ルートに関連する2個のタイマ、「タイムアウト」および「ガベージコレクション」の時間があります。タイムアウトが満了すると、ルートはもはや有効ではありません。近所のルートが削除されたことを通知することができるようにしかし、それは短い時間のためにルーティングテーブルに保持されています。ガベージコレクションタイマーが満了すると、ルートが最終的には、ルーティングテーブルから削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The timeout is initialized when a route is established, and any time an update message is received for the route. If 180 seconds elapse from the last time the timeout was initialized, the route is considered to have expired, and the deletion process described below begins for that route.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
経路が確立されると、タイムアウトが初期化され、そして任意の時間更新メッセージがルートに受信されます。 180秒のタイムアウトが初期化された最後の時間から経過した場合は、ルートの有効期限が切れたとみなされ、以下の削除処理は、そのルートのために開始されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Deletions can occur for one of two reasons: the timeout expires, or the metric is set to 16 because of an update received from the current router (see section 3.7.2 for a discussion of processing updates from other routers). In either case, the following events happen:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
欠失は、2つの理由のいずれかで発生する可能性がありますタイムアウトが満了する、またはメトリックが（他のルータからの更新処理の説明についてはセクション3.7.2を参照）ので、現在のルータから受信した更新プログラム16に設定されています。いずれの場合も、以下のイベントが行われます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The garbage-collection timer is set for 120 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ガベージコレクションタイマーを120秒に設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The metric for the route is set to 16 (infinity). This causes the route to be removed from service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ルートのメトリックが16（無限大）に設定されています。これは、ルートがサービスから削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The route change flag is set to indicate that this entry has been changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 経路変更フラグは、このエントリが変更されたことを示すために設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- The output process is signalled to trigger a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 出力処理は、応答をトリガするためにシグナリングされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Until the garbage-collection timer expires, the route is included in all updates sent by this router. When the garbage-collection timer expires, the route is deleted from the routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ガベージコレクションタイマが満了するまでは、ルートがこのルータによって送信されたすべての更新プログラムに含まれています。ガベージコレクションタイマーが満了すると、ルートがルーティングテーブルから削除されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Should a new route to this network be established while the garbage-collection timer is running, the new route will replace the one that is about to be deleted. In this case the garbage-collection timer must be cleared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ガベージコレクションタイマーが動作している間、このネットワークへの新しいルートが確立されなければならない、新しいルートが削除されようとしているものを置き換えます。この場合、ガベージコレクションタイマーをクリアする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Triggered updates also use a small timer; however, this is best described in section 3.9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トリガー更新はまた、小さなタイマーを使用します。しかし、これが最良のセクション3.9.1に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9 Input Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9入力処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section will describe the handling of datagrams received on the RIP port. Processing will depend upon the value in the command field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、RIPポートで受信したデータグラムの取り扱いを説明します。処理は、コマンドフィールドの値に依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
See sections 4.6 and 5.1 for details on handling version numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクションにバージョン番号の取り扱いの詳細については、4.6と5.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9.1 Request Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9.1リクエスト・メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Request is used to ask for a response containing all or part of a router&#39;s routing table. Normally, Requests are sent as broadcasts (multicasts for RIP-2), from the RIP port, by routers which have just come up and are seeking to fill in their routing tables as quickly as possible. However, there may be situations (e.g., router monitoring) where the routing table of only a single router is needed. In this case, the Request should be sent directly to that router from a UDP port other than the RIP port. If such a Request is received, the router responds directly to the requestor&#39;s address and port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストは、ルータのルーティングテーブルの全部または一部を含む応答を求めるために使用されています。通常、要求はちょうど出ていると、可能な限り迅速にそのルーティングテーブルに記入しようとしているルータによって、RIPポートから、ブロードキャスト（RIP-2のためのマルチキャスト）として送信されます。しかし、単一のルータのルーティングテーブルが必要とされる状況（例えば、ルータの監視）があってもよいです。この場合、リクエストはRIPポート以外のUDPポートからそのルータに直接送信する必要があります。そのような要求を受信した場合、ルータは、要求元のアドレスとポートに直接応答します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Request is processed entry by entry. If there are no entries, no response is given. There is one special case. If there is exactly one entry in the request, and it has an address family identifier of zero and a metric of infinity (i.e., 16), then this is a request to send the entire routing table. In that case, a call is made to the output process to send the routing table to the requesting address/port. Except for this special case, processing is quite simple. Examine the list of RTEs in the Request one by one. For each entry, look up the destination in the router&#39;s routing database and, if there is a route, put that route&#39;s metric in the metric field of the RTE. If there is no explicit route to the specified destination, put infinity in the metric field. Once all the entries have been filled in, change the command from Request to Response and send the datagram back to the requestor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リクエストはエントリごとに処理されます。エントリがない場合は、何の応答が与えられていません。 1特殊なケースがあります。そこ要求に正確に一つのエントリであり、それはゼロのアドレスファミリー識別子と無限のメトリックを有する場合（すなわち、16）、これは全体ルーティングテーブルを送信するための要求です。その場合には、コールが要求したアドレス/ポートにルーティングテーブルを送信する出力処理に対して行われます。この特別な場合を除いて、処理が非常に簡単です。リクエスト一つ一つでのRTEのリストを調べます。エントリごとに、ルータのルーティングデータベース内の宛先を検索し、ルートがある場合は、RTEのメトリックフィールドにそのルートのメトリックを置きます。指定された宛先への明示的なルートが存在しない場合、メトリックフィールドに無限大を置きます。すべてのエントリが記入されていたら、レスポンスにリクエストからコマンドを変更し、バック要求側にデータグラムを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Note that there is a difference in metric handling for specific and whole-table requests. If the request is for a complete routing table, normal output processing is done, including Split Horizon (see section 3.9 on Split Horizon). If the request is for specific entries, they are looked up in the routing table and the information is returned as is; no Split Horizon processing is done. The reason for this distinction is the expectation that these requests are likely to be used for different purposes. When a router first comes up, it multicasts a Request on every connected network asking for a complete routing table. It is assumed that these complete routing tables are to be used to update the requestor&#39;s routing table. For this reason, Split Horizon must be done. It is further assumed that a Request for specific networks is made only by diagnostic software, and is not used for routing. In this case, the requester would want to know the exact contents of the routing table and would not want any information hidden or modified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
具体的な全体-テーブルの要求に対するメトリック取り扱いに差があることに注意してください。要求が完全なルーティングテーブルのためのものである場合、通常の出力処理は、スプリットホライズン（スプリットホライズンのセクション3.9を参照）を含む、行われます。要求が特定のエントリのためのものである場合、それらはルーティングテーブルで検索されているような情報が返されます。スプリットホライズン処理は行われません。この区別の理由は、これらの要求が異なる目的のために使用される可能性があることを期待しています。ルータが最初に起動したとき、それは完全なルーティングテーブルを求め、すべての接続されたネットワーク上の要求をマルチキャスト。これらの完全なルーティングテーブルが要求元のルーティングテーブルを更新するために使用されることを想定しています。このため、スプリットホライズンを行わなければなりません。さらに、特定のネットワークの要求のみ診断ソフトウェアによって行われ、ルーティングのために使用されていないものとします。この場合、要求者は、ルーティングテーブルの正確な内容を知りたいでしょうし、任意の情報を非表示にしたり変更したいとは思わないでしょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9.2 Response Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9.2応答メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A Response can be received for one of several different reasons:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答は、いくつかの異なった理由の一つのために受信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- response to a specific query - regular update (unsolicited response) - triggered update caused by a route change
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 経路の変化による更新をトリガ - 定期的な更新（迷惑応答） - 特定のクエリへの応答
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Processing is the same no matter why the Response was generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
処理は関係なく、レスポンスが生成された理由と同じではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because processing of a Response may update the router&#39;s routing table, the Response must be checked carefully for validity. The Response must be ignored if it is not from the RIP port. The datagram&#39;s IPv4 source address should be checked to see whether the datagram is from a valid neighbor; the source of the datagram must be on a directly-connected network. It is also worth checking to see whether the response is from one of the router&#39;s own addresses. Interfaces on broadcast networks may receive copies of their own broadcasts/multicasts immediately. If a router processes its own output as new input, confusion is likely so such datagrams must be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
レスポンスの処理は、ルータのルーティングテーブルを更新する可能性があるため、応答は妥当性を慎重にチェックする必要があります。それはRIPポートからではない場合の対応は無視されなければなりません。データグラムのIPv4送信元アドレスは、データグラムが有効なネイバーからであるかどうかを確認するためにチェックする必要があります。データグラムのソースが直接接続されたネットワーク上にある必要があります。また、応答がルータ自身のアドレスのいずれかからであるかどうかをチェックする価値があります。ブロードキャストネットワークのインターフェイスはすぐに自分のブロードキャスト/マルチキャストのコピーを受け取ることができます。ルータが新しい入力として、独自の出力を処理した場合、そのようなデータグラムは無視しなければならないので、混乱する可能性が高くなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once the datagram as a whole has been validated, process the RTEs in the Response one by one. Again, start by doing validation. Incorrect metrics and other format errors usually indicate misbehaving neighbors and should probably be brought to the administrator&#39;s attention. For example, if the metric is greater than infinity, ignore the entry but log the event. The basic validation tests are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
全体として、データグラムが検証された後、レスポンス一つずつでのRTEを処理します。ここでも、検証を行うことで開始します。不正なメトリックおよびその他のフォーマットエラーは通常、不正な動作隣人を示し、おそらく管理者の注意を喚起しなければなりません。メトリックが無限よりも大きければ、例えば、エントリを無視しますが、イベントをログに記録します。基本的な検証テストは以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- is the destination address valid (e.g., unicast; not net 0 or 127) - is the metric valid (i.e., between 1 and 16, inclusive)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 有効な宛先アドレスが（例えば、ユニキャスト、0ネットまたは127ではない）である - メトリック有効である（すなわち、1と16の間に、包括的）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If any check fails, ignore that entry and proceed to the next. Again, logging the error is probably a good idea.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いずれかのチェックが失敗した場合、そのエントリを無視して次へ進みます。ここでも、エラーをログに記録することは、おそらく良いアイデアです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Once the entry has been validated, update the metric by adding the cost of the network on which the message arrived. If the result is greater than infinity, use infinity. That is,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
エントリが検証された後、メッセージが到着したネットワークのコストを追加することにより、メトリックを更新します。結果は無限大よりも大きい場合、無限大を使用しています。あれは、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
metric = MIN (metric + cost, infinity)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
メトリック= MIN（メトリック+コスト、無限大）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Now, check to see whether there is already an explicit route for the destination address. If there is no such route, add this route to the routing table, unless the metric is infinity (there is no point in adding a route which is unusable). Adding a route to the routing table consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
さて、すでに宛先アドレスの明示的なルートがあるかどうかを確認します。そのような経路が存在しない場合、メトリックが無限でない限り（使用不可であるルートを追加するにはポイントが存在しない）、ルーティングテーブルにこのルートを追加します。ルーティングテーブルへのルートを追加することで構成されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Setting the destination address to the destination address in the RTE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 -  RTEの宛先アドレスへの送信先アドレスを設定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Setting the metric to the newly calculated metric (as described above)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 新たに計算されたメトリックのメトリックを設定する（上記のように）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Set the next hop address to be the address of the router from which the datagram came
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - データグラムが来たルータのアドレスであることをネクストホップアドレスを設定します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Initialize the timeout for the route. If the garbage-collection timer is running for this route, stop it (see section 3.6 for a discussion of the timers)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - ルートのタイムアウトを初期化します。ガベージコレクションタイマーがこのルートのために実行されている場合は、それを停止（タイマーの議論についてはセクション3.6を参照してください）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Set the route change flag
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 経路変更フラグを設定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Signal the output process to trigger an update (see section 3.8.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - （セクション3.8.1を参照）の更新をトリガするために、出力プロセスに合図
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If there is an existing route, compare the next hop address to the address of the router from which the datagram came. If this datagram is from the same router as the existing route, reinitialize the timeout. Next, compare the metrics. If the datagram is from the same router as the existing route, and the new metric is different than the old one; or, if the new metric is lower than the old one; do the following actions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
既存のルートがある場合は、データグラムが来たルータのアドレスをネクストホップアドレスを比較します。このデータグラムが既存の経路と同じルータからのものである場合、タイムアウトを再初期化します。次に、メトリックを比較します。データグラムは、既存のルートと同じルータからのものであり、新しいメトリックが古いものと異なる場合。または、新しいメトリックが古いものよりも低い場合には、次の操作を行います。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Adopt the route from the datagram (i.e., put the new metric in and adjust the next hop address, if necessary).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - データグラムの経路を採用し（即ち、で新しいメトリックを入れ、必要に応じて、次ホップアドレスを調整します）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- Set the route change flag and signal the output process to trigger an update
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 経路変更フラグを設定し、更新をトリガーする出力処理を信号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- If the new metric is infinity, start the deletion process (described above); otherwise, re-initialize the timeout
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 新しいメトリックが無限である場合、（上記）削除処理を開始します。それ以外の場合は、タイムアウトを再初期化します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the new metric is infinity, the deletion process begins for the route, which is no longer used for routing packets. Note that the deletion process is started only when the metric is first set to infinity. If the metric was already infinity, then a new deletion process is not started.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいメトリックが無限大である場合は、削除プロセスは、もは​​やルーティングパケットのために使用されているルート、のために開始されます。メトリックが最初に無限大に設定されている場合にのみ、削除プロセスが開始されていることに注意してください。メトリックがすでに無限大だった場合、新しい削除プロセスが開始されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If the new metric is the same as the old one, it is simplest to do nothing further (beyond re-initializing the timeout, as specified above); but, there is a heuristic which could be applied. Normally, it is senseless to replace a route if the new route has the same metric as the existing route; this would cause the route to bounce back and forth, which would generate an intolerable number of triggered updates. However, if the existing route is showing signs of timing out, it may be better to switch to an equally-good alternative route immediately, rather than waiting for the timeout to happen. Therefore, if the new metric is the same as the old one, examine the timeout for the existing route. If it is at least halfway to the expiration point, switch to the new route. This heuristic is optional, but highly recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
新しいメトリックが古いものと同じであるならば、それはさらに（上記のように、再初期化のタイムアウトを超えて）何もしないことが最も簡単です。しかし、適用することができヒューリスティックがあります。通常は、新しい経路が既存の経路と同じメトリックを持っている場合、ルートを交換するために無意味です。これは、トリガ更新の耐え難い数を生成する前後にバウンスするルートを引き起こします。既存のルートは、タイミングの兆しを見せている場合は、むしろ、タイムアウトが発生するのを待つよりも、すぐに同じように、良い代替ルートへの切り替えをより良いかもしれません。新しいメトリックが古いものと同じである場合はそのため、既存のルートのタイムアウトを調べます。それは有効期限ポイントに少なくとも途中であれば、新しい経路に切り替えます。このヒューリスティックはオプションですが、強くお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Any entry that fails these tests is ignored, as it is no better than the current route.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それは現在のルートよりも良いではないとして、これらのテストに失敗した任意のエントリは、無視されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10 Output Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10出力処理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes the processing used to create response messages that contain all or part of the routing table. This processing may be triggered in any of the following ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、ルーティングテーブルのすべてまたは一部を含む応答メッセージを作成するために使用される処理について説明します。この処理は、次のいずれかの方法でトリガすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- By input processing, when a Request is received (this Response is unicast to the requestor; see section 3.7.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 要求が受信された入力処理によって（この応答は、要求者へのユニキャストである、セクション3.7.1を参照します）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- By the regular routing update (broadcast/multicast every 30 seconds) router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - 定期的なルーティング更新（ブロードキャスト/マルチキャスト30秒ごと）ルータによって。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
- By triggered updates (broadcast/multicast when a route changes)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
 - トリガ更新によって（ブロードキャスト/マルチキャストときルート変更）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
When a Response is to be sent to all neighbors (i.e., a regular or triggered update), a Response message is directed to the router at the far end of each connected point-to-point link, and is broadcast (multicast for RIP-2) on all connected networks which support broadcasting. Thus, one Response is prepared for each directly-connected network, and sent to the appropriate address (direct or broadcast/multicast). In most cases, this reaches all neighboring routers. However, there are some cases where this may not be good enough. This may involve a network that is not a broadcast network (e.g., the ARPANET), or a situation involving dumb routers. In such cases, it may be necessary to specify an actual list of neighboring routers and send a datagram to each one explicitly. It is left to the implementor to determine whether such a mechanism is needed, and to define how the list is specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
応答は、すべての隣人（すなわち、規則的またはトリガ更新）に送信する場合、応答メッセージは、（各接続ポイントツーポイントリンクの遠端のルータに向けられ、そして放送されるRIP-マルチキャスト2）放送をサポートするすべての接続されたネットワーク上。従って、一つの応答は、それぞれ直接接続されたネットワークのために調製し、適切なアドレス（直接またはブロードキャスト/マルチキャスト）に送られます。ほとんどの場合、これは、すべての隣接ルータに到達しました。しかし、これは十分ではないかもしれない場合があります。これは、（例えば、ARPANET）放送ネットワーク、またはダムルータが関与する状況ではないネットワークを含むことができます。このような場合には、隣接ルータの実際のリストを指定して明示的にそれぞれにデータグラムを送信する必要があるかもしれません。このようなメカニズムが必要とされているかどうかを判断するために、リストが指定されている方法を定義するために実装者に任されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.1 Triggered Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.1トリガアップデート
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Triggered updates require special handling for two reasons. First, experience shows that triggered updates can cause excessive load on networks with limited capacity or networks with many routers on them. Therefore, the protocol requires that implementors include provisions to limit the frequency of triggered updates. After a triggered update is sent, a timer should be set for a random interval between 1 and 5 seconds. If other changes that would trigger updates occur before the timer expires, a single update is triggered when the timer expires. The timer is then reset to another random value between 1 and 5 seconds. A triggered update should be suppressed if a regular update is due by the time the triggered update would be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トリガアップデートは、2つの理由のために特別な処理を必要とします。まず、経験がトリガ更新が彼らに多くのルータに限られた容量のネットワークやネットワーク上の過剰な負荷を引き起こす可能性があることを示しています。したがって、プロトコルは、実装者がトリガ更新の頻度を制限する規定を含むことが必要です。トリガ更新が送信された後、タイマーは1と5秒の間のランダムな間隔で設定する必要があります。タイマーが切れる前に更新をトリガーする他の変更が発生した場合、タイマーが満了したとき、単一の更新がトリガされます。タイマーは、1と5秒の間、別のランダムな値にリセットされます。定期的な更新がトリガ更新が送信される時間によって原因である場合にトリガ更新が抑制されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Second, triggered updates do not need to include the entire routing table. In principle, only those routes which have changed need to be included. Therefore, messages generated as part of a triggered update must include at least those routes that have their route change flag set. They may include additional routes, at the discretion of the implementor; however, sending complete routing updates is strongly discouraged. When a triggered update is processed, messages should be generated for every directly-connected network. Split Horizon processing is done when generating triggered updates as well as normal updates (see section 3.9). If, after Split Horizon processing for a given network, a changed route will appear unchanged on that network (e.g., it appears with an infinite metric), the route need not be sent. If no routes need be sent on that network, the update may be omitted. Once all of the triggered updates have been generated, the route change flags should be cleared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
第二に、トリガアップデートは、ルーティングテーブル全体を含める必要はありません。原則として、変更されている唯一のそれらのルートが含まれる必要があります。したがって、トリガ更新の一部として生成されたメッセージは、その経路変更フラグが設定されている少なくともそれらのルートを含まなければなりません。彼らは、実装の裁量で、付加的な経路を含むことができます。しかし、完全なルーティングアップデートを送信することを強くお勧めします。トリガ更新が処理されると、メッセージは、すべての直接接続されたネットワークのために生成されるべきです。トリガ更新ならびに正常更新（セクション3.9を参照）を生成するときにスプリットホライズン処理が行われます。与えられたネットワークのためのスプリットホライズン処理した後、変更されたルートはそのネットワーク上そのまま表示されます、場合、ルートは送信される必要がない（例えば、それは無限のメトリックが表示されます）。何のルートはそのネットワーク上で送信される必要がない場合は、アップデートを省略することができます。トリガ更新の全てが生成された後は、ルート変更フラグをクリアしてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If input processing is allowed while output is being generated, appropriate interlocking must be done. The route change flags should not be changed as a result of processing input while a triggered update message is being generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
出力が生成されている間に入力処理が許可されている場合、適切な連動が行われなければなりません。経路変更フラグは、トリガ更新メッセージが生成されている間に、入力を処理した結果として変更されるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The only difference between a triggered update and other update messages is the possible omission of routes that have not changed. The remaining mechanisms, described in the next section, must be applied to all updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
トリガ更新と他の更新メッセージの唯一の違いは、変更されていない経路の可能な省略です。次のセクションで説明した残りのメカニズムは、すべての更新に適用されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.2 Generating Response Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.2生成応答メッセージ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section describes how a Response message is generated for a particular directly-connected network:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、応答メッセージが特定の直接接続されたネットワークのために生成される方法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Set the version number to either 1 or 2. The mechanism for deciding which version to send is implementation specific; however, if this is the Response to a Request, the Response version should match the Request version. Set the command to Response. Set the bytes labeled &#34;must be zero&#34; to zero. Start filling in RTEs. Recall that there is a limit of 25 RTEs to a Response; if there are more, send the current Response and start a new one. There is no defined limit to the number of datagrams which make up a Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1または2のいずれかに実装固有である送信するバージョンを決定するためのメカニズムをバージョン番号を設定します。これは、要求への応答である場合には、レスポンスのバージョンは、リクエストのバージョンと一致する必要があります。レスポンスにコマンドを設定します。ゼロへ「ゼロでなければなりません」と表示されたバイト数を設定します。 RTEで充填を開始します。レスポンスへの25件のRTEの限界があることを思い出してください。より多く存在する場合、現在の応答を送信し、新しいものを開始します。レスポンスを構成するデータグラムの数に定義された制限はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
To fill in the RTEs, examine each route in the routing table. If a triggered update is being generated, only entries whose route change flags are set need be included. If, after Split Horizon processing, the route should not be included, skip it. If the route is to be included, then the destination address and metric are put into the RTE. Routes must be included in the datagram even if their metrics are infinite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RTEを埋めるために、ルーティングテーブル内の各ルートを調べます。トリガ更新が生成されている場合は、そのルート変更のフラグが設定されている唯一のエントリが含まれる必要があります。 、スプリットホライズン処理した後、ルートは含めるべきではない場合は、それをスキップ。ルートが含まれている場合は、送信先アドレスとメトリックをRTEに入れています。ルートは、そのメトリックが無限であっても、データグラムに含まれている必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Protocol Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.プロトコル拡張
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This section does not change the RIP protocol per se. Rather, it provides extensions to the message format which allows routers to share important additional information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このセクションでは、RIPプロトコル自体は変更されません。むしろ、それはルータが重要な追加情報を共有することを可能にするメッセージ形式の拡張機能を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The same header format is used for RIP-1 and RIP-2 messages (see section 3.4). The format for the 20-octet route entry (RTE) for RIP-2 is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
同じヘッダフォーマットがRIP-1、RIP-2メッセージのために使用される（セクション3.4参照）。 RIP-2の20オクテットのルートエントリ（RTE）の形式は次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Address Family Identifier (2) |        Route Tag (2)          |
   +-------------------------------+-------------------------------+
   |                         IP Address (4)                        |
   +---------------------------------------------------------------+
   |                         Subnet Mask (4)                       |
   +---------------------------------------------------------------+
   |                         Next Hop (4)                          |
   +---------------------------------------------------------------+
   |                         Metric (4)                            |
   +---------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Address Family Identifier, IP Address, and Metric all have the meanings defined in section 3.4. The Version field will specify version number 2 for RIP messages which use authentication or carry information in any of the newly defined fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
アドレスファミリ識別子、IPアドレス、およびメトリックは、すべてのセクション3.4で定義された意味を持っています。バージョンフィールドには、認証を使用するか、新たに定義されたフィールドのいずれかに情報を運ぶRIPメッセージのバージョン番号2を指定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since authentication is a per message function, and since there is only one 2-octet field available in the message header, and since any reasonable authentication scheme will require more than two octets, the authentication scheme for RIP version 2 will use the space of an entire RIP entry. If the Address Family Identifier of the first (and only the first) entry in the message is 0xFFFF, then the remainder of the entry contains the authentication. This means that there can be, at most, 24 RIP entries in the remainder of the message. If authentication is not in use, then no entries in the message should have an Address Family Identifier of 0xFFFF. A RIP message which contains an authentication entry would begin with the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証は、メッセージごとの関数であるため、そこにメッセージヘッダ内の利用可能な唯一の2オクテットフィールドであり、任意の合理的な認証方式が二つ以上のオクテットを必要とするので、RIPバージョン2の認証方式は、ANのスペースを使用するので全体のRIPエントリ。メッセージ内の最初の（そして唯一の最初の）エントリのアドレスファミリ識別子が0xFFFFである場合、エントリの残りの部分は、認証を含んでいます。これは、最大で、メッセージの残りの部分24個のRIPエントリが存在することを意味します。認証が使用されていない場合、メッセージにはエントリは0xFFFFでのアドレスファミリ識別子を持つべきではありません。次の形式で始まるでしょう認証エントリが含まれているRIPメッセージ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0                   1                   2                   3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Command (1)   | Version (1)   |            unused             |
   +---------------+---------------+-------------------------------+
   |             0xFFFF            |    Authentication Type (2)    |
   +-------------------------------+-------------------------------+
   ~                       Authentication (16)                     ~
   +---------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Currently, the only Authentication Type is simple password and it is type 2. The remaining 16 octets contain the plain text password. If the password is under 16 octets, it must be left-justified and padded to the right with nulls (0x00).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
現在、唯一の認証タイプは、単純なパスワードであり、残りの16個のオクテットは、プレーンテキストのパスワードが含まれているタイプ2です。パスワードは16オクテットの下にある場合、それは左寄せとヌル（$ 00）を右に埋めなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 Route Tag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2ルートタグ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Route Tag (RT) field is an attribute assigned to a route which must be preserved and readvertised with a route. The intended use of the Route Tag is to provide a method of separating &#34;internal&#34; RIP routes (routes for networks within the RIP routing domain) from &#34;external&#34; RIP routes, which may have been imported from an EGP or another IGP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルートタグ（RT）フィールドには、ルートに保存し、再び通知しなければならないルートに割り当てられた属性です。ルートタグの使用目的は、EGPまたは別のIGPからインポートされていてもよい「外部」RIPルートから「内部」RIPルート（RIPルーティングドメイン内のネットワークのためのルート）を分離する方法を提供することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Routers supporting protocols other than RIP should be configurable to allow the Route Tag to be configured for routes imported from different sources. For example, routes imported from EGP or BGP should be able to have their Route Tag either set to an arbitrary value, or at least to the number of the Autonomous System from which the routes were learned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP以外のプロトコルをサポートしているルータは、ルートタグは、異なるソースからインポートされたルートのために構成されることを可能にするように構成すべきです。例えば、EGPやBGPからインポートされたルートは、任意の値に、または少なくともルートが学習された元の自律システムの数に設定いずれかそれらのルートタグを有することができなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Other uses of the Route Tag are valid, as long as all routers in the RIP domain use it consistently. This allows for the possibility of a BGP-RIP protocol interactions document, which would describe methods for synchronizing routing in a transit network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ルートタグの他の用途は限りRIPドメイン内のすべてのルータが一貫してそれを使用するように、有効です。これは、中継ネットワーク内のルーティングを同期させるための方法を記載しているであろうBGP-RIPプロトコル相互作用文書の可能性を可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 Subnet mask
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3サブネットマスク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The Subnet Mask field contains the subnet mask which is applied to the IP address to yield the non-host portion of the address. If this field is zero, then no subnet mask has been included for this entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
サブネットマスクフィールドは、アドレスの非ホスト部分を生成するIPアドレスに適用されるサブネットマスクを含んでいます。このフィールドがゼロであれば、何のサブネットマスクがこのエントリのために含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On an interface where a RIP-1 router may hear and operate on the information in a RIP-2 routing entry the following rules apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP-1ルータが聞くと、次の規則が適用RIP-2ルーティングエントリ内の情報に動作することができるインターフェイスで：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
1) information internal to one network must never be advertised into another network,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
1）一つのネットワークへの内部情報が別のネットワークにアドバタイズしてはなりません、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
2) information about a more specific subnet may not be advertised where RIP-1 routers would consider it a host route, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP-1ルータがホストルート検討する場合2）、より特定のサブネットに関する情報は、アドバタイズされないことと
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
3) supernet routes (routes with a netmask less specific than the &#34;natural&#34; network mask) must not be advertised where they could be misinterpreted by RIP-1 routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
それらはRIP-1ルータによって誤って解釈することができた場合3）「天然の」ネットワークマスクよりも少ない特定のネットマスクを持つスーパールート（経路）アドバタイズしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4 Next Hop
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4次ホップ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The immediate next hop IP address to which packets to the destination specified by this route entry should be forwarded. Specifying a value of 0.0.0.0 in this field indicates that routing should be via the originator of the RIP advertisement. An address specified as a next hop must, per force, be directly reachable on the logical subnet over which the advertisement is made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
このルートエントリで指定された宛先へのパケットが転送されなければならないための即時ネクストホップIPアドレス。このフィールドに0.0.0.0の値を指定すると、ルーティングがRIP広告の創始経由でなければならないことを示しています。ネクストホップとして指定されたアドレスは、力ごとに、広告が作られ、その上論理サブネット上に直接到達可能でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The purpose of the Next Hop field is to eliminate packets being routed through extra hops in the system. It is particularly useful when RIP is not being run on all of the routers on a network. A simple example is given in Appendix A. Note that Next Hop is an &#34;advisory&#34; field. That is, if the provided information is ignored, a possibly sub-optimal, but absolutely valid, route may be taken. If the received Next Hop is not directly reachable, it should be treated as 0.0.0.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
次ホップフィールドの目的は、システム内の余分なホップ経由でルーティングされたパケットを排除することです。 RIPは、ネットワーク上のすべてのルータ上で実行されていないときには特に便利です。簡単な例は、次ホップが「アドバイザリ」フィールドである付録A注で与えられます。これは、提供された情報を無視すれば、おそらく最適なサブますが、絶対に有効なルートを取ることができる、です。受信したネクストホップが直接到達可能でない場合、それは0.0.0.0として扱われるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5 Multicasting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5マルチキャスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to reduce unnecessary load on those hosts which are not listening to RIP-2 messages, an IP multicast address will be used for periodic broadcasts. The IP multicast address is 224.0.0.9. Note that IGMP is not needed since these are inter-router messages which are not forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP-2へのメッセージを聞いていないこれらのホスト上の不要な負荷を軽減するために、IPマルチキャストアドレスは、定期的な放送のために使用されます。 IPマルチキャストアドレスは224.0.0.9です。これらが転送されていないルータ間のメッセージであるため、IGMPが必要とされていないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
On NBMA networks, unicast addressing may be used. However, if a response addressed to the RIP-2 multicast address is received, it should be accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
NBMAネットワークでは、ユニキャスト・アドレッシングを使用してもよいです。応答が受信されたRIP-2マルチキャストアドレス宛場合は、それが受け入れられるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
In order to maintain backwards compatibility, the use of the multicast address will be configurable, as described in section 5.1. If multicasting is used, it should be used on all interfaces which support it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
セクション5.1で説明したように後方互換性を維持するために、マルチキャストアドレスの使用は、構成可能であろう。マルチキャストを使用する場合は、それをサポートするすべてのインターフェイスで使用されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6 Queries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6クエリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
If a RIP-2 router receives a RIP-1 Request, it should respond with a RIP-1 Response. If the router is configured to send only RIP-2 messages, it should not respond to a RIP-1 Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP-2ルータがRIP-1のリクエストを受信した場合、それはRIP-1応答で応答する必要があります。ルータが唯一のRIP-2メッセージを送信するように設定されている場合は、RIP-1のリクエストに応じるべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Compatibility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.互換性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC [1] showed considerable forethought in its specification of the handling of version numbers. It specifies that RIP messages of version 0 are to be discarded, that RIP messages of version 1 are to be discarded if any Must Be Zero (MBZ) field is non-zero, and that RIP messages of any version greater than 1 should not be discarded simply because an MBZ field contains a value other than zero. This means that the new version of RIP is totally backwards compatible with existing RIP implementations which adhere to this part of the specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RFC [1]バージョン番号の取り扱いその仕様にかなりの配慮を示しました。これは、フィールドが非ゼロであり、1より大きい任意のバージョンのRIPメッセージはすべきではないいずれかがゼロ（MBZ）しなければならない場合は、バージョン0のRIPメッセージは破棄され、バージョン1とRIPメッセージは破棄されていることを指定しますMBZフィールドがゼロ以外の値が含まれているため、単純に廃棄。これは、RIPの新バージョンは、仕様のこの部分に接着し、既存のRIP実装と完全に下位互換性があることを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 Compatibility Switch
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1互換性スイッチ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
A compatibility switch is necessary for two reasons. First, there are implementations of RIP-1 in the field which do not follow RFC [1] as described above. Second, the use of multicasting would prevent RIP-1 systems from receiving RIP-2 updates (which may be a desired feature in some cases). This switch should be configurable on a per-interface basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
互換性スイッチは、2つの理由のために必要です。まず、上述したように[1] RFCに従わないフィールドにおけるRIP-1の実装が存在します。第二に、マルチキャストの使用は（いくつかの場合において、所望の特徴であってもよい）RIP-2アップデートを受信することからRIP-1システムを妨げます。このスイッチは、インターフェイス単位で設定可能でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The switch has four settings: RIP-1, in which only RIP-1 messages are sent; RIP-1 compatibility, in which RIP-2 messages are broadcast; RIP-2, in which RIP-2 messages are multicast; and &#34;none&#34;, which disables the sending of RIP messages. It is recommended that the default setting be either RIP-1 or RIP-2, but not RIP-1 compatibility. This is because of the potential problems which can occur on some topologies. RIP-1 compatibility should only be used when all of the consequences of its use are well understood by the network administrator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
スイッチは、4つの設定があります。RIP-1、唯一のRIP-1メッセージが送信されると、 RIP-1 RIP-2メッセージが放送された互換性、。 RIP-2、RIP-2メッセージがマルチキャストされました。 RIPメッセージの送信を無効にし、「なし」、。デフォルト設定はRIP-1またはRIP-2のいずれかにすることをお勧めしますが、RIP-1ではない互換性がされています。これは、いくつかのトポロジ上で発生する可能性が潜在的な問題です。その使用の結果の全てがよく、ネットワーク管理者によって理解されているとき、RIP-1互換性にのみ使用してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
For completeness, routers should also implement a receive control switch which would determine whether to accept, RIP-1 only, RIP-2 only, both, or none. It should also be configurable on a per-interface basis. It is recommended that the default be compatible with the default chosen for sending updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全性のために、ルータはまた、RIP-1だけ、RIP-2、両方、またはnoneを受け入れるかどうかを決定するであろう受信制御スイッチを実装しなければなりません。また、インターフェイスごとに設定可能でなければなりません。デフォルトでは、更新を送信するために選択されたデフォルトと互換性があることをお勧めします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2認証
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   The following algorithm should be used to authenticate a RIP message.
   If the router is not configured to authenticate RIP-2 messages, then
   RIP-1 and unauthenticated RIP-2 messages will be accepted;
   authenticated RIP-2 messages shall be discarded.  If the router is
   configured to authenticate RIP-2 messages, then RIP-1 messages and
   RIP-2 messages which pass authentication testing shall be accepted;
   unauthenticated and failed authentication RIP-2 messages shall be
   discarded.  For maximum security, RIP-1 messages should be ignored when authentication is in use (see section 4.1); otherwise, the
   routing information from authenticated messages will be propagated by
   RIP-1 routers in an unauthenticated manner.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Since an authentication entry is marked with an Address Family Identifier of 0xFFFF, a RIP-1 system would ignore this entry since it would belong to an address family other than IP. It should be noted, therefore, that use of authentication will not prevent RIP-1 systems from seeing RIP-2 messages. If desired, this may be done using multicasting, as described in sections 4.5 and 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
認証エントリは0xFFFFでのアドレスファミリ識別子が付いているので、それはIP以外のアドレスファミリーに属するであろうから、RIP-1システムでは、このエントリを無視します。したがって、認証の使用はRIP-2メッセージを見てからRIP-1のシステムを防ぐことはできません、注意すべきです。所望であれば、セクション4.5および5.1に記載されているように、これは、マルチキャストを使用して行うことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 Larger Infinity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3大きなインフィニティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
While on the subject of compatibility, there is one item which people have requested: increasing infinity. The primary reason that this cannot be done is that it would violate backwards compatibility. A larger infinity would obviously confuse older versions of rip. At best, they would ignore the route as they would ignore a metric of 16. There was also a proposal to make the Metric a single octet and reuse the high three octets, but this would break any implementations which treat the metric as a 4-octet entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
増加無限：互換性をテーマにしながら、人々が要求した一つの項目があります。これを行うことができないことを主な理由は、それが後方互換性に違反するだろうということです。大きな無限大は明らかに、RIPの古いバージョンを混乱させる。最高の状態で、彼らは16のメトリックを無視するように、彼らはルートを無視するでしょうがありメトリックに単一オクテットを作り、高の3つのオクテットを再利用するという提案でもあったが、これは、4-としてメトリックを扱うすべての実装を壊しますオクテットエンティティ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 Addressless Links
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4アドレスなしリンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
As in RIP-1, addressless links will not be supported by RIP-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
RIP-1と同様に、アドレスなしのリンクはRIP-2でサポートされることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Interaction between version 1 and version 2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
バージョン1とバージョン2の間の前記相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Because version 1 packets do not contain subnet information, the semantics employed by routers on networks that contain both version 1 and version 2 networks should be limited to that of version 1. Otherwise it is possible either to create blackhole routes (i.e., routes for networks that do not exist) or to create excessive routing information in a version 1 environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
バージョン1パケットは、サブネット情報が含まれていないので、両方のバージョン1とバージョン2つのネットワークが含まれているネットワーク上のルータによって使用されるセマンティクスは、バージョンのものに限定されるべきである1.それ以外の場合は、どちらかのネットワーク用のブラックホールルート（すなわち、ルートを作成することが可能ですそれは存在しない）、またはバージョン1環境での過度のルーティング情報を作成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Some implementations attempt to automatically summarize groups of adjacent routes into single entries, the goal being to reduce the total number of entries. This is called auto-summarization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
いくつかの実装は、自動的に単一のエントリに隣接する経路のグループを要約しようとすると、目標は、エントリの合計数を減らすことです。これは、自動集約と呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Specifically, when using both version 1 and version 2 within a network, a single subnet mask should be used throughout the network. In addition, auto-summarization mechanisms should be disabled for such networks, and implementations must provide mechanisms to disable auto-summarization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ネットワーク内のバージョン1とバージョン2の両方を使用する場合、具体的に、単一のサブネットマスクは、ネットワーク全体で使用されるべきです。また、自動要約メカニズムは、そのようなネットワークのために無効にする必要があり、および実装は、自動要約を無効にするメカニズムを提供しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The basic RIP protocol is not a secure protocol. To bring RIP-2 in line with more modern routing protocols, an extensible authentication mechanism has been incorporated into the protocol enhancements. This mechanism is described in sections 4.1 and 5.2. Security is further enhanced by the mechanism described in [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
基本的なRIPプロトコルは安全なプロトコルではありません。より近代的なルーティングプロトコルに沿ったRIP-2をもたらすために、拡張可能な認証メカニズムは、プロトコルの拡張に組み込まれています。このメカニズムは、セクション4.1および5.2に記載されています。セキュリティがさらに[3]で説明したメカニズムによって強化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Appendix A
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
付録A
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This is a simple example of the use of the next hop field in a rip entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
これは、RIPエントリの次ホップフィールドの使用の簡単な例です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
      -----   -----   -----           -----   -----   -----
      |IR1|   |IR2|   |IR3|           |XR1|   |XR2|   |XR3|
      --+--   --+--   --+--           --+--   --+--   --+--
        |       |       |               |       |       |
      --+-------+-------+---------------+-------+-------+--
        &lt;-------------RIP-2-------------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Assume that IR1, IR2, and IR3 are all &#34;internal&#34; routers which are under one administration (e.g. a campus) which has elected to use RIP-2 as its IGP. XR1, XR2, and XR3, on the other hand, are under separate administration (e.g. a regional network, of which the campus is a member) and are using some other routing protocol (e.g. OSPF). XR1, XR2, and XR3 exchange routing information among themselves such that they know that the best routes to networks N1 and N2 are via XR1, to N3, N4, and N5 are via XR2, and to N6 and N7 are via XR3. By setting the Next Hop field correctly (to XR2 for N3/N4/N5, to XR3 for N6/N7), only XR1 need exchange RIP-2 routes with IR1/IR2/IR3 for routing to occur without additional hops through XR1. Without the Next Hop (for example, if RIP-1 were used) it would be necessary for XR2 and XR3 to also participate in the RIP-2 protocol to eliminate extra hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
IR1、IR2、およびIR3はそのすべてのIGPとしてRIP-2を使用することを選択したものの投与を受けている「内部」ルータ（例えばキャンパス）であると仮定する。 XR1、XR2及びXR3は、一方で、別々の投与（キャンパスがメンバーである例えば地域ネットワーク）の下で、いくつかの他のルーティングプロトコル（例えばOSPF）を使用しています。 XR1、XR2、およびXR3交換N3、N4、およびN5に、彼らはネットワークN1およびN2への最適ルートがXR1を経由していることを知っているようにそれらの間でルーティング情報をXR2を経由しており、N6とN7にXR3を経由しています。正しくネクストホップフィールドを設定することにより（N3 / N4 / N5ためXR2に、N6 / N7用XR3に）のみXR1は交換RIP-2 XR1スルー追加ホップなしに発生するルーティングするIR1 / IR2 / IR3とのルートを必要とします。 XR2及びXR3はまた、余分なホップを排除するRIP-2プロトコルに参加するための次のホップ（例えば、RIP-1を使用した場合）ことなく、それが必要であろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
リファレンス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1] Hedrick, C., &#34;Routing Information Protocol&#34;, STD 34, RFC 1058, Rutgers University, June 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[1]ヘドリック、C.、​​ &#34;ルーティング情報プロトコル&#34;、STD 34、RFC 1058、ラトガース大学、1988年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2] Malkin, G., and F. Baker, &#34;RIP Version 2 MIB Extension&#34;, RFC 1389, January 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[2]マルキン、G.、およびF.ベイカー、 &#34;RIPバージョン2 MIB拡張&#34;、RFC 1389、1993年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3] Baker, F., and R. Atkinson, &#34;RIP-II MD5 Authentication&#34;, RFC 2082, January 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[3]ベーカー、F.、およびR.アトキンソン、 &#34;RIP-II MD5認証&#34;、RFC 2082、1997年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4] Bellman, R. E., &#34;Dynamic Programming&#34;, Princeton University Press, Princeton, N.J., 1957.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[4]ベルマン、R. E.、 &#34;ダイナミックプログラミング&#34;、プリンストン大学プレス、プリンストン、ニュージャージ州、1957年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5] Bertsekas, D. P., and Gallaher, R. G., &#34;Data Networks&#34;, Prentice-Hall, Englewood Cliffs, N.J., 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[5] Bertsekas、D. P.、及びガラハー、R. G.、 &#34;データネットワーク&#34;、プレンティス・ホール、イングルウッドクリフ、ニュージャージー、1987。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6] Braden, R., and Postel, J., &#34;Requirements for Internet Gateways&#34;, STD 4, RFC 1009, June 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[6]ブレーデン、R.、およびポステル、J.、 &#34;インターネットゲートウェイの要件&#34;、STD 4、RFC 1009、1987年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[7] Boggs, D. R., Shoch, J. F., Taft, E. A., and Metcalfe, R. M., &#34;Pup: An Internetwork Architecture&#34;, IEEE Transactions on Communications, April 1980.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[7]ボッグズ、D. R.、Shoch、J. F.、タフト、E. A.、およびメトカーフ、R. M.、 &#34;子犬：インターネットワークアーキテクチャ&#34;、通信に関するIEEEトランザクション、1980年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[8] Ford, L. R. Jr., and Fulkerson, D. R., &#34;Flows in Networks&#34;, Princeton University Press, Princeton, N.J., 1962.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[8]フォード、L. R.ジュニア、およびフルカーソン、D. R.は、プリンストン大学プレス、プリンストン、ニュージャージ州、1962年、 &#34;ネットワークに流れます&#34;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[9] Xerox Corp., &#34;Internet Transport Protocols&#34;, Xerox System Integration Standard XSIS 028112, December 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[9]ゼロックス社、「インターネットトランスポートプロトコル」、ゼロックスシステムインテグレーション標準XSIS 028112、1981年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[10] Floyd, S., and V. Jacobson, &#34;The synchronization of Periodic Routing Messages,&#34; ACM Sigcom &#39;93 symposium, September 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[10]フロイド、S.、およびV. Jacobsonの &#34;周期的ルーティングメッセージの同期、&#34; ACM Sigcom &#39;93シンポジウム、1993年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
[11] Baker, F., &#34;Requirements for IP Version 4 Routers.&#34; RFC 1812, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
[11]ベーカー、F.、 &#34;IPバージョン4つのルータのための要件。&#34; RFC 1812、1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Gary Scott Malkin Bay Networks 8 Federal Street Billerica, MA 01821
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
ゲーリースコットマルキンベイネットワーク8連邦ストリートビレリカ、MA 01821
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Phone: (978) 916-4237 EMail: gmalkin@baynetworks.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
電話：（978）916-4237 Eメール：gmalkin@baynetworks.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
完全な著作権声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
著作権（C）インターネット協会（1998）。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text">
この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。
        </p>
      </div>
    </div>
  </div>
  <div class="footer"></div>
</body>
</html>
