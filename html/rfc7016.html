<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7016 - Adobe&#39;s Secure Real-Time Media Flow Protocol 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7016</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7016 - Adobe's Secure Real-Time Media Flow Protocol 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7016">
              https://tools.ietf.org/html/rfc7016
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7016 - Adobeのセキュアリアルタイムメディアフロープロトコル</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                     M. Thornburgh
Request for Comments: 7016                                         Adobe
Category: Informational                                    November 2013
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              Adobe&#39;s Secure Real-Time Media Flow Protocol
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes Adobe&#39;s Secure Real-Time Media Flow Protocol (RTMFP), an endpoint-to-endpoint communication protocol designed to securely transport parallel flows of real-time video, audio, and data messages, as well as bulk data, over IP networks. RTMFP has features that make it effective for peer-to-peer (P2P) as well as client-server communications, even when Network Address Translators (NATs) are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、Adobe社のセキュアリアルタイムメディアフロープロトコル（RTMFP）、セキュアIPネットワーク上で、リアルタイムのビデオ、オーディオ、およびデータメッセージのパラレルフローだけでなく、大量のデータを転送するために設計されたエンドポイント間の通信プロトコルを記述します。 RTMFPは、ネットワークが翻訳器（NAT）のアドレスであっても、それが効果的なピア・ツー・ピア（P2P）のために作るの機能だけでなく、クライアント - サーバ間の通信は、使用されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7016で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG Note
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG注意
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document represents technology developed outside the processes of the IETF and the IETF community has determined that it is useful to publish it as an RFC in its current form. It is a product of the IETF only in that it has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG), but the content of the document does not represent a consensus of the IETF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書は、IETFの過程外で開発された技術を表し、IETFコミュニティは、現在の形でのRFCとして公開するために有用であると判断しました。それは公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されているだけという点で、IETFの製品ですが、ドキュメントの内容は、IETFのコンセンサスを表すものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may not be modified, and derivative works of it may not be created, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFCとして公表のためにそれをフォーマットしたり、英語以外の言語に翻訳することを除いて、このドキュメントは変更されないことがあり、それの派生作品が作成されないことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1. Introduction ....................................................5
      1.1. Design Highlights of RTMFP .................................6
      1.2. Terminology ................................................7
   2. Syntax ..........................................................8
      2.1. Common Elements ............................................8
           2.1.1. Elementary Types and Constructs .....................8
           2.1.2. Variable Length Unsigned Integer (VLU) .............10
           2.1.3. Option .............................................10
           2.1.4. Option List ........................................11
           2.1.5. Internet Socket Address (Address) ..................12
      2.2. Network Layer .............................................13
           2.2.1. Encapsulation ......................................13
           2.2.2. Multiplex ..........................................13
           2.2.3. Encryption .........................................14
           2.2.4. Packet .............................................15
      2.3. Chunks ....................................................18
           2.3.1. Packet Fragment Chunk ..............................20
           2.3.2. Initiator Hello Chunk (IHello) .....................21
           2.3.3. Forwarded Initiator Hello Chunk (FIHello) ..........22
           2.3.4. Responder Hello Chunk (RHello) .....................23
           2.3.5. Responder Redirect Chunk (Redirect) ................24
           2.3.6. RHello Cookie Change Chunk .........................26
           2.3.7. Initiator Initial Keying Chunk (IIKeying) ..........27
           2.3.8. Responder Initial Keying Chunk (RIKeying) ..........29
           2.3.9. Ping Chunk .........................................31
           2.3.10. Ping Reply Chunk ..................................32
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           2.3.11. User Data Chunk ...................................33
                  2.3.11.1. Options for User Data ....................35
                           2.3.11.1.1. User&#39;s Per-Flow Metadata ......35
                           2.3.11.1.2. Return Flow Association .......36
           2.3.12. Next User Data Chunk ..............................37
           2.3.13. Data Acknowledgement Bitmap Chunk (Bitmap Ack) ....39
           2.3.14. Data Acknowledgement Ranges Chunk (Range Ack) .....41
           2.3.15. Buffer Probe Chunk ................................43
           2.3.16. Flow Exception Report Chunk .......................43
           2.3.17. Session Close Request Chunk (Close) ...............44
           2.3.18. Session Close Acknowledgement Chunk (Close Ack) ...44
   3. Operation ......................................................45
      3.1. Overview ..................................................45
      3.2. Endpoint Identity .........................................46
      3.3. Packet Multiplex ..........................................48
      3.4. Packet Fragmentation ......................................48
      3.5. Sessions ..................................................50
           3.5.1. Startup ............................................53
                  3.5.1.1. Normal Handshake ..........................53
                           3.5.1.1.1. Initiator ......................54
                           3.5.1.1.2. Responder ......................55
                  3.5.1.2. Cookie Change .............................57
                  3.5.1.3. Glare .....................................59
                  3.5.1.4. Redirector ................................60
                  3.5.1.5. Forwarder .................................61
                  3.5.1.6. Redirector and Forwarder with NAT .........63
                  3.5.1.7. Load Distribution and Fault Tolerance .....66
           3.5.2. Congestion Control .................................67
                  3.5.2.1. Time Critical Reverse Notification ........68
                  3.5.2.2. Retransmission Timeout ....................68
                  3.5.2.3. Burst Avoidance ...........................71
           3.5.3. Address Mobility ...................................71
           3.5.4. Ping ...............................................72
                  3.5.4.1. Keepalive .................................72
                  3.5.4.2. Address Mobility ..........................73
                  3.5.4.3. Path MTU Discovery ........................74
           3.5.5. Close ..............................................74
      3.6. Flows .....................................................75
           3.6.1. Overview ...........................................75
                  3.6.1.1. Identity ..................................75
                  3.6.1.2. Messages and Sequencing ...................76
                  3.6.1.3. Lifetime ..................................77
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           3.6.2. Sender .............................................78
                  3.6.2.1. Startup ...................................80
                  3.6.2.2. Queuing Data ..............................80
                  3.6.2.3. Sending Data ..............................81
                           3.6.2.3.1. Startup Options ................83
                           3.6.2.3.2. Send Next Data .................83
                  3.6.2.4. Processing Acknowledgements ...............83
                  3.6.2.5. Negative Acknowledgement and Loss .........84
                  3.6.2.6. Timeout ...................................85
                  3.6.2.7. Abandoning Data ...........................86
                           3.6.2.7.1. Forward Sequence Number
                                      Update .........................86
                  3.6.2.8. Examples ..................................87
                  3.6.2.9. Flow Control ..............................89
                           3.6.2.9.1. Buffer Probe ...................89
                  3.6.2.10. Exception ................................89
                  3.6.2.11. Close ....................................90
           3.6.3. Receiver ...........................................90
                  3.6.3.1. Startup ...................................93
                  3.6.3.2. Receiving Data ............................94
                  3.6.3.3. Buffering and Delivering Data .............95
                  3.6.3.4. Acknowledging Data ........................97
                           3.6.3.4.1. Timing .........................98
                           3.6.3.4.2. Size and Truncation ............99
                           3.6.3.4.3. Constructing ...................99
                           3.6.3.4.4. Delayed Acknowledgement .......100
                           3.6.3.4.5. Obligatory Acknowledgement ....100
                           3.6.3.4.6. Opportunistic
                                      Acknowledgement ...............100
                           3.6.3.4.7. Example .......................101
                  3.6.3.5. Flow Control .............................102
                  3.6.3.6. Receiving a Buffer Probe .................103
                  3.6.3.7. Rejecting a Flow .........................103
                  3.6.3.8. Close ....................................104
   4. IANA Considerations ...........................................104
   5. Security Considerations .......................................105
   6. Acknowledgements ..............................................106
   7. References ....................................................107
      7.1. Normative References .....................................107
      7.2. Informative References ...................................107
   Appendix A. Example Congestion Control Algorithm .................108
     A.1. Discussion ................................................108
     A.2. Algorithm .................................................110
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adobe&#39;s Secure Real-Time Media Flow Protocol (RTMFP) is intended for use as a general purpose endpoint-to-endpoint data transport service in IP networks. It has features that make it well suited to the transport of real-time media (such as low-delay video, audio, and data) as well as bulk data, and for client-server as well as peer-to-peer (P2P) communication. These features include independent parallel message flows that may have different delivery priorities, variable message reliability (from TCP-like full reliability to UDP-like best effort), multi-point congestion control, and built-in security. Session multiplexing and facilities to support UDP hole-punching simplify Network Address Translator (NAT) traversal in peer-to-peer systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adobeのセキュアリアルタイムメディアフロープロトコル（RTMFP）は、IPネットワークにおける汎用エンドポイント間のデータ転送サービスとして使用するためのものです。これは、リアルタイムメディアの輸送にそれが適しせる機能を備えています（このような低遅延ビデオ、オーディオ、およびデータなど）だけでなく、大量のデータ、およびクライアント・サーバー用としてだけでなく、ピア・ツー・ピア（P2P ） コミュニケーション。これらの特徴は、独立パラレル（UDPのようなベストエフォートにTCPのような完全な信頼性の）異なる配信優先度、可変メッセージの信頼性を有することができるメッセージ・フロー、マルチポイント輻輳制御、およびセキュリティ内蔵を含みます。セッションの多重化やピア・ツー・ピアシステムにおけるネットワークアドレス変換（NAT）トラバーサルを簡略化するUDPホールパンチングをサポートするための施設。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP is implemented in Flash Player, Adobe Integrated Runtime (AIR), and Adobe Media Server (AMS, formerly Flash Media Server or FMS), all from Adobe Systems Incorporated, and is used as the foundation transport protocol for real-time video, audio, and data communication, both client-server and P2P, in those products. At the time of writing, the Adobe Flash Player runtime is installed on more than one billion end-user desktop computers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、すべてのAdobe Systems Incorporated（アドビシステムズ社）から、Flash Playerが、アドビの統合ランタイム（AIR）、およびAdobeメディアサーバー（AMS、以前のFlash Media ServerまたはFMS）で実装されており、リアルタイムのビデオ、オーディオのための基盤トランスポートプロトコルとして使用されています、データ通信、これらの製品の両方のクライアント・サーバーやP2P、と。執筆時点では、Adobe Flash Playerのランタイムは、以上の10億エンドユーザーのデスクトップコンピュータにインストールされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP was developed by Adobe Systems Incorporated and is not the product of an IETF activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、Adobe Systems Incorporated（アドビシステムズ社）によって開発され、IETF活動の製品ではありませんました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes the syntax and operation of the Secure Real-Time Media Flow Protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、セキュアリアルタイムメディアフロープロトコルの構文と動作について説明しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes a general security framework that, when combined with an application-specific Cryptography Profile, can be used to establish a confidential and authenticated session between endpoints. The application-specific Cryptography Profile, not defined herein, would detail the specific cryptographic algorithms, data formats, and semantics to be used within this framework. Interoperation between applications of RTMFP requires common or compatible Cryptography Profiles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、アプリケーション固有の暗号プロファイルと組み合わせた場合、エンドポイント間の機密と認証されたセッションを確立するために使用することができる一般的なセキュリティフレームワークを記述する。アプリケーション固有の暗号プロファイルは、本明細書で定義されていないが、詳細特定の暗号化アルゴリズム、データフォーマット、及び意味論は、このフレームワーク内で使用されるであろう。 RTMFPのアプリケーション間の相互運用は、共通または互換性のある暗号化プロファイルが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note to implementers: at the time of writing, the Cryptography Profile used by the above-mentioned Adobe products is not publicly described by Adobe. Implementers should investigate the availability of documentation of that Cryptography Profile prior to implementing RTMFP for the purpose of interoperation with the above-mentioned Adobe products.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装者への注意：執筆時点では、上記のアドビ製品で使用される暗号化のプロフィールは、公的アドビによって記述されていません。実装者は、上記のアドビ製品との相互運用のために、RTMFPを実装する前に、その暗号プロファイルのドキュメントの利用可能性を調査する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Design Highlights of RTMFP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1.  RTMFPのデザインのハイライト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Between any pair of communicating endpoints is a single, bidirectional, secured, congestion controlled session. Unidirectional flows convey messages from one end to the other within the session. An endpoint can have concurrent sessions with multiple other far endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信エンドポイントの任意のペア間の単一の、双方向、固定、輻輳制御セッションです。単方向フローは、セッション内の他の端から端までのメッセージを伝えます。エンドポイントは、他の複数の遠くのエンドポイントとの同時セッションを持つことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Design highlights of RTMFP include the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPのデザインのハイライトは次のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The security framework is an inherent part of the basic protocol. The application designer chooses the cryptographic formats and algorithms to suit the needs of the application, and may update them as the state of the security arts progresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oセキュリティフレームワークは、基本的なプロトコルの固有の部分です。アプリケーション設計者は、アプリケーションのニーズに合わせて、暗号形式とアルゴリズムを選択し、セキュリティ芸術の状態が進むにつれて、それらを更新することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cryptographic Endpoint Discriminators can resist port scanning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O暗号化エンドポイントディスクリミネータは、ポートスキャンを抵抗することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All header, control, and framing information, except for network addressing information and a session identifier, is encrypted according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oネットワークアドレス情報及びセッション識別子を除くすべてのヘッダー、制御、及びフレーミング情報は、暗号化プロファイルに従って暗号化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is a single session and associated congestion control state between a pair of endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oエンドポイントのペア間の単一のセッションと関連した輻輳制御状態です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each session may have zero or more unidirectional message-oriented flows in each direction. All of a session&#39;s sending flows share the session&#39;s congestion control state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oの各セッションは、各方向におけるゼロ以上の一方向メッセージ指向の流れを有することができます。セッションの送信フローのすべてのセッションの輻輳制御状態を共有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Return Flow Association (Section 2.3.11.1.2) generalizes bidirectional communication to arbitrarily complex trees of flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oリターンフロー協会（セクション2.3.11.1.2）はフローの任意の複雑な木々に双方向通信を一般化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Messages in flows can be arbitrarily large and are fragmented for transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oフロー内のメッセージは、任意の大きさであってもよく、送信のために断片化されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Messages of any size may be sent with full, partial, or no reliability (sender&#39;s choice). Messages may be delivered to the receiving user in original queuing order or network arrival order (receiver&#39;s choice).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O任意のサイズのメッセージは、完全、部分、または全く信頼性（送信者の選択肢）を用いて送信することができます。メッセージは、元の待ち行列の順序またはネットワーク到着順序（受信機の選択）に受信ユーザに送達することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Flows are named with arbitrary, user-defined metadata (Section 2.3.11.1.1) rather than port or stream numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oフローは、任意のユーザ定義メタデータ（セクション2.3.11.1.1）よりもむしろポートまたはストリーム番号で命名されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence numbers of each flow are independent of all other flows and are not permanently bound to a session-wide transmission ordering. This allows real-time priority decisions to be made at transmission or retransmission time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oを各フローのシーケンス番号は、他のすべてのフローの独立しており、恒久的にセッション全体の伝送順序にバインドされていません。これは、リアルタイムの優先順位の決定は、送信または再送信時に行うことを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each flow has its own receive window and, therefore, independent flow control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O各フローは、独自の、窓を受け、したがって、独立したフロー制御を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Round trips are expensive and are minimized or eliminated when possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O往復は高価であり、可能な場合は、最小化または排除されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o After a session is established, flows begin by sending the flow&#39;s messages with no additional handshake (and associated round trips).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションが確立された後、O、追加のハンドシェイク（および関連する往復）と流れのメッセージを送信することから始めて流れ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Transmitting bytes on the network is much more expensive than moving bytes in a CPU or memory. Wasted bytes are minimized or eliminated when possible and practical, and variable length encodings are used, even at the expense of breaking 32-bit alignment and making the text diagrams in this specification look awkward.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワーク上のバイトを送信oをCPUやメモリ内のバイトを移動するよりもはるかに高価です。無駄なバイトがあっても、32ビットの整列を破壊し、本明細書のテキスト図は厄介見せるを犠牲にし、最小化または可能で実用的な、及び可変長符号化が使用されるときに除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o P2P lookup and peer introduction (including UDP hole-punching for NAT and firewall traversal) are supported directly by the session startup handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O P2P検索と（NATやファイアウォール越えのためのUDPホールパンチングを含む）ピア導入は、セッション起動ハンドシェイクによって直接サポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Session identifiers allow an endpoint to multiplex many sessions over a single local transport address while allowing sessions to survive changes in transport address (as may happen in mobile or wireless deployments).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（モバイルまたはワイヤレス展開に起こり得るような）トランスポートアドレスの変更を生き残るためにセッションを可能にしながら、Oセッション識別子は、エンドポイントが単一のローカルトランスポートアドレス上で多くのセッションを多重化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The syntax of the protocol is detailed in Section 2. The operation of the protocol is detailed in Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルの構文は、プロトコルの動作は、第3節に詳述されている第2節に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 用語
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キーワード &#34;MUST&#34;、 &#34;MUST NOT&#34;、 &#34;REQUIRED&#34;、 &#34;SHALL&#34;、 &#34;SHOULD&#34;、 &#34;ないもの&#34;、 &#34;推奨&#34; &#34;ない（SHOULD NOT）&#34;、 &#34;MAY&#34;、 &#34;推奨NOT&#34;、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Syntax
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.構文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definitions of types and structures in this specification use traditional text diagrams paired with procedural descriptions using a C-like syntax. The C-like procedural descriptions SHALL be construed as definitive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本明細書における種類や構造の定義は、Cに似た構文を使用して、手続きの記述とペアになって、伝統的なテキスト・ダイアグラムを使用しています。 C-ような手続き記述は決定的なものと解釈されるものとする（SHALL）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structures are packed to take only as many bytes as explicitly indicated. There is no 32-bit alignment constraint, and fields are not padded for alignment unless explicitly indicated or described. Text diagrams may include a bit ruler across the top; this is a convenience for counting bits in individual fields and does not necessarily imply field alignment on a multiple of the ruler width.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造はとして明示的に示されているだけのように多くのバイトを取るためにパックされています。そこには、32ビットのアライメント制約はなく、明示又は記載されない限りフィールドは、位置合わせのために埋め込まれていません。テキスト図は、上部にビット定規を含むことができます。これは、個々のフィールド内のビットをカウントするための便宜であり、必ずしも定規幅の複数のフィールドの配置を意味するものではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless specified otherwise, reserved fields SHOULD be set to 0 by a sender and MUST be ignored by a receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に指定のない限り、予約フィールドは、送信者によって0に設定されるべきであり、受信機で無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedural syntax of this specification defines correct and error-free encoded inputs to a parser. The procedural syntax does not describe a fully featured parser, including error detection and handling. Implementations MUST include means to identify error circumstances, including truncations causing elementary or composed types to not fit inside containing structures, fields, or elements. Unless specified otherwise, an error circumstance SHALL abort the parsing and processing of an element and its enclosing elements, up to the containing packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本明細書の手続き構文パーサに正しいとエラーフリー符号化入力を定義します。手続き型構文は、エラー検出および処理を含むフル機能のパーサーを、説明していません。実装は、構造、フィールド、または要素を含む内側適合しないように、基本構成や種類を引き起こす切断などのエラー状況を識別するための手段を含まなければなりません。特に断らない限り、エラー状況を含むパケットまで、要素とその囲み要素の解析および処理を中断します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Common Elements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 共通要素
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section lists types and structures that are used throughout this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、本明細書を通じて使用されている種類と構造を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1. Elementary Types and Constructs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.1. 小学校種類と構築
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section lists the elementary types and constructs out of which all of the following sections&#39; definitions are built.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、次のセクションの定義のすべてが構築されるのうち基本タイプと構造を示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8_t var;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8_tでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer 8 bits (one byte) in length and byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
長さとバイト位置合わせの符号なし整数8ビット（1バイト）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint16_t var;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint16_tでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer 16 bits in length, in network byte order (&#34;big endian&#34;) and byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
符号なし整数ネットワークバイト順で長さが16ビット（「ビッグエンディアン」）とバイトを整列します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32_t var;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint32_tでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer 32 bits in length, in network byte order and byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
符号なし整数ネットワークバイト順と、バイト整列の長さは32ビット、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint128_t var;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint128_tでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer 128 bits in length, in network byte order and byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
符号なし整数ネットワークバイト順とバイト位置合わせされ、長さ128ビット、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uintn_t var :bitsize;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そこuint_t：bitesizeを。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An unsigned integer of any other size, potentially not byte aligned. Its size in bits is specified explicitly by bitsize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
他のサイズの符号なし整数、潜在的にバイトにアライメントが合っていません。ビットでそのサイズはビットサイズによって明示的に指定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bool_t var :1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bool_tは以下の通りであった：1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A boolean flag having the value true (1 or set) or false (0 or clear) and being one bit in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
ブール・フラグ（1またはセット）または偽（0またはクリア）真の値を有し、長さが1ビットです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type var[num];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプは、[NUM]でした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A packed array of type with length num*sizeof(type)*8 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
長num個の*のはsizeof（タイプ）* 8ビットのタイプのパックされたアレイ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
struct name_t { ... } name :bitsize;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
構造体のtime_t {...}名前：bitesize。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A packed structure. Its size in bits is specified by bitsize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
充填構造。ビットでそのサイズはbitesizeによって指定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
remainder();
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残りの（）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The number of bytes from the current offset to the end of the enclosing structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
囲い構造の端部にオフセット電流からのバイトの数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type var[remainder()];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイプした余り（）]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A packed array of type, its size extending to the end of the enclosing structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
タイプのパックされた配列は、その大きさは、封入構造体の端まで延びます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a bitsize of &#34;variable&#34; indicates that the size of the structure is determined by the sizes of its interior components. A bitsize of &#34;n*8&#34; indicates that the size of the structure is a whole number of bytes and is byte aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「可変」のビットサイズは、構造のサイズは、その内部コンポーネントのサイズによって決定されることを示していることに留意されたいです。 「N * 8」のビットサイズは、構造のサイズがバイトの整数であり、バイト整列であることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2. Variable Length Unsigned Integer (VLU)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.2. 可変長符号なし整数（VLU）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A VLU encodes any finite non-negative integer into one or more bytes. For each encoded byte, if the high bit is set, the next byte is also part of the VLU. If the high bit is clear, this is the final byte of the VLU. The remaining bits encode the number, seven bits at a time, from most significant to least significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VLUは、一つ以上のバイトに任意の有限の負でない整数を符号化します。高いビットが設定されている場合、各符号化されたバイトのために、次のバイトはまた、VLUの一部です。高ビットがクリアされている場合、これはVLUの最後のバイトです。残りのビットは最下位の最上位から、一度に数、7ビットを符号化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7                 0 1 2 3 4 5 6 7
   +~+~+~+~+~+~+~+~+               +-+-+-+-+-+-+-+-+
   |1|    digit    |...............|0|    digit    |
   +~+~+~+~+~+~+~+~+               +-+-+-+-+-+-+-+-+
   ^                               ^
   +--------- zero or more --------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct vlu_t
   {
       value = 0;
       do {
           bool_t  more  :1;
           uintn_t digit :7;
           value = (value * 128) + digit;
       } while(more);
   } :variable*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                              +-------------/-+
                              |             \ |
                              +-------------/-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Figure 1: VLU Depiction in Following Diagrams
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
図1：以下の図ではVLU描写
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless stated otherwise in this specification, implementations SHOULD handle VLUs encoding unsigned integers at least 64 bits in length (that is, encoding a maximum value of at least 2^64 - 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本明細書において特に明記しない限り、実装は、（ -  1、少なくとも2 ^ 64の最大値を符号化する、つまり）のVLUが符号なし整数を長さが少なくとも64ビットを符号化処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.3. Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.3. オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Option is a Length-Type-Value triplet. Length and Type are encoded in VLU format. Length is the number of bytes of payload following the Length field. The payload comprises the Type and Value fields. Type identifies the kind of option this is. The syntax of the Value field is determined by the type of option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションは、長さ・タイプ値のトリプレットです。長さとタイプはVLU形式でエンコードされています。長さは、長さフィールド、次のペイロードのバイト数です。ペイロードは型と値フィールドを含みます。タイプは、これはオプションの種類を識別します。値フィールドの構文は、オプションの種類によって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Option can have a length of zero, in which case it has no type and no value and is empty. An empty Option is called a &#34;Marker&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションは、それがタイプと値を持たない空である場合には、ゼロの長さを有することができます。空のオプションは、「マーカー」と呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------/-+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |    type     \ |            value              |
   +-------------/-+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
                   ^                                               ^
                   +-------- length bytes long (may be 0) ---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct option_t
   {
       vlu_t length :variable*8; // &#34;L&#34;
       if(length &gt; 0)
       {
           struct {
               vlu_t   type :variable*8;   // &#34;T&#34;
               uint8_t value[remainder()]; // &#34;V&#34;
           } payload :length*8;
       }
   } :variable*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                             +---/---/-------+
                             | L \ T \   V   |
                             +---/---/-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 2: Option Depiction in Following Diagrams
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
図2：以下の図ではオプションの描写
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.4. Option List
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.4. オプションリスト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Option List is a sequence of zero or more non-empty Options terminated by a Marker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプションリストは、マーカーで終了し、ゼロ以上の非空のオプションのシーケンスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+
   | L \ T \   V   |...............| L \ T \   V   |       0     \ |
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+
   ^                                               ^     Marker
   +------- zero or more non-empty Options --------+ (empty Option)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct optionList_t
   {
       do
       {
           option_t option :variable*8;
       } while(option.length &gt; 0);
   } :variable*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.5. Internet Socket Address (Address)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1.5. インターネットソケットアドレス（住所）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When communicating an Internet socket address (a combination of a 32-bit IPv4 [RFC0791] or 128-bit IPv6 [RFC2460] address and a 16-bit port number) to another RTMFP, this encoding is used. This encoding additionally allows an address to be tagged with an origin type, which an RTMFP MAY use to modify the use or disposition of the address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別のRTMFPにインターネットソケットアドレス（32ビットのIPv4 [RFC0791]または128ビットのIPv6 [RFC2460]アドレスと16ビットのポート番号の組み合わせ）を通信する場合、このエンコーディングが使用されます。この符号化は、さらに、アドレスがRTMFPは、アドレスの使用または処分を変更するために使用するかもしれ原点タイプ、でタグ付けされることを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                                        1
    0 1 2 3 4 5 6 7                 0 1 2 3 4 5 6 7|8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-----/.../-----+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |I|         | O |    Internet   |                               |
   |P|0 0 0 0 0| R |    address    |              port             |
   |6|   rsv   | I |32 or 128 bits |                               |
   +-+-+-+-+-+-+-+-+-----/.../-----+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct address_t
   {
       bool_t  inet6    :1;     // &#34;IP6&#34;
       uintn_t reserved :5 = 0; // &#34;rsv&#34;
       uintn_t origin   :2;     // &#34;ORI&#34;
       if(inet6)
           uint128_t ipAddress;
       else
           uint32_t ipAddress;
       uint16_t port;
   } :variable*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inet6: If set, the Internet address is a 128-bit IPv6 address. If clear, the Internet address is a 32-bit IPv4 address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INET6：設定されている場合、インターネットアドレスは128ビットのIPv6アドレスです。明確な場合は、インターネット・アドレスは32ビットのIPv4アドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
origin: The origin tag of this address. Possible values are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原産地：このアドレスの原点タグ。可能な値は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0: Unknown, unspecified, or &#34;other&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0：不明、未指定、または「その他」
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1: Address was reported by the origin as a local, directly attached interface address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1：アドレスは、ローカル、直接接続されたインターフェイスのアドレスとして、原点で報告されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2: Address was observed to be the source address from which a packet was received (a &#34;reflexive transport address&#34; in the terminology of [RFC5389])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2：アドレスは、パケットが受信された送信元アドレス（[RFC5389]の用語では「再帰トランスポートアドレス」）であることが観察されました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3: Address is a relay, proxy, or introducer (a Redirector and/or Forwarder)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3：アドレスは、リレー、プロキシ、または導入（リダイレクタおよび/またはフォワーダ）であります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ipAddress: The Internet address, in network byte order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ipAddressは：インターネットアドレス、ネットワークバイトオーダーインチ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
port: The 16-bit port number, in network byte order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポート：ネットワークバイトオーダーで16ビットのポート番号、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Network Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. ネットワーク層
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. Encapsulation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.1. カプセル化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP Multiplex packets are usually carried in UDP [RFC0768] datagrams so that they may transit commonly deployed NATs and firewalls, and so that RTMFP may be implemented on commonly deployed operating systems without special privileges or permissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らはトランジットは、一般のNATやファイアウォールを展開することができ、RTMFPは、特別な特権または許可なしに、一般的に展開され、オペレーティング・システム上に実装することができるようにというように、RTMFP多重パケットは、通常はUDPで[RFC0768]データグラムを実施しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP Multiplex packets MAY be carried by any suitable datagram transport or encapsulation where endpoints are addressed by an Internet socket address (that is, an IPv4 or IPv6 address and a 16-bit port number).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP多重パケットは、エンドポイントがインターネットソケットアドレス（すなわち、IPv4またはIPv6アドレスと16ビットのポート番号である）によってアドレス指定される任意の適切なデータグラム輸送またはカプセル化によって実施することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The choice of port numbers is not mandated by this specification. Higher protocol layers or the application define the port numbers used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ポート番号の選択は、この仕様書で義務付けられていません。より高いプロトコル層またはアプリケーションが使用するポート番号を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. Multiplex
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.2. 複数の
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Scrambled Session ID (SSID)                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             e             first32[0]                          |
   |- - - - - -  n  - - - - - - - - - - - - - - - - - - - - - - - -|
   |             c             first32[1]                          |
   +- - - - - -  r  - - - - - - - - - - - - - - - - - - - - - - - -+
   |             y                                                 |
   |             pted packet                                       |
   +---------------------------------------------------------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct multiplex_t
   {
       uint32_t scrambledSessionID; // &#34;SSID&#34;
       union {
           uint32_t first32[2]; // see note
           uint8_t  encryptedPacket[remainder()];
       } :(encapsulation.length - 4)*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       // if encryptedPacket is less than 8 bytes long, treat it
       // as if it were end-padded with 0s for the following:
       sessionID = scrambledSessionID XOR first32[0] XOR first32[1];
   } :encapsulation.length*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 32-bit Scrambled Session ID is the 32-bit session ID modified by performing a bitwise exclusive-or with the bitwise exclusive-or of the first two 32-bit words of the encrypted packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションIDスクランブル32ビットは、排他的または排他的または暗号化されたパケットの最初の2つの32ビット・ワードのビット単位でビット単位を行うことによって改変さ32ビットのセッションIDです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The session ID is a 32-bit value that the receiver has requested to be used by the sender when sending packets to this receiver (Sections 2.3.7 and 2.3.8). The session ID identifies the session to which this packet belongs and the decryption key to be used to decrypt the encrypted packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションIDは、受信機は、この受信機（セクション2.3.7および2.3.8）にパケットを送信するとき、送信者によって使用されることを要求した32ビットの値です。セッションIDは、このパケットが属するセッションと暗号化されたパケットを解読するために使用する復号鍵を特定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Session ID 0 (prior to scrambling) denotes the startup pseudo-session and implies the Default Session Key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：セッションID 0（前のスクランブルに）起動擬似セッションを示し、デフォルトのセッションキーを意味します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: If the encrypted packet is less than 8 bytes long, then for the scrambling operation, perform the exclusive-or as though the encrypted packet were end-padded with enough 0-bytes to bring its length to 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化されたパケットが8バイト未満の長さである場合には、スクランブリング動作のために、排他的または暗号化されたパケットかのように実行8にその長さを持って0バイト十分で末端パディングした：注意。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3. Encryption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.3. 暗号化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP packets are encrypted according to a Cryptography Profile. This specification doesn&#39;t define a Cryptography Profile or mandate a particular choice of cryptography. The application defines the cryptographic syntax and algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPパケットは暗号化プロファイルに応じて暗号化されています。この仕様は、暗号化プロファイルを定義したり、暗号の特定の選択を強制しません。アプリケーションは、暗号化構文とアルゴリズムを定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet encryption is RECOMMENDED to be a block cipher operating in Cipher Block Chaining [CBC] or similar mode. Encrypted packets MUST be decipherable without inter-packet dependency, since packets may be lost, duplicated, or reordered in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットの暗号化は、暗号ブロック連鎖[CBC]または類似のモードで動作するブロック暗号であることが推奨されます。パケットは、失われた複製、またはネットワークに並べ替えることができるので、暗号化されたパケットは、パケット間の依存関係なしに解読していなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet encryption layer is responsible for data integrity and authenticity of packets, for example by means of a checksum or cryptographic message authentication code. To mitigate replay attacks, data integrity SHOULD comprise duplicate packet detection, for example by means of a session-wide packet sequence number. The packet encryption layer SHALL discard a received packet that does not pass integrity or authenticity tests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットの暗号化層は、チェックサムまたは暗号のメッセージ認証コードを用いて、たとえば、パケットのデータの整合性と信頼性に責任があります。リプレイ攻撃を軽減するために、データの整合性は、セッション全体のパケットシーケンス番号によって例えば、重複パケット検出を、含むべきです。パケットの暗号化層は、整合性や信頼性のテストに合格しない、受信したパケットを破棄すること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the structures described below are of plain, unencrypted packets. Encrypted packets MUST be decrypted according to the Session Key associated with the Multiplex Session ID before being interpreted according to this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下記の構造は、プレーン、暗号化されていないパケットであることに注意してください。暗号化されたパケットは、この仕様に従って解釈される前に、多重セッションIDに関連付けられたセッションキーに従って復号化しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Cryptography Profile defines a well-known Default Session Key that is used at session startup, during which per-session key(s) are negotiated by the two endpoints. A session ID of zero denotes use of the Default Session Key. The Default Session Key is also used with non-zero session IDs during the latter phases of session startup (Sections 2.3.6 and 2.3.8). See Security Considerations (Section 5) for more about the Default Session Key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号プロファイルごとのセッション鍵（s）は2つのエンドポイントによってネゴシエートされる間のセッションの起動時に使用されるよく知られたデフォルトのセッションキーを定義します。ゼロのセッションIDは、デフォルトのセッションキーを使用することを示しています。デフォルトのセッションキーは、セッションの起動（セクション2.3.6および2.3.8）の後半の段階でゼロ以外のセッションIDが使用されています。デフォルトのセッションキーの詳細のためのセキュリティ上の考慮事項（第5節）を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.4. Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2.4. パケット
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An (unencrypted, plain) RTMFP packet consists of a variable sized common header, zero or more chunks, and padding. Padding can be inserted by the encryption layer of the sender to meet cipher block size constraints and is ignored by the receiver. A sender&#39;s encryption layer MAY pad the end of a packet with bytes with value 0xff such that the resulting packet is a natural and appropriate size for the cipher. Alternatively, the Cryptography Profile MAY define its own framing and padding scheme, if needed, such that decrypted packets are compatible with the syntax defined in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（暗号化されていない、プレーン）RTMFPパケットは可変サイズの共通ヘッダ、ゼロまたはそれ以上のチャンク、およびパディングで構成されています。パディングは暗号ブロックサイズの制約を満たすために、送信者の暗号化層によって挿入することができ、受信側では無視されます。送信者の暗号化層MAYパッド得られたパケットは暗号の天然及び適切なサイズであるような値は0xFFとバイトのパケットの終わり。必要に応じて、あるいは、暗号化プロファイルは、復号化されたパケットは、このセクションで定義された構文と互換性があるように、独自のフレーミングとパディング方式を定義することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |T|T| r |T|T| M |
   |C|C| s |S|S| O |
   | |R| v | |E| D |
   +-+-+-+-+-+-+-+-+
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
   |        if(TS) timestamp       |     if(TSE) timestampEcho     |
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                             Chunk                             |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
                                   :
                                   :
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                             Chunk                             |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                            padding                            |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct packet_t
   {
       bool_t  timeCritical         :1; // &#34;TC&#34;
       bool_t  timeCriticalReverse  :1; // &#34;TCR&#34;
       uintn_t reserved             :2; // &#34;rsv&#34;
       bool_t  timestampPresent     :1; // &#34;TS&#34;
       bool_t  timestampEchoPresent :1; // &#34;TSE&#34;
       uintn_t mode                 :2; // &#34;MOD&#34;
       if(0 != mode)
       {
           if(timestampPresent)
               uint16_t timestamp;
           if(timestampEchoPresent)
               uint16_t timestampEcho;
           while(remainder() &gt; 2)
           {
               uint8_t  chunkType;
               uint16_t chunkLength;
               if(remainder() &lt; chunkLength)
                   break;
               uint8_t  chunkPayload[chunkLength];
           } // chunks
           uint8_t padding[remainder()];
       }
   } :plainPacket.length*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeCritical: Time Critical Forward Notification. If set, indicates that this packet contains real-time user data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeCritical：タイムクリティカルフォワード通知。設定された場合、このパケットは、リアルタイムのユーザーデータが含まれていることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeCriticalReverse: Time Critical Reverse Notification. If set, indicates that the sender is currently receiving packets on other sessions that have the timeCritical flag set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timeCriticalReverse：タイムクリティカルリバース通知。設定した場合、送信者は現在timeCriticalフラグが設定されている他のセッションでパケットを受信して​​いることを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampPresent: If set, indicates that the timestamp field is present. If clear, there is no timestamp field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampPresentは：設定した場合、タイムスタンプフィールドが存在していることを示しています。明確な場合は、タイムスタンプフィールドはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEchoPresent: If set, indicates that the timestamp echo field is present. If clear, there is no timestamp echo field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEchoPresentは：設定した場合、タイムスタンプエコーフィールドが存在することを示しています。明確な場合は、タイムスタンプエコーフィールドがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mode: The mode of this packet. See below for additional discussion of packet modes. Possible values are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
モード：このパケットのモード。パケットモードの追加の議論については、以下を参照してください。可能な値は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0: Forbidden value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0：禁断の値
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1: Initiator Mark
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1：イニシエータマーク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2: Responder Mark
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2：レスポンダマーク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3: Startup
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3：スタートアップ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestamp: If the timestampPresent flag is set, this field is present and contains the low 16 bits of the sender&#39;s 250 Hz clock (4 milliseconds per tick) at transmit time. The sender&#39;s clock MAY have its origin at any time in the past.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムスタンプ：timestampPresentフラグが設定されている場合、このフィールドが存在し、送信時に送信者250 Hzのクロックの下位16ビット（目盛り当たり4ミリ秒）を含みます。送信者の時計は、過去の任意の時点でその起源を持っているかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEcho: If the timestampEchoPresent flag is set, this field is present and contains the sender&#39;s estimate of what the timestamp field of a packet received from the other end would be at the time this packet was transmitted, using the method described in Section 3.5.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEcho：timestampEchoPresentフラグが設定されている場合、このフィールドは存在し、もう一方の端から受信したパケットのタイムスタンプフィールドは、セクション3.5.2.2に記載の方法を用いて、このパケットが送信された時点であろうものの送信者の推定値を含んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunks: Zero or more chunks follow the header. It is RECOMMENDED that a packet contain at least one chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンク：ゼロ以上のチャンクは、ヘッダに従います。パケットは、少なくとも1つのチャンクが含まれていることが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding: Zero or more bytes of padding follow the chunks. The following conditions indicate padding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パディング：パディングのゼロ以上のバイトチャンクに従ってください。以下の条件は、パディングを示します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* Fewer than three bytes (the size of a chunk header) remain in the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 3バイト（チャンクヘッダの大きさ）よりも少ないパケットに残ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* The chunkLength field of what would be the current chunk header indicates that the hypothetical chunk payload wouldn&#39;t fit in the remaining bytes of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*現在のチャンクヘッダであるもののchunkLengthフィールドは、仮想的なチャンクペイロードは、パケットの残りのバイトに収まらないであろうことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet mode 0 is not allowed. Packets marked with this mode are invalid and MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットモード0が許可されていません。このモードでマークされたパケットは無効であり、捨てなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The original initiator of a session MUST mark all non-startup packets it sends in that session with packet mode 1 (&#34;Initiator Mark&#34;). It SHOULD ignore any packet received in that session with packet mode 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの元のイニシエータは、それがパケットモード1（「イニシエータマーク」）と、そのセッションに送信するすべての非起動パケットをマークしなければなりません。これは、パケットモード1と、そのセッションで受信されたすべてのパケットを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The original responder of a session MUST mark all non-startup packets it sends in that session with packet mode 2 (&#34;Responder Mark&#34;). It SHOULD ignore any packet received in that session with packet mode 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの元レスポンダは、それがパケットモード2（「レスポンダマーク」）と、そのセッションに送信するすべての非起動パケットをマークしなければなりません。これは、パケットモード2と、そのセッションで受信されたすべてのパケットを無視する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet mode 3 is for session startup. Session startup chunks are only allowed in packets with this mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットモード3は、セッション起動のためです。セッション起動チャンクはこのモードだけを持つパケットで許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Chunks that are not for session startup are only allowed in packets with modes 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション起動のためではありませんチャンクはモード1または2のパケットに許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Chunks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. チャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   chunkType   |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |        chunkPayload (chunkLength bytes, may be zero)          |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct chunk_t
   {
       uint8_t  chunkType;
       uint16_t chunkLength;
       uint8_t  chunkPayload[chunkLength];
   } :variable*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkType: The chunk type code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkType：チャンクタイプコード。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkLength: The size, in bytes, of the chunk payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkLength：チャンクペイロードのバイト単位のサイズ、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkPayload: The type-specific payload of this chunk, chunkLength bytes in length (may be empty).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chunkPayload：このチャンクの型特異的ペイロード、chunkLengthは（空の場合もある）長さがバイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Defined chunk types are enumerated here in the order they might be encountered in the course of a typical session. The following chunk type codes are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定義のチャンクタイプは、彼らは典型的なセッションの過程で遭遇する可能性があるために、ここに列挙されています。以下のチャンクタイプコードが定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x7f: Packet Fragment (Section 2.3.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x7f：パケットフラグメント（2.3.1項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x30: Initiator Hello (Section 2.3.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x30から：イニシエータこんにちは（2.3​​.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0f: Forwarded Initiator Hello (Section 2.3.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0Fの：転送されたイニシエータこんにちは（2.3​​.3項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x70: Responder Hello (Section 2.3.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x70：レスポンダこんにちは（2.3​​.4項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x71: Responder Redirect (Section 2.3.5)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（0x71）を：レスポンダリダイレクト（2.3.5項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x79: RHello Cookie Change (Section 2.3.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x79：RHelloクッキーの変更（2.3.6項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x38: Initiator Initial Keying (Section 2.3.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x38：イニシエータ初期キーイング（2.3.7項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x78: Responder Initial Keying (Section 2.3.8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x78と：初期キーイングレスポンダ（第2.3.8項）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x01: Ping (Section 2.3.9)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x01の：Pingの（セクション2.3.9）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x41: Ping Reply (Section 2.3.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0×41：ping応答（セクション2.3.10）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x10: User Data (Section 2.3.11)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x10のユーザデータ（セクション2.3.11）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x11: Next User Data (Section 2.3.12)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x11を：次のユーザーデータ（セクション2.3.12）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x50: Data Acknowledgement Bitmap (Section 2.3.13)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x50を：データ確認応答ビットマップ（セクション2.3.13）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x51: Data Acknowledgement Ranges (Section 2.3.14)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x51：データ確認応答（セクション2.3.14）を範囲
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x18: Buffer Probe (Section 2.3.15)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x18の：バッファプローブ（セクション2.3.15）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x5e: Flow Exception Report (Section 2.3.16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x5Eの：フロー例外レポート（セクション2.3.16）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0c: Session Close Request (Section 2.3.17)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0Cの：セッションクローズリクエスト（セクション2.3.17）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x4c: Session Close Acknowledgement (Section 2.3.18)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x4c：セッションを閉じる確認応答（セクション2.3.18）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x00: Ignore/Padding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
$ 00：無視/パディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xff: Ignore/Padding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0xffの：無視/パディング
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver MUST ignore a chunk having an unrecognized chunk type code. A receiver MUST ignore a chunk appearing in a packet having a mode inappropriate to that chunk type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機は、認識されないチャンクタイプコードを有するチャンクを無視しなければなりません。受信機は、チャンクタイプに不適切なモードを有するパケットに現れるチャンクを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless specified otherwise, if a chunk has a syntax or processing error (for example, the chunk&#39;s payload field is not long enough to contain the specified syntax elements), the chunk SHALL be ignored as though it was not present in the packet, and parsing and processing SHALL commence with the next chunk in the packet, if any.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特に指定のない限りチャンクが構文または処理エラーがある場合、（例えば、チャンクのペイロードフィールドは、指定された構文要素を含むのに十分な長さではありません）、チャンクは、それがパケット中に存在していなかったかのように無視され、解析されるものとする（SHALL）もしあれば、処理は、パケット内の次のチャンクを開始しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. Packet Fragment Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.1. パケットのフラグメントチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is used to divide a plain RTMFP packet (Section 2.2.4) that is unavoidably larger than the path MTU (such as session startup packets containing Responder Hello (Section 2.3.4) or Initiator Initial Keying (Section 2.3.7) chunks with large certificates) into segments that do not exceed the path MTU, and to allow the segments to be sent through the network at a moderated rate to avoid jamming interfaces, links, or paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、パスMTU（例えば、レスポンダハローを含むセッション起動パケットとして（セクション2.3.4）または初期キーイング（セクション2.3.7）チャンクイニシエータより不可避的に大きくなっている無地RTMFPパケット（セクション2.2.4）に分割するために使用されていますパスMTUを超えない、およびセグメントがジャミングインターフェイス、リンク、または経路を避けるために、緩やかな速度でネットワークを介して送信できるようにセグメントに大きい証明書）を有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x7f     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-------------/-+-------------/-+
   |M|  reserved   |   packetID  \ | fragmentNum \ |
   +-+-+-+-+-+-+-+-+-------------/-+-------------/-+
   +---------------------------------------------------------------+
   |                         packetFragment                        |
   +---------------------------------------------------------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fragmentChunkPayload_t
   {
       bool_t  moreFragments :1; // M
       uintn_t reserved      :7;
       vlu_t   packetID      :variable*8;
       vlu_t   fragmentNum   :variable*8;
       uint8_t packetFragment[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
moreFragments: If set, the indicated packet comprises additional fragments. If clear, this fragment is the final fragment of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
moreFragments：設定した場合は、指示されたパケットは、追加の断片を含みます。明確な場合は、このフラグメントは、パケットの最後のフラグメントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
reserved: Reserved for future use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
予約：将来の使用のために予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packetID: VLU, the identifier of this segmented packet. All fragments of the same packet have the same packetID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packetID：VLU、このセグメント化されたパケットの識別子。同じパケットのすべてのフラグメントは、同じpacketIDを持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentNum: VLU, the index of this fragment of the indicated packet. The first fragment of the packet MUST be index 0. Fragments are numbered consecutively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentNum：VLU、指示されたパケットのこのフラグメントのインデックス。パケットの最初のフラグメントは、インデックス0断片は、連続的に番号付けされなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packetFragment: The bytes of the indicated segment of the indicated original plain RTMFP packet. A packetFragment MUST NOT be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
packetFragment：示されたオリジナル無地RTMFPパケットの指示セグメントのバイト。 packetFragmentは空にすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of this mechanism is detailed in Section 3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメカニズムの使用は3.4節で詳述されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. Initiator Hello Chunk (IHello)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.2. イニシエータこんにちはチャンク（IHello）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the initiator of a new session to begin the startup handshake. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、スタートアップハンドシェイクを開始するために、新しいセッションのイニシエータによって送信されます。このチャンクは唯一のデフォルトのセッションキーで暗号化され、セッションID 0のパケットで許可され、パケットモード3（スタートアップ）を有するています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x30     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  epdLength  \ |    endpointDiscriminator (epdLength bytes)    |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                              tag                              |
   +---------------------------------------------------------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct ihelloChunkPayload_t
   {
       vlu_t   epdLength :variable*8;
       uint8_t endpointDiscriminator[epdLength];
       uint8_t tag[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
epdLength: VLU, the length of the following endpointDiscriminator field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
epdLength：VLU、バイト単位で次endpointDiscriminatorフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpointDiscriminator: The Endpoint Discriminator for the identity with which the initiator wants to communicate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpointDiscriminator：イニシエータが通信したいとアイデンティティのためのエンドポイント識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tag: Initiator-provided data to be returned in a Responder Hello&#39;s tagEcho field. The tag/tagEcho is used to match Responder Hellos to the initiator&#39;s session startup state independent of the responder&#39;s address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タグ：イニシエータが提供するデータは、レスポンダこんにちはのtagEchoフィールドに返されます。タグ/ tagEchoは、応答者のアドレスの独立したイニシエータのセッション起動状態にレスポンダhelloを一致させるために使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of IHello is detailed in Section 3.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IHelloの使用は3.5.1項に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.3. Forwarded Initiator Hello Chunk (FIHello)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.3. 転送されたイニシエータこんにちはチャンク（FIHello）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent on behalf of an initiator by a Forwarder. It is only allowed in packets of an established session having packet mode 1 or 2. A receiver MAY treat this chunk as though it was an Initiator Hello received directly from replyAddress. Alternatively, if the receiver is selected by the Endpoint Discriminator, it MAY respond to replyAddress with an Implied Redirect (Section 2.3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクはフォワーダにより開始剤の代わりに送信されます。これは、唯一それがイニシエータこんにちはreplyAddressから直接受信したかのように、受信機がこのチャンクを扱うかもしれ1または2で確立されたセッションのパケットモードのパケットに許可されています。受信機は、エンドポイント識別子によって選択された場合あるいは、それは暗黙のリダイレクト（セクション2.3.5）とreplyAddressに応答することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x0f     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  epdLength  \ |    endpointDiscriminator (epdLength bytes)    |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                          replyAddress                         |
   +---------------------------------------------------------------/
   +---------------------------------------------------------------+
   |                              tag                              |
   +---------------------------------------------------------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct fihelloChunkPayload_t
   {
       vlu_t     epdLength :variable*8;
       uint8_t   endpointDiscriminator[epdLength];
       address_t replyAddress :variable*8;
       uint8_t   tag[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
epdLength: VLU, the length of the following endpointDiscriminator field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
epdLength：VLU、バイト単位で次endpointDiscriminatorフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpointDiscriminator: The Endpoint Discriminator for the identity with which the original initiator wants to communicate, copied from the original Initiator Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
endpointDiscriminator：元イニシエータが通信したいとアイデンティティのためのエンドポイント識別子、元イニシエータこんにちはからコピー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
replyAddress: Address format (Section 2.1.5), the address that the forwarding node derived from the received Initiator Hello, to which the receiver should respond.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
replyAddress：アドレス形式（セクション2.1.5）、受信されたイニシエータハロー由来する転送ノードは、受信機が応答しなければならないためにアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tag: Copied from the original Initiator Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タグ：元イニシエータからコピーこんにちは。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of FIHello is detailed in Section 3.5.1.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FIHelloの使用は、セクション3.5.1.5で詳述されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.4. Responder Hello Chunk (RHello)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.4. レスポンダこんにちはチャンク（RHello）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by a responder in response to an Initiator Hello or Forwarded Initiator Hello if the Endpoint Discriminator indicates the responder&#39;s identity. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイント識別子は、応答者のアイデンティティを示している場合、このチャンクは、イニシエータのHelloまたは転送イニシエータこんにちはに応じて、応答者によって送られます。このチャンクは唯一のデフォルトのセッションキーで暗号化され、セッションID 0のパケットで許可され、パケットモード3（スタートアップ）を有するています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x70     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  tagLength  \ |            tagEcho (tagLength bytes)          |
   +-------------/-+-----------------------------------------------/
   +-------------/-+-----------------------------------------------+
   | cookieLength\ |           cookie (cookieLength bytes)         |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                     responderCertificate                      |
   +---------------------------------------------------------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rhelloChunkPayload_t
   {
       vlu_t   tagLength :variable*8;
       uint8_t tagEcho[tagLength];
       vlu_t   cookieLength :variable*8;
       uint8_t cookie[cookieLength];
       uint8_t responderCertificate[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagLength: VLU, the length of the following tagEcho field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagLength：VLU、バイト単位で次tagEchoフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagEcho: The tag from the Initiator Hello, unaltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagEcho：変更されていないイニシエータこんにちはからタグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieLength: VLU, the length of the following cookie field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieLength：VLU、バイト単位で次のCookieフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookie: Responder-created state data to authenticate a future Initiator Initial Keying message (in order to prevent denial-of-service attacks).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クッキー：レスポンダが作成した状態データ（サービス拒否攻撃を防ぐために）将来のイニシエータ初期キーイングメッセージを認証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderCertificate: The responder&#39;s cryptographic credentials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderCertificate：応答の暗号資格情報。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: This specification doesn&#39;t mandate a specific choice of certificate format. The Cryptography Profile determines the syntax, algorithms, and interpretation of the responderCertificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：この仕様は、証明書フォーマットの特定の選択を強制しません。暗号化プロファイルは、構文、アルゴリズム、およびresponderCertificateの解釈を決定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of RHello is detailed in Section 3.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RHelloの使用は3.5.1項に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.5. Responder Redirect Chunk (Redirect)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.5. レスポンダリダイレクトチャンク（リダイレクト）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent in response to an Initiator Hello or Forwarded Initiator Hello to indicate that the requested endpoint can be reached at one or more of the indicated addresses. A receiver can add none, some, or all of the indicated addresses to the set of addresses to which it is sending Initiator Hello messages for the opening session associated with tagEcho. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、要求されたエンドポイントが示されたアドレスの一つ以上に達することができることを示すために、イニシエータこんにちはまたは転送イニシエータこんにちはに対応して送信されます。受信機は、追加することができなし、tagEchoに関連付けられた開口セッションのためのいくつかの、またはアドレスのセットに示されたアドレスの全ては、それが送信されたイニシエータHelloメッセージ。このチャンクは唯一のデフォルトのセッションキーで暗号化され、セッションID 0のパケットで許可され、パケットモード3（スタートアップ）を有するています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x71     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  tagLength  \ |            tagEcho (tagLength bytes)          |
   +-------------/-+-----------------------------------------------/
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                     redirectDestination 1                     |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
                                   :
                                   :
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                     redirectDestination N                     |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct responderRedirectChunkPayload_t
   {
       vlu_t   tagLength :variable*8;
       uint8_t tagEcho[tagLength];
       addressCount = 0;
       while(remainder() &gt; 0)
       {
           address_t redirectDestination :variable*8;
           addressCount++;
       }
       if(0 == addressCount)
           redirectDestination = packetSourceAddress();
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagLength: VLU, the length of the following tagEcho field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagLength：VLU、バイト単位で次tagEchoフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagEcho: The tag from the Initiator Hello, unaltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tagEcho：変更されていないイニシエータこんにちはからタグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
redirectDestination: (Zero or more) Address format (Section 2.1.5) addresses to add to the opening set for the indicated session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
redirectDestination：（ゼロ以上）アドレス形式（2.1.5）が示されたセッションに設定開口部に追加するアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this chunk lists zero redirectDestination addresses, then this is an Implied Redirect, and the indicated address is the address from which the packet containing this chunk was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクがゼロredirectDestinationアドレスを一覧表示している場合、これは暗黙のリダイレクトされ、示されたアドレスは、このチャンクを含むパケットを受信したアドレスです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Redirect is detailed in Sections 3.5.1.1.1, 3.5.1.1.2, and 3.5.1.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リダイレクトの使用はセクション3.5.1.1.1、3.5.1.1.2、および3.5.1.4に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.6. RHello Cookie Change Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.6.  RHelloクッキーの変更チャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk SHOULD be sent by a responder to an initiator in response to an Initiator Initial Keying if that chunk&#39;s cookie appears to have been created by the responder but the cookie is incorrect (for example, it includes a hash of the initiator&#39;s address, but the initiator&#39;s address is different than the one that elicited the Responder Hello containing the original cookie).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのチャンクのCookieが応答者によって作成されているように見えますが、クッキーが間違っている（例えば、それは、イニシエータのアドレスのハッシュが含まれていますが、この場合、チャンクは、イニシエータ初期キーイングに応じて、イニシエータとレスポンダーで送ってくださいイニシエータのアドレスは、オリジナルのクッキーを含むレスポンダこんにちは）を誘発したものとは異なっています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is only allowed in a packet encrypted with the Default Session Key and having packet mode 3, and with the session ID indicated in the initiatorSessionID field of the Initiator Initial Keying to which this is a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは唯一のデフォルトのセッションキーとパケットモード3、およびこれが応答であるためにイニシエータ初期キーイングのinitiatorSessionIDフィールドに示されたセッションIDとを持つ暗号化されたパケットに許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x79     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   | oldCookieLen\ |        oldCookie (oldCookieLen bytes)         |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                           newCookie                           |
   +---------------------------------------------------------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rhelloCookieChangeChunkPayload_t
   {
       vlu_t   oldCookieLen :variable*8;
       uint8_t oldCookie[oldCookieLen];
       uint8_t newCookie[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldCookieLen: VLU, the length of the following oldCookie field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldCookieLen：VLU、バイト単位で次oldCookieフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldCookie: The cookie that was sent in a previous Responder Hello and Initiator Initial Keying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oldCookie：前のレスポンダこんにちは、イニシエータ初期キーイングで送信されたクッキー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
newCookie: The new cookie that the responder would like sent (and signed) in a replacement Initiator Initial Keying. The old and new cookies need not have the same lengths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
newCookie：レスポンダが送信され（と署名）の交換イニシエータ初期キーイングに希望の新しいクッキー。古いものと新しいクッキーは、同じ長さを有している必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of this chunk, the initiator SHOULD compute, sign, and send a new Initiator Initial Keying having newCookie in place of oldCookie. The use of this chunk is detailed in Section 3.5.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクを受信すると、イニシエータは、計算に署名、およびoldCookieの代わりにnewCookieを有する新規イニシエータ初期キーイングを送るべきです。このチャンクの使用は、セクション3.5.1.2で詳述されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.7. Initiator Initial Keying Chunk (IIKeying)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.7. 初期キーイングチャンクを開始剤（IIKeying）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by an initiator to establish a session with a responder. The initiator MUST have obtained a valid cookie to use with the responder, typically by receiving a Responder Hello from it. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは応答者とのセッションを確立するために、イニシエータによって送信されます。開始剤は、典型的には、それから、レスポンダのHelloを受信することにより、応答で使用するための有効なクッキーを取得している必要があります。このチャンクは唯一のデフォルトのセッションキーで暗号化され、セッションID 0のパケットで許可され、パケットモード3（スタートアップ）を有するています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x38     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       initiatorSessionID                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   | cookieLength\ |                  cookieEcho                   |
   +-------------/-+-----------------------------------------------/
   +-------------/-+-----------------------------------------------+
   |  certLength \ |             initiatorCertificate              |
   +-------------/-+-----------------------------------------------/
   +-------------/-+-----------------------------------------------+
   |  skicLength \ |          sessionKeyInitiatorComponent         |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                           signature                           |
   +---------------------------------------------------------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct iikeyingChunkPayload_t
   {
       struct
       {
           uint32_t initiatorSessionID;
           vlu_t    cookieLength :variable*8;
           uint8_t  cookieEcho[cookieLength];
           vlu_t    certLength :variable*8;
           uint8_t  initiatorCertificate[certLength];
           vlu_t    skicLength :variable*8;
           uint8_t  sessionKeyInitiatorComponent[skicLength];
       } initiatorSignedParameters :variable*8;
       uint8_t signature[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorSessionID: The session ID to be used by the responder when sending packets to the initiator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorSessionID：イニシエータにパケットを送信するときにレスポンダが使用するセッションID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieLength: VLU, the length of the following cookieEcho field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieLength：VLU、バイト単位で次cookieEchoフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieEcho: The cookie from the Responder Hello, unaltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cookieEcho：変更されていないレスポンダこんにちはからクッキー、。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certLength: VLU, the length of the following initiatorCertificate field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certLength：VLU、バイト単位で次initiatorCertificateフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorCertificate: The initiator&#39;s identity credentials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorCertificate：イニシエータの身元の資格。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
skicLength: VLU, the length of the following sessionKeyInitiatorComponent field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
skicLength：VLU、バイト単位で次sessionKeyInitiatorComponentフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sessionKeyInitiatorComponent: The initiator&#39;s portion of the session key negotiation according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sessionKeyInitiatorComponent：暗号化プロファイルに応じてセッションキー交渉のイニシエータの一部。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorSignedParameters: The payload portion of this chunk up to the signature field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initiatorSignedParameters：署名フィールドに、このチャンクの最大のペイロード部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature: The initiator&#39;s digital signature of the initiatorSignedParameters according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名：暗号プロファイルに従ってinitiatorSignedParametersのイニシエータのデジタル署名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: This specification doesn&#39;t mandate a specific choice of cryptography. The Cryptography Profile determines the syntax, algorithms, and interpretation of the initiatorCertificate, responderCertificate, sessionKeyInitiatorComponent, sessionKeyResponderComponent, and signature, and how the sessionKeyInitiatorComponent and sessionKeyResponderComponent are combined to derive the session keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：この仕様は、暗号化の具体的な選択を強制しません。暗号プロフィールinitiatorCertificate、responderCertificate、sessionKeyInitiatorComponent、sessionKeyResponderComponent、および署名の構文、アルゴリズム、及び解釈を決定し、sessionKeyInitiatorComponentとsessionKeyResponderComponentはセッションキーを導出するために結合される方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of IIKeying is detailed in Section 3.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IIKeyingの使用は3.5.1項に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.8. Responder Initial Keying Chunk (RIKeying)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.8. レスポンダ初期キーイングチャンク（RIKeying）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by a responder in response to an Initiator Initial Keying as the final phase of session startup. This chunk is only allowed in a packet encrypted with the Default Session Key, having packet mode 3 (Startup), and sent to the initiator with the session ID specified by the initiatorSessionID field from the Initiator Initial Keying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクはセッション起動の最終段階として、イニシエータ初期キーイングに応じて、応答者によって送られます。このチャンクは唯一のパケットモード3（スタートアップ）を有する、デフォルトのセッション鍵で暗号化されたパケットで許可され、イニシエータ初期キーイングからinitiatorSessionIDフィールドで指定されたセッションIDのイニシエータに送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x78     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       responderSessionID                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-----------------------------------------------+
   |  skrcLength \ |         sessionKeyResponderComponent          |
   +-------------/-+-----------------------------------------------/
   +---------------------------------------------------------------+
   |                           signature                           |
   +---------------------------------------------------------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct rikeyingChunkPayload_t
   {
       struct
       {
           uint32_t responderSessionID;
           vlu_t    skrcLength :variable*8;
           uint8_t  sessionKeyResponderComponent[skrcLength];
       } responderSignedParametersPortion :variable*8;
       uint8_t  signature[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct
   {
       responderSignedParametersPortion;
       sessionKeyInitiatorComponent;
   } responderSignedParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSessionID: The session ID to be used by the initiator when sending packets to the responder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSessionID：レスポンダにパケットを送信するときに、セッションIDは、イニシエータによって使用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
skrcLength: VLU, the length of the following sessionKeyResponderComponent field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
skrcLength：VLU、バイト単位で次sessionKeyResponderComponentフィールドの長さ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sessionKeyResponderComponent: The responder&#39;s portion of the session key negotiation according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sessionKeyResponderComponent：暗号化プロファイルに応じてセッションキー交渉の応答者の一部。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSignedParametersPortion: The payload portion of this chunk up to the signature field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSignedParametersPortion：署名フィールドまでの、このチャンクのペイロード部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature: The responder&#39;s digital signature of the responderSignedParameters (see below) according to the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
署名：responderSignedParametersの応答者のデジタル署名暗号化プロファイルに従って（下記参照）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSignedParameters: The concatenation of the responderSignedParametersPortion (the payload portion of this chunk up to the signature field) and the sessionKeyInitiatorComponent from the Initiator Initial Keying to which this chunk is a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responderSignedParameters：このチャンクが応答されたイニシエータ初期キーイングからresponderSignedParametersPortion（署名フィールドに、このチャンク最大のペイロード部分）とsessionKeyInitiatorComponentの連結。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: This specification doesn&#39;t mandate a specific choice of cryptography. The Cryptography Profile determines the syntax, algorithms, and interpretation of the initiatorCertificate, responderCertificate, sessionKeyInitiatorComponent, sessionKeyResponderComponent, and signature, and how the sessionKeyInitiatorComponent and sessionKeyResponderComponent are combined to derive the session keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：この仕様は、暗号化の具体的な選択を強制しません。暗号プロフィールinitiatorCertificate、responderCertificate、sessionKeyInitiatorComponent、sessionKeyResponderComponent、および署名の構文、アルゴリズム、及び解釈を決定し、sessionKeyInitiatorComponentとsessionKeyResponderComponentはセッションキーを導出するために結合される方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the responder has computed the sessionKeyResponderComponent, it has all of the information and state necessary for an established session with the initiator. Once the responder has sent this chunk to the initiator, the session is established and ready to carry flows of user data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レスポンダがsessionKeyResponderComponentを計算した後、それは開始剤と確立されたセッションに必要な情報及び状態の全てを有しています。レスポンダはイニシエータにこのチャンクを送信した後は、セッションが確立され、ユーザデータの流れを伝送する準備ができています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the initiator receives, verifies, and processes this chunk, it has all of the information and state necessary for an established session with the responder. The session is established and ready to carry flows of user data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータは、受信を確認し、このチャンクを処理したら、レスポンダとの確立されたセッションに必要な情報及び状態の全てを有しています。セッションが確立され、ユーザデータの流れを伝送する準備ができています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of RIKeying is detailed in Section 3.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIKeyingの使用は3.5.1項に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.9. Ping Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.9.  pingのチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent in order to elicit a Ping Reply from the receiver. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは受信機からのping応答を惹起するために送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x01     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                             message                           |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct pingChunkPayload_t
   {
       uint8_t message[chunkLength];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message: The (potentially empty) message that is expected to be returned by the other end of the session in a Ping Reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージ：ping応答におけるセッションの他方の端部によって戻されると予想される（潜在的に空の）メッセージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver of this chunk SHOULD reply as immediately as is practical with a Ping Reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクの受信機は、ping応答を持つ実用的である限り、直ちに返信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping and the expected Ping Reply are typically used for session keepalive, endpoint address change verification, and path MTU discovery. See Section 3.5.4 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pingと予想されるping応答は、通常のセッションキープアライブ、エンドポイントアドレス変更の確認、およびパスMTUディスカバリのために使用されています。詳細については、3.5.4項を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.10. Ping Reply Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.10.  ping応答チャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent in response to a Ping chunk. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクはPingのチャンクに対応して送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x41     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                           messageEcho                         |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct pingReplyChunkPayload_t
   {
       uint8_t messageEcho[chunkLength];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
messageEcho: The message from the Ping to which this is a response, unaltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
messageEcho：これは変更されていない応答であり、これには、pingからのメッセージ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11. User Data Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11. ユーザーデータチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is the basic unit of transmission for the user messages of a flow. A user message comprises one or more fragments. Each fragment is carried in its own chunk and has a unique sequence number in its flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローのユーザメッセージのための伝送の基本単位です。ユーザのメッセージは、一つ以上の断片を含みます。各断片は、それ自身のチャンクに運ばれ、その流れに固有のシーケンス番号を有しています。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x10     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+
   |O|r| F | r |A|F|
   |P|s| R | s |B|I|
   |T|v| A | v |N|N|
   +-+-+-+-+-+-+-+-+
   +-------------/-+-------------/-+-------------/-+
   |   flowID    \ |     seq#    \ |  fsnOffset  \ |
   +-------------/-+-------------/-+-------------/-+
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+
   | L \ T \   V   |... options ...| L \ T \   V   |       0     \ |
   \~~~/~~~/~~~~~~~+   [if(OPT)]   +~~~/~~~/~~~~~~~+-------------/-/
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                            userData                           |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct userDataChunkPayload_t
   {
       bool_t  optionsPresent :1;  // &#34;OPT&#34;
       uintn_t reserved1 :1;       // &#34;rsv&#34;
       uintn_t fragmentControl :2; // &#34;FRA&#34;
           // 0=whole, 1=begin, 2=end, 3=middle
       uintn_t reserved2 :2;       // &#34;rsv&#34;
       bool_t  abandon :1;         // &#34;ABN&#34;
       bool_t  final :1;           // &#34;FIN&#34;
       vlu_t   flowID :variable*8;
       vlu_t   sequenceNumber :variable*8; // &#34;seq#&#34;
       vlu_t   fsnOffset :variable*8;
       forwardSequenceNumber = sequenceNumber - fsnOffset;
       if(optionsPresent)
           optionList_t options :variable*8;
       uint8_t userData[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
optionsPresent: If set, indicates the presence of an option list before the user data. If clear, there is no option list in this chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
optionsPresent：設定されている場合、ユーザデータの前にオプションのリストが存在することを示しています。明確な場合は、このチャンクにはオプションリストはありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentControl: Indicates how this fragment is assembled, potentially with others, into a complete user message. Possible values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragmentControl：ユーザーメッセージに、潜在的に他の人と、このフラグメントを組み立てる方法を示します。可能な値：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0: This fragment is a complete message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0：このフラグメントは、完全なメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1: This fragment is the first of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1：このフラグメントは、マルチ断片メッセージの最初のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2: This fragment is the last of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2：このフラグメントは、マルチ断片メッセージの最後です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3: This fragment is in the middle of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3：このフラグメントは、マルチ断片メッセージの真ん中にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A single-fragment user message has a fragment control of &#34;0-whole&#34;. When a message has more than one fragment, the first fragment has a fragment control of &#34;1-begin&#34;, then zero or more &#34;3-middle&#34; fragments, and finally a &#34;2-end&#34; fragment. The sequence numbers of a multi-fragment message MUST be contiguous.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
シングル断片ユーザ・メッセージが「0-全体」の断片の制御を有します。メッセージが複数の断片を有している場合、最初のフラグメントは、「1-開始」、ゼロまたはそれ以上の「3中間」断片、および最後に「2エンド」断片の断片の制御を有します。マルチ断片メッセージのシーケンス番号が連続していなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
abandon: If set, this sequence number has been abandoned by the sender. The userData, if any, MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
放棄：設定されている場合、このシーケンス番号は、送信者が放棄されています。 userDataは、もしあれば、無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
final: If set, this is the last sequence number of the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最終：設定されている場合、これは流れの最後のシーケンス番号です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequenceNumber: VLU, the sequence number of this fragment. Fragments are assigned contiguous increasing sequence numbers in a flow. The first sequence number of a flow SHOULD be 1. The first sequence number of a flow MUST be greater than zero. Sequence numbers are unbounded and do not wrap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequenceNumberが：VLU、この断片のシーケンス番号。フラグメントは、フロー内の連続増加するシーケンス番号が割り当てられています。フローの最初のシーケンス番号は、フローの最初のシーケンス番号がゼロより大きくなければならない1であるべきです。シーケンス番号は無制限であり、折り返されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsnOffset: VLU, the difference between the sequence number and the Forward Sequence Number. This field MUST NOT be zero if the abandon flag is not set. This field MUST NOT be greater than sequenceNumber.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fsnOffset：VLU、シーケンス番号とフォワードシーケンス番号の違い。放棄フラグが設定されていない場合、このフィールドはゼロであるはずがありません。このフィールドは、sequenceNumberがより大きくすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
forwardSequenceNumber: The flow sender will not send (or resend) any fragment with a sequence number less than or equal to the Forward Sequence Number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
forwardSequenceNumber：フローの送信者は、以下転送シーケンス番号に等しいシーケンス番号を有する任意の断片を送信（または再送信）しないであろう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
options: If the optionsPresent flag is set, a list of zero or more Options terminated by a Marker is present. See Section 2.3.11.1 for defined options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オプション：optionsPresentフラグが設定されている場合は、マーカーで終了し、ゼロ以上のオプションのリストが存在しています。定義されたオプションについては、セクション2.3.11.1を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
userData: The actual user data for this fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
userData：このフラグメントのための実際のユーザデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of User Data is detailed in Section 3.6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータの使用は3.6.2項に詳述されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1. Options for User Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1。ユーザーデータのためのオプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section lists options that may appear in User Data option lists. A conforming implementation MUST support the options in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、ユーザーデータのオプションリストに表示される場合がありますオプションを示します。準拠した実装では、このセクションのオプションをサポートしなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow receiver MUST reject a flow containing a flow option that is not understood if the option type is less than 8192 (0x2000). A flow receiver MUST ignore any flow option that is not understood if the option type is 8192 or greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、オプションタイプ未満8192（0x2000で）である場合には理解されていないフローオプションを含む流れを拒絶しなければなりません。フロー受信機は、オプションタイプが8192以上である場合には理解されていない任意のフローオプションを無視しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following option type codes are defined for User Data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のオプション・タイプ・コードは、ユーザデータのために定義されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x00: User&#39;s Per-Flow Metadata (Section 2.3.11.1.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
$ 00：ユーザーズ・フロー単位のメタデータ（セクション2.3.11.1.1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0a: Return Flow Association (Section 2.3.11.1.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0x0Aを：リターンフロー協会（セクション2.3.11.1.2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1.1. User&#39;s Per-Flow Metadata
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1.1。ユーザーごとのフローのメタデータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This option conveys the user&#39;s per-flow metadata for the flow to which it&#39;s attached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このオプションは、それが取り付けられていますする流れのためのユーザーのフローごとのメタデータを伝えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |   length    \ |     0x00    \ |         userMetadata          |
   +-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct userMetadataOptionValue_t
   {
       uint8_t userMetadata[remainder()];
   } :remainder()*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user associates application-defined metadata with each flow. The metadata does not change over the life of the flow. Every flow MUST have metadata. A flow sender MUST send this option with the first User Data chunk for this flow in each packet until an acknowledgement for this flow is received. A flow sender SHOULD NOT send this option more than once for each flow in any one packet. A flow sender SHOULD NOT send this option for a flow once the flow has been acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザは、各フローにアプリケーション定義のメタデータを関連付けます。メタデータは、フローの期間にわたって変更されません。すべてのフローは、メタデータを持っていなければなりません。このフローの確認応答を受信するまでのフローの送信者は、各パケット内のこのフローの最初のユーザデータのチャンクでは、このオプションを送らなければなりません。フローの送信者は、いずれかのパケット内の各フローのためにこのオプションを複数回送信することはできません。流れが確認された後、フローの送信者は、フローのために、このオプションを送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification doesn&#39;t mandate the encoding, syntax, or interpretation of the user&#39;s per-flow metadata; this is determined by the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この仕様は、ユーザーのフローごとのメタデータのエンコーディング、構文、または解釈を強制しません。これは、アプリケーションによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The userMetadata SHOULD NOT exceed 512 bytes. The userMetadata MAY be 0 bytes in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
userMetadataは512バイトを超えないようにしてください。 userMetadataは、長さが0バイトになる場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1.2. Return Flow Association
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.11.1.2。リターンフロー協会
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A new flow can be considered to be in return (or response) to a flow sent by the other endpoint. This option encodes the receive flow identifier to which this new sending flow is a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいフローは、他のエンドポイントによって送信されたフローにリターン（または応答）であると考えることができます。このオプションでは、この新しい送信フローが応答されている受信フロー識別子を符号化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   +-------------/-+-------------/-+-------------/-+
   |   length    \ |     0x0a    \ |    flowID   \ |
   +-------------/-+-------------/-+-------------/-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct returnFlowAssociationOptionValue_t
   {
       vlu_t flowID :variable*8;
   } :variable*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider endpoints A and B. Endpoint A begins a flow with identifier 5 to endpoint B. A is the flow sender for A&#39;s flowID=5, and B is the flow receiver for A&#39;s flowID=5. B begins a return flow with identifier 7 to A in response to A&#39;s flowID=5. B is the flow sender for B&#39;s flowID=7, and A is the flow receiver for B&#39;s flowID=7. B sends this option with flowID set to 5 to indicate that B&#39;s flowID=7 is in response to and associated with A&#39;s flowID=5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントAを考えるとBエンドポイントAは、B、AがAのフローID = 5のためのフロー送信元であるエンドポイントに識別子5と流れを開始し、BはAのフローID = 5のためのフローの受信機です。 Bは、AのフローID = 5に対応してAに識別子7とリターン・フローを開始します。 Bは、BのフローID = 7のフローの送信者であり、そしてAは、BのフローID = 7のためのフローの受信機です。 Bは、BのフローID = 7に対応しており、= 5 AのフローIDに関連付けられていることを示すために、5に設定フローIDと、このオプションを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is a return association, the flow sender MUST send this option with the first User Data chunk for this flow in each packet until an acknowledgement for this flow is received. A flow sender SHOULD NOT send this option more than once for each flow in any one packet. A flow sender SHOULD NOT send this option for a flow once the flow has been acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リターン・アソシエーションが存在する場合、この流れのための肯定応答が受信されるまで、フローの送信者は、各パケット内のこのフローの最初のユーザデータのチャンクでは、このオプションを送らなければなりません。フローの送信者は、いずれかのパケット内の各フローのためにこのオプションを複数回送信することはできません。流れが確認された後、フローの送信者は、フローのために、このオプションを送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow MUST NOT indicate more than one return association.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、複数の戻り値の関連性を示してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow MUST indicate its return association, if any, upon its first transmission of a User Data chunk. A return association can&#39;t be added to a sending flow after it begins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、ユーザデータチャンクの最初の送信時に、もしあれば、その戻り関連を示さなければなりません。それは開始後リターンの関連付けは、送信フローに追加することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow receiver MUST reject a new receiving flow having a return flow association that does not indicate an F_OPEN sending flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機はF_OPEN送信フローを示していないリターン・フロー・アソシエーションを有する新たな受信フローを拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.12. Next User Data Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.12. 次のユーザデータチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is equivalent to the User Data chunk for purposes of sending the user messages of a flow. When used, it MUST follow a User Data chunk or another Next User Data chunk in the same packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローのユーザメッセージを送信する目的のためにユーザーデータチャンクに相当します。使用した場合、それは同じパケット内のユーザデータチャンクまたは他の次のユーザーデータのチャンクに従わなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x11     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-+-+-+-+-+-+-+-+
   |O|r| F | r |A|F|
   |P|s| R | s |B|I|
   |T|v| A | v |N|N|
   +-+-+-+-+-+-+-+-+
   +~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+
   | L \ T \   V   |... options ...| L \ T \   V   |       0     \ |
   \~~~/~~~/~~~~~~~+   [if(OPT)]   +~~~/~~~/~~~~~~~+-------------/-/
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
   |                            userData                           |
   +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct nextUserDataChunkPayload_t
   {
       bool_t  optionsPresent :1;  // &#34;OPT&#34;
       uintn_t reserved1 :1;       // &#34;rsv&#34;
       uintn_t fragmentControl :2; // &#34;FRA&#34;
           // 0=whole, 1=begin, 2=end, 3=middle
       uintn_t reserved2 :2;       // &#34;rsv&#34;
       bool_t  abandon :1;         // &#34;ABN&#34;
       bool_t  final :1;           // &#34;FIN&#34;
       if(optionsPresent)
           optionList_t options :variable*8;
       uint8_t userData[remainder()];
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is considered to be for the same flowID as the most recently preceding User Data or Next User Data chunk in the same packet, having the same Forward Sequence Number, and having the next sequence number. The optionsPresent, fragmentControl, abandon, and final flags, and the options (if present), have the same interpretation as for the User Data chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最近同じ転送シーケンス番号を有し、次のシーケンス番号を有する同じパケット内のユーザデータまたは次のユーザデータチャンクに先行するように、このチャンクは同一のフローIDのためであると考えられます。 optionsPresent、fragmentControl、放棄、および最終フラグ、およびオプション（存在する場合）は、ユーザデータのチャンクと同じ解釈を持っています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
               ...
               ----------+------------------------------------
               10 00 07  | User Data chunk, length=7
               00        | OPT=0, FRA=0 &#34;whole&#34;, ABN=0, FIN=0
               02 05 03  | flowID=2, seq#=5, fsn=(5-3)=2
               00 01 02  | data 3 bytes: 00, 01, 02
               ----------+------------------------------------
               11 00 04  | Next User Data chunk,length=4
               00        | OPT=0, FRA=0 &#34;whole&#34;, ABN=0, FIN=0
                         | flowID=2, seq#=6, fsn=2
               03 04 05  | data 3 bytes: 03, 04, 05
               ----------+------------------------------------
               11 00 04  | Next User Data chunk, length=4
               00        | OPT=0, FRA=0 &#34;whole&#34;, ABN=0, FIN=0
                         | flowID=2, seq#=7, fsn=2
               06 07 08  | data 3 bytes: 06, 07, 08
               ----------+------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Figure 3: Sequential Messages in One Packet Using Next User Data
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
図3：次のユーザーデータを使用して一つのパケットでシーケンシャルのメッセージ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Next User Data is detailed in Section 3.6.2.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のユーザーデータの使用は、セクション3.6.2.3.2で詳細です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.13. Data Acknowledgement Bitmap Chunk (Bitmap Ack)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.13. データ確認応答ビットマップチャンク（ビットマップACK）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the flow receiver to indicate to the flow sender the User Data fragment sequence numbers that have been received for one flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フロー送信者に一つのフローのために受信されているユーザーデータの断片配列番号を示すために、フロー受信機によって送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver can choose to acknowledge User Data with this chunk or with a Range Ack. It SHOULD choose whichever format has the most compact encoding of the sequence numbers received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、このチャンク、あるいは範囲ACKでユーザーデータを確認することを選択できます。これは、受信したシーケンス番号の最もコンパクトなエンコーディングを持っている方のフォーマットを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x50     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-------------/-+-------------/-+
   |   flowID    \ |   bufAvail  \ |    cumAck   \ |
   +-------------/-+-------------/-+-------------/-+
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
   |C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|
   |+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|
   |9|8|7|6|5|4|3|2|1|1|1|1|1|1|1|1|2|2|2|2|2|2|1|1| ....
   | | | | | | | | |7|6|5|4|3|2|1|0|5|4|3|2|1|0|9|8|
   +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dataAckBitmapChunkPayload_t
   {
       vlu_t flowID :variable*8;
       vlu_t bufferBlocksAvailable :variable*8; // &#34;bufAvail&#34;
       vlu_t cumulativeAck :variable*8; // &#34;cumAck&#34;
       bufferBytesAvailable = bufferBlocksAvailable * 1024;
       acknowledge(0 through cumulativeAck);
       ackCursor = cumulativeAck + 1;
       while(remainder() &gt; 0)
       {
           for(bitPosition = 8; bitPosition &gt; 0; bitPosition--)
           {
               bool_t bit :1;
               if(bit)
                   acknowledge(ackCursor + bitPosition);
           }
           ackCursor += 8;
       }
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bufferBlocksAvailable: VLU, the number of 1024-byte blocks of User Data that the receiver is currently able to accept. Section 3.6.3.5 describes how to calculate this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bufferBlocksAvailable：VLU、受信機は現在、受け入れることができるユーザーデータの1024バイトのブロックの数。セクション3.6.3.5は、この値を計算する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cumulativeAck: VLU, the acknowledgement of every fragment sequence number in this flow that is less than or equal to this value. This MUST NOT be less than the highest Forward Sequence Number received in this flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cumulativeAck：VLU、この値以下であり、このフローのすべてのフラグメントシーケンス番号の確認応答。これは、この流れで受信し、最高順方向シーケンス番号以上でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bit field: A sequence of zero or more bytes representing a bit field of received fragment sequence numbers after the cumulative acknowledgement, least significant bit first. A set bit indicates receipt of a sequence number. A clear bit indicates that sequence number was not received. The least significant bit of the first byte is the second sequence number following the cumulative acknowledgement, the next bit is the third sequence number following, and so on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ビットフィールド：最初の累積確認応答の後、最下位ビットを受信したフラグメントのシーケンス番号のビット・フィールドを表すゼロ以上のバイトのシーケンス。設定されたビットは、シーケンス番号の受信を示しています。クリアビットは、シーケンス番号が受信されなかったことを示しています。最初のバイトの最下位ビットは、累積確認応答を、以下の第二シーケンス番号は、次のビットがそうで次の第3のシーケンス番号であり、です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 4 shows an example Bitmap Ack indicating acknowledgement of fragment sequence numbers 0 through 16, 18, 21 through 24, 27, and 28.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図4は、16、18、21〜24、27、及び28を介してフラグメントシーケンス番号0の肯定応答を示す実施例ビットマップACKを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
50 00 05 | Bitmap Ack, length=5 bytes 05 7f 10 | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16 79 06 | 01111001 00000110 = 18, 21, 22, 23, 24, 27, 28
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
50 00 05 |ビットマップACK、長さ= 5バイト05 7F 10 |フローID = 5、bufAvail = 127 * 1024バイト、cumAck = 0..16 79 06 | 01111001 00000110 = 18、21、22、23、24、27、28
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
Figure 4: Example Bitmap Ack
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-23">
図4：例ビットマップのAck
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.14. Data Acknowledgement Ranges Chunk (Range Ack)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.14. データ確認応答がチャンクを範囲（レンジのAck）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the flow receiver to indicate to the flow sender the User Data fragment sequence numbers that have been received for one flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フロー送信者に一つのフローのために受信されているユーザーデータの断片配列番号を示すために、フロー受信機によって送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver can choose to acknowledge User Data with this chunk or with a Bitmap Ack. It SHOULD choose whichever format has the most compact encoding of the sequence numbers received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、このチャンクまたはビットマップACKでユーザーデータを確認することを選択できます。これは、受信したシーケンス番号の最もコンパクトなエンコーディングを持っている方のフォーマットを選択する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x51     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-------------/-+-------------/-+
   |   flowID    \ |   bufAvail  \ |    cumAck   \ |
   +-------------/-+-------------/-+-------------/-+
   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+
   |   #holes-1  \ |   #recv-1   \ |
   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+
                   :
                   :
   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+
   |   #holes-1  \ |   #recv-1   \ |
   +~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct dataAckRangesChunkPayload_t
   {
       vlu_t flowID :variable*8;
       vlu_t bufferBlocksAvailable :variable*8; // &#34;bufAvail&#34;
       vlu_t cumulativeAck :variable*8; // &#34;cumAck&#34;
       bufferBytesAvailable = bufferBlocksAvailable * 1024;
       acknowledge(0 through cumulativeAck);
       ackCursor = cumulativeAck;
       while(remainder() &gt; 0)
       {
           vlu_t holesMinusOne :variable*8; // &#34;#holes-1&#34;
           vlu_t receivedMinusOne :variable*8; // &#34;#recv-1&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           ackCursor++;
           rangeFrom = ackCursor + holesMinusOne + 1;
           rangeTo = rangeFrom + receivedMinusOne;
           acknowledge(rangeFrom through rangeTo);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
           ackCursor = rangeTo;
       }
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bufferBlocksAvailable: VLU, the number of 1024-byte blocks of User Data that the receiver is currently able to accept. Section 3.6.3.5 describes how to calculate this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bufferBlocksAvailable：VLU、受信機は現在、受け入れることができるユーザーデータの1024バイトのブロックの数。セクション3.6.3.5は、この値を計算する方法について説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cumulativeAck: VLU, the acknowledgement of every fragment sequence number in this flow that is less than or equal to this value. This MUST NOT be less than the highest Forward Sequence Number received in this flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cumulativeAck：VLU、この値以下であり、このフローのすべてのフラグメントシーケンス番号の確認応答。これは、この流れで受信し、最高順方向シーケンス番号以上でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
holesMinusOne / receivedMinusOne: Zero or more acknowledgement ranges, run-length encoded. Runs are encoded as zero or more pairs of VLUs indicating the number (minus one) of missing sequence numbers followed by the number (minus one) of received sequence numbers, starting at the cumulative acknowledgement. NOTE: If a parser syntax error is encountered here (that is, if the chunk is truncated such that not enough bytes remain to completely encode both VLUs of the acknowledgement range), then treat and process this chunk as though it was properly formed up to the last completely encoded range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
holesMinusOne / receivedMinusOne：ゼロ以上の承認範囲は、ランレングス符号化さ。実験は、累積確認応答から始まる、受信されたシーケンス番号の数（マイナス1）、続いて欠落したシーケンス番号の数（マイナス1）を示すのVLUのゼロまたはそれ以上の対として符号化されます。注：パーサ構文エラーが（チャンクが十分でないバイトが完全に受信確認の範囲の両方のVLUをエンコードするために残るよう切り捨てられた場合には、ある）、ここで検出された場合、それが適切にまで形成されたかのように、このチャンクを処理し、処理最後に、完全にエンコードされた範囲。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 5 shows an example Range Ack indicating acknowledgement of fragment sequence numbers 0 through 16, 18, 21, 22, 23, and 24.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図5は、16、18、21、22、23、及び24を介してフラグメントシーケンス番号0の肯定応答を示す実施例の範囲ACKを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
51 00 07 | Range Ack, length=7 05 7f 10 | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16 00 00 | holes=1, received=1 -- missing 17, received 18 01 03 | holes=2, received=4 -- missing 19..20, received 21..24
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
51 00 07 |レンジのAck、長= 7 05 7F 10 |フローID = 5、bufAvail = 127 * 1024バイト、cumAck = 0..16 00 00 |穴= 1、= 1受信 - 、17の欠落が受信18 01 03 | 、19..20が欠落21..24を受信 -  = 2穴は、= 4を受け
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure 5: Example Range Ack
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
図5：例範囲のAck
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 6 shows an example Range Ack indicating acknowledgement of fragment sequence numbers 0 through 16 and 18, with a truncated last range. Note that the truncation and parse error does not abort the entire chunk in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図6は、切り捨て最後範囲で、16および18を介してフラグメントシーケンス番号0の肯定応答を示す実施例の範囲ACKを示しています。切り捨てとパースエラーが、この場合、全体のチャンクを中止しないことに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
51 00 07 | Range Ack, length=9 05 7f 10 | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16 00 00 | holes=1, received=1 -- missing 17, received 18 01 83 | holes=2, received=VLU parse error, ignore this range
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
51 00 07 |レンジのAck、長= 9 05 7F 10 |フローID = 5、bufAvail = 127 * 1024バイト、cumAck = 0..16 00 00 |ホール= 1、= 1受信 - 、17欠落が受け取ら18 01 83 | = 2穴は、この範囲を無視して、= VLUの解析エラーを受信しました
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 6: Example Truncated Range Ack
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図6：例切り捨て範囲のAck
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.15. Buffer Probe Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.15. バッファプローブチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the flow sender in order to request the current available receive buffer (in the form of a Data Acknowledgement) for a flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、フローのため（データ確認応答の形で）現在利用可能な受信バッファを要求するためにフロー送信者によって送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x18     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+
   |   flowID    \ |
   +-------------/-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct bufferProbeChunkPayload_t
   {
       vlu_t flowID :variable*8;
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver of this chunk SHOULD reply as immediately as is practical with a Data Acknowledgement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクの受信機は、データ受信確認と実用的である限り、直ちに返信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.16. Flow Exception Report Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.16. フロー例外レポートチャンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent by the flow receiver to indicate that it is not (or is no longer) interested in the flow and would like the flow sender to close the flow. This chunk SHOULD precede every Data Acknowledgement chunk for the same flow in this condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクはそれがない（または、もはやありません）の流れに興味や流れを閉じるには、フローの送信者を希望することを示すために、フロー受信機によって送信されます。このチャンクは、この状態で同一のフローごとのデータ謝辞塊に先行すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is only allowed in a packet belonging to an established session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクはパケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x5e     |          chunkLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   +-------------/-+-------------/-+
   |   flowID    \ |  exception  \ |
   +-------------/-+-------------/-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   struct flowExceptionReportChunkPayload_t
   {
       vlu_t flowID :variable*8;
       vlu_t exception :variable*8;
   } :chunkLength*8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flowID: VLU, the flow identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローID：VLU、フロー識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exception: VLU, the application-defined exception code being reported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例外：VLU、アプリケーション定義の例外コードが報告されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving RTMFP might reject a flow automatically, for example if it is missing metadata, or if an invalid return association is specified. In circumstances where an RTMFP rejects a flow automatically, the exception code MUST be 0. The application can specify any exception code, including 0, when rejecting a flow. All non-zero exception codes are reserved for the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信RTMFPは、メタデータが不足している場合など、自動的に流れを拒否、または無効なリターン協会が指定されている場合があります。アプリケーションフローを拒否するとき、0を含む任意の例外コードを指定することができ0 RTMFPが自動的にフローを拒否状況では、例外コードでなければなりません。すべてのゼロ以外の例外コードがアプリケーション用に予約されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.17. Session Close Request Chunk (Close)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.17. セッションクローズリクエストチャンク（閉じます）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent to cleanly terminate a session. It is only allowed in a packet belonging to an established or closing session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクはきれいにセッションを終了するために送信されます。これは、パケットのみ確立または閉じたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x0c     |               0               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk has no payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは何のペイロードを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Close is detailed in Section 3.5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
閉じるの使用は、セクション3.5.5で詳述されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.18. Session Close Acknowledgement Chunk (Close Ack)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3.18. セッションを閉じる謝辞チャンク（クローズACK）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk is sent in response to a Session Close Request to indicate that the sender has terminated the session. It is only allowed in a packet belonging to an established or closing session and having packet mode 1 or 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは、送信者がセッションを終了したことを示すためにセッションを閉じる要求に応答して送信されます。これは、パケットのみ確立または閉じたセッションに属するパケットモード1または2を有することを許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      0x4c     |               0               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This chunk has no payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このチャンクは何のペイロードを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of Close Ack is detailed in Section 3.5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
閉じるのAckの使用は、セクション3.5.5で詳述されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
              +--------+                             +--------+
              | Peer A |        S E S S I O N        | Peer B |
              |        /=============================\        |
              |       ||            Flows            ||       |
              |       ||----------------------------&gt;||       |
              |       ||----------------------------&gt;||       |
              |       ||&lt;----------------------------||       |
              |       ||&lt;----------------------------||       |
              |       ||&lt;----------------------------||       |
              |        \=============================/        |
              |        |                             |        |
              |        |                             +--------+
              |        |
              |        |                             +--------+
              |        |        S E S S I O N        | Peer C |
              |        /=============================\        |
              |       ||            Flows            ||       |
              |       ||----------------------------&gt;||       |
              |       ||&lt;----------------------------||       |
              |       ||&lt;----------------------------||       |
              |        \=============================/        |
              |        |                             |        |
              +--------+                             +--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Figure 7: Sessions between Pairs of Communicating Endpoints
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
図7：通信エンドポイントのペア間のセッション
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Between any pair of communicating endpoints is a single, bidirectional, secured, congestion controlled session. Unidirectional flows convey messages from one end to the other within the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信エンドポイントの任意のペア間の単一の、双方向、固定、輻輳制御セッションです。単方向フローは、セッション内の他の端から端までのメッセージを伝えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint initiates a session to a far end when communication is desired. An initiator begins with one or more candidate destination socket addresses, and it may learn and try more candidate addresses during startup handshaking. Eventually, a first suitable response is received, and that endpoint is selected. Startup proceeds to the selected endpoint. In the case of session startup glare, one endpoint is the prevailing initiator and the other assumes the role of responder. Encryption keys and session identifiers are negotiated between the endpoints, and the session is established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通信が望まれるとき、エンドポイントは、遠端にセッションを開始します。イニシエータは、一の以上の候補先のソケットアドレスで始まり、それが起動ハンドシェーク中に複数の候補アドレスを学習してみてください。最終的には、まず適切な応答が受信され、そのエンドポイントが選択されます。スタートアップは、選択したエンドポイントに移行します。セッション起動グレアの場合、一方のエンドポイントがprevailingイニシエータであり、他方がレスポンダの役割を想定しています。暗号化鍵とセッション識別子は、エンドポイント間でネゴシエートされ、セッションが確立されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each endpoint may begin sending message flows to the other end. For each flow, the far end may accept it and deliver its messages to the user, or it may reject the flow and transmit an exception to the sender. The flow receiver may close and reject a flow at a later time, after first accepting it. The flow receiver acknowledges all data sent to it, regardless of whether the flow was accepted. Acknowledgements drive a congestion control mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージの送信を開始することができる各エンドポイントは、他方の端部へと流れます。各フローについて、遠端はそれを受け入れることができ、ユーザにそのメッセージを配信、またはそれが流れを拒否し、送信者に例外を送信してもよいです。フロー受信機は、最初にそれを受け入れた後、後で流れを閉じ、拒否することができます。フロー受信機は、フローが受け入れられたかどうかに関係なく、それに送られたすべてのデータを肯定応答します。謝辞は、輻輳制御機構を駆動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint may have concurrent sessions with other far endpoints. The multiple sessions are distinguished by a session identifier rather than by socket address. This allows an endpoint&#39;s address to change mid-session without having to tear down and re-establish a session. The existing cryptographic state for a session can be used to verify a change of address while protecting against session hijacking or denial of service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、他のこれまでのエンドポイントとの同時セッションを有することができます。複数のセッションは、セッション識別子ではなく、ソケットアドレスで区別されています。これは、エンドポイントのアドレスを取り壊すとのセッションを再確立することなく、半ばセッションを変更することができます。セッションの既存の暗号化状態は、セッションハイジャック又はサービスの拒否から保護しながら、アドレスの変更を確認するために使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender may indicate to a receiver that some user messages are of a time critical or real-time nature. A receiver may indicate to senders on concurrent sessions that it is receiving time critical messages from another endpoint. The other senders SHOULD modify their congestion control parameters to yield capacity to the session carrying time critical messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、一部のユーザーのメッセージがタイムクリティカルまたはリアルタイムの性質のものであることを受信機に示すことができます。受信機は、それが別のエンドポイントからの時間重要なメッセージを受信して​​いる同時セッションの送信者に示すことができます。他の送信者は、タイムクリティカルなメッセージを運ぶセッションに容量を得るために彼らの輻輳制御パラメータを変更する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender may close a flow. The flow is completed when the receiver has no outstanding gaps before the final fragment of the flow. The sender and receiver reserve a completed flow&#39;s identifier for a time to allow in-flight messages to drain from the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、流れを閉じることができます。受信機は、フローの最後の断片の前に未処理のギャップを持っていない場合、フローは終了します。送信者と受信者は、飛行中のメッセージがネットワークから排出させるための時間で完了フローの識別子を予約します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eventually, neither end will have any flows open to the other. The session will be idle and quiescent. Either end may reliably close the session to recover its resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
結局、どちらの終わりには、他に開いているすべてのフローを持つことになります。セッションがアイドル状態と休止状態になります。どちらの終わりには、確実にそのリソースを回復するために、セッションを閉じることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In certain circumstances, an endpoint may be ceasing operation and not have time to wait for acknowledgement of a reliable session close. In this case, the halting endpoint may send an abrupt session close to advise the far end that it is halting immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定の状況では、エンドポイントは、運転を停止し、信頼性の高いセッションクローズの確認応答を待機する時間を持っていなくても良いです。この場合、停止エンドポイントは、それが即座に停止される遠端に助言するために近くに突然のセッションを送信することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Endpoint Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. エンドポイントのアイデンティティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each RTMFP endpoint has an identity. The identity is encoded in a certificate. This specification doesn&#39;t mandate any particular certificate format, cryptographic algorithms, or cryptographic properties for certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各RTMFPエンドポイントは、同一性を有します。アイデンティティは、証明書にエンコードされています。この仕様は、証明書のいずれかの特定の証明書形式、暗号化アルゴリズム、または暗号化プロパティを強制しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint is named by an Endpoint Discriminator. This specification doesn&#39;t mandate any particular format for Endpoint Discriminators.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、エンドポイント識別子によって命名されます。この仕様は、エンドポイントディスクリミネータのための特定のフォーマットを規定していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Endpoint Discriminator MAY select more than one identity and MAY match more than one distinct certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイント識別子は、複数のIDを選択することと、複数の異なる証明書を一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple distinct Endpoint Discriminators MAY match one certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数の異なるエンドポイントディスクリミネータは、1証明書を一致させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that multiple endpoints not have the same identity. Entities with the same identity are indistinguishable during session startup; this situation could be undesirable in some applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のエンドポイントが同じIDを持っていないことが推奨されます。同じIDを持つエンティティは、セッションの起動時に見分けがつきません。このような状況は、いくつかの用途では望ましくない可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint MAY have more than one address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、複数のアドレスを持っているかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Cryptography Profile implements the following functions for identities, certificates, and Endpoint Discriminators, whose operation MUST be deterministic:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号化プロファイルは、操作決定論的でなければならないのアイデンティティ、証明書、およびエンドポイントディスクリミネータ、について以下の機能を実装しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Test whether a given certificate is authentic. Authenticity can comprise verifying an issuer signature chain in a public key infrastructure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O指定された証明書が本物であるかどうかをテストします。真正性は、公開鍵インフラストラクチャに発行者の署名チェーンを検証することを含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Test whether a given Endpoint Discriminator selects a given certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所与のエンドポイント識別子が指定された証明書を選択するかどうかをテストし、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Test whether a given Endpoint Discriminator selects the local endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所与のエンドポイント識別子は、ローカルエンドポイントを選択するかどうかをテストし、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Generate a Canonical Endpoint Discriminator for a given certificate. Canonical Endpoint Discriminators for distinct identities SHOULD be distinct. If two distinct identities have the same Canonical Endpoint Discriminator, an initiator might abort a new opening session to the second identity (Section 3.5.1.1.1); this behavior might not be desirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O指定された証明書のための正規エンドポイント識別子を生成します。明確なアイデンティティのための正規のエンドポイントディスクリミネータは明瞭であるべきです。二つの異なるアイデンティティが同じ正規エンドポイント識別子を使用している場合、イニシエータは、第二のアイデンティティ（セクション3.5.1.1.1）への新しいオープニングセッションを中止するかもしれません。この動作は望ましくない場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Given a certificate, a message, and a digital signature over the message, test whether the signature is valid and generated by the owner of the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O証明書、メッセージ、およびメッセージ上のデジタル署名を考えると、署名が有効と証明書の所有者によって生成されるかどうかをテストします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Generate a digital signature for a given message corresponding to the near identity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O周辺のアイデンティティに対応する与えられたメッセージのデジタル署名を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Given the near identity and a far certificate, determine which one shall prevail as Initiator and which shall assume the Responder role in the case of startup glare. The far end MUST arrive at the same conclusion. A comparison function can comprise performing a lexicographic ordering of the binary certificates, declaring the far identity the prevailing endpoint if the far certificate is ordered before the near certificate, and otherwise declaring the near identity to be the prevailing endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O近くのアイデンティティと遠く証明書を考えると、1がイニシエータとして優先するものとされ、起動グレアの場合、レスポンダの役割を負うかを決定します。遠端は同じ結論に到着しなければなりません。比較関数は、はるかに証明書が近い証明書の前に注文された場合にこれまでのアイデンティティに有力なエンドポイントを宣言し、それ以外の場合は現行のエンドポイントであることを近くのアイデンティティを宣言し、バイナリ証明書の辞書式順序付けを行うことを含むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Given a first certificate and a second certificate, test whether a new incoming session from the second shall override an existing session with the first. It is RECOMMENDED that the test comprise testing whether the certificates are bitwise identical.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O最初の証明書と第二の証明書を考えると、第二の新しい着信セッションが最初との既存のセッションを無効にするものかどうかをテストします。テスト証明書は、同一のビット単位されているかどうかをテストすることを含むことが推奨されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All other semantics for certificates and Endpoint Discriminators are determined by the Cryptography Profile and the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
証明書およびエンドポイントディスクリミネータのための他のすべてのセマンティクスは暗号プロファイルおよびアプリケーションによって決定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Packet Multiplex
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. パケット多重
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTMFP typically has one or more interfaces through which it communicates with other RTMFP endpoints. RTMFP can communicate with multiple distinct other RTMFP endpoints through each local interface. Session multiplexing over a shared interface can facilitate peer-to-peer communications through a NAT, by enabling third-party endpoints such as Forwarders (Section 3.5.1.5) and Redirectors (Section 3.5.1.4) to observe the translated public address and inform peers of the translation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、典型的には、それが他のRTMFPエンドポイントと通信する1つまたは複数のインターフェイスを有しています。 RTMFPは、各ローカルインタフェースを介して複数の異なる他のRTMFPエンドポイントと通信することができます。共有インターフェース上のセッション多重化は、（セクション3.5.1.4）は、翻訳パブリックアドレスを観察し、ピアに通知する（セクション3.5.1.5）とリダイレクタフォワーダとしてサードパーティのエンドポイントを有効にすることによって、NATを介してピア・ツー・ピア通信を容易にすることができます翻訳の。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An interface is typically a UDP socket (Section 2.2.1) but MAY be any suitable datagram transport service where endpoints can be addressed by IPv4 or IPv6 socket addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
インターフェースは、典型的には、UDPソケット（セクション2.2.1）であるが、エンドポイントがIPv4またはIPv6のソケット・アドレスによってアドレス指定することができる任意の適切なデータグラム輸送サービスとすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP uses a session ID to multiplex and demultiplex communications with distinct endpoints (Section 2.2.2), in addition to the endpoint socket address. This allows an RTMFP to detect a far-end address change (as might happen, for example, in mobile and wireless scenarios) and allows communication sessions to survive address changes. This also allows an RTMFP to act as a Forwarder or Redirector for an endpoint with which it has an active session, by distinguishing startup packets from those of the active session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、エンドポイントのソケットアドレスに加えて、異なるエンドポイント（セクション2.2.2）との通信を多重化及び逆多重化するために、セッションIDを使用します。これは、（モバイルおよびワイヤレスのシナリオでは、例えば、発生する可能性があります）RTMFPは、遠端アドレスの変更を検出することを可能にし、通信セッションは、アドレスの変更を生き残ることができます。これはまた、RTMFPは、それがアクティブセッションのものから起動パケットを区別することによって、アクティブなセッションを有するとエンドポイントのフォワーダまたはリダイレクタとして作用することを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving a packet, an RTMFP decodes the session ID to look up the corresponding session information context and decryption key. Session ID 0 is reserved for session startup and MUST NOT be used for an active session. A packet for Session ID 0 uses the Default Session Key as defined by the Cryptography Profile.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットを受信すると、RTMFPは、対応するセッション情報のコンテキストと復号鍵をルックアップするためにセッションIDをデコードします。セッションID 0は、セッション起動のために予約されており、アクティブなセッションのために使用してはいけません。セッションID 0のためのパケットが暗号化プロファイルで定義されたデフォルトのセッションキーを使用しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Packet Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. パケットの断片
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an RTMFP packet (Section 2.2.4) is unavoidably larger than the path MTU (such as a startup packet containing an RHello (Section 2.3.4) or IIKeying (Section 2.3.7) chunk with a large certificate), it can be fragmented into segments that do not exceed the path MTU by using the Packet Fragment chunk (Section 2.3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPパケット（セクション2.2.4）（例えばRHello（セクション2.3.4）またはIIKeying（セクション2.3.7）大きい証明書を使用してチャンクを含むスタートアップ・パケットのような）パスMTUよりも不可避的に大きい場合、それはすることができパケットの断片化のチャンク（2.3.1）を使用してパスMTUを超えないセグメントに断片化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet fragmentation mechanism SHOULD be used only to segment unavoidably large packets. Accordingly, this mechanism SHOULD be employed only during session startup with Session ID 0. This mechanism MUST NOT be used instead of the natural fragmentation mechanism of the User Data (Section 2.3.11) and Next User Data (Section 2.3.12) chunks for dividing the messages of the user&#39;s data flows into segments that do not exceed the path MTU.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットの断片化機構は、セグメント不可避大きなパケットにのみ使用されるべきです。従って、このメカニズムは、セッションID 0とのセッションの起動時にのみ、このメカニズムを使用されるべきである代わりに、ユーザデータの天然の断片化機構（セクション2.3.11）、次のユーザデータ（セクション2.3.12）のチャンクのための使用してはいけませんユーザデータのメッセージを分割すると、パスMTUを超えていないセグメントに流れます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A fragmented plain RTMFP packet is reassembled by concatenating the packetFragment fields of the fragments for the packet in contiguous ascending order, starting from index 0 through and including the final fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断片化された無地RTMFPパケットは、連続昇順でパケットのフラグメントのpacketFragmentフィールドを連結することを介して、インデックス0から開始し、最終的な断片を含むことによって再組み立てされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When reassembling packets for Session ID 0, a receiver SHOULD identify the packets by the socket address from which the packet containing the fragment was received, as well as the indicated packetID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションID 0のパケットを再組み立てするとき、受信機は、断片を含むパケットが受信されたソケットアドレス、ならびに指示packetIDによってパケットを識別すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver SHOULD allow up to 60 seconds to completely receive a fragmented packet for which progress is being made. A packet is progressing if at least one new fragment for it was received in the last second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機は、完全に進歩が行われているフラグメントパケットを受信するために60秒まで可能にすべきです。それのための少なくとも1つの新しいフラグメントが最後の1秒に受信された場合、パケットが進んでいます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver MUST discard a Packet Fragment chunk having an empty packetFragment field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機は、空packetFragmentフィールドを有するパケットフラグメントチャンクを捨てなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mode of each packet containing Packet Fragments for the same fragmented packet MUST match the mode of the fragmented packet. A receiver MUST discard any new Packet Fragment chunk received in a packet with a mode different from the mode of the packet containing the first received fragment. A receiver MUST discard any reassembled packet with a mode different than the packets containing its fragments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同じフラグメントパケットのためのパケット断片を含む各パケットのモードは、断片化されたパケットのモードと一致しなければなりません。受信機は、最初に受信したフラグメントを含むパケットのモードとは異なるモードのパケットで受信された任意の新しいパケットフラグメントチャンクを捨てなければなりません。受信機は、そのフラグメントを含むパケットとは異なるモードを有する任意の再構成されたパケットを破棄しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid jamming the network, the sender MUST rate limit packet transmission. In the absence of specific path capacity information (for instance, during session startup), a sender SHOULD NOT send more than 4380 bytes nor more than four packets per distinct endpoint every 200 ms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークを妨害避けるために、送信者は、リミットパケット伝送を評価しなければなりません。 （例えば、セッションの起動時に）特定のパス能力情報がない場合、送信者は、以上の4380のバイトもの別個のエンドポイントごとに複数の4つのパケット毎に200ミリ秒を送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid resource exhaustion, a receiver SHOULD limit the number of concurrent packet reassembly buffers and the size of each buffer. Limits can depend, for example, on the expected size of reassembled packets, on the rate at which fragmented packets are expected to be received, on the expected degree of interleaving, and on the expected function of the receiver. Limits can depend on the available resources of the receiver. There can be different limits for packets with Session ID 0 and packets for established sessions. For example, a busy server might need to allow for several hundred concurrent packet reassembly buffers to accommodate hundreds of connection requests per second with potentially interleaved fragments, but a client device with constrained resources could allow just a few reassembly buffers. In the absence of specific information regarding the expected size of reassembled packets, a receiver should set the limit for each packet reassembly buffer to 65536 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースの枯渇を回避するために、受信機は、同時パケット再アセンブリ・バッファの数と各バッファのサイズを制限する必要があります。制限は断片化されたパケットをインターリーブの期待度に、受信されることが期待される速度で、再組み立てされたパケットの予想されるサイズに、例えば、依存し、受信機の予想される機能にすることができます。制限は、受信機の利用可能なリソースに依存することができます。確立されたセッションのセッションIDが0のパケットとパケットごとに異なる制限がある場合もあります。例えば、ビジー状態のサーバは、潜在的にインターリーブ断片毎秒接続要求の数百人を収容するための数百の同時パケットの再構成バッファを可能にする必要があるかもしれませんが、制約のリソースを持つクライアントデバイスは、わずか数再組み立てバッファを可能性があります。再組み立てされたパケットの予想されるサイズに関する特定の情報がない場合、受信機は、65536バイトの各パケットの再組み立てバッファの制限を設定すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. セッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A session is the protocol relationship between a pair of communicating endpoints, comprising the shared and endpoint-specific information context necessary to carry out the communication. The session context at each end includes at least:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションは、エンドポイントを連通信を行うために必要な共有およびエンドポイント固有の情報コンテキストを含む一対の間のプロトコルの関係です。各端部セッションコンテキストを少なくとも含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_RX: the last timestamp received from the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TS_RX：遠端から受信した最後のタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_RX_TIME: the time at which TS_RX was first observed to be different than its previous value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TS_RX_TIME：TS_RXは最初の前の値とは異なることが観察された時間。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_ECHO_TX: the last timestamp echo sent to the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TS_ECHO_TX：最後のタイムスタンプは、遠端に送信されたエコー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MRTO: the measured retransmission timeout;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O MRTO：測定された再送タイムアウト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ERTO: the effective retransmission timeout;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERTO○：効果的な再送タイムアウト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cryptographic keys for encrypting and decrypting packets, and for verifying the validity of packets, according to the Cryptography Profile;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットの暗号化及び復号化するための、および暗号化プロファイルに従って、パケットの正当性を検証するためのO暗号鍵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Cryptographic near and far nonces according to the Cryptography Profile, where the near nonce is the far end&#39;s far nonce, and vice versa;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O暗号遠近ナンス周辺nonceが遠端の遠ノンスである暗号化プロファイル、およびその逆に係ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The certificate of the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遠端の証明書O;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The receive session identifier, used by the far end when sending packets to this end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この目的のためにパケットを送信するとき、遠端で使用される受信セッション識別子、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The send session identifier to use when sending packets to the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遠端にパケットを送信するときに使用する送信セッション識別子O;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DESTADDR: the destination socket address to use when sending packets to the far end;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DESTADDR：遠端にパケットを送信するときに使用する先のソケットアドレス。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The set of all sending flow contexts (Section 3.6.2);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
すべての送信フローの状況（3.6.2項）のセットO;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The set of all receiving flow contexts (Section 3.6.3);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O全ての受信フローコンテキスト（セクション3.6.3）のセット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The transmission budget, which controls the rate at which data is sent into the network (for example, a congestion window);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データは、（例えば、輻輳ウィンドウ）ネットワークに送信される速度を制御する送信予算、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o S_OUTSTANDING_BYTES: the total amount of user message data outstanding, or in flight, in the network -- that is, the sum of the F_OUTSTANDING_BYTES of each sending flow in the session;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O S_OUTSTANDING_BYTES：ユーザメッセージデータの合計量発行済、または飛行中、ネットワークに - つまり、セッション内の各送信フローのF_OUTSTANDING_BYTESの和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RX_DATA_PACKETS: a count of the number of received packets containing at least one User Data chunk since the last acknowledgement was sent, initially 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RX_DATA_PACKETS O：最初に少なくとも一つのユーザーデータチャンクを含む受信パケットの数のカウント最後の確認応答が送信されたので、0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACK_NOW: a boolean flag indicating whether an acknowledgement should be sent immediately, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O ACK_NOW：肯定応答が偽最初に、すぐに送信されるべきかどうかを示すブールフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DELACK_ALARM: an alarm to trigger an acknowledgement after a delay, initially unset;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O DELACK_ALARM：遅延の後に確認応答をトリガするアラーム、当初は未設定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state, at any time being one of the following values: the opening states S_IHELLO_SENT and S_KEYING_SENT, the open state S_OPEN, the closing states S_NEARCLOSE and S_FARCLOSE_LINGER, and the closed states S_CLOSED and S_OPEN_FAILED; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O状態は、次の値のいずれかである任意の時点で：開口部はS_IHELLO_SENTとS_KEYING_SENT、開状態S_OPEN、閉鎖状態がS_NEARCLOSEとS_FARCLOSE_LINGER、及び閉状態S_CLOSEDとS_OPEN_FAILED述べて。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The role -- either Initiator or Responder -- of this end of the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータまたはレスポンダのどちらか -   - セッションのこの終わりの役割O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：以下の図は、状態遷移とその原因となるイベントの概要だけで、完全な動作仕様ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          rcv IIKeying Glare
          far prevails +-------------+   ultimate open timeout
        +--------------|S_IHELLO_SENT|-------------+
        |              +-------------+             |
        |                     |rcv RHello          |
        |                     |                    v
        |                     v             +-------------+
        |&lt;-----------(duplicate session?)   |S_OPEN_FAILED|
        |         yes         |no           +-------------+
        |                     |                    ^
        | rcv IIKeying Glare  v                    |
        | far prevails +-------------+             |
        |&lt;-------------|S_KEYING_SENT|-------------+
        |              +-------------+   ultimate open timeout
        |                     |rcv RIKeying
        |                     |
        |       rcv           v
        |   +-+ IIKeying  +--------+ rcv Close Request
        |   |X|----------&gt;| S_OPEN |--------------------+
        |   +-+           +--------+                    |
        |                   |    |ABRUPT CLOSE          |
        |      ORDERLY CLOSE|    |or rcv Close Ack      |
        |                   |    |or rcv IIKeying       |
        |                   |    |   session override   |
        |                   |    +-------+              |
        |                   v            |              v
        |             +-----------+      |     +-----------------+
        |             |S_NEARCLOSE|      |     |S_FARCLOSE_LINGER|
        |             +-----------+      |     +-----------------+
        |      rcv Close Ack|            |              |rcv Close Ack
        |      or 90 seconds|            v              |or 19 seconds
        |                   |       +--------+          |
        |                   +------&gt;|S_CLOSED|&lt;---------+
        +--------------------------&gt;|        |
                                    +--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 8: Session State Diagram
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
図8：セッション状態図
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1. Startup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1. 起動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1. Normal Handshake
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1。通常のハンドシェイク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP sessions are established with a 4-way handshake in two round trips. The initiator begins by sending an IHello to one or more candidate addresses for the desired destination endpoint. A responder statelessly sends an RHello in response. The first correct RHello received at the initiator is selected; all others are ignored. The initiator computes its half of the session keying and sends an IIKeying. The responder receives the IIKeying and, if it is acceptable, computes its half of the session keying, at which point it can also compute the shared session keying and session nonces. The responder creates a new S_OPEN session with the initiator and sends an RIKeying. The initiator receives the RIKeying and, if it is acceptable, computes the shared session keying and session nonces. The initiator&#39;s session is now S_OPEN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPセッションは2回の往復で4ウェイハンドシェイクで確立されています。開始剤は、所望の宛先エンドポイントのための1つまたは複数の候補アドレスにIHelloを送信することによって始まります。応答者は、ステートレスに応じてRHelloを送信します。最初の正しいRHelloが選択されているイニシエータで受信しました。他のすべては無視されます。イニシエータは、セッションキーのその半分を計算しIIKeyingを送信します。それが許容される場合、レスポンダは、IIKeyingを受信し、それはまた、共有セッションキーとセッションナンスを計算することができ、その時点で、セッションキーのその半分を計算します。レスポンダは、イニシエータで新しいS_OPENセッションを作成し、RIKeyingを送信します。イニシエータはRIKeyingを受信し、それが許容される場合、共有セッションキーとセッションナンスを計算します。イニシエータのセッションは今S_OPENです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        .     Initiator                                Responder     .
                      | IHello                         |
                      |(EPD,Tag)                       |
        S_IHELLO_SENT |(SID=0)                         |
                      |-------------------------------&gt;|
                      |                                |
                      |                         RHello |
                      |              (Tag,Cookie,RCert)|
                      |                         (SID=0)|
                      |&lt;-------------------------------|
        S_KEYING_SENT |                                |
                      | IIKeying                       |
                      |(ISID,Cookie,ICert,SKIC,ISig)   |
                      |(SID=0)                         |
                      |-------------------------------&gt;|
                      |                                |
                      |                       RIKeying |
                      |                (RSID,SKRC,RSig)|
                      |          (SID=ISID,Key=Default)| S_OPEN
                      |&lt;-------------------------------|
               S_OPEN |                                |
                      |          S E S S I O N         |
                      |&lt;-------------------(SID=ISID)--|
                      |--(SID=RSID)-------------------&gt;|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure 9: Normal Handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
図9：通常のハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following sections, the handshake is detailed from the perspectives of the initiator and responder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下のセクションでは、ハンドシェークは、イニシエータとレスポンダーの観点から詳細に説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1.1. Initiator
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1.1。イニシエータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator determines that a session is needed for an Endpoint Discriminator. The initiator creates state for a new opening session and begins with a candidate endpoint address set containing at least one address. The new session is placed in the S_IHELLO_SENT state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータは、セッションがエンドポイント識別子のために必要であると判断します。イニシエータは、新しいオープニングセッションの状態を作成し、少なくとも1つのアドレスを含む候補エンドポイントアドレスのセットから始まります。新しいセッションがS_IHELLO_SENT状態に置かれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the session does not move to the S_OPEN state before an ultimate open timeout, the session has failed and moves to the S_OPEN_FAILED state. The RECOMMENDED ultimate open timeout is 95 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションが究極のオープンタイムアウト前S_OPEN状態に移動できない場合、セッションは失敗したとS_OPEN_FAILED状態に移行しました。推奨究極のオープンタイムアウトは95秒です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator chooses a new, unique tag not used by any currently opening session. It is RECOMMENDED that the tag be cryptographically pseudorandom and be at least 8 bytes in length, so that it is hard to guess. The initiator constructs an IHello chunk (Section 2.3.2) with the Endpoint Discriminator and the tag.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータは、任意の現在開くセッションで使用されていない新しい、ユニークなタグを選択します。タグが暗号擬似ランダムであっても、推測しにくいように、長さが少なくとも8バイトであることが推奨されます。イニシエータは、エンドポイント識別子とタグとIHelloチャンク（2.3.2項）を構築します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the initiator is in the S_IHELLO_SENT state, it sends the IHello to each candidate endpoint address in the set, on a backoff schedule. The backoff SHOULD NOT be less than multiplicative, with not less than 1.5 seconds added to the interval between each attempt. The backoff SHOULD be scheduled separately for each candidate address, since new candidates can be added over time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータはS_IHELLO_SENT状態にある間、それはバックオフスケジュールで、セット内の各候補エンドポイントアドレスにIHelloを送信します。バックオフは、各試行間の間隔に追加されていない以下1.5秒以上で、乗法未満すべきではありません。新しい候補者が時間をかけて追加することができるので、バックオフは、各候補アドレスに対して個別にスケジュールする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator receives a Redirect chunk (Section 2.3.5) with a tag echo matching this session, AND this session is in the S_IHELLO_SENT state, then for each redirect destination indicated in the Redirect: if the candidate endpoint address set contains fewer than REDIRECT_THRESHOLD addresses, add the indicated redirect destination to the candidate endpoint address set. REDIRECT_THRESHOLD SHOULD NOT be more than 24.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータは、このセッションに一致するエコータグと（セクション2.3.5）リダイレクトチャンクを受信し、このセッションがS_IHELLO_SENT状態である場合、各リダイレクトに示されている宛先をリダイレクトするための：候補エンドポイントアドレスセットがREDIRECT_THRESHOLDより少ないが含まれている場合アドレスは、候補エンドポイントアドレスのセットに示されたリダイレクト先を追加します。 REDIRECT_THRESHOLDは24以上すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator receives an RHello chunk (Section 2.3.4) with a tag echo matching this session, AND this session is in the S_IHELLO_SENT state, AND the responder certificate matches the desired Endpoint Discriminator, AND the certificate is authentic according to the Cryptography Profile, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータは、このセッションに一致するタグエコーとRHelloチャンク（2.3.4項）を受信し、このセッションはS_IHELLO_SENT状態であり、レスポンダの証明書は、所望のエンドポイント識別子と一致し、証明書は暗号化プロファイルに従って真正である場合に、そして：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the Canonical Endpoint Discriminator for the responder certificate matches the Canonical Endpoint Discriminator of another existing session in the S_KEYING_SENT or S_OPEN states, AND the certificate of the other opening session matches the desired Endpoint Discriminator, then this session is a duplicate and SHOULD be aborted in favor of the other existing session; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.レスポンダ証明書の正規エンドポイント識別子がS_KEYING_SENT又はS_OPEN状態で別の既存のセッションの標準エンドポイント識別子と一致し、他方の開口セッションの証明書は、所望のエンドポイント識別子と一致する場合、このセッションが重複してすべきであり他の既存のセッションの賛成で中止され、そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Move to the S_KEYING_SENT state. Set DESTADDR, the far-end address for the session, to the address from which this RHello was received. The initiator chooses a new, unique receive session ID, not used by any other session, for the responder to use when sending packets to the initiator. It computes a Session Key Initiator Component appropriate to the responder&#39;s certificate according to the Cryptography Profile. Using this data and the cookie from the RHello, the initiator constructs and signs an IIKeying chunk (Section 2.3.7).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_KEYING_SENT状態に2.移動します。このRHelloを受信したアドレスを、DESTADDR、セッションのための遠端アドレスを設定します。イニシエータは、イニシエータにパケットを送信するときに使用する応答者のためではなく、他のセッションで使用される新しい、ユニークな受信セッションIDを、選択します。これは、暗号化プロファイルに応じた応答者の証明書にセッションキーイニシエータコンポーネントの適切なを計算します。このデータとRHello、イニシエータ構築物および標識IIKeyingチャンク（セクション2.3.7）からクッキーを使用して。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the initiator is in the S_KEYING_SENT state, it sends the IIKeying to DESTADDR on a backoff schedule. The backoff SHOULD NOT be less than multiplicative, with not less than 1.5 seconds added to the interval between each attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータはS_KEYING_SENT状態にあるが、それはバックオフスケジュールでDESTADDRにIIKeyingを送信します。バックオフは、各試行間の間隔に追加されていない以下1.5秒以上で、乗法未満すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator receives an RIKeying chunk (Section 2.3.8) in a packet with this session&#39;s receive session identifier, AND this session is in the S_KEYING_SENT state, AND the signature in the chunk is authentic according to the far end&#39;s certificate (from the RHello), AND the Session Key Responder Component successfully combines with the Session Key Initiator Component and the near and far certificates to form the shared session keys and nonces according to the Cryptography Profile, then the session has opened successfully. The session moves to the S_OPEN state. The send session identifier is set from the RIKeying. Packet encryption, decryption, and verification now use the newly computed shared session keys, and the session nonces are available for application-layer cryptographic challenges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータは、このセッションのセッション識別子を受信し、このセッションがS_KEYING_SENT状態であり、チャンク内の署名がRHelloから（遠端の証明書によれば本物であるとパケットにRIKeyingチャンク（セクション2.3.8）を受信した場合）、およびセッションキーレスポンダコンポーネントが正常に暗号化プロファイルに従って、共有セッション鍵とナンスを形成するためにセッションキーイニシエータコンポーネントと近くと遠くの証明書と結合し、その後、セッションが正常にオープンしました。セッションはS_OPEN状態に移行します。送信セッション識別子はRIKeyingから設定されています。パケットの暗号化、復号化、および検証は今、新たに計算された共有セッションキーを使用して、セッションナンスは、アプリケーション層の暗号化の課題のために用意されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1.2. Responder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.1.2。答え
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IHello chunk (Section 2.3.2) with an Endpoint Discriminator that selects its identity, an endpoint SHOULD construct an RHello chunk (Section 2.3.4) and send it to the address from which the IHello was received. To avoid a potential resource exhaustion denial of service, the endpoint SHOULD NOT create any persistent state associated with the IHello. The endpoint MUST generate the cookie for the RHello in such a way that it can be recognized as authentic and valid when echoed in an IIKeying. The endpoint SHOULD use the address from which the IHello was received as part of the cookie generation formula. Cookies SHOULD be valid only for a limited time; that lifetime SHOULD NOT be less than 95 seconds (the recommended ultimate session open timeout).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのアイデンティティーを選択するエンドポイント識別子とIHelloチャンク（セクション2.3.2）の受信時に、エンドポイントはRHelloチャンク（2.3.4項）を構築すべきであり、IHelloが受信されたアドレスに送信します。サービスの潜在的な資源枯渇の拒否を回避するために、エンドポイントはIHelloに関連するすべての永続的な状態を作成しないでください。エンドポイントはIIKeyingにこだましたときに、それは本物と有効なものとして認識できるようにRHelloのCookieを生成しなければなりません。エンドポイントはIHelloクッキー生成式の一部として受信されたアドレスを使用する必要があります。クッキーには、限られた時間のみ有効であるべきです。その寿命は95未満秒（推奨究極のセッションタイムアウトオープン）すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an FIHello chunk (Section 2.3.3) from a Forwarder (Section 3.5.1.5) where the Endpoint Discriminator selects its identity, an endpoint SHOULD do one of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイント識別子は、そのIDを選択フォワーダからFIHelloチャンク（2.3.3項）（セクション3.5.1.5）を受信すると、エンドポイントは、次のいずれかを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Compute, construct, and send an RHello as though the FIHello was an IHello received from the indicated reply address; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.計算、構成、及びFIHelloが指示返信アドレスからIHelloを受信されたかのようにRHelloを送信します。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Construct and send an Implied Redirect (Section 2.3.5) to the FIHello&#39;s reply address; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.構築とFIHelloの返信アドレスに暗黙リダイレクト（2.3.5項）​​を送ります。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Ignore this FIHello.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.このFIHelloを無視します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IIKeying chunk (Section 2.3.7), if the cookie is not authentic or if it has expired, ignore this IIKeying; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IIKeyingチャンク（セクション2.3.7）を受信すると、クッキーが本物でない、期限が切れている場合は、このIIKeyingを無視すれば、そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IIKeying chunk, if the cookie appears authentic but does not match the address from which the IIKeying&#39;s packet was received, perform the special processing at Cookie Change (Section 3.5.1.2); otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クッキーは本物表示されますが、IIKeyingのパケットが受信されたアドレスと一致しない場合IIKeyingチャンクを受信すると、クッキーの変更（セクション3.5.1.2）で特別な処理を行います。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IIKeying with an authentic and valid cookie, if the certificate is authentic according to the Cryptography Profile, AND the signature in the chunk is authentic according to the far end&#39;s certificate and the Cryptography Profile, AND the Session Key Initiator Component is acceptable, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本物と有効なクッキーとIIKeyingを受信すると、証明書は暗号化プロファイルに応じて、本物である、チャンク内の署名は、遠端の証明書と暗号化のプロフィールによると、本物である、とセッション鍵イニシエータコンポーネントが受け入れ可能である場合、そして：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the address from which this IIKeying was received corresponds to an opening session in the S_IHELLO_SENT or S_KEYING_SENT state, perform the special processing at Glare (Section 3.5.1.3); otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.このIIKeyingがS_IHELLO_SENT又はS_KEYING_SENT状態で開口セッションに対応する受信されたアドレスは、グレア（セクション3.5.1.3）での特別な処理を実行する場合、そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the address from which this IIKeying was received corresponds to a session in the S_OPEN state, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.このIIKeyingが受信されたアドレスは、S_OPEN状態でセッションに対応する場合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       1.  If the receiver was the Responder for the S_OPEN session and
           the session identifier, certificate, and Session Key
           Initiator Component are identical to those of the S_OPEN
           session, this IIKeying is a retransmission, so resend the
           S_OPEN session&#39;s RIKeying using the Default Session Key as
           specified below; otherwise,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. If the certificate from this IIKeying does not override the certificate of the S_OPEN session, ignore this IIKeying; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2.このIIKeyingから証明書がS_OPENセッションの証明書を無効にしない場合は、このIIKeyingを無視します。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. The certificate from this IIKeying overrides the certificate of the S_OPEN session; this is a new opening session from the same identity, and the existing S_OPEN session is stale. Move the existing S_OPEN session to S_CLOSED and abort all of its flows (signaling exceptions to the user), then continue processing this IIKeying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3.このIIKeyingから証明書がS_OPENセッションの証明書を無効にします。これは、同じIDからの新オープニングセッションで、既存のS_OPENセッションが古くなっています。 S_CLOSED既存S_OPENセッションを移動し、このIIKeyingの処理を続行し、（ユーザの例外をシグナリング）そのフローのすべてを中止。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Compute a Session Key Responder Component and choose a new, unique receive session ID not used by any other session for the initiator to use when sending packets to the responder. Using this data, construct and, with the Session Key Initiator Component, sign an RIKeying chunk (Section 2.3.8). Using the Session Key Initiator and Responder Components and the near and far certificates, the responder combines and computes the shared session keys and nonces according to the Cryptography Profile. The responder creates a new session in the S_OPEN state, with the far-endpoint address DESTADDR taken from the source address of the packet containing the IIKeying and the send session identifier taken from the IIKeying. The responder sends the RIKeying to the initiator using the Default Session Key and the requested send session identifier. Packet encryption, decryption, and verification of all future packets for this session use the newly computed keys, and the session nonces are available for application-layer cryptographic challenges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.計算セッションキーレスポンダコンポーネントとレスポンダにパケットを送信するときに使用するイニシエータのために他のセッションで使用されていない新しい、ユニークな受信セッションIDを選択してください。セッションキーイニシエータコンポーネントで、このデータを使用して構築し、RIKeyingチャンク（第2.3.8項）に署名。セッションキーイニシエータとレスポンダコンポーネントと近くと遠くの証明書を使用して、応答者のコンバインと暗号化プロファイルに従って、共有セッション鍵とナンスを計算します。レスポンダはIIKeyingとIIKeyingから取られた送信セッション識別子を含むパケットの送信元アドレスから取られた遠エンドポイントアドレスDESTADDRで、S_OPEN状態で新しいセッションを作成します。応答者は、デフォルトのセッションキーと要求された送信セッション識別子を使用してイニシエータにRIKeyingを送信します。パケットの暗号化、復号化、およびこのセッションのすべての将来のパケットの検証が新たに算出されたキーを使用して、セッションナンスは、アプリケーション層の暗号化の課題のために用意されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.2. Cookie Change
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.2。クッキーの変更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some circumstances, the responder may generate an RHello cookie for an initiator&#39;s address that isn&#39;t the address the initiator would use when sending packets directly to the responder. This can happen, for example, when the initiator has multiple local addresses and uses one address to reach a Forwarder (Section 3.5.1.5) but another to reach the responder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの状況では、レスポンダはレスポンダに直接パケットを送信するときに、イニシエータが使用するアドレスではありません、イニシエータのアドレスのためのRHelloクッキーを生成してもよいです。これは、イニシエータが、複数のローカルアドレスを持っており、フォワーダ（セクション3.5.1.5）に達するが、別の応答者に到達するために一つのアドレスを使用する場合、例えば、発生する可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の例を考えてみます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                    Forwarder                     Responder
   | IHello                         |                                 |
   |(Src=Ix)                        |                                 |
   |-------------------------------&gt;|                                 |
   |                                | FIHello                         |
   |                                |(RA=Ix)                          |
   |                                |--------------------------------&gt;|
   |                                                                  |
   |                                                           RHello |
   |                                                       (Cookie:Ix)|
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   | IIKeying                                                         |
   |(Cookie:Ix,Src=Iy)                                                |
   |-----------------------------------------------------------------&gt;|
   |                                                                  |
   |                                             RHello Cookie Change |
   |                                             (Cookie:Ix,Cookie:Iy)|
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   | IIKeying                                                         |
   |(Cookie:Iy)                                                       |
   |-----------------------------------------------------------------&gt;|
   |                                                                  |
   |                                                         RIKeying |
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   |&lt;======================== S E S S I O N =========================&gt;|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 10: Handshake with Cookie Change
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図10：クッキーの変更と握手
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator has two network interfaces: a first preferred interface with address Ix = 192.0.2.100:50000, and a second with address Iy = 198.51.100.101:50001. The responder has one interface with address Ry = 198.51.100.200:51000, on the same network as the initiator&#39;s second interface. The initiator uses its first interface to reach a Forwarder. The Forwarder observes the initiator&#39;s address of Ix and sends a Forwarded IHello (Section 2.3.3) to the responder. The responder treats this as if it were an IHello from Ix, calculates a corresponding cookie, and sends an RHello to Ix. The initiator receives this RHello from Ry and selects that address as the destination for the session. It then sends an IIKeying, copying the cookie from the RHello. However, since the source of the RHello is Ry, on a network to which the initiator is directly connected, the initiator uses its second interface Iy to send the IIKeying. The responder, on receiving the IIKeying, will compare the cookie to the expected value based on the source address of the packet, and since the IIKeying source doesn&#39;t match the IHello source used to generate the cookie, the responder will reject the IIKeying.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アドレス1×= 192.0.2.100:50000有する第一の好ましい界面、及びアドレスIyの= 198.51.100.101:50001と第二：開始剤は、2つのネットワークインタフェースを有します。レスポンダは、イニシエータの第2のインタフェースと同じネットワーク上に、アドレスさRy = 198.51.100.200:51000とつのインタフェースを有しています。イニシエータは、フォワーダに到達するための最初のインターフェイスを使用しています。フォワーダーは、IXのイニシエータのアドレスを観察し、応答者に転送IHello（2.3.3項）を送信します。応答者の扱い、このことは、1×からIHelloであるかのように、対応するクッキーを計算し、およびIXにRHelloを送信します。開始剤は、ライからこのRHelloを受信し、セッションの宛先としてそのアドレスを選択します。その後RHelloからクッキーをコピーし、IIKeyingを送信します。 RHelloのソースはイニシエータが直接接続されるネットワーク上のRyが、あるので、イニシエータはIIKeyingを送信するために、その第2のインタフェースIyのを使用します。応答者は、IIKeyingを受信すると、パケットの送信元アドレスに基づいて、期待値にクッキーを比較し、IIKeying源がクッキーを生成するために使用さIHelloソースと一致しないので、応答者はIIKeyingを拒否します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the responder determines that it generated the cookie in the IIKeying but the cookie doesn&#39;t match the sender&#39;s address (for example, if the cookie is in two parts, with a first part generated independently of the initiator&#39;s address and a second part dependent on the address), the responder SHOULD generate a new cookie based on the address from which the IIKeying was received and send an RHello Cookie Change chunk (Section 2.3.6) to the source of the IIKeying, using the session ID from the IIKeying and the Default Session Key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
レスポンダは、IIKeyingにクッキーを生成することを決定するが、クッキーは、2つの部分にある場合、クッキーは、イニシエータのアドレスとに依存する第二の部分とは独立して生成された第一の部分と、（例えば、送信者のアドレスと一致しない場合アドレス）、応答者はIIKeyingが受信されたアドレスに基づいて、新しいクッキーを生成し、IIKeyingのソースにRHelloクッキーの変更チャンク（2.3.6項）を送信し、IIKeyingからセッションIDを使用したとすべきですセッションキーをデフォルト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the initiator receives an RHello Cookie Change chunk for a session in the S_KEYING_SENT state, AND the old cookie matches the one originally sent to the responder, then the initiator adopts the new cookie, constructs and signs a new IIKeying chunk, and sends the new IIKeying to the responder. The initiator SHOULD NOT change the cookie for a session more than once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータはS_KEYING_SENT状態でのセッションのためにRHelloクッキーの変更チャンクを受け取り、古いクッキーは元々レスポンダに送信されたものと一致した場合、その後、イニシエータは新しいクッキー、構築物及び看板新しいIIKeyingチャンクを採用し、新しいを送信しますレスポンダにIIKeying。イニシエータは、複数回のセッションのためにクッキーを変更しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.3. Glare
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.3。グレア
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Glare occurs when two endpoints attempt to initiate sessions to each other concurrently. Glare is detected by receipt of a valid and authentic IIKeying from an endpoint address that is a destination for an opening session. Only one session is allowed between a pair of endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2つのエンドポイントが同時に互いにセッションを開始しようとすると、グレアが発生します。グレアは、開口セッションの宛先であるエンドポイントアドレスから有効かつ本物IIKeyingの受信によって検出されます。一つだけのセッションは、エンドポイントのペアの間で許可されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Glare is resolved by comparing the certificate in the received IIKeying with the near end&#39;s certificate. The Cryptography Profile defines a certificate comparison function to determine the prevailing endpoint when there is glare.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
グレアは、近端の証明書を使用して、受信IIKeyingに証明書を比較することによって解決されます。暗号化プロファイルはグレアがある場合に支配エンドポイントを決定するために、証明書の比較関数を定義します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the near end prevails, discard and ignore the received IIKeying. The far end will abort its opening session on receipt of IIKeying from the near end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
近端が優勢ならば、破棄し、受信IIKeyingを無視します。遠端が近端からIIKeyingの領収書にそのオープニングセッションを中止します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, the far end prevails:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それ以外の場合は、遠端が優先さ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the certificate in the IIKeying overrides the certificate associated with the near opening session according to the Cryptography Profile, then abort and destroy the near opening session. Then,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. IIKeying内の証明書は、暗号化プロファイルに従って周辺開口セッションに関連付けられた証明書を上書きした場合、周辺の開口セッションを中止し、破壊します。その後、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Continue with normal Responder IIKeying processing (Section 3.5.1.1.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.通常のレスポンダIIKeying処理（セクション3.5.1.1.2）に進みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.4. Redirector
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.4。リダイレクタ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        +-----------+           +------------+          +-----------+
        | Initiator |----------&gt;| Redirector |          | Responder |
        |           |&lt;----------|            |          |           |
        |           |           +------------+          |           |
        |           |&lt;=================================&gt;|           |
        +-----------+                                   +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Figure 11: Redirector
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
図11：リダイレクタ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Redirector acts like a name server for Endpoint Discriminators. An initiator MAY use a Redirector to discover additional candidate endpoint addresses for a desired endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リダイレクターは、エンドポイントディスクリミネータのネームサーバのように動作します。イニシエータは、所望の終点のための追加の候補エンドポイントのアドレスを発見するためにリダイレクタを使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IHello chunk with an Endpoint Discriminator that does not select the Redirector&#39;s identity, the Redirector constructs and sends back to the initiator a Responder Redirect chunk (Section 2.3.5) containing one or more additional candidate addresses for the indicated endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リダイレクタのアイデンティティ、リダイレクタの構造を選択して、イニシエータに戻って指示されたエンドポイントの1つの以上の追加の候補アドレスを含むレスポンダリダイレクトチャンク（セクション2.3.5）を送信していないエンドポイント識別子とIHelloチャンクを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                   Redirector                     Responder
   | IHello                         |                                 |
   |-------------------------------&gt;|                                 |
   |                                |                                 |
   |                       Redirect |                                 |
   |&lt;-------------------------------|                                 |
   |                                                                  |
   | IHello                                                           |
   |-----------------------------------------------------------------&gt;|
   |                                                                  |
   |                                                           RHello |
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   | IIKeying                                                         |
   |-----------------------------------------------------------------&gt;|
   |                                                                  |
   |                                                         RIKeying |
   |&lt;-----------------------------------------------------------------|
   |                                                                  |
   |&lt;======================== S E S S I O N =========================&gt;|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 12: Handshake Using a Redirector
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図12：リダイレクタを使用してハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Deployment Design Note: Redirectors SHOULD NOT initiate new sessions to endpoints that might use the Redirector&#39;s address as a candidate for another endpoint, since the far end might interpret the Redirector&#39;s IIKeying as glare for the far end&#39;s initiation to the other endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
展開のデザインノート：リダイレクタは、遠端が他のエンドポイントへの遠端の開始のためのグレアとしてリダイレクタのIIKeyingを解釈するかもしれないので、別のエンドポイントの候補としてリダイレクタのアドレスを使用する場合がありますエンドポイントに新しいセッションを開始すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.5. Forwarder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.5。フォワーダ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         +-----------+     +-----------+     +---+     +-----------+
         | Initiator |----&gt;| Forwarder |&lt;===&gt;| N |&lt;===&gt;| Responder |
         |           |     +-----------+     | A |     |           |
         |           |&lt;=====================&gt;| T |&lt;===&gt;|           |
         +-----------+                       +---+     +-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
Figure 13: Forwarder
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-27">
図13：フォワーダー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A responder might be behind a NAT or firewall that doesn&#39;t allow inbound packets to reach the endpoint until it first sends an outbound packet for a particular far-endpoint address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答者は、それが第1の特定の遠エンドポイントのアドレスに発信パケットを送信するまで着信パケットがエンドポイントに到達することはできませんNATやファイアウォールの背後にあるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Forwarder&#39;s endpoint address MAY be a candidate address for another endpoint. A responder MAY use a Forwarder to receive FIHello chunks sent on behalf of an initiator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォワーダのエンドポイントアドレスは、別のエンドポイントの候補アドレスであってもよいです。レスポンダは、開始剤の代わりに送信FIHelloチャンクを受信するフォワーダを使用するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an IHello chunk with an Endpoint Discriminator that does not select the Forwarder&#39;s identity, if the Forwarder has an S_OPEN session with an endpoint whose certificate matches the desired Endpoint Discriminator, the Forwarder constructs and sends an FIHello chunk (Section 2.3.3) to the selected endpoint over the S_OPEN session, using the tag and Endpoint Discriminator from the IHello chunk and the source address of the packet containing the IHello for the corresponding fields of the FIHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フォワーダがFIHelloチャンクを証明希望エンドポイント識別子、フォワーダーの構造に一致するエンドポイントとS_OPENセッションを持っており、送信した場合、フォワーダーのIDを選択していないエンドポイント識別子とIHelloチャンクを受信する（2.3.3項） S_OPENセッションにわたって選択されたエンドポイントに、IHelloチャンクとFIHelloの対応するフィールドのIHelloを含むパケットの送信元アドレスからタグとエンドポイント識別子を使用して。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an FIHello chunk, a responder might send an RHello or Implied Redirect to the original source of the IHello (Section 3.5.1.1.2), potentially allowing future packets to flow directly between the initiator and responder through the NAT or firewall.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FIHelloチャンクを受信すると、応答は、潜在的に、将来のパケットがNATまたはファイアウォールを介してイニシエータとレスポンダとの間で直接流すこと、IHello（セクション3.5.1.1.2）の元のソースにRHelloまたは暗黙のリダイレクトを送信するかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                    Forwarder           NAT       Responder
   | IHello                         |                |                |
   |-------------------------------&gt;|                |                |
   |                                | FIHello        |                |
   |                                |---------------&gt;|---------------&gt;|
   |                                                 |                |
   |                                                 |         RHello |
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   | IIKeying                                        :                |
   |-------------------------------------------------:---------------&gt;|
   |                                                 :                |
   |                                                 :       RIKeying |
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   |&lt;======================== S E S S I O N ========&gt;:&lt;==============&gt;|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 14: Forwarder Handshake where Responder Sends an RHello
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
図14：レスポンダはRHelloを送信フォワーダハンドシェイク
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator                    Forwarder           NAT       Responder
   | IHello                         |                |                |
   |-------------------------------&gt;|                |                |
   |                                | FIHello        |                |
   |                                |---------------&gt;|---------------&gt;|
   |                                                 |                |
   |                                                 |       Redirect |
   |                                                 | (Implied,RD={})|
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   | IHello                                          :                |
   |------------------------------------------------&gt;:---------------&gt;|
   |                                                 :                |
   |                                                 :         RHello |
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   | IIKeying                                        :                |
   |------------------------------------------------&gt;:---------------&gt;|
   |                                                 :                |
   |                                                 :       RIKeying |
   |                                                 :&lt;---------------|
   |&lt;------------------------------------------------:                |
   |                                                 :                |
   |&lt;======================== S E S S I O N ========&gt;:&lt;==============&gt;|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          Figure 15: Forwarder Handshake where Responder Sends an
                             Implied Redirect
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.6. Redirector and Forwarder with NAT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.6。リダイレクトとNATを進めます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +---+       +---+       +---+      +---+      +---+
             | I |       | N |       | I |      | N |      | R |
             | n |------&gt;| A |------&gt;| n |      | A |      | e |
             | i |       | T |       | t |&lt;====&gt;| T |&lt;====&gt;| s |
             | t |&lt;------|   |&lt;------| r |      |   |      | p |
             | i |       |   |       | o |      |   |      | o |
             | a |       |   |       +---+      |   |      | n |
             | t |       |   |                  |   |      | d |
             | o |&lt;=====&gt;|   |&lt;================&gt;|   |&lt;====&gt;| e |
             | r |       |   |                  |   |      | r |
             +---+       +---+                  +---+      +---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Figure 16: Introduction Service for Initiator and Responder behind NATs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
図16：NATの背後はじめイニシエータのサービスとレスポンダ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An initiator and responder might each be behind distinct NATs or firewalls that don&#39;t allow inbound packets to reach the respective endpoints until each first sends an outbound packet for a particular far-endpoint address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータとレスポンダは、それぞれ各第一は、特定の遠エンドポイントのアドレスに発信パケットを送信するまでの着信パケットは、それぞれのエンドポイントに到達することはできません。個別のNATのか、ファイアウォールの背後かもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An introduction service comprising Redirector and Forwarder functions may facilitate direct communication between endpoints each behind a NAT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リダイレクタとフォワーダ機能を含む紹介サービスは、NATの背後にあるエンドポイントのそれぞれとの間の直接通信を容易にすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The responder is registered with the introduction service via an S_OPEN session to it. The service observes and records the responder&#39;s public NAT address as the DESTADDR of the S_OPEN session. The service MAY record other addresses for the responder, for example addresses that the responder self-reports as being directly attached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答者は、それにS_OPENセッションを介して紹介サービスに登録されています。サービスはS_OPENセッションのDESTADDRとして応答者のパブリックNATアドレスを観察し、記録します。サービスは、応答者のために他のアドレスを記録することができ、例えば、直接接続されているとして、その応答の自己報告に対応しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator begins with an address of the introduction service as an initial candidate. The Redirector portion of the service sends to the initiator a Responder Redirect containing at least the responder&#39;s public NAT address as previously recorded. The Forwarder portion of the service sends to the responder a Forwarded IHello containing the initiator&#39;s public NAT address as observed to be the source of the IHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータは最初の候補として紹介サービスのアドレスから始まります。サービスのリダイレクター部分は、以前に記録された少なくとも応答者のパブリックNATアドレスを含むイニシエータレスポンダリダイレクトに送信します。 IHelloの源であることが観察されたサービスのフォワーダ部分は、イニシエータのパブリックNATアドレスを含む応答転送さIHelloに送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The responder sends an RHello to the initiator&#39;s public NAT address in response to the FIHello. This will allow inbound packets to the responder through its NAT from the initiator&#39;s public NAT address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答者は、FIHelloに応じて、イニシエータのパブリックNATアドレスにRHelloを送信します。これは、イニシエータのパブリックNATアドレスからのNAT経由のレスポンダへのインバウンドパケットを許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initiator sends an IHello to the responder&#39;s public NAT address in response to the Responder Redirect. This will allow inbound packets to the initiator through its NAT from the responder&#39;s public NAT address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータは、レスポンダリダイレクトに応じて、応答者のパブリックNATアドレスにIHelloを送信します。これは、応答者のパブリックNATアドレスからのNAT経由イニシエータへのインバウンドパケットを許可します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With transit paths created in both NATs, normal session startup can proceed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
トランジットパスは両方のNATで作成すると、通常のセッションの起動を続行することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Initiator     NAT-I    Redirector+Forwarder     NAT-R      Responder
   |               |                |                |                |
   | IHello        |                |                |                |
   |(Dst=Intro)    |                |                |                |
   |--------------&gt;|                |                |                |
   |               |---------------&gt;|                |                |
   |               |                | FIHello        |                |
   |               |                |(RA=NAT-I-Pub)  |                |
   |               |                |---------------&gt;|---------------&gt;|
   |               |       Redirect |                |                |
   |               | (RD={NAT-R-Pub,|                |                |
   |               |           ...})|                |                |
   |&lt;--------------|&lt;---------------|                |                |
   |               |                                 |         RHello |
   |               |                                 | (Dst=NAT-I-Pub)|
   |               |                                 :&lt;---------------|
   |               | (*)  &lt;--------------------------:                |
   | IHello        |                                 :                |
   |(Dst=NAT-R-Pub)|                                 :                |
   |--------------&gt;:                                 :                |
   |               :--------------------------------&gt;:---------------&gt;|
   |               :                                 :                |
   |               :                                 :         RHello |
   |               :                                 :&lt;---------------|
   |&lt;--------------:&lt;--------------------------------:                |
   |               :                                 :                |
   | IIKeying      :                                 :                |
   |--------------&gt;:                                 :                |
   |               :--------------------------------&gt;:---------------&gt;|
   |               :                                 :                |
   |               :                                 :       RIKeying |
   |               :                                 :&lt;---------------|
   |&lt;--------------:&lt;--------------------------------:                |
   |               :                                 :                |
   |&lt;=============&gt;:&lt;======== S E S S I O N ========&gt;:&lt;==============&gt;|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Figure 17: Handshake with Redirector and Forwarder
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
図17：リダイレクタとフォワーダと握手
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the point in Figure 17 marked (*), the responder&#39;s RHello from the FIHello might arrive at the initiator&#39;s NAT before or after the initiator&#39;s IHello is sent outbound to the responder&#39;s public NAT address. If it arrives before, it may be dropped by the NAT. If it arrives after, it will transit the NAT and trigger keying without waiting for another round-trip time. The timing of this race depends, among other factors, on the relative distances of the initiator and responder from each other and from the introduction service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
イニシエータのIHelloが応答者のパブリックNATアドレスへの送信を送信される前または後に、図17のポイントマーク（*）で、FIHelloからの応答者のRHelloは、イニシエータのNATに到着するかもしれません。それは前に到着した場合、それはNATによってドロップすることができます。それが後に到着した場合、それはトランジットNATとトリガーは別のラウンドトリップ時間を待たずにキーイングします。このレースのタイミングは、互いに及び紹介サービスからイニシエータとレスポンダとの相対距離に、他の要因の中でも特に、依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.7. Load Distribution and Fault Tolerance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.1.7。負荷分散とフォールトトレランス
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
             +---+    IHello/RHello    +-------------+
             | I |&lt;-------------------&gt;| Responder 1 |
             | n |                     +-------------+
             | i |  SESSION  +-------------+
             | t |&lt;=========&gt;| Responder 2 |
             | i |           +-------------+
             | a |   IHello...                 +----------------+
             | t |-------------------------&gt; X | Dead Responder |
             | o |                             +----------------+
             | r |  IHello/RHello   +-------------+
             |   |&lt;----------------&gt;| Responder N |
             +---+                  +-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Figure 18: Parallel Open to Multiple Endpoints
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
図18：複数のエンドポイントへのオープンパラレル
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in Section 3.2, more than one endpoint is allowed to be selected by one Endpoint Discriminator. This will typically be the case for a set of servers, any of which could accommodate a connecting client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.2で指定されるように、複数のエンドポイントは、一つエンドポイント識別子によって選択することが許されます。これは、一般的に接続しているクライアントを収容できる任意のそれらのサーバーのセット、のためのケースとなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in Section 3.5.1.1.1, an initiator is allowed to use multiple candidate endpoint addresses when starting a session, and the sender of the first acceptable RHello chunk to be received is selected to complete the session, with later responses ignored. An initiator can start with the multiple candidate endpoint addresses, or it may learn them during startup from one or more Redirectors (Section 3.5.1.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
節3.5.1.1.1に規定されているように、イニシエータがセッションを開始するときに複数の候補エンドポイントアドレスを使用させ、第一に許容されるRHelloチャンクの送信者が受信すべき無視以降の応答と、セッションを完了するために選択されます。イニシエータは、複数の候補のエンドポイントアドレスで開始することができ、またはそれは、一つ以上のリダイレクタ（セクション3.5.1.4）からの起動時にそれらを学ぶことがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parallel open to multiple endpoints for the same Endpoint Discriminator, combined with selection by earliest RHello, can be used for load distribution and fault tolerance. The cost at each endpoint that is not selected is limited to receiving and processing an IHello, and generating and sending an RHello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最も早いRHelloによる選択と組み合わされ、同じエンドポイント識別子のための複数のエンドポイントと平行オープンは、負荷分散およびフォールトトレランスのために使用することができます。選択されていない各エンドポイントにおけるコストを受信しIHelloを処理し、生成しRHelloの送信に限定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In one circumstance, multiple servers of similar processing and networking capacity may be located in near proximity to each other, such as in a data center. In this circumstance, a less heavily loaded server can respond to an IHello more quickly than more heavily loaded servers and will tend to be selected by a client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1つの状況では、同様の処理及びネットワーク容量の複数のサーバは、データセンターのように、互いに近くに近接して配置することができます。この状況では、少ない負荷の高いサーバは、より高負荷のサーバよりも早くIHelloに応答することができますし、クライアントが選択される傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In another circumstance, multiple servers may be located in different physical locations, such as different data centers. In this circumstance, a server that is located nearer (in terms of network distance) to the client can respond earlier than more distant servers and will tend to be selected by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
別の状況では、複数のサーバは、異なるデータセンターのような異なる物理的位置に配置することができます。この状況では、クライアントに（ネットワーク距離の面で）近いが置かれているサーバーは、より遠くのサーバよりも早く対応することができ、クライアントによって選択される傾向があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiple servers, in proximity or distant from one another, can form a redundant pool of servers. A client can perform a parallel open to the multiple servers. In normal operation, the multiple servers will all respond, and the client will select one of them as described above. If one of the multiple servers fails, other servers in the pool can still respond to the client, allowing the client to succeed to an S_OPEN session with one of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
複数のサーバは、互いに近接または遠隔で、サーバの冗長プールを形成することができます。クライアントが複数のサーバーに並行オープンを実行することができます。通常の操作では、複数のサーバがすべて応答します、そして前述のように、クライアントはそれらのいずれかを選択します。複数のサーバのいずれかに障害が発生した場合は、プール内の他のサーバーは、まだクライアントはそのうちの一つでS_OPENセッションに成功することができ、クライアントに応答することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2. Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2. 輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTMFP MUST implement congestion control and avoidance algorithms that are &#34;TCP compatible&#34;, in accordance with Internet best current practice [RFC2914]. The algorithms SHOULD NOT be more aggressive in sending data than those described in &#34;TCP Congestion Control&#34; [RFC5681] and MUST NOT be more aggressive in sending data than the &#34;slow start algorithm&#34; described in Section 3.1 of RFC 5681.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、インターネットのベストプラクティス現在の[RFC2914]に従って、「TCP互換性」であり、輻輳制御と回避アルゴリズムを実装しなければなりません。アルゴリズムは[RFC5681]「TCP輻輳制御」に記載されているものよりもデータを送信し、より積極的にすべきではないとRFC 5681のセクション3.1に記載された「スロースタートアルゴリズム」よりデータを送信することで、より積極的にすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint maintains a transmission budget in the session information context of each S_OPEN session (Section 3.5), controlling the rate at which the endpoint sends data into the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、エンドポイントがネットワークにデータを送信する速度を制御し、各S_OPENセッション（セクション3.5）のセッション情報コンテキストで伝送バジェットを維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For window-based congestion control and avoidance algorithms, the transmission budget is the congestion window, which is the amount of user data that is allowed to be outstanding, or in flight, in the network. Transmission is allowed when S_OUTSTANDING_BYTES (Section 3.5) is less than the congestion window (Section 3.6.2.3). See Appendix A for an experimental window-based congestion control algorithm for real-time and bulk data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ウィンドウベースの輻輳制御と回避アルゴリズムは、送信予算は、ネットワーク内の、未処理が許可されるユーザデータの量、または飛行中である輻輳ウィンドウ、です。 S_OUTSTANDING_BYTES（セクション3.5）輻輳ウィンドウ（セクション3.6.2.3）未満である場合、送信が許可されています。リアルタイムとバルクデータのための実験的なウィンドウベースの輻輳制御アルゴリズムについては、付録Aを参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint avoids sending large bursts of data or packets into the network (Section 3.5.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、ネットワーク（セクション3.5.2.3）へのデータまたはパケットの大バーストを送信することが回避されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sending endpoint increases and decreases its transmission budget in response to acknowledgements (Section 3.6.2.4) and loss according to the congestion control and avoidance algorithms. Loss is detected by negative acknowledgement (Section 3.6.2.5) and timeout (Section 3.6.2.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントの増加を送信し、肯定応答（セクション3.6.2.4）と、輻輳制御と回避アルゴリズムに従って損失に応答してその送信予算を減少させます。損失は​​否定応答（セクション3.6.2.5）とタイムアウト（セクション3.6.2.6）によって検出されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timeout is determined by the Effective Retransmission Timeout (ERTO) (Section 3.5.2.2). The ERTO is measured using the Timestamp and Timestamp Echo packet header fields (Section 2.2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムアウトは、効果的な再送信タイムアウト（ERTO）（セクション3.5.2.2）によって決定されます。 ERTOは、タイムスタンプ及びタイムスタンプエコーパケットヘッダフィールド（セクション2.2.4）を用いて測定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving endpoint acknowledges all received data (Section 3.6.3.4) to enable the sender to measure receipt of data, or lack thereof.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信エンドポイントは、すべてのそのデータの受信、又は欠如を測定するために、送信者を有効にする（セクション3.6.3.4）でデータを受信し承認します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving endpoint may be receiving time critical (or real-time) data from a first sender while receiving data from other senders. The receiving endpoint can signal its other senders (Section 2.2.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信エンドポイントは、他の送信者からのデータを受信しながら最初の送信者からの臨界時間（またはリアルタイム）データを受信して​​もよいです。受信エンドポイントが、その他の送信者信号を送ることができる（セクション2.2.4）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
to cause them to decrease the aggressiveness of their congestion control and avoidance algorithms, in order to yield network capacity to the time critical data (Section 3.5.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らは重要なデータ（セクション3.5.2.1）時にネットワーク容量を得るために、彼らの輻輳制御と回避アルゴリズムの攻撃性を減少させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.1. Time Critical Reverse Notification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.1。タイムクリティカルリバース通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender can increase its transmission budget at a rate compatible with (but not exceeding) the &#34;slow start algorithm&#34; specified in RFC 5681 (with which the transmission rate is doubled every round trip when beginning or restarting transmission, until loss is detected). However, a sender MUST behave as though the slow start threshold SSTHRESH is clamped to 0 (disabling the slow start algorithm&#39;s exponential increase behavior) on a session where a Time Critical Reverse Notification (Section 2.2.4) indication has been received from the far end within the last 800 milliseconds, unless the sender is itself currently sending time critical data to the far end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は（損失が検出されるまで、開始または送信を再開する場合、伝送速度は、すべてのラウンドトリップを倍増している）RFC 5681で指定された「スロースタートアルゴリズムを」（しかし超えない）と互換性の速度でその伝送予算を増やすことができます。スロースタートしきい値SSTHRESHは、タイムクリティカルリバース通知（2.2.4）表示が遠端から受信されたセッションで（スロースタートアルゴリズムの指数関数的な増加の動作を無効にする）0にクランプされているかのようしかし、送信者が振る舞わなければならない（MUST）送信者が自分自身でない限り、最後の800ミリ秒以内に、現在の遠端にタイムクリティカルなデータを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During each round trip, a sender SHOULD NOT increase the transmission budget by more than 0.5% or by 384 bytes per round trip (whichever is greater) on a session where a Time Critical Reverse Notification indication has been received from the far end within the last 800 milliseconds, unless the sender is itself currently sending time critical data to the far end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各ラウンドトリップ中に、送信者は、タイムクリティカル逆通知指示が最後内の遠端から受信されたセッションで（いずれか大きい方）より0.5％によって、または往復当たり384バイトで送信予算を増やすべきではありません800ミリ秒、送信者自身が現在、遠端にタイムクリティカルなデータを送信している場合を除きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.2. Retransmission Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.2。再送信タイムアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP uses the ERTO to detect when a user data fragment has been lost in the network. The ERTO is typically calculated in a manner similar to that specified in &#34;Requirements for Internet Hosts - Communication Layers&#34; [RFC1122] and is a function of round-trip time measurements and persistent timeout behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、ユーザデータフラグメントがネットワークで失われたときを検出するERTOを使用します。 ERTOは、典型的には、「インターネットホストのための要件 - 通信層」で指定したのと同様の方法で計算され、[RFC1122]と往復時間の測定と持続タイムアウト挙動の関数です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ERTO SHOULD be at least 250 milliseconds and SHOULD allow for the receiver to delay sending an acknowledgement for up to 200 milliseconds (Section 3.6.3.4.4). The ERTO MUST NOT be less than the round-trip time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ERTOは、少なくとも250ミリ秒であるべきであり、最大200ミリ秒（セクション3.6.3.4.4）に対する肯定応答を送信遅延させる受信を可能にすべきです。 ERTOは往復時間以上でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To facilitate round-trip time measurement, an endpoint MUST implement the Timestamp Echo facility:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
往復時間の測定を容易にするために、エンドポイントは、タイムスタンプエコー機能を実装する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On a session entering the S_OPEN state, initialize TS_RX_TIME to negative infinity, and initialize TS_RX and TS_ECHO_TX to have no value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O S_OPEN状態に入るセッションで、負の無限大にTS_RX_TIMEを初期化し、値を持たないようにTS_RXとTS_ECHO_TXを初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a packet in an S_OPEN session with the timestampPresent (Section 2.2.4) flag set, if the timestamp field in the packet is different than TS_RX, set TS_RX to the value of the timestamp field in the packet, and set TS_RX_TIME to the current time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O timestampPresent（セクション2.2.4）フラグが設定されたS_OPENセッションでパケットを受信すると、パケットにおけるタイムスタンプフィールドはTS_RX_TIMEパケットにおけるタイムスタンプフィールドの値にTS_RXを設定し、TS_RXは異なる、と設定している場合現在の時刻に。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When sending a packet to the far end in an S_OPEN session:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENセッションで遠端にパケットを送信する場合○：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1. Calculate TS_RX_ELAPSED = current time - TS_RX_TIME. If TS_RX_ELAPSED is more than 128 seconds, then set TS_RX and TS_ECHO_TX to have no value, and do not include a timestamp echo; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1.計算TS_RX_ELAPSED =現在の時刻 -  TS_RX_TIME。 TS_RX_ELAPSED以上128秒である場合には、TS_RXとTS_ECHO_TXが値を持たないように設定され、タイムスタンプのエコーが含まれていません。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2. Calculate TS_RX_ELAPSED_TICKS to be the number of whole 4-millisecond periods in TS_RX_ELAPSED; then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2.計算TS_RX_ELAPSED_TICKS TS_RX_ELAPSEDにおける全4ミリ秒期間の数であり;それから
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3. Calculate TS_ECHO = (TS_RX + TS_RX_ELAPSED_TICKS) MODULO 65536; then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3.計算TS_ECHO =（TS_RX + TS_RX_ELAPSED_TICKS）MODULO 65536。それから
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. If TS_ECHO is not equal to TS_ECHO_TX, then set TS_ECHO_TX to TS_ECHO, set the timestampEchoPresent flag, and set the timestampEcho field to TS_ECHO_TX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
4. TS_ECHOがTS_ECHO_TXに等しくない場合、timestampEchoPresentフラグを設定し、TS_ECHO_TXにtimestampEchoフィールドを設定し、TS_ECHOにTS_ECHO_TXを設定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remainder of this section describes an OPTIONAL method for calculating the ERTO. Real-time applications and P2P mesh applications often require knowing the round-trip time and RTT variance. This section additionally describes a method for measuring the round-trip time and RTT variance, and calculating a smoothed round-trip time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションの残りはERTOを計算するための任意の方法を記載しています。リアルタイムアプリケーションやP2Pメッシュアプ​​リケーションは、多くの場合、往復時間とRTTの変動を知る必要があります。このセクションでは、さらに、往復時間とRTTの変動を測定し、平滑化往復時間を計算するための方法を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain additional variables:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報のコンテキストは、追加の変数が含まれてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_TX: the last timestamp sent to the far end, initialized to have no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TS_TX：遠端に送信された最後のタイムスタンプは、値を持たないように初期化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TS_ECHO_RX: the last timestamp echo received from the far end, initialized to have no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O TS_ECHO_RX：最後のタイムスタンプが値を持たないように初期化、遠端から受信されたエコー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SRTT: the smoothed round-trip time, initialized to have no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SRTT：値を持たないように初期化平滑化往復時間、;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RTTVAR: the round-trip time variance, initialized to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RTTVAR：往復時間の分散、0に初期化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialize MRTO to 250 milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
250ミリ秒にMRTOを初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialize ERTO to 3 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3秒にERTOを初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On sending a packet to the far end of an S_OPEN session, if the current send timestamp is not equal to TS_TX, then set TS_TX to the current send timestamp, set the timestampPresent flag in the packet header, and set the timestamp field to TS_TX.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の送信タイムスタンプがTS_TXに等しくない場合、S_OPENセッションの遠端にパケットを送信することで、その後TS_TX現在の送信タイムスタンプに設定され、パケットヘッダにtimestampPresentフラグを設定し、TS_TXにタイムスタンプフィールドを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a packet from the far end of an S_OPEN session, if the timestampEchoPresent flag is set in the packet header, AND the timestampEcho field is not equal to TS_ECHO_RX, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
timestampEchoPresentフラグは、パケットヘッダに設定された場合S_OPENセッションの遠端からパケットを受信すると、timestampEchoフィールドが次にTS_ECHO_RX、に等しくありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Set TS_ECHO_RX to timestampEcho;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
timestampEcho 1.設定TS_ECHO_RX。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Calculate RTT_TICKS = (current send timestamp - timestampEcho) MODULO 65536;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.計算RTT_TICKS =（現在の送信タイムスタンプ -  timestampEcho）MODULO 65536。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If RTT_TICKS is greater than 32767, the measurement is invalid, so discard this measurement; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. RTT_TICKSが32767より大きい場合、測定が無効であるため、この測定値を捨てます。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Calculate RTT = RTT_TICKS * 4 milliseconds;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.計算RTT = RTT_TICKS * 4ミリ秒。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If SRTT has a value, then calculate new values of RTTVAR and SRTT:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. SRTTが値を持っている場合、RTTVARとSRTTの新しい値を計算します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. RTT_DELTA = | SRTT - RTT |;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. RTT_DELTA = | SRTT  -  RTT |。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. RTTVAR = ((3 * RTTVAR) + RTT_DELTA) / 4;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. RTTVAR =（（3 * RTTVAR）+ RTT_DELTA）/ 4。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. SRTT = ((7 * SRTT) + RTT) / 8.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. SRTT =（（7 *のSRTT）+ RTT）/ 8。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. If SRTT has no value, then set SRTT = RTT and RTTVAR = RTT / 2;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SRTTに値がない場合6.は、SRTT = RTTとRTTVAR = RTT / 2を設定します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Set MRTO = SRTT + 4 * RTTVAR + 200 milliseconds;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.設定しMRTO = SRTT + 4 *のRTTVAR + 200ミリ秒。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Set ERTO to MRTO or 250 milliseconds, whichever is greater.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
大きい方MRTO又は250ミリ秒に8セットERTO、。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A retransmission timeout occurs when the most recently transmitted user data fragment has remained outstanding in the network for ERTO. When this timeout occurs, increase ERTO on an exponential backoff with an ultimate backoff cap of 10 seconds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再送タイムアウトは、最後に送信されたユーザデータの断片がERTOのためのネットワークに優れ残っている場合に発生します。このタイムアウトが発生した場合、10秒の究極のバックオフキャップで指数バックオフにERTOを増やします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Calculate ERTO_BACKOFF = ERTO * 1.4142;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.計算ERTO_BACKOFF = ERTO * 1.4142;
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Calculate ERTO_CAPPED to be ERTO_BACKOFF or 10 seconds, whichever is less;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.計算ERTO_CAPPED小さい方ERTO_BACKOFF又は10秒、ことを特徴とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Set ERTO to ERTO_CAPPED or MRTO, whichever is greater.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
いずれか大きい方ERTO_CAPPEDまたはMRTO 3.設定ERTO、。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.3. Burst Avoidance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.2.3。バースト回避
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application&#39;s sending patterns may cause the transmission budget to grow to a large value, but at times its sending patterns will result in a comparatively small amount of data outstanding in the network. In this circumstance, especially with a window-based congestion avoidance algorithm, if the application then has a large amount of new data to send (for example, a new bulk data transfer), it could send data into the network all at once to fill the window. This kind of transmission burst is undesirable, however, because it can jam interfaces, links, and buffers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションの送信パターンは、伝送バジェットが大きい値に成長する可能性がありますが、時にはその送信パターンは、ネットワーク内の未処理データ量が比較的少ないになります。特にウィンドウベースの輻輳回避アルゴリズムと、このような状況において、アプリケーションはその後（例えば、新しいバルクデータ転送）を送信するための新たな大量のデータを有する場合、それは埋めるために一斉ネットワークにデータを送信することができ窓。それはインターフェイス、リンク、および緩衝液を妨害することができるので、送信バーストのこの種は、しかし、望ましくありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Accordingly, in any session, an endpoint SHOULD NOT send more than six packets containing user data between receiving any acknowledgements or retransmission timeouts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
従って、任意のセッションで、エンドポイントは、任意の確認応答又は再送タイムアウトを受信する間に、ユーザデータを含む以上の6つのパケットを送るべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes an OPTIONAL method to avoid bursting large numbers of packets into the network:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、ネットワークにパケットを大量に破裂を避けるために任意の方法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain an additional variable DATA_PACKET_COUNT, initialized to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報コンテキストが0に初期化され、追加の変数DATA_PACKET_COUNTを、含まれてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transmission of a user data fragment on this session is not allowed if DATA_PACKET_COUNT is greater than or equal to 6, regardless of any other allowance of the congestion control algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DATA_PACKET_COUNTに関係なく、輻輳制御アルゴリズムの他の手当の、より大きいまたは6に等しい場合、このセッションのユーザデータフラグメントの送信が許可されていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On transmission of a packet containing at least one User Data chunk (Section 2.3.11), set DATA_PACKET_COUNT = DATA_PACKET_COUNT + 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも1つのユーザデータチャンク（セクション2.3.11）を含むパケットの送信に、= DATA_PACKET_COUNT + 1 DATA_PACKET_COUNTを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an acknowledgement chunk (Sections 2.3.13 and 2.3.14), set DATA_PACKET_COUNT to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
肯定応答チャンク（セクション2.3.13および2.3.14）の受信時に、0にDATA_PACKET_COUNTを設定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a retransmission timeout, set DATA_PACKET_COUNT to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再送タイムアウトでは、0にDATA_PACKET_COUNTを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.3. Address Mobility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.3. 住所モビリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sessions are demultiplexed with a 32-bit session ID, rather than by endpoint address. This allows an endpoint&#39;s address to change during an S_OPEN session. This can happen, for example, when switching from a wireless to a wired network, or when moving from one wireless base station to another, or when a NAT restarts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションはなく、エンドポイントアドレスによるよりも、32ビットのセッションIDを用いて分離されます。これは、エンドポイントのアドレスがS_OPENセッション中に変更することができます。 NAT再起動を有線ネットワークに無線から切り替えるとき、または別の無線基地局から移動するとき、またはとき、これは、例えば、起こることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the near end receives a valid packet for an S_OPEN session from a source address that doesn&#39;t match DESTADDR, the far end might have changed addresses. The near end SHOULD verify that the far end is definitively at the new address before changing DESTADDR. A suggested verification method is described in Section 3.5.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
近端がDESTADDRと一致しない送信元アドレスからのS_OPENセッションの有効なパケットを受信した場合、遠端のアドレスを変更している場合があります。近端は、遠端がDESTADDRを変更する前に、新しいアドレスに決定的であることを確認する必要があります。提案検証方法は、セクション3.5.4.2に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4. Ping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.  Pingの
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an endpoint receives a Ping chunk (Section 2.3.9) in a session in the S_OPEN state, it SHOULD construct and send a Ping Reply chunk (Section 2.3.10) in response if possible, copying the message unaltered. The Ping Reply SHOULD be sent as quickly as possible following receipt of a Ping. The semantics of a Ping&#39;s message is reserved for the sender; a receiver SHOULD NOT interpret the Ping&#39;s message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントがS_OPEN状態でのセッションでpingのチャンク（セクション2.3.9）を受信した場合、可能ならば、それは変更されていないメッセージをコピーし、応答（セクション2.3.10）ping応答チャンクを構築し、送信すべきです。 ping応答は、Pingのを受けた後、可能な限り迅速に送ってください。 Pingのメッセージの意味は、送信者のために予約されています。受信機は、Pingののメッセージを解釈すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoints can use the mechanism of the Ping chunk and the expected Ping Reply for any purpose. This specification doesn&#39;t mandate any specific constraints on the format or semantics of a Ping message. A Ping Reply MUST be sent only as a response to a Ping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、Pingのチャンクのメカニズムと任意の目的のために予想されるping応答を使用することができます。この仕様は、Pingメッセージの形式や意味論上の任意の特定の制約を強制しません。 ping応答が唯一のPingへの応答として送らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receipt of a Ping Reply implies live bidirectional connectivity. This specification doesn&#39;t mandate any other semantics for a Ping Reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ping応答の領収書は、ライブ双方向接続を意味します。この仕様は、ping応答のための任意の他のセマンティクスを強制しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.1. Keepalive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.1。生き続ける
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can use a Ping to test for live bidirectional connectivity, to test that the far end of a session is still in the S_OPEN state, to keep NAT translations alive, and to keep firewall holes open.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、生きているNAT変換を維持するために、オープンファイアウォールの穴を維持するために、セッションの遠端がS_OPEN状態のままであることをテストするために、ライブ双方向の接続をテストするには、pingを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can use a Ping to hasten detection of a near-end address change by the far end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、遠端で近端アドレス変更の検出を早めるためのPingを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint may declare a session to be defunct and dead after a persistent failure by the far end to return Ping Replies in response to Pings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、Pingのがpingに応答して返信を返すために、遠端で永続的な障害が発生した後は亡きと死んだようにセッションを宣言することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If used for these purposes, a Keepalive Ping SHOULD have an empty message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これらの目的のために使用した場合は、キープアライブのPingは、空のメッセージを持っているべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Keepalive Ping SHOULD NOT be sent more often than once per ERTO. If a corresponding Ping Reply is not received within ERTO of sending the Ping, ERTO SHOULD be increased according to Section 3.5.2 (&#34;Congestion Control&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キープアライブpingはERTOに一回よりも頻繁に送るべきではありません。対応するping応答がpingを送信ERTO内に受信されない場合、ERTOセクション3.5.2（「輻輳制御」）に応じて増加されるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.2. Address Mobility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.2。住所モビリティ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes an OPTIONAL but suggested method for processing and verifying a far-end address change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセクションでは、処理し、遠端アドレスの変更を確認するためのオプションですが、提案された方法を説明します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session context contain additional variables MOB_TX_TS, MOB_RX_TS, and MOB_SECRET. MOB_TX_TS and MOB_RX_TS have initial values of negative infinity. MOB_SECRET should be a cryptographically pseudorandom value not less than 128 bits in length and known only to this end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションコンテキストは、追加の変数MOB_TX_TS、MOB_RX_TS、およびMOB_SECRETが含まれてみましょう。 MOB_TX_TSとMOB_RX_TSは負の無限大の初期値を持っています。 MOB_SECRETは、長さが128ビット未満しかこの目的のために知られていない暗号擬似ランダム値であるべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a packet for an S_OPEN session, after processing all chunks in the packet: if the session is still in the S_OPEN state, AND the source address of the packet does not match DESTADDR, AND MOB_TX_TS is at least one second in the past, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPENセッションのためのパケットを受信すると、パケット内のすべてのチャンクを処理した後：セッションがS_OPEN状態のままであり、パケットの送信元アドレスはDESTADDRと一致していない、とMOB_TX_TSは、過去に少なくとも一つの第二の場合、そして：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Set MOB_TX_TS to the current time;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
現在の時刻に1セットMOB_TX_TS。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Construct a Ping message comprising the following: a marking to indicate (to this end when returned in a Ping Reply) that it is a mobility check (for example, the first byte being ASCII &#39;M&#39; for &#34;Mobility&#34;), a timestamp set to MOB_TX_TS, and a cryptographic hash over the following: the preceding items, the address from which the packet was received, and MOB_SECRET; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.以下を含んでPingメッセージを構築：（ping応答で返されたときにこの目的のために）それは（、「モビリティ」のための最初のバイトであることASCII「M」は、例えば）モビリティ・チェックであることを示すためにマーキング、 MOB_TX_TSに設定されたタイムスタンプ、および下記オーバー暗号ハッシュ：上記項目、パケットが受信されたアドレス、及びMOB_SECRET。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Send this Ping to the address from which the packet was received, instead of DESTADDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.代わりにDESTADDRの、パケットが受信されたアドレスにこのPing]を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a Ping Reply in an S_OPEN session, if the Ping Reply&#39;s message satisfies all of these conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ping応答のメッセージは、これらの条件のすべてを満たす場合のPingを受信すると、S_OPENセッションに返信：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o it has this end&#39;s expected marking to indicate that it is a mobility check, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは、この最後の期待している、それはモビリティチェックであることを示すためにマーキングし、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the timestamp in the message is not more than 120 seconds in the past, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージのタイムスタンプが過去に120秒以上ではないO、及び
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the timestamp in the message is greater than MOB_RX_TS, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OメッセージのタイムスタンプはMOB_RX_TSより大きく、そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o the cryptographic hash matches the expected value according to the contents of the message plus the source address of the packet containing this Ping Reply and MOB_SECRET,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号ハッシュは、メッセージの内容に応じた期待値プラスこのping応答とMOB_SECRETを含むパケットの送信元アドレスと一致oを
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
その後：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Set MOB_RX_TS to the timestamp in the message; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
メッセージのタイムスタンプに1セットMOB_RX_TS。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Set DESTADDR to the source address of the packet containing this Ping Reply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このping応答を含むパケットの送信元アドレスに2セットDESTADDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.3. Path MTU Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.4.3。パスMTUディスカバリ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;Packetization Layer Path MTU Discovery&#34; [RFC4821] describes a method for measuring the path MTU between communicating endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「パケット化層のパスMTUディスカバリ」[RFC4821]は通信エンドポイント間のパスMTUを測定するための方法を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RTMFP SHOULD perform path MTU discovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、パスMTUディスカバリを実行する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method described in RFC 4821 can be adapted for use in RTMFP by sending a probe packet comprising one of the Padding chunk types (type 0x00 or 0xff) and a Ping. The Ping chunk SHOULD come after the Padding chunk, to guard against a false positive response in case the probe packet is truncated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 4821に記載された方法は、パディングチャンクタイプ（タイプ0×00または0xffの）とPingのいずれかを含むプローブパケットを送信することによってRTMFPにおける使用に適合させることができます。 pingのチャンクは、プローブパケットが切り捨てられる場合には偽陽性反応を防ぐために、パディングチャンクの後に来る必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.5. Close
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5.5. 閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint may close a session at any time. Typically, an endpoint will close a session when there have been no open flows in either direction for a time. In another circumstance, an endpoint may be ceasing operation and will close all of its sessions even if they have open flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、いつでもセッションを閉じることができます。時間のためにどちらかの方向にもオープンフローがなかった場合、通常、エンドポイントは、セッションを終了します。別の状況では、エンドポイントは、運転を停止することができると、彼らはオープンフローを持っている場合でも、そのセッションのすべてを閉じます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To close an S_OPEN session in a reliable and orderly fashion, an endpoint moves the session to the S_NEARCLOSE state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
信頼性が高く、整然とS_OPENセッションを閉じるには、エンドポイントはS_NEARCLOSE状態にセッションを移動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a session transitioning from S_OPEN to S_NEARCLOSE and every 5 seconds thereafter while still in the S_NEARCLOSE state, send a Session Close Request chunk (Section 2.3.17).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションでは、セッションクローズリクエストチャンク（セクション2.3.17）を送信し、その後しばらくまだS_NEARCLOSE状態で5秒をS_NEARCLOSE、すべてのためにS_OPENから移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A session that has been in the S_NEARCLOSE state for at least 90 seconds (allowing time to retransmit the Session Close Request multiple times) SHOULD move to the S_CLOSED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（セッションのクローズリクエストを複数回再送する時間を与えること）は、少なくとも90秒間S_NEARCLOSE状態にあったセッションがS_CLOSED状態に移動する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a session transitioning from S_OPEN to the S_NEARCLOSE, S_FARCLOSE_LINGER or S_CLOSED state, immediately abort and terminate all open or closing flows. Flows only exist in S_OPEN sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_NEARCLOSE、S_FARCLOSE_LINGERまたはS_CLOSED状態にS_OPENから移行セッションで、直ちにすべての開いているか閉じて流れを中断して終了。フローは唯一S_OPENセッションに存在します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To close an S_OPEN session abruptly, send a Session Close Acknowledgement chunk (Section 2.3.18), then move to the S_CLOSED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（セクション2.3.18）セッションを閉じる謝辞チャンクを送信、突然S_OPENセッションを閉じるには、その後、S_CLOSED状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a Session Close Request chunk for a session in the S_OPEN, S_NEARCLOSE, or S_FARCLOSE_LINGER states, send a Session Close Acknowledgement chunk; then, if the session is in the S_OPEN state, move to the S_FARCLOSE_LINGER state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPEN、S_NEARCLOSE、またはS_FARCLOSE_LINGER状態でのセッションのセッションクローズリクエストチャンクを受信すると、セッションを閉じる謝辞チャンクを送信します。セッションがS_OPEN状態にある場合には、その後、S_FARCLOSE_LINGER状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A session that has been in the S_FARCLOSE_LINGER state for at least 19 seconds (allowing time to answer 3 retransmissions of a Session Close Request) SHOULD move to the S_CLOSED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（時間はセッションクローズリクエストの3つの再送を答えるためにできるように）少なくとも19秒間S_FARCLOSE_LINGER状態にあったセッションがS_CLOSED状態に移動する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a Session Close Acknowledgement chunk for a session in the S_OPEN, S_NEARCLOSE, or S_FARCLOSE_LINGER states, move to the S_CLOSED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S_OPEN、S_NEARCLOSE、またはS_FARCLOSE_LINGER状態でのセッションのためのセッションを閉じる謝辞チャンクを受信すると、S_CLOSED状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Flows
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 流れ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow is a unidirectional communication channel in a session for transporting a correlated series of user messages from a sender to a receiver. Each end of a session may have zero or more sending flows to the other end. Each sending flow at one end has a corresponding receiving flow at the other end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、受信機に送信機からユーザメッセージの相関系列を搬送するためのセッションにおける片方向通信チャネルです。セッションの各端部は、他端にゼロ個以上の送信フローを有することができます。一端にそれぞれ送信フローは、もう一方の端に対応する受信フローを有しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1. 概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.1. Identity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.1。身元
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows are multiplexed in a session by a flow identifier. Each end of a session chooses its sending flow identifiers independently of the other end. The choice of similar flow identifiers by both ends does not imply an association. A sender MAY choose any identifier for any flow; therefore, a flow receiver MUST NOT ascribe any semantic meaning, role, or name to a flow based only on its identifier. There are no &#34;well known&#34; or reserved flow identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、フロー識別子によってセッション中に多重化されています。セッションの各端部は、他方の端部とは独立してその送信フロー識別子を選択します。両端によると同様のフロー識別子の選択は、関連を意味するものではありません。送信者は、任意の流れのための任意の識別子を選ぶかもしれ。そのため、フロー受信機はその識別子に基づいて、フローにどんな意味論的な意味、役割、または名前を帰するてはなりません。何も「よく知られている」または予約フロー識別子がありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bidirectional flow association is indicated at flow startup with the Return Flow Association option (Section 2.3.11.1.2). An endpoint can indicate that a new sending flow is in return (or response) to a receiving flow from the other end. A sending flow MUST NOT indicate more than one return association. A receiving flow can be specified as the return association for any number of sending flows. The return flow association, if any, is fixed for the lifetime of the sending flow. Note: Closure of one flow in an association does not automatically close other flows in the association, except as specified in Section 3.6.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双方向フローの関連付けはリターンフロー協会オプション（セクション2.3.11.1.2）と流れが起動時に表示されます。エンドポイントは、新しい送信フローが他端から受信フローにリターン（または応答）であることを示すことができます。送信フローは、複数の戻り値の関連性を示してはいけません。受信フローは、フローを送信する任意の数のリターン・アソシエーションとして指定することができます。リターン・フロー・アソシエーションは、もしあれば、送信フローの寿命のために固定されています。注：会合した1つの流れの閉鎖を自動的にセクション3.6.3.1に指定される場合を除き、関連して他のフローを閉じません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows are named with arbitrary user metadata. This specification doesn&#39;t mandate any particular encoding, syntax, or semantics for the user metadata, except for the encoded size (Section 2.3.11.1.1); the user metadata is entirely reserved for the application. The user metadata is fixed for the lifetime of the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、任意のユーザメタデータと命名されています。この仕様は、符号化されたサイズ（セクション2.3.11.1.1）を除いて、任意の特定の符号化、構文、またはユーザメタデータのセマンティクスを強制しません。ユーザメタデータは完全にアプリケーションのために予約されています。ユーザメタデータは、フローの寿命のために固定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.2. Messages and Sequencing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.2。メッセージとシーケンシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows provide message-oriented framing. Large messages are fragmented for transport in the network. Receivers reassemble fragmented messages and only present complete messages to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローは、メッセージ指向のフレーミングを提供しています。大きなメッセージは、ネットワーク内の輸送のために断片化されています。レシーバは、断片化されたメッセージと、ユーザーにのみ存在の完全なメッセージを組み立て直します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender queues messages on a sending flow one after another. A receiver can recover the original queuing order of the messages, even when they are reordered in transit by the network or as a result of loss and retransmission, by means of the messages&#39; fragment sequence numbers. Flows are the basic units of message sequencing; each flow is sequenced independently of all other flows; inter-flow message arrival and delivery sequencing are not guaranteed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は送信フロー次々にメッセージをキューに入れます。受信機は、それらがメッセージフラグメントシーケンス番号によって、ネットワークによって、または損失および再送の結果として、輸送中に並べ替えられた場合でも、メッセージの元のキューイング順序を回復することができます。フローは、メッセージシーケンスの基本単位です。各フローは、独立して、他のすべてのフローの配列決定されます。インターフローメッセージ到着と配達の順序は保証されません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Independent flow sequencing allows a sender to prioritize the transmission or retransmission of the messages of one flow over those of other flows in a session, allocating capacity from the transmission budget according to priority. RTMFP is designed for flows to be the basic unit of prioritization. In any flow, fragment sequence numbers are unique and monotonically increasing; that is, the fragment sequence numbers for any message MUST be greater than the fragment sequence numbers of all messages previously queued in that flow. Receipt of fragments out of sequence number order within a flow creates discontiguous gaps at the receiver, causing it to send an acknowledgement for every packet and also causing the size of the encoded acknowledgements to grow. Therefore, for any flow, the sender SHOULD send lower sequence numbers first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
独立した流れ配列は、送信者が優先順位に従って送信予算から容量を割り当てる、セッション中に他のフローのものよりつの流れのメッセージの送信または再送信を優先することを可能にします。 RTMFPは、優先順位付けの基本単位となるフローのために設計されています。任意のフローでは、フラグメントシーケンス番号は一意であり、単調に増加します。つまり、任意のメッセージのフラグメントシーケンス番号が以前にそのフローのキューに入れられたすべてのメッセージの断片シーケンス番号よりも大きくなければなりません。フロー内のシーケンス番号順のうちフラグメントの受信は、それがすべてのパケットに対する肯定応答を送信させ、また、符号化された確認応答のサイズが成長させ、受信機において不連続ギャップを作成します。したがって、任意の流れのために、送信者は、第一下部のシーケンス番号を送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender can abandon a queued message at any time, even if some fragments of that message have been received by the other end. A receiver MUST be able to detect a gap in the flow when a message is abandoned; therefore, each message SHOULD take at least one sequence number from the sequence space even if no fragments for that message are ever sent. The sender will transmit the fragments of all messages not abandoned, and retransmit any lost fragments of all messages not abandoned, until all the fragments of all messages not abandoned are acknowledged by the receiver. A sender indicates a Forward Sequence Number (FSN) to instruct the receiver that sequence numbers less than or equal to the FSN will not be transmitted or retransmitted. This allows the receiver to move forward over gaps and continue sequenced delivery of completely received messages to the user. Any incomplete messages missing fragments with sequence numbers less than or equal to the FSN were abandoned by the sender and will never be completed. A gap indication MUST be communicated to the receiving user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、そのメッセージのいくつかの断片が、もう一方の端で受信された場合でも、いつでもキューに入れられたメッセージを放棄することができます。受信機は、メッセージが破棄されるフローのギャップを検出することができなければなりません。そのため、各メッセージは、そのメッセージのための断片が今までに送信されない場合でも、シーケンス空間から少なくとも1つのシーケンス番号を取る必要があります。送信者が放棄されていないすべてのメッセージの断片を送信し、放棄されていないすべてのメッセージの全ての断片が受信機によって承認されるまでは、放棄されていないすべてのメッセージのいずれかの失われた断片を再送します。送信者は、以下FSNに等しいシーケンス番号が送信または再送されないことを受信機に指示する転送シーケンス番号（FSN）を示しています。これは、受信機はギャップ上に前進し、ユーザに完全に受信したメッセージのシーケンスされた送達を継続することを可能にします。以下FSNに等しいシーケンス番号を有する断片が欠けて任意の不完全なメッセージは送信者によって放棄された、完成されることはありません。ギャップ指示は、受信ユーザに通信されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.3. Lifetime
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.1.3。一生
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender begins a flow by sending user message fragments to the other end, and including the user metadata and, if any, the return flow association. The sender continues to include the user metadata and return flow association until the flow is acknowledged by the far end, at which point the sender knows that the receiver has received the user metadata and, if any, the return flow association. After that point, the flow identifier alone is sufficient.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、他端にユーザメッセージフラグメントを送信し、ユーザメタデータと、もしあれば、戻り流協会含むことによって流れを開始します。送信者は、流れが、もしあれば、リターン・フロー・アソシエーションを送信者が受信機は、ユーザメタデータを受信したことを知っている時点で、遠端によって承認とされるまで、ユーザメタデータ及びリターンフローの関連付けを含むことを続けます。その時点の後、単独でフロー識別子は十分です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow receivers SHOULD acknowledge all sequence numbers received for any flow, whether the flow is accepted or rejected. Flow receivers MUST NOT acknowledge sequence numbers higher than the FSN that were not received. Acknowledgements drive the congestion control and avoidance algorithms and therefore must be accurate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、流れを受諾するか拒否するかを、任意のフローのために受信したすべてのシーケンス番号を認識すべきです。フロー受信機は受信されませんでしたFSNよりも高いシーケンス番号を認めてはなりません。謝辞は、輻輳制御と回避アルゴリズムを駆動し、したがって、正確でなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint can reject a receiving flow at any time in the flow&#39;s lifetime. To reject the flow, the receiving endpoint sends a Flow Exception Report chunk (Section 2.3.16) immediately preceding every acknowledgement chunk for the rejected receiving flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、フローの寿命の任意の時点で受信フローを拒否することができます。流れを拒否するには、受信エンドポイントはすぐに拒否された受信フローごとに受信確認のチャンクの前のフロー例外レポートのチャンク（セクション2.3.16）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An endpoint may eventually conclude and close a sending flow. The last sequence number of the flow is marked with the Final flag. The sending flow is complete when all sequence numbers of the flow, including the final sequence number, have been cumulatively acknowledged by the receiver. The receiving flow is complete when every sequence number from the FSN to the final sequence number has been received. The sending flow and corresponding receiving flow at the respective ends hold the flow identifier of a completed flow in reserve for a time to allow delayed or duplicated fragments and acknowledgements to drain from the network without erroneously initiating a new receiving flow or erroneously acknowledging a new sending flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
エンドポイントは、最終的に送信する流れを締結して閉じることができます。流れの最後のシーケンス番号は、最終的なフラグでマークされています。最後のシーケンス番号を含む流れ、すべてのシーケンス番号は、累積的に受信機によって承認された場合、送信フローは完了です。最終シーケンス番号FSNからすべてのシーケンス番号が受信されたときに受信フローが完了する。それぞれの端部での流れを送信し、対応する受信フローが遅延または複製フラグメントおよび確認応答が誤って送信新を認める誤っ新しい受信流れを開始又はなしでネットワークから排出することを可能にする時間の予備で終了フローのフロー識別子を保持しますフロー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a flow sender receives a Flow Exception indication from the other end, the flow sender SHOULD close the flow and abandon all of the undelivered queued messages. The flow sender SHOULD indicate an exception to the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー送信者がもう一方の端からのフロー例外の指示を受信した場合は、フロー送信者はフローを終了し、未配信キューに入れられたメッセージのすべてを放棄すべきです。フローの送信者は、ユーザーに例外を示すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2. Sender
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2. 送信者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each sending flow comprises the flow-specific information context necessary to transfer that flow&#39;s messages to the other end. Each sending flow context includes at least:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各送信フローは、他端にそのフローのメッセージを転送するために必要なフロー固有情報コンテキストを含みます。各送信フローコンテキストは、少なくとも、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_FLOW_ID: this flow&#39;s identifier;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O F_FLOW_ID：このフローの識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o STARTUP_OPTIONS: the set of options to send to the receiver until this flow is acknowledged, including the User&#39;s Per-Flow Metadata and, if set, the Return Flow Association;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O STARTUP_OPTIONS：このフローが確認されるまで、ユーザーのフローごとのメタデータと、設定した場合、リターンフロー協会を含め、受信機に送信するためのオプションのセット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEND_QUEUE: the unacknowledged message fragments queued in this flow, initially empty; each message fragment entry comprising the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SEND_QUEUE：このフローにキューイング未確認のメッセージフラグメント、最初は空。以下を含む各メッセージフラグメントエントリ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SEQUENCE_NUMBER: the sequence number of this fragment;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SEQUENCE_NUMBER：このフラグメントのシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DATA: this fragment&#39;s user data;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DATA：このフラグメントのユーザーデータ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* FRA: the fragment control value for this message fragment, having one of the values enumerated for that purpose in Section 2.3.11 (&#34;User Data Chunk&#34;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* FRA：このメッセージフラグメントについてのフラグメント制御値、セクション2.3.11（「ユーザデータチャンク」）で、その目的のために列挙された値の1つを有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* ABANDONED: a boolean flag indicating whether this fragment has been abandoned;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
*放棄：このフラグメントは、放棄されたかどうかを示すブールフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SENT_ABANDONED: a boolean flag indicating whether this fragment was abandoned when sent;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SENT_ABANDONED：送信されたときに、この断片を放棄されたかどうかを示すブールフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EVER_SENT: a boolean flag indicating whether this fragment has been sent at least once, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* EVER_SENT：このフラグメントは偽最初に、少なくとも一回送信されたかどうかを示すブールフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* NAK_COUNT: a count of the number of negative acknowledgements detected for this fragment, initially 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* NAK_COUNT：最初にこのフラグメントについて検出された否定応答の数のカウント、0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* IN_FLIGHT: a boolean flag indicating whether this fragment is currently outstanding, or in flight, in the network, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* IN_FLIGHT：このフラグメントは、現在未処理であるか、または飛行中かどうかを示すブールフラグ、ネットワークに、最初に偽。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* TRANSMIT_SIZE: the size, in bytes, of the encoded User Data chunk (including the chunk header) for this fragment when it was transmitted into the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* TRANSMIT_SIZE：このフラグメントのための（チャンクヘッダを含む）符号化されたユーザーデータチャンクのバイト単位のサイズは、それがネットワークに送信された場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_OUTSTANDING_BYTES: the sum of the TRANSMIT_SIZE of each entry in SEND_QUEUE where entry.IN_FLIGHT is true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F_OUTSTANDING_BYTES O：entry.IN_FLIGHTが真SEND_QUEUEの各エントリのTRANSMIT_SIZEの和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RX_BUFFER_SIZE: the most recent available buffer advertisement from the other end (Sections 2.3.13 and 2.3.14), initially 65536 bytes;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RX_BUFFER_SIZE：もう一方の端から最新の利用可能なバッファ広告（セクション2.3.13および2.3.14）、最初は65536バイト。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NEXT_SN: the next sequence number to assign to a message fragment, initially 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O NEXT_SN：最初は1、メッセージフラグメントに割り当てる次のシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o F_FINAL_SN: the sequence number assigned to the final message fragment of the flow, initially having no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O F_FINAL_SN：最初は値を持たない、流れの最終メッセージフラグメントに割り当てられたシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCEPTION: a boolean flag indicating whether an exception has been reported by the receiver, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O EXCEPTION：例外が偽最初に、受信機によって報告されているかどうかを示すブールフラグ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state, at any time being one of the following values: the open state F_OPEN; the closing states F_CLOSING and F_COMPLETE_LINGER; and the closed state F_CLOSED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いつ次のいずれかの値である時、状態O：オープン状態F_OPEN。クローズ状態F_CLOSINGとF_COMPLETE_LINGER。そして、閉状態がF_CLOSED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：以下の図は、状態遷移とその原因となるイベントの概要だけで、完全な動作仕様ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                 +--------+
                                 | F_OPEN |
                                 +--------+
                                      |CLOSE or
                                      |rcv Flow Exception
                                      |
                                      v
                                 +---------+
                                 |F_CLOSING|
                                 +---------+
                                      |rcv Data Ack
                                      |  0..F_FINAL_SN
                                      v
                             +-----------------+
                             |F_COMPLETE_LINGER|
                             +-----------------+
                                      | 130 seconds
                                      v
                                  +--------+
                                  |F_CLOSED|
                                  +--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 19: Sending Flow State Diagram
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図19：フロー状態図を送信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.1. Startup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.1。起動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application opens a new sending flow to the other end in an S_OPEN session. The implementation chooses a new flow ID that is not assigned to any other sending flow in that session in the F_OPEN, F_CLOSING, or F_COMPLETE_LINGER states. The flow starts in the F_OPEN state. The STARTUP_OPTIONS for the new flow is set with the User&#39;s Per-Flow Metadata (Section 2.3.11.1.1). If this flow is in return (or response) to a receiving flow from the other end, that flow&#39;s ID is encoded in a Return Flow Association (Section 2.3.11.1.2) option and added to STARTUP_OPTIONS. A new sending flow SHOULD NOT be opened in response to a receiving flow from the other end that is not in the RF_OPEN state when the sending flow is opened.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションはS_OPENセッション内の他の最後に新しい送信の流れを開きます。実装はF_OPEN、F_CLOSING、またはF_COMPLETE_LINGER状態で、そのセッション内の他の送信フローに割り当てられていない新しいフローIDを選択します。流れはF_OPEN状態で起動します。新しいフローのためのSTARTUP_OPTIONSは、ユーザーのフローごとのメタデータ（セクション2.3.11.1.1）で設定されています。この流れは、もう一方の端からの受信の流れに戻る（または応答）にある場合は、そのフローのIDは、リターンフロー協会（セクション2.3.11.1.2）オプションでエンコードし、STARTUP_OPTIONSに追加されます。新しい送信フローは、送信フローが開かれたときRF_OPEN状態ではないもう一方の端からの受信の流れに応じて開かないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, the flow exists in the sender but not in the receiver. The flow begins when user data fragments are transmitted to the receiver. A sender can begin a flow in the absence of immediate user data by sending a Forward Sequence Number Update (Section 3.6.2.7.1), by queuing and transmitting a user data fragment that is already abandoned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この時点で、流れは、送信者ではなく、受信機に存在します。ユーザデータの断片が受信機に送信されたときにフローが開始されます。送信者は、キューイング、すでに放棄されたユーザデータの断片を送信することにより、転送シーケンス番号の更新（セクション3.6.2.7.1）を送信することによって直ちにユーザデータが存在しない場合のフローを開始することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.2. Queuing Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.2。キューイングデータ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application queues messages in an F_OPEN sending flow for transmission to the far end. The implementation divides each message into one or more fragments for transmission in User Data chunks (Section 2.3.11). Each fragment MUST be small enough so that, if assembled into a packet (Section 2.2.4) with a maximum-size common header, User Data chunk header, and, if not empty, this flow&#39;s STARTUP_OPTIONS, the packet will not exceed the path MTU (Section 3.5.4.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
アプリケーションは、遠端に送信するための流れを送るF_OPENでメッセージをキューに入れます。実装は、ユーザデータのチャンクで送信するための1つの以上のフラグメント（セクション2.3.11）に各メッセージを分割します。各断片は、最大サイズの共通ヘッダ、ユーザデータチャンクヘッダとなるように、パケットに組み立てられた場合（セクション2.2.4）に十分小さくなければならない、そして、空でない場合は、このフローのSTARTUP_OPTIONS、パケットはパスを超えませんMTU（セクション3.5.4.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each fragment, create a fragment entry and set fragmentEntry.SEQUENCE_NUMBER to flow.NEXT_SN, and increment flow.NEXT_SN by one. Set fragmentEntry.FRA according to the encoding in User Data chunks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各断片について、断片エントリを作成し、flow.NEXT_SNにfragmentEntry.SEQUENCE_NUMBERを設定し、いずれかによってflow.NEXT_SNをインクリメントします。ユーザーデータのチャンクでエンコーディングに従ってfragmentEntry.FRA設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0: This fragment is a complete message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0：このフラグメントは、完全なメッセージです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1: This fragment is the first of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1：このフラグメントは、マルチ断片メッセージの最初のものです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2: This fragment is the last of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2：このフラグメントは、マルチ断片メッセージの最後です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3: This fragment is in the middle of a multi-fragment message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3：このフラグメントは、マルチ断片メッセージの真ん中にあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Append fragmentEntry to flow.SEND_QUEUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flow.SEND_QUEUEにfragmentEntryを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3. Sending Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3。データの送信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sending flow is ready to transmit if the SEND_QUEUE contains at least one entry that is eligible to send, and if either RX_BUFFER_SIZE is greater than F_OUTSTANDING_BYTES or EXCEPTION is set to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローはSEND_QUEUEを送信するために資格がある少なくとも1つのエントリが含まれている場合に送信する準備ができている、とのいずれかRX_BUFFER_SIZEがF_OUTSTANDING_BYTESより大きい場合、または例外がtrueに設定されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SEND_QUEUE entry is eligible to send if it is not IN_FLIGHT, AND at least one of the following conditions holds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEND_QUEUEエントリは、それがIN_FLIGHTない場合に送信する資格があるし、次の条件のうちの少なくとも1つが成り立ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The entry is not ABANDONED; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oエントリが放棄されていません。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The entry is the first one in the SEND_QUEUE; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OエントリはSEND_QUEUEにおける最初のものです。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The entry&#39;s SEQUENCE_NUMBER is equal to flow.F_FINAL_SN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OエントリのSEQUENCE_NUMBERはflow.F_FINAL_SNに等しいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the session&#39;s transmission budget allows, a flow that is ready to transmit is selected for transmission according to the implementation&#39;s prioritization scheme. The manner of flow prioritization is not mandated by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションの伝送予算が許すならば、送信する準備ができている流れは、実装の優先順位付け方式による伝送のために選択されています。フロー優先順位付けの方法は、本明細書で義務付けられていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Trim abandoned messages from the front of the queue, and find the Forward Sequence Number (FSN):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
キューの先頭から捨てられたメッセージをトリム、およびフォワードシーケンス番号（FSN）を見つけます：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. While the SEND_QUEUE contains at least two entries, AND the first entry is not IN_FLIGHT, AND the first entry is ABANDONED, remove and discard the first entry from the SEND_QUEUE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. SEND_QUEUEは、少なくとも2つのエントリを含むが、最初のエントリはIN_FLIGHTではなく、最初のエントリを削除し、SEND_QUEUEから最初のエントリを破棄し、破棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the first entry in the SEND_QUEUE is not abandoned, set FSN to entry.SEQUENCE_NUMBER - 1; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. SEND_QUEUEの最初のエントリが放棄されていない場合、entry.SEQUENCE_NUMBERにFSNを設定 -  1。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the first entry in the SEND_QUEUE is IN_FLIGHT, AND entry.SENT_ABANDONED is false, set FSN to entry.SEQUENCE_NUMBER - 1; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. SEND_QUEUEの最初のエントリがIN_FLIGHTで、entry.SENT_ABANDONEDがfalseの場合、entry.SEQUENCE_NUMBERにFSNを設定 -  1。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The first entry in the SEND_QUEUE is abandoned and either is not IN_FLIGHT or was already abandoned when sent; set FSN to entry.SEQUENCE_NUMBER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. SEND_QUEUEの最初のエントリは、放棄されたいずれかIN_FLIGHTないか、または送信されたときに既に放棄しています。 entry.SEQUENCE_NUMBERにFSNを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FSN MUST NOT be greater than any sequence number currently outstanding. The FSN MUST NOT be equal to any sequence number currently outstanding that was not abandoned when sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FSNは現在、優れた任意のシーケンス番号よりも大きくすることはできません。 FSNは、送信されたときに放棄されていなかった、現在未解決の任意のシーケンス番号と同じにすることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assemble user data chunks for this flow into a packet to send to the receiver. While enough space remains in the packet and the flow is ready to transmit:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機に送信するパケットには、この流れのためのユーザ・データ・チャンクを組み立てます。十分なスペースは、パケットに残り、流れは、送信する準備ができているものの：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Starting at the head of the SEND_QUEUE, find the first eligible fragment entry;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. SEND_QUEUEの先頭から開始し、最初の適格なフラグメントエントリを見つけます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Encode the entry into a User Data chunk (Section 2.3.11) or, if possible (Section 3.6.2.3.2), a Next User Data chunk (Section 2.3.12);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.ユーザデータチャンク（セクション2.3.11）へのエントリまたは、可能な場合（セクション3.6.2.3.2）、次のユーザデータチャンク（セクション2.3.12）をコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. If present, set chunk.flowID to flow.F_FLOW_ID;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.存在する場合、chunk.flowIDはflow.F_FLOW_IDに設定。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. If present, set chunk.sequenceNumber to entry.SEQUENCE_NUMBER;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.存在する場合、chunk.sequenceNumberはentry.SEQUENCE_NUMBERに設定します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. If present, set chunk.fsnOffset to entry.SEQUENCE_NUMBER - FSN;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.存在する場合、chunk.fsnOffsetはentry.SEQUENCE_NUMBERに設定 -  FSN。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Set chunk.fragmentControl to entry.FRA;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
entry.FRA 6.設定chunk.fragmentControl。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Set chunk.abandon to entry.ABANDONED;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
entry.ABANDONEDに設定7. chunk.abandon。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. If entry.SEQUENCE_NUMBER equals flow.F_FINAL_SN, set chunk.final to true; else set chunk.final to false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. entry.SEQUENCE_NUMBERはflow.F_FINAL_SNに等しい場合は、trueに設定しchunk.final。それ以外の場合はfalseに設定しchunk.final。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. If any options are being sent with this chunk, set chunk.optionsPresent to true, assemble the options into the chunk, and assemble a Marker to terminate the option list;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9.すべてのオプションは、このチャンクで送信されている場合は、チャンクにオプションを組み立て、そしてオプションリストを終了するマーカーを組み立て、trueにchunk.optionsPresentを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   10.  If entry.ABANDONED is true, set chunk.userData to empty;
        otherwise, set chunk.userData to entry.DATA;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. If adding the assembled chunk to the packet would cause the packet to exceed the path MTU, do not assemble this chunk into the packet; enough space no longer remains in the packet; stop. Otherwise, continue:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11.パケットに組み立てられたチャンクを追加することで、パケットにこのチャンクを組み立てていない、パスMTUを超過するパケットを起こした場合、十分なスペースは、もは​​やパケット内に残っていません。やめる。それ以外の場合は、継続します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Set entry.IN_FLIGHT to true;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
trueに設定する12. entry.IN_FLIGHT。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Set entry.EVER_SENT to true;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
trueに設定する13. entry.EVER_SENT。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Set entry.NAK_COUNT to 0;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
0 14.設定entry.NAK_COUNT。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Set entry.SENT_ABANDONED to entry.ABANDONED;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
entry.ABANDONEDにentry.SENT_ABANDONED 15セット。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16. Set entry.TRANSMIT_SIZE to the size of the assembled chunk, including the chunk header;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
チャンクヘッダーを含む組み立てられたチャンクのサイズに16を設定entry.TRANSMIT_SIZE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Assemble this chunk into the packet; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17パケットにこのチャンクをアセンブル。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
18. If this flow or entry is considered Time Critical (real-time), set the timeCritical flag in the packet header (Section 2.2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
18.このフローまたはエントリがタイムクリティカル（リアルタイム）であると考えられる場合、パケットヘッダ（セクション2.2.4）にtimeCriticalフラグを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Complete any other appropriate packet processing, and transmit the packet to the far end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任意の他の適切なパケット処理を完了し、遠端にパケットを送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3.1. Startup Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3.1。起動オプション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If STARTUP_OPTIONS is not empty, then when assembling the FIRST User Data chunk for this flow into a packet, add the encoded STARTUP_OPTIONS to that chunk&#39;s option list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STARTUP_OPTIONSが空でない場合、パケットには、この流れのための最初のユーザデータチャンクを組み立てる際に、そして、そのチャンクのオプションリストにエンコードSTARTUP_OPTIONSを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3.2. Send Next Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.3.2。次のデータを送信します
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Next User Data chunk (Section 2.3.12) is a compact encoding for a user message fragment when multiple contiguous fragments are assembled into one packet. Using this chunk where possible can conserve space in a packet, potentially reducing transmission overhead or allowing additional information to be sent in a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のユーザデータチャンク（セクション2.3.12）は、複数の連続したフラグメントが1つのパケットに組み立てられるユーザメッセージフラグメントのためのコンパクトな符号化です。可能な場合、このチャンクを使用すると、潜在的に送信オーバーヘッドを低減または追加情報がパケットで送信できるように、パケット内のスペースを節約することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If, after assembling a user message fragment of a flow into a packet (Section 3.6.2.3), the next eligible fragment to be selected for assembly into that packet belongs to the same flow, AND its sequence number is one greater than that of the fragment just assembled, it is RECOMMENDED that an implementation encode a Next User Data chunk instead of a User Data chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
、パケット（セクション3.6.2.3）への流れのユーザメッセージフラグメントを組み立てた後、次の対象断片がそのパケットに組み立てのために選択される場合、同じフローに属し、そのシーケンス番号がよりも1大きいです断片は、実装は次のユーザデータチャンクの代わりにユーザデータチャンクをエンコードすることが推奨され、組み立てられました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FIRST fragment of a flow assembled into a packet MUST be encoded as a User Data chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットに組み立てフローの最初の断片は、ユーザデータチャンクとして符号化されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.4. Processing Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.4。処理謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Data Acknowledgement Bitmap chunk (Section 2.3.13) or a Data Acknowledgement Ranges chunk (Section 2.3.14) encodes the acknowledgement of receipt of one or more sequence numbers of a flow, as well as the receiver&#39;s current receive window advertisement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ確認応答ビットマップチャンク（セクション2.3.13）またはデータ肯定応答は、チャンク（セクション2.3.14）は、1つ又は複数の流れのシーケンス番号、ならびに受信機の現在の受信ウィンドウ広告の受信の肯定応答を符号化する範囲です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of an acknowledgement chunk for a sending flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローに対する肯定応答のチャンクを受信します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Set PRE_ACK_OUTSTANDING_BYTES to flow.F_OUTSTANDING_BYTES;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
flow.F_OUTSTANDING_BYTES 1.設定PRE_ACK_OUTSTANDING_BYTES。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Set flow.STARTUP_OPTIONS to empty;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
空へ2.設定flow.STARTUP_OPTIONS。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Set flow.RX_BUFFER_SIZE to chunk.bufferBytesAvailable;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
chunk.bufferBytesAvailable 3.設定flow.RX_BUFFER_SIZE。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. For each sequence number encoded in the acknowledgement, if there is an entry in flow.SEND_QUEUE with that sequence number and its IN_FLIGHT is true, then remove the entry from flow.SEND_QUEUE; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そこそのシーケンス番号を持つflow.SEND_QUEUEのエントリがあり、そのIN_FLIGHTが真である場合、次いでflow.SEND_QUEUEからエントリを削除し、肯定応答でエンコードされた各シーケンス番号4.。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Notify the congestion control and avoidance algorithms that PRE_ACK_OUTSTANDING_BYTES - flow.F_OUTSTANDING_BYTES were acknowledged. Note that negative acknowledgements (Section 3.6.2.5) affect &#34;TCP friendly&#34; congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flow.F_OUTSTANDING_BYTESが確認された -  5 PRE_ACK_OUTSTANDING_BYTES輻輳制御と回避アルゴリズムを通知します。否定応答（セクション3.6.2.5）は、「TCPフレンドリー」輻輳制御に影響を与えることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.5. Negative Acknowledgement and Loss
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.5。否定応答と損失
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A negative acknowledgement is inferred for an outstanding fragment if an acknowledgement is received for any other fragments sent after it in the same session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
肯定応答は、同じセッション内で後に送信される任意の他のフラグメントを受信した場合、否定応答が未処理断片について推定されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation SHOULD consider a fragment to be lost once that fragment receives three negative acknowledgements. A lost fragment is no longer outstanding in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装は、その断片が、3つの否定応答を受信するとフラグメントが失われるために検討すべきです。失われたフラグメントは、もはや優れたネットワークではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes an OPTIONAL method for detecting negative acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、否定応答を検出するための任意の方法を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session track the order in which fragments are transmitted across all its sending flows by way of a monotonically increasing Transmission Sequence Number (TSN) recorded with each fragment queue entry each time that fragment is transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッションは、フラグメントは、各フラグメントキューエントリとフラグメントが送信されるたびに記録された単調増加送信シーケンス番号（TSN）の方法によって、すべての送信のフローを介して送信される順序を追跡してみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain additional variables:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報のコンテキストは、追加の変数が含まれてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NEXT_TSN: the next TSN to record with a fragment&#39;s queue entry when it is transmitted, initially 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O NEXT_TSN：それが送信されると、最初は1、フラグメントのキューエントリを記録するために次のTSN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MAX_TSN_ACK: the highest acknowledged TSN, initially 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAX_TSN_ACK O：最高認めTSN、最初は0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let each fragment queue entry contain an additional variable TSN, initially 0, to track its transmission order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各フラグメントのキュー・エントリは、その送信順序を追跡するために、最初は0、追加の変数TSNを含んでいましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On transmission of a message fragment into the network, set its entry.TSN to session.NEXT_TSN, and increment session.NEXT_TSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ネットワークへのメッセージフラグメントの送信に、session.NEXT_TSNへのentry.TSNを設定し、session.NEXT_TSNをインクリメントします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On acknowledgement of an outstanding fragment, if its entry.TSN is greater than session.MAX_TSN_ACK, set session.MAX_TSN_ACK to entry.TSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未処理断片の確認応答に、そのentry.TSNはsession.MAX_TSN_ACKより大きい場合、entry.TSNにsession.MAX_TSN_ACKを設定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After processing all acknowledgements in a packet containing at least one acknowledgement, then for each sending flow in that session, for each entry in that flow&#39;s SEND_QUEUE, if entry.IN_FLIGHT is true and entry.TSN is less than session.MAX_TSN_ACK, increment entry.NAK_COUNT and notify the congestion control and avoidance algorithms that a negative acknowledgement was detected in this packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
entry.IN_FLIGHTが真であるとentry.TSNがsession.MAX_TSN_ACK未満である場合に少なくとも一つの肯定応答を含むパケット内のすべての肯定応答を処理した後、そのセッション内の各送信フローについて、そのフローのSEND_QUEUEの各エントリについて、エントリをインクリメント。否定応答は、このパケットで検出された輻輳制御と回避アルゴリズムをNAK_COUNTと通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each sending flow in that session, for each entry in that flow&#39;s SEND_QUEUE, if entry.IN_FLIGHT is true and entry.NAK_COUNT is at least 3, that fragment was lost in the network and is no longer considered to be in flight. Set entry.IN_FLIGHT to false. Notify the congestion control and avoidance algorithms of the loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
entry.IN_FLIGHTが真であるとentry.NAK_COUNTは少なくとも3である場合、そのセッション内の各送信の流れについて、その流れのSEND_QUEUEの各エントリのために、その断片がネットワークで失われなかったし、もはや飛行中であると考えられています。 falseにentry.IN_FLIGHTを設定します。輻輳制御と損失の回避アルゴリズムを通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.6. Timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.6。タイムアウト
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A fragment is considered lost and no longer in flight in the network if it has remained outstanding for at least ERTO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは、少なくともERTOのために優れ残っている場合はフラグメントは、ネットワーク内の飛行中、もはや失われたと考えられていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes an OPTIONAL method to manage transmission timeouts. This method REQUIRES that either burst avoidance (Section 3.5.2.3) is implemented or the implementation&#39;s congestion control and avoidance algorithms will eventually stop sending new fragments into the network if acknowledgements are persistently not received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、送信のタイムアウトを管理するための任意の方法を説明します。この方法では、バースト回避（セクション3.5.2.3）のいずれかが実装されているか、実装の輻輳制御と回避アルゴリズムは、最終的に確認応答が永続的に受信されない場合、ネットワークに新たなフラグメントの送信を停止することを必要とします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain an alarm TIMEOUT_ALARM, initially unset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報のコンテキストが最初に設定解除、警報TIMEOUT_ALARMが含まれてみましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On sending a packet containing at least one User Data chunk, set or reset TIMEOUT_ALARM to fire in ERTO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも1つのユーザデータチャンクを含むパケットを送信するには、設定またはERTOに発射するTIMEOUT_ALARMをリセットします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving a packet containing at least one acknowledgement, reset TIMEOUT_ALARM (if already set) to fire in ERTO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも一つの肯定応答を含むパケットを受信すると、ERTOに発射するためにTIMEOUT_ALARMを（既に設定されている場合）にリセット。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When TIMEOUT_ALARM fires:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ときTIMEOUTアラーム火災：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Set WAS_LOSS = false;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.設定WAS_LOSS =偽;
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. For each sending flow in the session, and for each entry in that flow&#39;s SEND_QUEUE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各送信セッション中に流れ、その流れのSEND_QUEUEの各エントリの2.：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. If entry.IN_FLIGHT is true, set WAS_LOSS = true; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. entry.IN_FLIGHTがtrueの場合、真WAS_LOSS =を設定します。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Set entry.IN_FLIGHT to false.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
falseに設定する2. entry.IN_FLIGHT。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. If WAS_LOSS is true, perform ERTO backoff (Section 3.5.2.2); and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. WAS_LOSSがtrueの場合、ERTOバックオフ（セクション3.5.2.2）を行います。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Notify the congestion control and avoidance algorithms of the timeout and, if WAS_LOSS is true, that there was loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.損失があったこと、WAS_LOSSが真である場合、タイムアウトの輻輳制御と回避アルゴリズムを通知し。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.7. Abandoning Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.7。データを放棄
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application can abandon queued messages at any time and for any reason. Example reasons include (but are not limited to) the following: one or more fragments of a message have remained in the SEND_QUEUE for longer than a specified message lifetime; a fragment has been retransmitted more than a specified retransmission limit; a prior message on which this message depends (such as a key frame in a prediction chain) was abandoned and not delivered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
放棄することができるアプリケーションは、いつでも、いかなる理由でメッセージをキューに入れられました。例示的な理由は、以下のものが挙げられる（これらに限定されない）：メッセージの1つのまたは複数のフラグメントが指定されたメッセージの有効期間よりも長くSEND_QUEUEに残っています。フラグメントは、指定された再送信の制限を超えて再送されています。このメッセージは、（例えば、予測チェーンのキーフレームのように）依存する前にメッセージを破棄し、配信されませんでした。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To abandon a message fragment, set its SEND_QUEUE entry&#39;s ABANDON flag to true. When abandoning a message fragment, abandon all fragments of the message to which it belongs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージフラグメントを放棄するには、trueにSEND_QUEUEエントリのABANDONフラグを設定します。メッセージフラグメントを放棄する場合、それが属するメッセージの全ての断片を放棄。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An abandoned fragment MUST NOT be un-abandoned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
捨てられた断片は、非放棄しているはずがありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.7.1. Forward Sequence Number Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.7.1。フォワードシーケンス番号を更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Abandoned data may leave gaps in the sequence number space of a flow. Gaps may cause the receiver to hold completely received messages for ordered delivery to allow for retransmission of the missing fragments. User Data chunks (Section 2.3.11) encode a Forward Sequence Number (FSN) to instruct the receiver that fragments with sequence numbers less than or equal to the FSN will not be transmitted or retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
放棄されたデータフローのシーケンス番号空間のギャップを残すことができます。ギャップは、受信機が行方不明の断片の再送信を可能にするよう命じ配信のための完全に受信したメッセージを保持する可能性があります。ユーザデータチャンク（セクション2.3.11）は、送信または再送信されないFSN以下のシーケンス番号を有する断片レシーバを指示する転送シーケンス番号（FSN）をコードします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the receiver has gaps in the received sequence number space and no non-abandoned message fragments remain in the SEND_QUEUE, the sender SHOULD transmit a Forward Sequence Number Update (FSN Update) comprising a User Data chunk marked abandoned, whose sequence number is the FSN and whose fsnOffset is 0. An FSN Update allows the receiver to skip gaps that will not be repaired and deliver received messages to the user. An FSN Update may be thought of as a transmission or retransmission of abandoned sequence numbers without actually sending the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機は、受信したシーケンス番号空間のギャップを有し、全く非放棄メッセージフラグメントがSEND_QUEUEに残っていない場合、送信側はシーケンス番号FSNである放棄されたマークされたユーザデータチャンクを含むフォワードシーケンス番号を更新（FSN更新）を送信しなければなりませんそして、そのfsnOffset 0であるFSN更新が修復されないギャップをスキップして、ユーザに受信したメッセージを配信するレシーバを可能にします。 FSN更新は、実際にデータを送信せずに放棄されたシーケンス番号の送信または再送信と考えることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The method described in Section 3.6.2.3 (&#34;Sending Data&#34;) generates FSN Updates when appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.6.2.3（「データ送信」）に記載された方法は、適切な場合FSN更新を生成します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.8. Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.8。例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    Sender
      |                   :
    1 |&lt;---  Ack  ID=2, seq:0-16
    2 |---&gt;  Data ID=2, seq#=25, fsnOff=9 (fsn=16)
    3 |---&gt;  Data ID=2, seq#=26, fsnOff=10 (fsn=16)
    4 |&lt;---  Ack  ID=2, seq:0-18
    5 |---&gt;  Data ID=2, seq#=27, fsnOff=9 (fsn=18)
    6 |---&gt;  Data ID=2, seq#=28, fsnOff=10 (fsn=18)
      |                   :
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are 9 sequence numbers in flight with delayed acknowledgements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遅延確認応答と飛行中の9つのシーケンス番号があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Figure 20: Normal Flow with No Loss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
図20：損失なしに通常フロー
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
    Sender
      |                   :
    1 |&lt;---  Ack  ID=3, seq:0-30
    2 |---&gt;  Data ID=3, seq#=45, fsnOff=15 (fsn=30)
    3 |&lt;---  Ack  ID=3, seq:0-30, 32 (nack 31:1)
    4 |---&gt;  Data ID=3, seq#=46, fsnOff=16 (fsn=30)
    5 |&lt;---  Ack  ID=3, seq:0-30, 32, 34 (nack 31:2, 33:1)
    6 |&lt;---  Ack  ID=3, seq:0-30, 32, 34-35 (nack 31:3=lost, 33:2)
    7 |---&gt;  Data ID=3, seq#=47, fsnOff=15 (fsn=32, abandon 31)
    8 |&lt;---  Ack  ID=3, seq:0-30, 32, 34-36 (nack 33:3=lost)
    9 |---&gt;  Data ID=3, seq#=33, fsnOff=1 (fsn=32, retransmit 33)
   10 |&lt;---  Ack  ID=3, seq:0-30, 32, 34-37
   11 |---&gt;  Data ID=3, seq#=48, fsnOff=16 (fsn=32)
      |                   :
      |      (continues through seq#=59)
      |                   :
   12 |---&gt;  Data ID=3, seq#=60, fsnOff=28(fsn=32)
   13 |&lt;---  Ack  ID=3, seq:0-30, 34-46
   14 |---&gt;  Data ID=3, seq#=61, fsnOff=29 (fsn=32)
   15 |&lt;---  Ack  ID=3, seq:0-32, 34-47
   16 |---&gt;  Data ID=3, seq#=62, fsnOff=30 (fsn=32)
   17 |&lt;---  Ack  ID=3, seq:0-47
   18 |---&gt;  Data ID=3, seq#=63, fsnOff=16 (fsn=47)
   19 |&lt;---  Ack  ID=3, seq:0-49
   20 |---&gt;  Data ID=3, seq#=64, fsnOff=15 (fsn=49)
      |                   :
   21 |&lt;---  Ack  ID=3, seq:0-59
   22 |&lt;---  Ack  ID=3, seq:0-59, 61 (nack 60:1)
   23 |&lt;---  Ack  ID=3, seq:0-59, 61-62 (nack 60:2)
   24 |&lt;---  Ack  ID=3, seq:0-59, 61-63 (nack 60:3=lost)
   25 |---&gt;  Data ID=3, ABN=1, seq#=60, fsnOff=0 (fsn=60, abandon 60)
   26 |&lt;---  Ack  ID=3, seq:0-59, 61-64
      |                   :
   27 |&lt;---  Ack  ID=3, seq:0-64
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flow with sequence numbers 31, 33, and 60 lost in transit, and a pause at 64. 33 is retransmitted; 31 and 60 are abandoned. Note that line 25 is a Forward Sequence Number Update (Section 3.6.2.7.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配列番号31、33、及び輸送中に失われた60、及び再送信される64 33で休止して流れます。 31と60は放棄されています。そのライン25は、フォワードシーケンス番号の更新（セクション3.6.2.7.1）であることに注意してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
Figure 21: Flow with Loss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
図21：損失と流れ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.9. Flow Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.9。フロー制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver advertises the amount of new data it&#39;s willing to accept from the flow sender with the bufferBytesAvailable derived field of an acknowledgement (Sections 2.3.13 and 2.3.14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、肯定応答（セクション2.3.13および2.3.14）のbufferBytesAvailable由来フィールドにフロー送信者から受け入れるの新しいデータの量をアドバタイズ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow sender MUST NOT send new data into the network if flow.F_OUTSTANDING_BYTES is greater than or equal to the most recently received buffer advertisement, unless flow.EXCEPTION is true (Section 3.6.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flow.EXCEPTION（セクション3.6.2.3）が真でなければflow.F_OUTSTANDING_BYTESは、最後に受信バッファ広告以上であれば、フローの送信者は、ネットワークに新たなデータを送ってはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.9.1. Buffer Probe
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.9.1。バッファプローブ
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow sender is suspended if the most recently received buffer advertisement is zero and the flow hasn&#39;t been rejected by the receiver -- that is, while RX_BUFFER_SIZE is zero AND EXCEPTION is false. To guard against potentially lost acknowledgements that might reopen the receive window, a suspended flow sender SHOULD send a packet comprising a Buffer Probe chunk (Section 2.3.15) for this flow from time to time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RX_BUFFER_SIZEがゼロであると例外が偽である間、である - 最後に受信バッファの広告がゼロで、流れがレシーバによって拒否されていない場合、フロー送信者が中断されます。受信ウィンドウを再度開く可能性がある潜在的に失われた確認応答を防ぐために、一時停止フローの送信者は、随時、この流れのためのバッファプローブチャンク（セクション2.3.15）を含むパケットを送信すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the receive window advertisement transitions from non-zero to zero, the flow sender MAY send a Buffer Probe immediately and SHOULD send a probe within one second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ゼロに非ゼロからウィンドウ広告遷移を受け取った場合は、フローの送信者は、直ちにバッファプローブを送信することと、1秒以内のプローブを送るべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial period between Buffer Probes SHOULD be at least one second or ERTO, whichever is greater. The period between probes SHOULD increase over time, but the period between probes SHOULD NOT be more than one minute or ERTO, whichever is greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファプローブ間の初期の期間は、大きい方の少なくとも一つの第二又はERTOでなければなりません。プローブ間の期間は、時間の経過と共に増加するはずであるが、プローブ間の期間は、いずれか大きい方を超える1分ERTO、すべきではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow sender SHOULD stop sending Buffer Probes if it is no longer suspended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはもはや中断された場合、フロー送信者はバッファプローブの送信を停止してはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.10. Exception
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.10。例外
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver can reject the flow at any time and for any reason. The flow receiver sends a Flow Exception Report (Section 2.3.16) when it has rejected a flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、いつでも、いかなる理由で流れを拒否することができます。フロー受信機は、それが流れを拒否したフロー例外レポート（セクション2.3.16）を送信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receiving a Flow Exception Report for a sending flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローのためのフロー例外レポートを受信します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the flow is F_OPEN, close the flow (Section 3.6.2.11) and notify the user that the far end reported an exception with the encoded exception code;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.フローがF_OPEN場合、遠端が符号化された例外コードに例外を報告することを流れ（セクション3.6.2.11）を閉じて、ユーザに通知します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Set the EXCEPTION flag to true; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.真の例外フラグを設定します。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. For each entry in SEND_QUEUE, set entry.ABANDONED = true.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
SEND_QUEUE内の各エントリについて3. entry.ABANDONED = trueを設定します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.11. Close
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.2.11。閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sending flow is closed by the user or as a result of an exception. To close an F_OPEN flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローは、ユーザによってまたは例外の結果として閉じられています。 F_OPENの流れを閉じるには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Move to the F_CLOSING state;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F_CLOSING状態1.移動し、
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the SEND_QUEUE is not empty, AND the tail entry of the SEND_QUEUE has a sequence number of NEXT_SN - 1, AND the tail entry.EVER_SENT is false, set F_FINAL_SN to entry.SEQUENCE_NUMBER; else
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. SEND_QUEUEは空ではなく、SEND_QUEUEの尾エントリはNEXT_SNのシーケンス番号がある場合は -  1を、テールentry.EVER_SENTが偽で、entry.SEQUENCE_NUMBERにF_FINAL_SNを設定します。他
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The SEND_QUEUE is empty, OR the tail entry does not have a sequence number of NEXT_SN - 1, OR the tail entry.EVER_SENT is true: enqueue a new SEND_QUEUE entry with entry.SEQUENCE_NUMBER = flow.NEXT_SN, entry.FRA = 0, and entry.ABANDONED = true, and set flow.F_FINAL_SN to entry.SEQUENCE_NUMBER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. SEND_QUEUEは空で、OR尾エントリはNEXT_SNのシーケンス番号がありません -  1を、ORテールentry.EVER_SENTが真である：entry.SEQUENCE_NUMBER = flow.NEXT_SN、entry.FRA = 0で新しいSEND_QUEUEエントリをエンキュー、およびentry.ABANDONED =真、およびentry.SEQUENCE_NUMBERにflow.F_FINAL_SNを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An F_CLOSING sending flow is complete when its SEND_QUEUE transitions to empty, indicating that all sequence numbers, including the FINAL_SN, have been acknowledged by the other end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのSEND_QUEUE遷移が空にするときの流れを送るF_CLOSINGはFINAL_SNを含むすべてのシーケンス番号が、もう一方の端に認知されていることを示す、完了です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an F_CLOSING sending flow becomes complete, move to the F_COMPLETE_LINGER state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
F_CLOSING送信の流れが完全になると、F_COMPLETE_LINGER状態に移行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sending flow MUST remain in the F_COMPLETE_LINGER state for at least 130 seconds. After at least 130 seconds, move to the F_CLOSED state. The sending flow is now closed, its resources can be reclaimed, and its F_FLOW_ID MAY be used for a new sending flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信フローは、少なくとも130秒間F_COMPLETE_LINGER状態のままにしなければなりません。少なくとも130秒後、F_CLOSED状態に移行します。送信フローは終了いたしました、そのリソースを再利用することができ、そしてそのF_FLOW_IDは新しい送信フローのために使用されるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3. Receiver
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3. 受信機
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each receiving flow comprises the flow-specific information context necessary to receive that flow&#39;s messages from the sending end and deliver completed messages to the user. Each receiving flow context includes at least:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
各受信フローは、送信端からそのフローのメッセージを受信し、ユーザに完了メッセージを配信するために必要なフロー固有情報コンテキストを含みます。各受信フローコンテキストを少なくとも含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RF_FLOW_ID: this flow&#39;s identifier;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RF_FLOW_ID：このフローの識別子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SEQUENCE_SET: the set of all fragment sequence numbers seen in this receiving flow, whether received or abandoned, initially empty;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SEQUENCE_SET：この受信フローに見られる全てのフラグメントシーケンス番号のセット、受信または放棄されたかどうか、最初は空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RF_FINAL_SN: the final fragment sequence number of the flow, initially having no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入出力RF_FINAL_SN：フローの最終的な断片のシーケンス番号は、最初は値を持ちません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RECV_BUFFER: the message fragments waiting to be delivered to the user, sorted by sequence number in ascending order, initially empty; each message fragment entry comprising the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O RECV_BUFFER：メッセージフラグメントが空最初に、昇順のシーケンス番号によってソートされ、ユーザに配信されるのを待っています。以下を含む各メッセージフラグメントエントリ：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SEQUENCE_NUMBER: the sequence number of this fragment;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SEQUENCE_NUMBER：このフラグメントのシーケンス番号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DATA: this fragment&#39;s user data; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* DATA：このフラグメントのユーザーデータ。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* FRA: the fragment control value for this message fragment, having one of the values enumerated for that purpose in Section 2.3.11 (&#34;User Data Chunk&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* FRA：このメッセージフラグメントについてのフラグメント制御値、セクション2.3.11（「ユーザデータチャンク」）で、その目的のために列挙された値の1つを有します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BUFFERED_SIZE: the sum of the lengths of each fragment in RECV_BUFFER plus any additional storage overhead for the fragments incurred by the implementation, in bytes;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O BUFFERED_SIZE：RECV_BUFFERの各断片の長さの合計を加えたバイト数、実装によって生じた断片のための任意の追加のストレージオーバーヘッド。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BUFFER_CAPACITY: the desired maximum size for the receive buffer, in bytes;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O BUFFER_CAPACITY：バッファを受信するための所望の最大サイズ（バイト単位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PREV_RWND: the most recent receive window advertisement sent in an acknowledgement, in 1024-byte blocks, initially having no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PREV_RWND：最新のは最初は値を持たない、1024バイトのブロックで、確認応答で送信されたウィンドウ広告を受け取ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SHOULD_ACK: whether or not an acknowledgement should be sent for this flow, initially false;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O SHOULD_ACK：確認応答がこの流れのために送られるべきかどうか、最初はfalse;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o EXCEPTION_CODE: the exception code to report to the sender when the flow has been rejected, initially 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O EXCEPTION_CODE：フローが拒否されたとき、送信者に報告する例外コード、最初は0;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state, at any time being one of the following values: the open state RF_OPEN; the closing states RF_REJECTED and RF_COMPLETE_LINGER; and the closed state RF_CLOSED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次の値のいずれかである任意の時点で、状態O：オープン状態RF_OPENと、クローズ状態RF_REJECTEDとRF_COMPLETE_LINGER。そして、閉状態がRF_CLOSED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：以下の図は、状態遷移とその原因となるイベントの概要だけで、完全な動作仕様ではありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                                       +-+
                                       |X|
                                       +-+
                                        |rcv User Data for
                                        |  no existing flow
                                        v
                                   +---------+
                                   | RF_OPEN |
                                   +---------+
              rcv all sequence numbers|   |user reject,
                      0..RF_FINAL_SN  |   |rcv bad option,
                                      |   |no metadata at open,
                                      |   |association specified
                                      |   |  but not F_OPEN at open
                                  +---+   |
                                  |       v
                                  |  +-----------+
                                  |  |RF_REJECTED|
                                  |  +-----------+
                                  |       |rcv all sequence numbers
                                  |       |  0..RF_FINAL_SN
                                  v       v
                             +------------------+
                             |RF_COMPLETE_LINGER|
                             +------------------+
                                      | 120 seconds
                                      v
                                 +---------+
                                 |RF_CLOSED|
                                 +---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 22: Receiving Flow State Diagram
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図22：フロー状態図を受けます
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.1. Startup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.1。起動
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A new receiving flow starts on receipt of a User Data chunk (Section 2.3.11) encoding a flow ID not belonging to any other receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しい受信流れはRF_OPEN、RF_REJECTED、又はRF_COMPLETE_LINGER状態で同じセッション内の他の受信フローに属さないフローIDをコード化ユーザーデータチャンク（セクション2.3.11）の受信時に開始します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of such a User Data chunk:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのようなユーザーデータチャンクを受信します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Set temporary variables METADATA, ASSOCIATED_FLOWID, and ASSOCIATION to each have no value;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.値を持たないそれぞれに一時変数メタデータ、ASSOCIATED_FLOWID、および関連付けを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Create a new receiving flow context in this session, setting its RF_FLOW_ID to the flow ID encoded in the opening User Data chunk, and set to the RF_OPEN state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.開口ユーザデータチャンクに符号化フローIDへのRF_FLOW_IDを設定する、このセッションで新しい受信フローコンテキストを作成し、RF_OPEN状態に設定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the opening User Data chunk encodes a User&#39;s Per-Flow Metadata option (Section 2.3.11.1.1), set METADATA to option.userMetadata;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.オープニングユーザーデータチャンクがユーザーのフロー単位のメタデータオプション（セクション2.3.11.1.1）をコードする場合、option.userMetadataにメタデータを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the opening User Data chunk encodes a Return Flow Association option (Section 2.3.11.1.2), set ASSOCIATED_FLOWID to option.flowID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.オープニングユーザーデータチャンクがリターンフロー協会オプション（セクション2.3.11.1.2）、option.flowIDに設定ASSOCIATED_FLOWIDをコードする場合、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If METADATA has no value, the receiver MUST reject the flow (Section 3.6.3.7), moving it to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前記メタデータが値を持たない場合、受信機はRF_REJECTED状態に移動、流れ（セクション3.6.3.7）を拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If ASSOCIATED_FLOWID has a value, then if there is no sending flow in the same session with a flow ID of ASSOCIATED_FLOWID, the receiver MUST reject the flow, moving it to the RF_REJECTED state; otherwise, set ASSOCIATION to the indicated sending flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASSOCIATED_FLOWID値を有する場合ASSOCIATED_FLOWIDのフローIDと同じセッションには送信フローが存在しない場合6.次いで、受信機はRF_REJECTED状態に移動、流れを拒絶しなければなりません。そうでなければ、示さ送信フローに関連付けを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. If ASSOCIATION indicates a sending flow, AND that sending flow&#39;s state is not F_OPEN, the receiver MUST reject this receiving flow, moving it to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
協会は、送信フローを示しており、送信フローの状態がF_OPENないことならば、受信機はRF_REJECTED状態に移動、この受信フローを拒絶しなければなりません7。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. If the opening User Data chunk encodes any unrecognized option with a type code less than 8192 (Section 2.3.11.1), the receiver MUST reject the flow, moving it to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8開口ユーザデータチャンクは、タイプコードと認識されないオプション未満8192（セクション2.3.11.1）をコードする場合、受信機はRF_REJECTED状態に移動、流れを拒絶しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. If this new receiving flow is still RF_OPEN, then notify the user that a new receiving flow has opened, including the METADATA and, if present, the ASSOCIATION, and set flow.BUFFER_CAPACITY according to the user;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9.この新しい受信フローが依然としてRF_OPENである場合には、メタデータと、存在する場合、ASSOCIATION含む新たな受信フローが開いたことをユーザに通知し、ユーザに応じて設定さflow.BUFFER_CAPACITY。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Perform the normal data processing (Section 3.6.3.2) for the opening User Data chunk; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10開口ユーザデータチャンクのための通常のデータ処理（セクション3.6.3.2）を実行します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Set this session&#39;s ACK_NOW to true.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. trueに、このセッションのACK_NOWを設定します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.2. Receiving Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.2。データ受信中
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A User Data chunk (Section 2.3.11) or a Next User Data chunk (Section 2.3.12) encodes one fragment of a user data message of a flow, as well as the flow&#39;s Forward Sequence Number and potentially optional parameters (Section 2.3.11.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータチャンク（セクション2.3.11）または次のユーザデータチャンク（セクション2.3.12）は、一つのフローのユーザデータメッセージの断片、ならびに流れの順方向シーケンス番号と、潜在的に任意のパラメータ（セクション2.3をコードします。 11.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a User Data or Next User Data chunk:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーデータや次のユーザーデータチャンクを受信します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If chunk.flowID doesn&#39;t indicate an existing receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER state, perform the steps of Section 3.6.3.1 (&#34;Startup&#34;) to start a new receiving flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. chunk.flowID新しい受信フローを開始するために、セクション3.6.3.1（「スタートアップ」）の手順を実行し、RF_OPEN、RF_REJECTED、又はRF_COMPLETE_LINGER状態で同じセッションに存在する受信フローを示していない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Retrieve the receiving flow context for the flow indicated by chunk.flowID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. chunk.flowIDによって示される流れのための受信フローコンテキストを取得します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Set flow.SHOULD_ACK to true;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
trueに設定する3. flow.SHOULD_ACK。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the flow is RF_OPEN, AND the chunk encodes any unrecognized option with a type code less than 8192 (Section 2.3.11.1), the flow MUST be rejected: notify the user of an exception, and reject the flow (Section 3.6.3.7), moving it to the RF_REJECTED state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
流れがRF_OPENであり、チャンクタイプコード未満8192（セクション2.3.11.1）と認識されないオプションをコード4.場合、フローは拒絶しなければなりません：例外をユーザに通知し、フロー（3.6節を拒否する。 3.7）、RF_REJECTED状態に移動します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the flow is not in the RF_OPEN state, set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5.フローがRF_OPEN状態でない場合、session.ACK_NOWはtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If flow.PREV_RWND has a value and that value is less than 2 blocks, set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. flow.PREV_RWND値を持ち、その値が2つの未満のブロックである場合、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. If chunk.abandon is true, set session.ACK_NOW to true;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. chunk.abandonがtrueの場合、trueにsession.ACK_NOWを設定します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. If flow.SEQUENCE_SET has any gaps (that is, if it doesn&#39;t contain every sequence number from 0 through and including the highest sequence number in the set), set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. flow.SEQUENCE_SETは（それが0からを通じてすべてのシーケンス番号を含み、セット内の最高のシーケンス番号を含めない場合には、である）任意の間隙を有している場合、session.ACK_NOWをtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. If flow.SEQUENCE_SET contains chunk.sequenceNumber, then this chunk is a duplicate: set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. flow.SEQUENCE_SETはchunk.sequenceNumberが含まれている場合、このチャンクは重複です：trueにsession.ACK_NOWを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. If flow.SEQUENCE_SET doesn&#39;t contain chunk.sequenceNumber, AND chunk.final is true, AND flow.RF_FINAL_SN has no value, then set flow.RF_FINAL_SN to chunk.sequenceNumber, and set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. flow.SEQUENCE_SETはchunk.sequenceNumberが含まれていない、とchunk.finalがtrueで、flow.RF_FINAL_SNが値を持たない、そしてchunk.sequenceNumberにflow.RF_FINAL_SNを設定し、trueにsession.ACK_NOWを設定した場合、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11. If the flow is in the RF_OPEN state, AND flow.SEQUENCE_SET doesn&#39;t contain chunk.sequenceNumber, AND chunk.abandon is false, then create a new RECV_BUFFER entry for this chunk&#39;s data and set entry.SEQUENCE_NUMBER to chunk.sequenceNumber, entry.DATA to chunk.userData, and entry.FRA to chunk.fragmentControl, and insert this new entry into flow.RECV_BUFFER;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
11.フローはRF_OPEN状態にある、AND、flow.SEQUENCE_SETはchunk.sequenceNumberが含まれていない、とchunk.abandonがfalseで、このチャンクのデータのための新しいRECV_BUFFERエントリを作成し、chunk.sequenceNumberにentry.SEQUENCE_NUMBERを設定した場合chunk.fragmentControlにchunk.userData、およびentry.FRAにentry.DATA、およびflow.RECV_BUFFERにこの新しいエントリを挿入します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. Add to flow.SEQUENCE_SET the range of sequence numbers from 0 through and including the chunk.forwardSequenceNumber derived field;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
12. 0から通ってchunk.forwardSequenceNumber派生フィールドを含むシーケンス番号の範囲をflow.SEQUENCE_SETに加えます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Add chunk.sequenceNumber to flow.SEQUENCE_SET;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. flow.SEQUENCE_SETにchunk.sequenceNumberを追加します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
14. If flow.SEQUENCE_SET now has any gaps, set session.ACK_NOW to true;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
14. flow.SEQUENCE_SETは今のギャップを持っている場合は、session.ACK_NOWはtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
15. If session.ACK_NOW is false and session.DELACK_ALARM is not set, set session.DELACK_ALARM to fire in 200 milliseconds; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
15. session.ACK_NOWがfalseで、session.DELACK_ALARMが設定されていない場合、200ミリ秒で起動するようにsession.DELACK_ALARMを設定します。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16. Attempt delivery of completed messages in this flow&#39;s RECV_BUFFER to the user (Section 3.6.3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザにこの流れのRECV_BUFFERで完成したメッセージの16試行配信（セクション3.6.3.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After processing all chunks in a packet containing at least one User Data chunk, increment session.RX_DATA_PACKETS by one. If session.RX_DATA_PACKETS is at least two, set session.ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
少なくとも一つのユーザデータのチャンクを含むパケット内のすべてのチャンクを処理した後、いずれかによってsession.RX_DATA_PACKETSをインクリメントします。 session.RX_DATA_PACKETSは少なくとも2である場合、session.ACK_NOWはtrueに設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving flow that is not in the RF_CLOSED state is ready to send an acknowledgement if its SHOULD_ACK flag is set. Acknowledgements for receiving flows that are ready are sent either opportunistically by piggybacking on a packet that&#39;s already sending user data or an acknowledgement (Section 3.6.3.4.6), or when the session&#39;s ACK_NOW flag is set (Section 3.6.3.4.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RF_CLOSED状態でない受信フローは、そのSHOULD_ACKフラグが設定されている場合に肯定応答を送信する準備ができています。準備されたフローを受信するための謝辞日和見既にユーザデータ又は確認応答（セクション3.6.3.4.6）を送信だパケット、またはセッションのACK_NOWフラグがセットされている（セクション3.6.3.4.5）にピギーバックすることによってのいずれかで送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.3. Buffering and Delivering Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.3。バッファリングおよびデータ配信
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving flow&#39;s information context contains a RECV_BUFFER for reordering, reassembling, and holding the user data messages of the flow. Only complete messages are delivered to the user; an implementation MUST NOT deliver partially received messages, except by special arrangement with the user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローの情報コンテキストは再組み立て、およびフローのユーザデータメッセージを保持し、並べ替えのためRECV_BUFFERが含まれています。唯一の完全なメッセージがユーザーに配信されます。実装は、ユーザーとの特別な取り決めによる場合を除いて、部分的に受信したメッセージを届けるてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the Cumulative Acknowledgement Sequence Number (CSN) be the highest number in the contiguous range of numbers in SEQUENCE_SET starting with 0. For example, if SEQUENCE_SET contains {0, 1, 2, 3, 5, 6}, the contiguous range starting with 0 is 0..3, so the CSN is 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEQUENCE_SETが含まれている場合、累積確認応答シーケンス番号（CSN）は、例えば0から始まるSEQUENCE_SETの数字の連続した範囲内の最高数とする、{0、1、2、3、5、6}、連続した範囲が始まります0は0..3ので、CSNは3です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A message is complete if all of its fragments are present in the RECV_BUFFER. The fragments of one message have contiguous sequence numbers. A message can be either a single fragment, whose fragment control value is 0-whole, or two or more fragments where the first&#39;s fragment control value is 1-begin, followed by zero or more fragments with control value 3-middle, and terminated by a last fragment with control value 2-end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
そのフラグメントの全てがRECV_BUFFERに存在している場合、メッセージは完了です。一つのメッセージの断片は、連続したシーケンス番号を持っています。メッセージは、単一のその断片の制御値が0全体で断片、または初フラグメント制御値が制御値3中間ゼロ以上のフラグメントが続き、によって終了、1-始まる2つの以上のフラグメントのいずれかとすることができます制御値2端部を有する最後のフラグメント。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An incomplete message segment is a contiguous sequence of one or more fragments that do not form a complete message -- that is, a 1-begin followed by zero or more 3-middle fragments but with no 2-end, or zero or more 3-middle fragments followed by a 2-end but with no 1-begin, or one or more 3-middle fragments with neither a 1-begin nor a 2-end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不完全なメッセージセグメントは、完全なメッセージを形成しない1以上の断片の連続した配列である - つまり、1-始めるゼロ以上3中間断片ではなく、NO 2端と、続いて、またはゼロ以上3 -middle断片は、2エンドではなく、1-開始、または1-始まるも2端も有する1つ以上の3中間フラグメントなしで続きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Incomplete message segments can either be in progress or abandoned. An incomplete segment is abandoned in the following cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不完全なメッセージセグメントはいずれか進行中であるか、または放棄することができます。不完全なセグメントは、次の場合に破棄されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence number of the segment&#39;s first fragment is less than or equal to the CSN, AND that fragment&#39;s control value is not 1-begin; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oセグメントの最初のフラグメントのシーケンス番号は、CSN以下である、その断片の制御値は、1-開始ありません。または
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence number of the segment&#39;s last fragment is less than the CSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oセグメントの最後のフラグメントのシーケンス番号は、CSNよりも小さいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Abandoned message segments will never be completed, so they SHOULD be removed from the RECV_BUFFER to make room in the advertised receive window and the receiver&#39;s memory for messages that can be completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
放棄されたメッセージのセグメントが完了することはありませんので、それらを受け取る広告ウィンドウと完了することができ、メッセージのための受信機のメモリに空きを作るためにRECV_BUFFERから削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user can suspend delivery of a flow&#39;s messages. A suspended receiving flow holds completed messages in its RECV_BUFFER until the user resumes delivery. A suspended flow can cause the receive window advertisement to go to zero even when the BUFFER_CAPACITY is non-zero; this is described in detail in Section 3.6.3.5 (&#34;Flow Control&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーは、フローのメッセージの配信を一時停止することができます。ユーザーが配信を再開するまで一時停止の受信フローは、そのRECV_BUFFERで完成したメッセージを保持しています。中断の流れはBUFFER_CAPACITYがゼロでない場合でも、ゼロに行くウィンドウ広告を受け取る引き起こす可能性があります。これは、セクション3.6.3.5（「フロー制御」）に詳細に記載されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the receiving flow is not suspended, the original queuing order of the messages is recovered by delivering, in ascending sequence number order, complete messages in the RECV_BUFFER whose sequence numbers are less than or equal to the CSN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローが中断されていない場合、メッセージの元の待ち行列の順序は、シーケンス番号の昇順に、シーケンス番号は以下CSNに等しいRECV_BUFFERで完全なメッセージを送達することによって回収されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes a method for discarding abandoned message segments and delivering complete messages in original queuing order when the receiving flow is not suspended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は放棄されたメッセージのセグメントを破棄し、受信フローが中断されていない場合、元の待ち行列の順序で完了メッセージを配信するための方法を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the first fragment entry in the RECV_BUFFER has a sequence number less than or equal to the CSN and delivery is still possible:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECV_BUFFERにおける最初のフラグメントエントリがCSNにシーケンス番号以下であり、送達が依然として可能であるが。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If entry.FRA is 0-whole, deliver entry.DATA to the user, and remove this entry from RECV_BUFFER; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. entry.FRA 0-全体ある場合、ユーザにentry.DATAを提供し、RECV_BUFFERからこのエントリを削除します。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If entry.FRA is 2-end or 3-middle, this entry belongs to an abandoned segment, so remove and discard this entry from RECV_BUFFER; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. entry.FRA 2末端または3中間である場合、このエントリが放棄されたセグメントに属しているので、RECV_BUFFERからこのエントリを削除し、破棄、そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Entry.FRA is 1-begin. Let LAST_ENTRY be the last RECV_BUFFER entry that is part of this message segment (LAST_ENTRY can be entry if the segment has only one fragment so far). Then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Entry.FRAは1-始まりです。 LAST_ENTRYこのメッセージセグメント（セグメントがこれまで唯一のフラグメントを有する場合LAST_ENTRYエントリであり得る）の一部であり、最後RECV_BUFFERエントリとします。その後：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       1.  If LAST_ENTRY.FRA is 2-end, this segment is a complete
           message, so concatenate the DATA fields of each fragment
           entry of this segment in ascending sequence number order and
           deliver the complete message to the user, then remove the
           entries for this complete message from RECV_BUFFER;
           otherwise,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. If LAST_ENTRY.SEQUENCE_NUMBER is less than CSN, this segment is incomplete and abandoned, so remove and discard the entries for this segment from RECV_BUFFER; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
2. LAST_ENTRY.SEQUENCE_NUMBERがCSNよりも小さい場合、このセグメントが不完全と放棄されたので、RECV_BUFFERからこのセグメントのエントリを削除して破棄。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. LAST_ENTRY.SEQUENCE_NUMBER is equal to CSN and LAST_ENTRY.FRA is not 2-end: this segment is incomplete but still in progress. Ordered delivery is no longer possible until at least one more fragment is received. Stop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
3. LAST_ENTRY.SEQUENCE_NUMBERは、CSNとLAST_ENTRY.FRAに等しい2エンドではない：このセグメントは不完全まだ進行中です。少なくとももう1つのフラグメントが受信されるまで、規則正しい配信はもはや不可能です。やめる。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If flow.RF_FINAL_SN has a value and is equal to the CSN, AND RECV_BUFFER is empty, all complete messages have been delivered to the user, so notify the user that the flow is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flow.RF_FINAL_SNが値を持っており、CSNに等しく、RECV_BUFFERが空の場合、すべての完全なメッセージがユーザーに配信するので、流れが完了したことをユーザに通知されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4. Acknowledging Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4。データを認識し
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A flow receiver SHOULD acknowledge all user data fragment sequence numbers seen in that flow. Acknowledgements drive the sender&#39;s congestion control and avoidance algorithms, clear data from the sender&#39;s buffers, and in some sender implementations clock new data into the network; therefore, the acknowledgements must be accurate and timely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、そのフローに見られるすべてのユーザーデータフラグメントのシーケンス番号を確認すべきです。謝辞は、ネットワークに新しいデータを送信側の輻輳制御と回避アルゴリズムを駆動し、送信側のバッファから明確なデータ、およびいくつかの送信者の実装のクロックで、そのため、確認応答は、正確かつタイムリーでなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.1. Timing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.1。タイミング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For reasons similar to those discussed in Section 4.2.3.2 of RFC 1122 [RFC1122], it is advantageous to delay sending acknowledgements for a short time, so that multiple data fragments can be acknowledged in a single transmission. However, it is also advantageous for a sender to receive timely notification about the receiver&#39;s disposition of the flow, particularly in unusual or exceptional circumstances, so that the circumstances can be addressed if possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 1122のセクション4.2.3.2 [RFC1122]で説明したものと同様の理由から、複数のデータフラグメントが単一の送信に肯定応答することができるように、短時間の確認応答を送信遅延することが有利です。可能であれば状況に対処できるように、送信者は、特に異常なまたは例外的な状況では、フローの受信機の配置についてタイムリーな通知を受信するためしかし、それはまた、有利です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, a flow receiver SHOULD send an acknowledgement for a flow as soon as is practical in any of the following circumstances:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、フロー受信機は、以下の状況のいずれかにおいて実用的であるとすぐに流れのための確認応答を送信する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data chunk that starts a new flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新しいフローを開始ユーザーデータチャンクを受信すると、O。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data or Next User Data chunk if the flow is not in the RF_OPEN state;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oユーザーデータまたは次のユーザデータチャンクを受信すると流れがRF_OPEN状態にない場合、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data chunk where, before processing the chunk, the SEQUENCE_SET of the indicated flow does not contain every sequence number between 0 and the highest sequence number in the set (that is, if there was a sequence number gap before processing the chunk);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
シーケンス番号のギャップを処理する前にあった場合、Oユーザーデータチャンクを受信するチャンクを処理する前に、指示された流れのSEQUENCE_SETは0〜セット内の最高のシーケンス番号（つまり、すべてのシーケンス番号を含まない場合、チャンク）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data chunk where, after processing the chunk, the flow&#39;s SEQUENCE_SET does not contain every sequence number between 0 and the highest sequence number in the set (that is, if this chunk causes a sequence number gap);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oチャンクを処理した後、フローのSEQUENCE_SETが0とセット内の最高のシーケンス番号（このチャンクは、シーケンス番号のギャップを生じさせる場合には、である）との間のすべてのシーケンス番号が含まれていないユーザデータチャンクを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a Buffer Probe for the flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oフローに対するバッファプローブを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data chunk if the last acknowledgement sent for the flow indicated fewer than two bufferBlocksAvailable;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oフローに対して送信された最後の確認応答がより少ない2 bufferBlocksAvailableを示した場合、ユーザーデータチャンクを受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data or Next User Data chunk for the flow if, after processing the chunk, the flow&#39;s BUFFER_CAPACITY is not at least 1024 bytes greater than BUFFERED_SIZE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oフローのためのユーザー・データまたは次のユーザデータチャンクを受信する場合には、チャンクを処理した後、フローのBUFFER_CAPACITYはBUFFERED_SIZEより少なくとも1024バイト大きくありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of a User Data or Next User Data chunk for any sequence number that was already seen (that is, on receipt of a duplicate);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oユーザーデータまたは既に見られた任意のシーケンス番号の次のユーザデータチャンクを受信すると（つまり、重複の受信時に、です）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On the first receipt of the final sequence number of the flow;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oフローの最終シーケンス番号の最初受信します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o On receipt of two packets in the session that contain user data for any flows since an acknowledgement was last sent, the new acknowledgements being for the flows having any User Data chunks in the received packets (that is, for every second packet containing user data);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O任意のフローのためのユーザデータを含むセッション内の2つのパケットの受信に肯定応答は新しい確認応答が受信されたパケット内の任意のユーザーデータチャンクを有するフローのためである、最後に送られたため（すなわち、ユーザデータを含むすべての第2のパケットのために、あります）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o After receipt of a User Data chunk for the flow, if an acknowledgement for any other flow is being sent (that is, consolidate acknowledgements);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oフローのためのユーザデータチャンクを受信すると、他のフローのための肯定応答が送信されている場合、後に（つまり、肯定応答を統合）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o After receipt of a User Data chunk for the flow, if any user data for a sending flow is being sent in a packet and if there is space available in the same packet (that is, attempt to piggyback an acknowledgement with user data if possible);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O、フローのためのユーザデータチャンクを受信した後に送信フローのための任意のユーザデータがパケットで送信され、同じパケットに空きがある場合（つまり、可能な場合、ユーザデータと受信確認をピギーバックしようとしている場合）;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o No longer than 200 milliseconds after receipt of a User Data chunk for the flow.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oもはや流れのためのユーザ・データ・チャンクの受領後200ミリ秒以下です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.2. Size and Truncation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.2。サイズと切り捨て
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Including an encoded acknowledgement in a packet might cause the packet to exceed the path MTU. In that case:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケット内のエンコードされた確認応答を含むパケットがパスMTUを超過することがあります。その場合には：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the packet is being sent primarily to send an acknowledgement, AND this is the first acknowledgement in the packet, truncate the acknowledgement so that the packet does not exceed the path MTU; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
パケットが確認応答を送信するために主に送信され、これは、パケットの最初の肯定応答である場合、パケットはパスMTUを超えないようにO、肯定応答を切り捨てます。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The acknowledgement is being piggybacked in a packet with user data or with an acknowledgement for another flow: do not include this acknowledgement in the packet, and send it later.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O承認は、ユーザデータを持つまたは他のフローに対する肯定応答のパケットにピギーバックされている：パケットでこの確認を含めて、後でそれを送信しないでください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.3. Constructing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.3。構築
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Data Acknowledgement Bitmap chunk (Section 2.3.13) and Data Acknowledgement Ranges chunk (Section 2.3.14) encode a receiving flow&#39;s SEQUENCE_SET and its receive window advertisement. The two chunks are semantically equivalent; implementations SHOULD send whichever provides the most compact encoding of the SEQUENCE_SET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データ確認応答ビットマップチャンク（セクション2.3.13）とデータ謝辞チャンク（セクション2.3.14）は受信フローのSEQUENCE_SET及びその受信ウィンドウ広告を符号化する範囲。 2つのチャンクは、意味的に等価です。実装はSEQUENCE_SETの最もコンパクトな符号化を提供する方送ります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When assembling an acknowledgement for a receiving flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローに対する肯定応答を組み立てる際：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If the flow&#39;s state is RF_REJECTED, first assemble a Flow Exception Report chunk (Section 2.3.16) for flow.flowID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.流れの状態が最初のflow.flowIDのフロー例外レポートのチャンク（セクション2.3.16）を組み立て、RF_REJECTEDであれば、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Choose the acknowledgement chunk type that most compactly encodes flow.SEQUENCE_SET;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.最もコンパクトflow.SEQUENCE_SETをコードして確認チャンクタイプを選択します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Use the method described in Section 3.6.3.5 (&#34;Flow Control&#34;) to determine the value for the acknowledgement chunk&#39;s bufferBlocksAvailable field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.確認のチャンクのbufferBlocksAvailableフィールドの値を決定するために、セクション3.6.3.5（「フロー制御」）に記載の方法を使用します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.4. Delayed Acknowledgement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.4。遅延確認応答
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in Section 3.6.3.4.1 (&#34;Timing&#34;), a flow receiver can delay sending an acknowledgement for up to 200 milliseconds after receiving user data. The method described in Section 3.6.3.2 (&#34;Receiving Data&#34;) sets the session&#39;s DELACK_ALARM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.6.3.4.1（「タイミング」）で説明したように、フロー受信機は、ユーザデータを受信した後、最大200ミリ秒の確認応答を送信遅延させることができます。 3.6.3.2項（「データ受信」）に記載された方法は、セッションのDELACK_ALARMを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When DELACK_ALARM fires, set ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DELACK_ALARM火災は、trueにACK_NOWを設定した場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.5. Obligatory Acknowledgement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.5。必須謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One or more acknowledgements should be sent as soon as is practical when the session&#39;s ACK_NOW flag is set. While the ACK_NOW flag is set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一つ以上の確認応答は、セッションのACK_NOWフラグが設定されている場合に実用的であるとすぐに送られるべきです。 ACK_NOWフラグがセットされている間：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Choose a receiving flow that is ready to send an acknowledgement;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.確認応答を送信する準備ができている受信フローを選択してください。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If there is no such flow, there is no work to do, set ACK_NOW to false, set RX_DATA_PACKETS to 0, clear the DELACK_ALARM, and stop; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.そのような流れが存在しない場合には、やるべき仕事決してありませんが、falseにACK_NOWを設定し、0にRX_DATA_PACKETSを設定DELACK_ALARMをクリアし、停止します。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Start a new packet;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.新しいパケットを開始します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Assemble an acknowledgement for the flow and include it in the packet, truncating it if necessary so that the packet doesn&#39;t exceed the path MTU;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.フローに対する肯定応答を組み立て、パケットが経路MTUを超えないように必要に応じて切り捨て、パケットに含めます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Set flow.SHOULD_ACK to false;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
falseに設定する5. flow.SHOULD_ACK。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Set flow.PREV_RWND to the bufferBlocksAvailable field of the included acknowledgement chunk;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6.セットが含ま承認チャンクのbufferBlocksAvailable分野にflow.PREV_RWND。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Attempt to piggyback acknowledgements for any other flows that are ready to send an acknowledgement into the packet, as described below; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下に説明するように、パケットに確認応答を送信する準備ができている他のフローの確認応答をピギーバックする試み7。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Send the packet.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.パケットを送信します。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.6. Opportunistic Acknowledgement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.6。日和見謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When sending a packet with user data or an acknowledgement, any other receiving flows that are ready to send an acknowledgement should include their acknowledgements in the packet if possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザデータや受信確認のパケットを送信するときに、可能な場合、確認応答を送信する準備ができている任意の他の受信フローは、パケットに自分の謝辞を含める必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To piggyback acknowledgements in a packet that is already being sent, where the packet contains user data or an acknowledgement, while there is at least one receiving flow that is ready to send an acknowledgement:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
確認応答を送信する準備ができている少なくとも一つの受信フローがある間、パケットが、ユーザデータ又は確認応答が含ま既に送信されたパケットに肯定応答をピギーバックします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Assemble an acknowledgement for the flow;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.流れのための肯定応答をアセンブル。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the acknowledgement cannot be included in the packet without exceeding the path MTU, the packet is full; stop. Otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.確認がパスMTUを超えることなく、パケットに含めることができない場合、パケットが満杯です。やめる。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Include the acknowledgement in the packet;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.パケットに確認応答を含めます。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Set flow.SHOULD_ACK to false;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
falseに設定する4. flow.SHOULD_ACK。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Set flow.PREV_RWND to the bufferBlocksAvailable field of the included acknowledgement chunk; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5.セットが含ま承認チャンクのbufferBlocksAvailable分野にflow.PREV_RWND。そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If there are no longer any receiving flows in the session that are ready to send an acknowledgement, set session.ACK_NOW to false, set session.RX_DATA_PACKETS to 0, and clear session.DELACK_ALARM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6.もはや存在している場合は任意の受信が確認応答を送信する準備ができているセッションでは流れない、falseにsession.ACK_NOWを設定し、0にsession.RX_DATA_PACKETSを設定し、クリアsession.DELACK_ALARM。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.7. Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.4.7。例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 23 shows an example flow with sequence numbers 31 and 33 lost in transit; 31 is abandoned, and 33 is retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
図23は、輸送中に失われたシーケンス番号31と33との例示的なフローを示す図です。 31は放棄され、そして33が再送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   Receiver
    1 |&lt;---  Data ID=3, seq#=29, fsnOff=11 (fsn=18)
    2 |&lt;---  Data ID=3, seq#=30, fsnOff=12 (fsn=18)
    3 |---&gt;  Ack  ID=3, seq:0-30
    4 |&lt;---  Data ID=3, seq#=32, fsnOff=12 (fsn=20)
    5 |---&gt;  Ack  ID=3, seq:0-30, 32
    6 |&lt;---  Data ID=3, seq#=34, fsnOff=12 (fsn=22)
    7 |---&gt;  Ack  ID=3, seq:0-30, 32, 34
      |                   :
    8 |&lt;---  Data ID=3, seq#=46, fsnOff=16 (fsn=30)
    9 |---&gt;  Ack  ID=3, seq:0-30, 32, 34-46
   10 |&lt;---  Data ID=3, seq#=47, fsnOff=15 (fsn=32)
   11 |---&gt;  Ack  ID=3, seq:0-32, 34-47
   12 |&lt;---  Data ID=3, seq#=33, fsnOff=1 (fsn=32)
   13 |---&gt;  Ack  ID=3, seq#=0-47
   14 |&lt;---  Data ID=3, seq#=48, fsnOff=16 (fsn=32)
   15 |&lt;---  Data ID=3, seq#=49, fsnOff=17 (fsn=32)
   16 |---&gt;  Ack  ID=3, seq#=0-49
      |                   :
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure 23: Flow Example with Loss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
図23：損失と流れの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.5. Flow Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.5。フロー制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver maintains a buffer for reassembling and reordering messages for delivery to the user (Section 3.6.3.3). The implementation and the user may wish to limit the amount of resources (including buffer memory) that a flow is allowed to use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、ユーザ（セクション3.6.3.3）への配信のためにメッセージを再組み立てし、並べ替えのためのバッファを維持します。実装およびユーザがフローが使用を許可されている（バッファメモリを含む）リソースの量を制限することを望むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFP provides a means for each receiving flow to govern the amount of data sent by the sender, by way of the bufferBytesAvailable derived field of acknowledgement chunks (Sections 2.3.13 and 2.3.14). This derived field indicates the amount of data that the sender is allowed to have outstanding in the network, until instructed otherwise. This amount is also called the receive window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTMFPは、肯定応答のチャンク（セクション2.3.13および2.3.14）のbufferBytesAvailable由来の分野の方法によって、送信側によって送信されたデータの量を管理するために、各受信フローのための手段を提供します。この派生フィールドには、そうでない場合は指示があるまで、送信者は、ネットワーク内で優秀なを持つことが許可されているデータの量を示しています。この量は、また、受信ウィンドウと呼ばれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flow receiver can suspend the sender by advertising a closed (zero length) receive window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フロー受信機は、受信ウィンドウを閉じ（ゼロ長さ）を広告することによって送信者を一時停止することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The user can suspend delivery of messages from the receiving flow (Section 3.6.3.3). This can cause the receive buffer to fill.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ユーザーは、受信フロー（セクション3.6.3.3）からのメッセージの配信を一時停止することができます。これは、受信バッファがいっぱいになる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for progress to be made on completing a fragmented message or repairing a gap for sequenced delivery in a flow, the flow receiver MUST advertise at least one buffer block in an acknowledgement if it is not suspended, even if the amount of data in the buffer exceeds the buffer capacity, unless the buffer capacity is 0. Otherwise, deadlock can occur, as the receive buffer will stay full and won&#39;t drain because of a gap or incomplete message, and the gap or incomplete message can&#39;t be repaired or completed because the sender is suspended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断片化されたメッセージを完成またはフローで配列決定送達のためのギャップを修復する上でなされるべき進歩のために、それが中断されていない場合、フロー受信機は、肯定応答で少なくとも一つのバッファブロックをアドバタイズする必要があり、偶数のデータ量であればバッファ容量がそうでなければ0でない限り、受信バッファがいっぱいにとどまるとドレインないのでギャップまたは不完全なメッセージを、ギャップまたは不完全なメッセージは修復できないようにバッファがバッファ容量を超えて、デッドロックが発生する可能性があります送信者が一時停止されているため、または完了しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receive window is advertised in units of 1024-byte blocks. For example, advertisements for 1 byte, 1023 bytes, and 1024 bytes each require one block. An advertisement for 1025 bytes requires two blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信ウィンドウは1024バイトのブロック単位でアドバタイズされます。例えば、1バイト、1023バイト、1024バイトの広告は、それぞれ一つのブロックを必要とします。 1025バイトの広告は、二つのブロックが必要です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following describes the RECOMMENDED method of calculating the bufferBlocksAvailable field of an acknowledgement chunk for a receiving flow:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下は、受信フローの確認応答チャンクのbufferBlocksAvailableフィールドを計算する推奨される方法を記載しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If BUFFERED_SIZE is greater than or equal to BUFFER_CAPACITY, set ADVERTISE_BYTES to 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. BUFFERED_SIZEがより大きいかBUFFER_CAPACITYに等しい場合、0にADVERTISE_BYTESを設定し、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If BUFFERED_SIZE is less than BUFFER_CAPACITY, set ADVERTISE_BYTES to BUFFER_CAPACITY - BUFFERED_SIZE;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. BUFFERED_SIZEがBUFFER_CAPACITY未満の場合、BUFFER_CAPACITYにセットADVERTISE_BYTES  -  BUFFERED_SIZE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Set ADVERTISE_BLOCKS to CEIL(ADVERTISE_BYTES / 1024);
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
CEIL 3.設定ADVERTISE_BLOCKS（ADVERTISE_BYTES / 1024）。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If ADVERTISE_BLOCKS is 0, AND BUFFER_CAPACITY is greater than 0, AND delivery to the user is not suspended, set ADVERTISE_BLOCKS to 1; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. ADVERTISE_BLOCKSは0であり、BUFFER_CAPACITYは0より大きく、ユーザへの配信が中断されていない、1にADVERTISE_BLOCKSを設定した場合、そして
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Set the acknowledgement&#39;s bufferBlocksAvailable field to ADVERTISE_BLOCKS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. ADVERTISE_BLOCKSに確認のbufferBlocksAvailableフィールドを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.6. Receiving a Buffer Probe
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.6。バッファプローブを受けます
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Buffer Probe chunk (Section 2.3.15) is sent by the flow sender (Section 3.6.2.9.1) to request the current receive window advertisement (in the form of an acknowledgement) from the flow receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファプローブチャンク（セクション2.3.15）は、フロー受信機から（確認応答の形で）現在の受信ウィンドウ広告を要求するフローの送信者（セクション3.6.2.9.1）によって送信されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On receipt of a Buffer Probe chunk:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
バッファプローブチャンクを受信します：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If chunk.flowID doesn&#39;t belong to a receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER state, ignore this Buffer Probe; otherwise,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. chunk.flowIDこのバッファプローブを無視し、RF_OPEN、RF_REJECTED、又はRF_COMPLETE_LINGER状態で同じセッションで受信フローに属していない場合。そうでなければ、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Retrieve the receiving flow context for the flow indicated by chunk.flowID; then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. chunk.flowIDによって示される流れのための受信フローコンテキストを取得します。それから
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Set flow.SHOULD_ACK to true; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
trueに設定する3. flow.SHOULD_ACK。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Set session.ACK_NOW to true.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
trueに設定する4. session.ACK_NOW。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.7. Rejecting a Flow
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.7。フローを拒否
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver can reject an RF_OPEN flow at any time and for any reason. To reject a receiving flow in the RF_OPEN state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機は、いつでも任意の理由でRF_OPENフローを拒否することができます。 RF_OPEN状態で受信フローを拒否するには：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Move to the RF_REJECTED state;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
RF_REJECTED状態1.移動し、
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Discard all entries in flow.RECV_BUFFER, as they are no longer relevant;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
彼らはもはや適切であるとして2、flow.RECV_BUFFER内のすべてのエントリを破棄しません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the user rejected the flow, set flow.EXCEPTION_CODE to the exception code indicated by the user; otherwise, the flow was rejected automatically by the implementation, so the exception code is 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.ユーザがフローを拒否した場合、flow.EXCEPTION_CODEは、ユーザによって示された例外コードに設定します。例外コードが0であるので、そうでない場合、フローは、実装によって自動的に拒否されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Set flow.SHOULD_ACK to true; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
trueに設定する4. flow.SHOULD_ACK。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Set session.ACK_NOW to true.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
trueに設定する5. session.ACK_NOW。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver indicates that it has rejected a flow by sending a Flow Exception Report chunk (Section 2.3.16) with every acknowledgement (Section 3.6.3.4.3) for a flow in the RF_REJECTED state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信機は、それがRF_REJECTED状態でフローごとに確認応答（セクション3.6.3.4.3）でフロー例外レポートのチャンク（セクション2.3.16）を送信することにより、流れを拒否したことを示しています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.8. Close
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6.3.8。閉じる
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving flow is complete when every sequence number from 0 through and including the final sequence number has been received -- that is, when flow.RF_FINAL_SN has a value and flow.SEQUENCE_SET contains every sequence number from 0 through flow.RF_FINAL_SN, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flow.RF_FINAL_SNの値を有し、flow.SEQUENCE_SETは、包括flow.RF_FINAL_SN 0〜毎にシーケンス番号が含まれている場合には、その - 受信フローは、最終シーケンス番号を含むすべての配列を介して0から番号とを受信したときに完了する。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an RF_OPEN or RF_REJECTED receiving flow becomes complete, move to the RF_COMPLETE_LINGER state, set flow.SHOULD_ACK to true, and set session.ACK_NOW to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RF_OPEN又はRF_REJECTED受信流れが完全になったとき、RF_COMPLETE_LINGER状態に移動し、trueにflow.SHOULD_ACKを設定し、trueにsession.ACK_NOWを設定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiving flow SHOULD remain in the RF_COMPLETE_LINGER state for 120 seconds. After 120 seconds, move to the RF_CLOSED state. The receiving flow is now closed, and its resources can be reclaimed once all complete messages in flow.RECV_BUFFER have been delivered to the user (Section 3.6.3.3). The same flow ID might be used for a new flow by the sender after this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受信フローは120秒間RF_COMPLETE_LINGER状態に留まるべきです。 120秒後、RF_CLOSED状態に移動します。受信フローは現在閉鎖され、そのリソースは一度flow.RECV_BUFFER内のすべての完全なメッセージがユーザー（セクション3.6.3.3）に配信されている再利用することができます。同じフローIDは、この点の後に送信者によって新しいフローのために使用される可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Discussion: The flow sender detects that the flow is complete on receiving an acknowledgement of all fragment sequence numbers of the flow. This can&#39;t happen until after the receiver has detected that the flow is complete and acknowledged all of the sequence numbers. The receiver&#39;s RF_COMPLETE_LINGER period is two minutes (one Maximum Segment Lifetime (MSL)); this period allows any in-flight packets to drain from the network without being misidentified and gives the sender an opportunity to retransmit any sequence numbers if the completing acknowledgement is lost. The sender&#39;s F_COMPLETE_LINGER period is at least two minutes plus 10 seconds and doesn&#39;t begin until the completing acknowledgement is received; therefore, the same flow identifier won&#39;t be reused by the flow sender for a new sending flow for at least 10 seconds after the flow receiver has closed the receiving flow context. This ensures correct operation independent of network delay, even when the sender&#39;s clock runs up to 8 percent faster than the receiver&#39;s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ディスカッション：フローの送信者は、流れが流れのすべての断片配列番号の確認を受けた上で完了したことを検知します。これは、受信機は、フローが完了したことを検出し、シーケンス番号のすべてを認めた後までに発生することはできません。受信機のRF_COMPLETE_LINGER期間は2分（1つの最大セグメント寿命（MSL））です。この期間は、任意の飛行中のパケットが誤認されることなく、ネットワークから流出することを可能にすると、送信者に完了の確認応答が失われた場合に任意のシーケンス番号を再送信する機会を与えてくれます。送信者のF_COMPLETE_LINGER期間は少なくとも2分プラス10秒で完了し、確認応答が受信されるまで開始されません。フロー受信機は、受信フローコンテキストを閉じた後従って、同じフロー識別子は、少なくとも10秒間、新規送信のフローのフロー送信者が再利用されないであろう。これは、送信側のクロックが受信側のより速い8％まで走る場合でも、ネットワーク遅延の正しい操作の独立を保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo specifies chunk type code values (Section 2.3) and User Data option type code values (Section 2.3.11.1). These type code values are assigned and maintained by Adobe. Therefore, this memo has no IANA actions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、チャンクタイプコード値（2.3節）とユーザーデータオプションタイプコード値（セクション2.3.11.1）を指定します。これらのタイプのコード値が割り当てられ、Adobeが維持されています。したがって、このメモにはIANAのアクションを持っていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.セキュリティについての考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo specifies a general framework that can be used to establish a confidential and authenticated session between endpoints. A Cryptography Profile, not specified herein, defines the cryptographic algorithms, data formats, and semantics as used within this framework. Designing a Cryptography Profile to ensure that communications are protected to the degree required by the application-specific threat model is outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモは、エンドポイント間の機密情報や認証されたセッションを確立するために用いることができる一般的なフレームワークを指定します。本明細書で指定されていない暗号化プロファイルは、このフレームワーク内で使用される暗号化アルゴリズム、データフォーマット、およびセマンティクスを定義します。通信は、アプリケーション固有の脅威モデルによって必要とされる程度に保護されることを保証するために暗号化プロファイルを設計することは、この明細書の範囲外です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A block cipher in CBC mode is RECOMMENDED for packet encryption (Section 2.2.3). An attacker can predict the values of some fields from one plain RTMFP packet to the next or predict that some fields may be the same from one packet to the next. This SHOULD be considered in choosing and implementing a packet encryption cipher and mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CBCモードでブロック暗号は、パケットの暗号化（2.2.3項）に推奨されます。攻撃者は、次の1つの普通RTMFPパケットからいくつかのフィールドの値を予測またはいくつかのフィールドが次の一つのパケットと同じであってもよいことが予測できます。これは、パケットの暗号化暗号およびモードを選択し、実行する際に考慮すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The well-known Default Session Key of a Cryptography Profile serves multiple purposes, including the scrambling of session startup packets to protect interior fields from undesirable modification by middleboxes such as NATs, increasing the effort required for casual passive observation of startup packets, and allowing different applications of RTMFP using different Default Session Keys to (intentionally or not) share network transport addresses without interference. The Default Session Key, being well known, MUST NOT be construed to contribute to the security of session startup; session startup is essentially in the clear.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
暗号プロファイルのよく知られているデフォルトのセッションキーは、そのようなNATのような中間装置によって、望ましくない変形から内部フィールドを保護するために、セッション開始パケットのスクランブル起動パケットのカジュアル受動的観察に必要な作業量を増加させる、および異なる許可を含む複数の目的を提供しています干渉なしRTMFPのアプリケーションに（意図的かどうか）は、異なるデフォルトのセッションキーを使用して共有ネットワーク・トランスポート・アドレス。デフォルトのセッションキーは、よく知られている、セッション起動の安全保障に貢献すると解釈してはなりません。セッションの起動が明らかに本質的です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 3.5.4.2 describes an OPTIONAL method for processing a change of network address of a communicating peer. Securely processing address mobility using that method, or any substantially similar method, REQUIRES at least that the packet encryption function of the Cryptography Profile (Section 2.2.3) employs a cryptographic verification mechanism comprising secret information known only to the two endpoints. Without this constraint, that method, or any substantially similar method, becomes &#34;session hijacking support&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.5.4.2は、通信ピアのネットワークアドレスの変更を処理するための任意の方法を記載しています。安全その方法、または任意の実質的に同様の方法を用いてアドレスの移動性を処理、暗号プロファイル（セクション2.2.3）のパケットの暗号化機能は、2つのだけのエンドポイントに知られている秘密情報を含む暗号化検証メカニズムを採用することを少なくとも必要とします。この制約がなければ、そのメソッド、または任意の実質的に類似の方法は、「セッションハイジャックのサポート」になります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Flows and packet fragmentation imply semantics that could cause unbounded resource utilization in receivers, causing a denial of service. Implementations SHOULD guard against unbounded or excessive resource use and abort sessions that appear abusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
フローおよびパケットの断片化は、サービス拒否を引き起こし、受信機で無制限のリソース使用率を引き起こす可能性があるセマンティクスを暗示しています。実装は無制限や過剰な資源利用を防ぐと虐待に表示されたセッションを中止すべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A rogue but popular Redirector (Section 3.5.1.4) could direct session initiators to flood a victim address or network with Initiator Hello packets, potentially causing a denial of service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不正しかし、人気のリダイレクタ（セクション3.5.1.4）は、潜在的にサービス拒否を引き起こし、イニシエータHelloパケットを犠牲者のアドレスまたはネットワークをあふれさせるセッションイニシエータを指示できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker that can passively observe an IHello and that possesses a certificate matching the Endpoint Discriminator (without having to know the private key, if any, associated with it) can deny the initiator access to the desired responder by sending an RHello before the desired responder does, since only the first received RHello is selected by the initiator. The attacker needn&#39;t forge the desired responder&#39;s source address, since the RHello is selected based on the tag echo and not the packet&#39;s source address. This can simplify the attack in some network or host configurations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受動IHello、それは（それに関連するすべての場合、秘密鍵を知ることなく、）エンドポイント識別子と一致する証明書を所有を観察することができ、攻撃者は、所望の応答前RHelloを送信することによって、所望の応答へのイニシエータのアクセスを拒否することができ最初の受信RHelloがイニシエータによって選択されているので、ありません。攻撃者はRHelloは、タグエコーではなく、パケットの送信元アドレスに基づいて選択されているので、希望応答の送信元アドレスを偽造する必要はありません。これは、いくつかのネットワークまたはホストの構成での攻撃を簡素化することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker that can passively observe and record the packets of an established session can use traffic analysis techniques to infer the start and completion of flows without decrypting the packets. The User Data fragments of flows have unique sequence numbers, so flows are immune to replay while they are open. However, once a flow has completed and the linger period has concluded, the attacker could replay the recorded packets, opening a new flow in the receiver and duplicating the flow&#39;s data; this replay might have undesirable effects on the receiver&#39;s application. The attacker could also infer that a new flow has begun reusing the recorded flow&#39;s identifier and replay the final sequence number or any of the other fragments in the flow, potentially denying or interfering with legitimate traffic to the receiver. Therefore, the data integrity aspect of packet encryption SHOULD comprise anti-replay measures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受動的に確立されたセッションのパケットを観察し、記録することができ、攻撃者は、パケットを復号化することなく、フローの開始と完了を推測するトラフィック分析技術を使用することができます。フローは、彼らが開いている間再生する免疫があるように、流れのユーザデータの断片は、ユニークなシーケンス番号を持っています。フローが完了したとリンガー期間が終了した後、しかし、攻撃者が受信機に新しい流れを開き、フローのデータを複製し、記録されたパケットを再生することができ、このリプレイは、受信側のアプリケーションに好ましくない影響を与える可能性があります。攻撃者はまた、新しい流れが記録フローの識別子を再利用し始めていることを推測し、潜在的に拒否または受信機への正当なトラフィックと干渉し、流れの中で、最終的なシーケンス番号または他のフラグメントのいずれかを再生することができます。そのため、パケットの暗号化データ整合性の側面は、アンチリプレイ対策を含むべきです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.謝辞
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Special thanks go to Matthew Kaufman for his contributions to the creation and design of RTMFP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特別な感謝は、RTMFPの作成と設計への貢献のためにマシュー・カウフマンに行きます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Jari Arkko, Ben Campbell, Wesley Eddy, Stephen Farrell, Philipp Hancke, Bela Lubkin, Hilarie Orman, Richard Scheffenegger, and Martin Stiemerling for their detailed reviews of this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このメモの詳細なレビューについてヤリArkko、ベン・キャンベル、ウェズリーエディ、スティーブン・ファレル、フィリップHancke、ベラLubkin、ヒラリーオーマン、リチャードScheffenegger、そしてマーティンStiemerlingに感謝します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.参考
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBC] Dworkin, M., &#34;Recommendation for Block Cipher Modes of Operation&#34;, NIST Special Publication 800-38A, December 2001, &lt;http://csrc.nist.gov/publications/ nistpubs/800-38a/sp800-38a.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CBC] Dworkin、M.、 &#34;操作のブロック暗号モードのための勧告&#34; は、NIST Special Publication 800-38Aの2001年12月、&lt;http://csrc.nist.gov/publications/ nistpubs / 800-38A / sp800-38a .PDF&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0768] Postel, J., &#34;User Datagram Protocol&#34;, STD 6, RFC 768, August 1980.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0768]ポステル、J.、 &#34;ユーザ・データグラム・プロトコル&#34;、STD 6、RFC 768、1980年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0791] Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC0791]ポステル、J.、 &#34;インターネットプロトコル&#34;、STD 5、RFC 791、1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]ブレーデン、R.、 &#34;インターネットホストのための要件 - 通信層&#34;、STD 3、RFC 1122、1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460]デアリング、S.とR. Hindenと、 &#34;インターネットプロトコルバージョン6（IPv6）の仕様&#34;、RFC 2460、1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914]フロイド、S.、 &#34;輻輳制御の原理&#34;、BCP 41、RFC 2914、2000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821] Mathis, M. and J. Heffner, &#34;Packetization Layer Path MTU Discovery&#34;, RFC 4821, March 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821]マシス、M.とJ. Heffner、 &#34;パケット化レイヤのパスMTUディスカバリ&#34;、RFC 4821、2007年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, September 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 &#34;TCP輻輳制御&#34;、RFC 5681、2009年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &#34;Session Traversal Utilities for NAT (STUN)&#34;, RFC 5389, October 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389]ローゼンバーグ、J.、マーイ、R.、マシューズ、P.、およびD.翼、 &#34;NAT（STUN）のセッショントラバーサルユーティリティ&#34;、RFC 5389、2008年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ScalableTCP] Kelly, T., &#34;Scalable TCP: Improving Performance in Highspeed Wide Area Networks&#34;, December 2002, &lt;http://datatag.web.cern.ch/datatag/papers/ pfldnet2003-ctk.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ScalableTCP]ケリー、T.、 &#34;スケーラブルTCP：ハイスピード広域ネットワークにおけるパフォーマンスの向上&#34;、2002年12月、&lt;http://datatag.web.cern.ch/datatag/papers/ pfldnet2003-ctk.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Example Congestion Control Algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A.例の輻輳制御アルゴリズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mandated in Section 3.5.2, an RTMFP is required to use TCP-compatible congestion control, but flexibility in exact implementation is allowed, within certain limits. This section describes an experimental window-based congestion control algorithm that is appropriate for real-time and bulk data transport in RTMFP. The algorithm includes slow start and congestion avoidance phases, including modified increase and decrease parameters. These parameters are further adjusted according to whether real-time data is being sent and whether Time Critical Reverse Notifications are received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セクション3.5.2に義務付けたように、RTMFPは、TCP互換輻輳制御を使用する必要があるが、正確な実装における柔軟性がある範囲内、許容されます。このセクションでは、リアルタイムおよびRTMFPバルクデータ転送に適した実験的なウィンドウベースの輻輳制御アルゴリズムを記載しています。アルゴリズムは、修正増減パラメータを含むスロースタートと輻輳回避フェーズを含みます。これらのパラメータは、さらに、リアルタイムデータが送信され、タイムクリティカル逆通知を受信したか否かをされているか否かに応じて調整されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1. Discussion
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1。討論
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681 defines the standard window-based congestion control algorithms for TCP. These algorithms are appropriate for delay-insensitive bulk data transport but have undesirable behaviors for delay- and loss-sensitive applications. Among the undesirable behaviors are the cutting of the congestion window in half during a loss event, and the rapidity of the slow start algorithm&#39;s exponential growth. Cutting the congestion window in half requires a large channel headroom to support a real-time application and can cause a large amount of jitter from sender-side buffering. Doubling the congestion window during the slow start phase can lead to the congestion window temporarily growing to twice the size it should be, causing a period of excessive loss in the path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 5681は、TCPのための標準的なウィンドウベースの輻輳制御アルゴリズムを定義します。これらのアルゴリズムは、遅延の影響を受けないバルクデータ転送に適していますが、遅延 - 、損失に敏感なアプリケーションのために望ましくない行動を持っています。望ましくない行動の中で損失事象の間に半分に輻輳ウィンドウの切断、およびスロースタートアルゴリズムの指数関数的な成長の速さです。半分に輻輳ウィンドウをカットするリアルタイムアプリケーションをサポートするために、大きなチャネルヘッドルームを必要とし、送信側のバッファリングからジッタを大量に発生する可能性があります。スロースタートフェーズの間に輻輳ウィンドウを倍増することは輻輳ウィンドウが一時的にパス内の過剰損失の期間を引き起こし、それがあるべき2倍のサイズに成長しているにつながることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We found that a number of deployed TCP implementations use the method of equation (3) from Section 3.1 of RFC 5681; this method, when combined with the recommended behavior of acknowledging every other packet, causes the congestion window to grow at approximately half the rate that the recommended method specifies. In order to compete fairly with these deployed TCPs, we choose 768 bytes per round trip as the increment during the normal congestion avoidance phase; this is approximately half of the typical maximum segment size of 1500 bytes and is also easily subdivided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我々は、展開TCP実装の数は、RFC 5681のセクション3.1から式（3）の方法を使用することを見出しました。この方法は、他のすべてのパケットを認めるの推奨動作と組み合わせると、約推奨される方法は指定ハーフレートすることを成長すると、輻輳ウィンドウが発生します。これらの展開のTCPと公平に競争するために、我々は、通常の輻輳回避フェーズの間に増分として往復ごとに768のバイトを選択してください。これは、約1500バイトの典型的な最大セグメントサイズの半分であり、また容易に細分されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sender may be sending real-time data to the far end. When sending real-time data, a smoother response to congestion is desired while still competing with reasonable fairness to other flows in the Internet. In order to scale the sending rate quickly, the slow start algorithm is desired, but slow start&#39;s normal rate of increase can cause excessive loss in the last round trip. Accordingly, slow start&#39;s exponential increase rate is adjusted to double approximately every 3 round trips instead of every round trip. The multiplicative decrease cuts the congestion window by one eighth on loss to maintain a smoother sending rate. The additive increase is done at half the normal rate (incrementing at 384 bytes per round trip), to both compensate for the less aggressive loss response and probe the path capacity more gently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
送信者は、遠端にリアルタイムデータを送信することができます。リアルタイムデータを送信する場合は、まだインターネットで他のフローを合理的な公正に競争しながら、混雑へのスムーズな対応が望まれます。素早く送信速度をスケーリングするためには、スロースタートアルゴリズムが望まれているが、増加のスロースタートの通常のレートは、最後のラウンドトリップで過度の損失を引き起こす可能性があります。したがって、スロースタートの指数関数的な増加率は約代わりにすべてのラウンドトリップのすべての3ラウンドトリップを倍増するように調整されます。乗算減少は、スムーズな送信レートを維持するために、損失の八分の一で輻輳ウィンドウをカット。添加物の増加は、両方の少ない積極的損失応答を補償するために、（ラウンドトリップあたり384バイトでインクリメント）通常の半分の速度で行われ、より緩やかパス能力をプローブです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The far end may report that it is receiving real-time data from other peers, or the sender may be sending real-time data to other far ends. In these circumstances (if not sending real-time data to this far end), it is desirable to respond differently than the standard TCP algorithms specify, to both yield capacity to the real-time flows and avoid excessive losses while probing the path capacity. Slow start&#39;s exponential increase is disabled, and the additive increase is done at half the normal rate (incrementing at 384 bytes per round trip). Multiplicative decrease is left at the normal rate (cutting by half) to yield to other flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遠端は、それが他のピアからのリアルタイムデータを受信して​​いる、または送信者が他の遠端にリアルタイムデータを送信することができることを報告することがあります。 （この遠端にリアルタイムデータを送信しない場合）このような状況では、標準のTCPアルゴリズムが指定するよりも、リアルタイムのフローの両方利回りの容量を、異なる応答とパス能力を探査しながら、過度の損失を回避することが望ましいです。スロースタートの指数関数的な増加は無効になり、添加物の増加は、（往復あたり384バイトでインクリメント）通常の半分の速度で実行されます。乗法減少が他のフローを生成するために、通常の速度（ハーフによる切断）に残されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since real-time messages may be small, and sent regularly, it is advantageous to spread congestion window increases out across the round-trip time instead of doing them all at once. We divide the round trip into 16 segments with an additive increase of a useful size (48 bytes) per segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リアルタイムのメッセージが小さく、定期的に送信される可能性があるので、輻輳ウィンドウは、一度にすべてを行うのではなく、往復時間を越えて増加広げることが有利です。我々は、セグメント当たりの有用なサイズ（48バイト）の添加の増加に伴って16個のセグメントに往復を分割します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Scalable TCP [ScalableTCP] describes experimental methods of modifying the additive increase and multiplicative decrease of the congestion window in large delay-bandwidth scenarios. The congestion window is increased by 1% each round trip and decreased by one eighth on loss in the congestion avoidance phase in certain circumstances (specifically, when a 1% increase is larger than the normal additive-increase amount). Those methods are adapted here. The scalable increase amount is 48 bytes for every 4800 bytes acknowledged, to spread the increase out over the round trip. The congestion window is decreased by one eighth on loss when it is at least 67200 bytes per round trip, which is seven eighths of 76800 (the point at which 1% is greater than 768 bytes per round trip). When sending real-time data to the far end, the scalable increase is 1% or 384 bytes per round trip, whichever is greater. Otherwise, when notified that the far end is receiving real-time data from other peers, the scaled increase is adjusted to 0.5% or 384 bytes per round trip, whichever is greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
スケーラブルTCPは[ScalableTCP】添加剤の増加と大遅延帯域幅シナリオにおける輻輳ウィンドウの乗法減少を変更する実験方法を記載しています。輻輳ウィンドウは1％ずつ往復を増加し、特定の状況における輻輳回避フェーズで損失に八分の一だけ減少される（具体的には、1％の増加は通常、添加剤の増加量よりも大きい場合）。これらの方法は、ここに適合されています。スケーラブルな増加量は、すべての4800バイトのための48のバイトは、往復の上に外に増加を広めるために、認識されています。輻輳ウィンドウは、76800の8分の7（1％往復当たり768バイトよりも大きい点）である損失に八分の一、それは往復あたり少なくとも67200バイトであり、減少されます。遠端にリアルタイムデータを送信する場合は、拡張性の増加が大きい方、1％または往復ごとに384バイトです。遠端が他のピアからのリアルタイムデータを受信して​​いることを通知されたとき、さもなければ、スケーリングされた増加は、大きい方のラウンドトリップ、0.5％、または384バイトに調整されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2. Algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2。アルゴリズム
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let SMSS denote the Sender Maximum Segment Size [RFC5681], for example 1460 bytes. Let CWND_INIT denote the Initial Congestion Window (IW) according to Section 3.1 of RFC 5681, for example 4380 bytes. Let CWND_TIMEDOUT denote the congestion window after a timeout indicating lost data, being 1*SMSS (for example, 1460 bytes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SMSSは、例えば、1460のバイトを送信側最大セグメントサイズ[RFC5681]を示すものとします。 CWND_INITは、例えば、4380バイトをRFC 5681のセクション3.1に従って初期輻輳ウィンドウ（IW）を表すものとします。 CWND_TIMEDOUT 1 *のSMSS（例えば、1460バイト）であり、失われたデータを示すタイムアウト後に輻輳ウィンドウを示すものとします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the session information context contain additional variables:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
セッション情報のコンテキストは、追加の変数が含まれてみましょう：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CWND: the congestion window, initialized to CWND_INIT;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O CWND：輻輳ウィンドウ、CWND_INITに初期化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSTHRESH: the slow start threshold, initialized to positive infinity;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSTHRESH O：スロースタート閾値を、正の無限大に初期化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACKED_BYTES_ACCUMULATOR: a count of acknowledged bytes, initialized to 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O ACKED_BYTES_ACCUMULATOR：0に初期化され承認されたバイト数、;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ACKED_BYTES_THIS_PACKET: a count of acknowledged bytes observed in the current packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OのACKED_BYTES_THIS_PACKET：現在のパケットで観察され承認されたバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PRE_ACK_OUTSTANDING: the number of bytes outstanding in the network before processing any acknowledgements in the current packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O PRE_ACK_OUTSTANDING：現在のパケット内の任意の肯定応答を処理する前に、ネットワーク内の未処理のバイト数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_LOSS: an indication of whether any loss has been detected in the current packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANY_LOSS O：任意の損失は、現在のパケットで検出されたかどうかの表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_NAKS: an indication of whether any negative acknowledgements have been detected in the current packet;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANY_NAKS O：否定確認応答が現在のパケットで検出されているかどうかの表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ANY_ACKS: an indication of whether any acknowledgement chunks have been received in the current packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANY_ACKS O：任意の肯定応答チャンクは、現在のパケットで受信されたかどうかの指示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let FASTGROW_ALLOWED indicate whether the congestion window is allowed to grow at the normal rate versus a slower rate, being false if a Time Critical Reverse Notification has been received on this session within the last 800 milliseconds (Sections 2.2.4 and 3.5.2.1) or if a Time Critical Forward Notification has been sent on ANY session in the last 800 milliseconds, and otherwise being true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
タイムクリティカルリバース通知は、最後の800ミリ秒以内に、このセッションで受信されている場合FASTGROW_ALLOWEDが偽であること、輻輳ウィンドウが遅い速度対通常の速度で成長することが許可されているかどうかを示してみましょう（セクション2.2.4および3.5.2.1）またはタイムクリティカルフォワードの通知が最後の800ミリ秒のいずれかのセッションで送信された場合、それ以外の場合は真であること。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let TC_SENT indicate whether a Time Critical Forward Notification has been sent on this session within the last 800 milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TC_SENTは、タイムクリティカルフォワードの通知は、最後の800ミリ秒以内にこのセッションで送信されたかどうかを示しましょう。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implement the method described in Section 3.6.2.6 to manage transmission timeouts, including setting the TIMEOUT_ALARM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIMEOUT_ALARM設定など、送信タイムアウトを管理するために、セクション3.6.2.6に記載の方法を実施します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On being notified that the TIMEOUT_ALARM has fired, perform the function shown in Figure 24:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIMEOUT_ALARMが発射したことを通知される上に、図24に示す機能を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
on TimeoutNotification(WAS_LOSS): set SSTHRESH to MAX(SSTHRESH, CWND * 3/4). set ACKED_BYTES_ACCUMULATOR to 0. if WAS_LOSS is true: set CWND to CWND_TIMEDOUT. else: set CWND to CWND_INIT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TimeoutNotification（WAS_LOSS）上：MAXに設定SSTHRESH（SSTHRESH、CWND * 3/4）。 WAS_LOSSがtrueの場合は0にACKED_BYTES_ACCUMULATORを設定します。CWND_TIMEDOUTにCWNDを設定します。他：CWND_INITにCWNDを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Figure 24: Pseudocode for Handling a Timeout Notification
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
図24：タイムアウトの通知を処理するための擬似コード
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before processing each received packet in this session:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセッションでは、各受信したパケットを処理する前に：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Set ANY_LOSS to false;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
falseに設定1. ANY_LOSS。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Set ANY_NAKS to false;
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
falseに設定2. ANY_NAKS。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Set ACKED_BYTES_THIS_PACKET to 0; and
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
0 3.設定ACKED_BYTES_THIS_PACKET。そして
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Set PRE_ACK_OUTSTANDING to S_OUTSTANDING_BYTES.
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
S_OUTSTANDING_BYTESにPRE_ACK_OUTSTANDING 4.設定。
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On notification of loss (Section 3.6.2.5), set ANY_LOSS to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
損失（セクション3.6.2.5）の通知には、trueにANY_LOSSを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On notification of negative acknowledgement (Section 3.6.2.5), set ANY_NAKS to true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
否定応答（セクション3.6.2.5）の通知には、trueにANY_NAKSを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On notification of acknowledgement of data (Section 3.6.2.4), set ANY_ACKS to true, and add the count of acknowledged bytes to ACKED_BYTES_THIS_PACKET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
データの確認応答（セクション3.6.2.4）の通知には、trueにANY_ACKSを設定し、ACKED_BYTES_THIS_PACKETに承認されたバイト数を追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After processing all chunks in each received packet for this session, perform the function shown in Figure 25:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このセッションのために、各受信したパケット内のすべてのチャンクを処理した後、図25に示す機能を実行します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
if ANY_LOSS is true: if (TC_SENT is true) OR (PRE_ACK_OUTSTANDING &gt; 67200 AND \ FASTGROW_ALLOWED is true): set SSTHRESH to MAX(PRE_ACK_OUTSTANDING * 7/8, CWND_INIT). else: set SSTHRESH to MAX(PRE_ACK_OUTSTANDING * 1/2, CWND_INIT). set CWND to SSTHRESH. set ACKED_BYTES_ACCUMULATOR to 0. else if (ANY_ACKS is true) AND (ANY_NAKS is false) AND \ (PRE_ACK_OUTSTANDING &gt;= CWND): set var INCREASE to 0. var AITHRESH. if FASTGROW_ALLOWED is true: if CWND &lt; SSTHRESH: set INCREASE to ACKED_BYTES_THIS_PACKET. else: add ACKED_BYTES_THIS_PACKET to ACKED_BYTES_ACCUMULATOR. set AITHRESH to MIN(MAX(CWND / 16, 64), 4800). while ACKED_BYTES_ACCUMULATOR &gt;= AITHRESH: subtract AITHRESH from ACKED_BYTES_ACCUMULATOR. add 48 to INCREASE. else FASTGROW_ALLOWED is false: if CWND &lt; SSTHRESH AND TC_SENT is true: set INCREASE to CEIL(ACKED_BYTES_THIS_PACKET / 4). else: var AITHRESH_CAP. if TC_SENT is true: set AITHRESH_CAP to 2400. else: set AITHRESH_CAP to 4800. add ACKED_BYTES_THIS_PACKET to ACKED_BYTES_ACCUMULATOR. set AITHRESH to MIN(MAX(CWND / 16, 64), AITHRESH_CAP). while ACKED_BYTES_ACCUMULATOR &gt;= AITHRESH: subtract AITHRESH from ACKED_BYTES_ACCUMULATOR. add 24 to INCREASE. set CWND to MAX(CWND + MIN(INCREASE, SMSS), CWND_INIT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ANY_LOSSがtrueの場合：（TC_SENTが真である）OR（PRE_ACK_OUTSTANDING&gt; 67200と\ FASTGROW_ALLOWEDが真である）場合：MAXにSSTHRESHを設定する（PRE_ACK_OUTSTANDING * 7/8、CWND_INIT）。他：MAXに設定SSTHRESH（PRE_ACK_OUTSTANDING * 1/2、CWND_INIT）。 SSTHRESHにCWNDを設定します。それ以外であれば0にACKED_BYTES_ACCUMULATORを設定する（ANY_ACKSが真）AND（ANY_NAKSはfalse）と\（PRE_ACK_OUTSTANDING&gt; = CWND）：0 VARのAITHRESHにセットするvar増加を。 FASTGROW_ALLOWEDがtrueの場合：もしCWND &lt;SSTHRESH：ACKED_BYTES_THIS_PACKETに設定し増加しました。他：ACKED_BYTES_ACCUMULATORにACKED_BYTES_THIS_PACKETを追加します。 MIN（MAX（CWND / 16、64）、4800）にAITHRESHセット。 ACKED_BYTES_ACCUMULATOR&gt; = AITHRESHながら：ACKED_BYTES_ACCUMULATORからAITHRESHを引きます。増加に48を追加します。他FASTGROW_ALLOWEDはfalseです：CWND &lt;SSTHRESHとTC_SENTがtrueの場合：CEIL（ACKED_BYTES_THIS_PACKET / 4）に設定された増加しました。他ます。var AITHRESH_CAP。 TC_SENTがtrueの場合：他の2400にAITHRESH_CAPを設定：4800に設定AITHRESH_CAP ACKED_BYTES_ACCUMULATORにACKED_BYTES_THIS_PACKETを追加します。 MIN（MAX（CWND / 16、64）、AITHRESH_CAP）にAITHRESHセット。 ACKED_BYTES_ACCUMULATOR&gt; = AITHRESHながら：ACKED_BYTES_ACCUMULATORからAITHRESHを引きます。増加に24を追加します。 MAX（CWND + MIN（INCREASE、SMSS）、CWND_INIT）にCWNDを設定します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
          Figure 25: Pseudocode for Congestion Window Adjustment
                         after Processing a Packet
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael C. Thornburgh Adobe Systems Incorporated 345 Park Avenue San Jose, CA 95110-2704 US
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
マイケルC. Thornburgh Adob​​e Systems Incorporated（アドビシステムズ社）345パークアベニューサンノゼ、CA 95110-2704米国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +1 408 536 6000 EMail: mthornbu@adobe.com URI: http://www.adobe.com/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+1 408 536 6000 Eメール：mthornbu@adobe.com URI：http://www.adobe.com/
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
