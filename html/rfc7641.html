<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>RFC 7641 - Observing Resources in the Constrained Application Protocol (CoAP) 日本語訳</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="https://tex2e.github.io/rfc-translater/favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>

  <script>
    var host = window.location.hostname;
    if (host != "localhost") {
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-75892425-1', 'auto');
      ga('send', 'pageview');
    }
  </script>

</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">7641</span>
  <div style="height: 1ex;"></div>
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 7641 - Observing Resources in the Constrained Application Protocol (CoAP) 日本語訳</h4>
          <span class="URL">URL :
            <a href="https://tools.ietf.org/html/rfc7641">
              https://tools.ietf.org/html/rfc7641
            </a>
          </span><br>
          <span class="title_ja">
            タイトル : <strong>RFC 7641 - 制約アプリケーションプロトコル（CoAP）にリソースを観察します</strong></span><br>
          <span class="updated_by">翻訳編集 : 自動生成</span><br>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         K. Hartke
Request for Comments: 7641                       Universitaet Bremen TZI
Category: Standards Track                                 September 2015
ISSN: 2070-1721
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observing Resources in the Constrained Application Protocol (CoAP)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約アプリケーションプロトコル（CoAP）にリソースを観察します
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
抽象
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Constrained Application Protocol (CoAP) is a RESTful application protocol for constrained nodes and networks. The state of a resource on a CoAP server can change over time. This document specifies a simple protocol extension for CoAP that enables CoAP clients to &#34;observe&#34; resources, i.e., to retrieve a representation of a resource and keep this representation updated by the server over a period of time. The protocol follows a best-effort approach for sending new representations to clients and provides eventual consistency between the state observed by each client and the actual resource state at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約アプリケーションプロトコル（CoAP）が制約ノードとネットワークのためのRESTfulアプリケーションプロトコルです。 CoAPサーバー上のリソースの状態は、時間の経過とともに変化することができます。この文書では、リソースの表現を取得し、一定期間にわたってサーバーによって更新この表現を維持するために、すなわち、リソースを「観察」するCoAPクライアントを可能にCoAPするための単純なプロトコル拡張を指定します。プロトコルは、クライアントに新しい表現を送信するためのベストエフォート型のアプローチに従い、各クライアントとサーバの実際のリソース状態で観測された状態の間で最終的な一貫性を提供します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
このメモのステータス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
これは、インターネット標準化過程文書です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7641.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7641で取得することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著作権表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目次
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Background  . . . . . . . . . . . . . . . . . . . . . . .  4
     1.2.  Protocol Overview . . . . . . . . . . . . . . . . . . . .  4
     1.3.  Consistency Model . . . . . . . . . . . . . . . . . . . .  6
     1.4.  Observable Resources  . . . . . . . . . . . . . . . . . .  7
     1.5.  Requirements Notation . . . . . . . . . . . . . . . . . .  8
   2.  The Observe Option  . . . . . . . . . . . . . . . . . . . . .  9
   3.  Client-Side Requirements  . . . . . . . . . . . . . . . . . . 10
     3.1.  Request . . . . . . . . . . . . . . . . . . . . . . . . . 10
     3.2.  Notifications . . . . . . . . . . . . . . . . . . . . . . 10
     3.3.  Caching . . . . . . . . . . . . . . . . . . . . . . . . . 11
     3.4.  Reordering  . . . . . . . . . . . . . . . . . . . . . . . 12
     3.5.  Transmission  . . . . . . . . . . . . . . . . . . . . . . 13
     3.6.  Cancellation  . . . . . . . . . . . . . . . . . . . . . . 13
   4.  Server-Side Requirements  . . . . . . . . . . . . . . . . . . 14
     4.1.  Request . . . . . . . . . . . . . . . . . . . . . . . . . 14
     4.2.  Notifications . . . . . . . . . . . . . . . . . . . . . . 14
     4.3.  Caching . . . . . . . . . . . . . . . . . . . . . . . . . 15
     4.4.  Reordering  . . . . . . . . . . . . . . . . . . . . . . . 16
     4.5.  Transmission  . . . . . . . . . . . . . . . . . . . . . . 17
   5.  Intermediaries  . . . . . . . . . . . . . . . . . . . . . . . 20
   6.  Web Linking . . . . . . . . . . . . . . . . . . . . . . . . . 20
   7.  Security Considerations . . . . . . . . . . . . . . . . . . . 21
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . . 22
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . . 22
     9.1.  Normative References  . . . . . . . . . . . . . . . . . . 22
     9.2.  Informative References  . . . . . . . . . . . . . . . . . 22
   Appendix A.  Examples . . . . . . . . . . . . . . . . . . . . . . 24
     A.1.  Client/Server Examples  . . . . . . . . . . . . . . . . . 24
     A.2.  Proxy Examples  . . . . . . . . . . . . . . . . . . . . . 28
   Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . . 30
   Author&#39;s Address  . . . . . . . . . . . . . . . . . . . . . . . . 30
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. はじめに
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. バックグラウンド
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Constrained Application Protocol (CoAP) [RFC7252] is intended to provide RESTful services [REST] not unlike HTTP [RFC7230] while reducing the complexity of implementation as well as the size of packets exchanged in order to make these services useful in a highly constrained network of themselves highly constrained nodes [RFC7228].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
制約アプリケーションプロトコル（CoAP）[RFC7252]はRESTfulなサービスを提供することを目的とする[REST]ではないとは異なり、HTTP [RFC7230]の実装の複雑さを低減するだけでなく、パケットのサイズは非常に制約でこれらのサービスを便利にするために交換しながら自身のネットワーク高度に制約ノード[RFC7228]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model of REST is that of a client exchanging representations of resources with a server, where a representation captures the current or intended state of a resource. The server is the authority for representations of the resources in its namespace. A client interested in the state of a resource initiates a request to the server; the server then returns a response with a representation of the resource that is current at the time of the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESTのモデルは、表現は、リソースの現在のまたは意図の状態をキャプチャし、サーバーとリソースの表現を交換するクライアントのことです。サーバーは、その名前空間内のリソースの表現のための権威です。リソースの状態に興味を持ってクライアントがサーバに要求を開始します。サーバは、要求時の電流であるリソースの表現で応答を返します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This model does not work well when a client is interested in having a current representation of a resource over a period of time. Existing approaches from HTTP, such as repeated polling or HTTP long polling [RFC6202], generate significant complexity and/or overhead and thus are less applicable in a constrained environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、一定期間にわたってリソースの現在の表現を持つことに興味を持っているときに、このモデルはうまく動作しません。このような繰り返しポーリングまたはHTTP長いポーリング[RFC6202]としてHTTPから既存のアプローチは、および/またはオーバーヘッド、したがってかなりの複雑を生成制約環境ではあまり適用可能です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol specified in this document extends the CoAP core protocol with a mechanism for a CoAP client to &#34;observe&#34; a resource on a CoAP server: the client retrieves a representation of the resource and requests this representation be updated by the server as long as the client is interested in the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この表現は限りサーバーによって更新されたクライアントは、リソースの表現を取得し、要求：この文書で指定されたプロトコルは、CoAPサーバー上のリソースを「観察」するCoAPクライアントのための機構を備えたCoAPコアプロトコルを拡張しますクライアントはリソースに興味があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol keeps the architectural properties of REST. It enables high scalability and efficiency through the support of caches and proxies. There is no intention, though, to solve the full set of problems that the existing HTTP solutions solve or to replace publish/subscribe networks that solve a much more general problem [RFC5989].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは、RESTのアーキテクチャの性質を保持します。これは、キャッシュとプロキシのサポートを通じて、高い拡張性と効率性を可能にします。何の意図は、既存のHTTPのソリューションが解決する問題の完全なセットを解決するか、より多くの一般的な問題[RFC5989]を解決するためのネットワークをパブリッシュ/サブスクライブ・交換するために、しかし、ありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. プロトコルの概要
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol is based on the well-known observer design pattern [GOF]. In this design pattern, components called &#34;observers&#34; register at a specific, known provider called the &#34;subject&#34; that they are interested in being notified whenever the subject undergoes a change in state. The subject is responsible for administering its list of registered observers. If multiple subjects are of interest to an observer, the observer must register separately for all of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは、周知のオブザーバデザインパターン[GOF]に基づいています。このデザインパターンにおいては、「観察者」と呼ばれるコンポーネントは、対象が状態の変化を受けるたびに通知されることに興味があることを「被験体」と呼ばれる特定の、既知のプロバイダに登録します。対象は、登録されたオブザーバーのリストを管理する責任があります。複数の被験者が観察者に関心がある場合、観察者はそれらのすべてに対して個別に登録する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       Observer             Subject
                          |                    |
                          |    Registration    |
                          +-------------------&gt;|
                          |                    |
                          |    Notification    |
                          |&lt;-------------------+
                          |                    |
                          |    Notification    |
                          |&lt;-------------------+
                          |                    |
                          |    Notification    |
                          |&lt;-------------------+
                          |                    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Figure 1: The Observer Design Pattern
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
図1：オブザーバーデザインパターン
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The observer design pattern is realized in CoAP as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにオブザーバーデザインパターンは、CoAPで実現されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subject: In the context of CoAP, the subject is a resource in the namespace of a CoAP server. The state of the resource can change over time, ranging from infrequent updates to continuous state transformations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
件名：CoAPの文脈において、対象はCoAPサーバーの名前空間内のリソースがあります。リソースの状態は、まれな更新から連続状態変換に至るまで、経時的に変化させることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observer: An observer is a CoAP client that is interested in having a current representation of the resource at any given time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブザーバー：観察者が任意の時点でのリソースの現在の表現を持つことに興味を持っているCoAPクライアントです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registration: A client registers its interest in a resource by initiating an extended GET request to the server. In addition to returning a representation of the target resource, this request causes the server to add the client to the list of observers of the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録：クライアントがサーバーに拡張されたGETリクエストを開始することによって、リソースでその関心を登録します。ターゲット・リソースの表現を返すことに加えて、この要求は、リソースのオブザーバーのリストにクライアントを追加するには、サーバーが発生します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notification: Whenever the state of a resource changes, the server notifies each client in the list of observers of the resource. Each notification is an additional CoAP response sent by the server in reply to the single extended GET request and includes a complete, updated representation of the new resource state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知：リソースの状態が変化したが、サーバはリソースのオブザーバーのリスト内の各クライアントに通知するたびに。各通知は、単一の拡張GETリクエストに応答してサーバから送信された追加のCoAP応答で、新しいリソースの状態の完全な、更新された表現を含みます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 2 below shows an example of a CoAP client registering its interest in a resource and receiving three notifications: the first with the current state upon registration, and then two upon changes to the resource state. Both the registration request and the notifications are identified as such by the presence of the Observe Option defined in this document. In notifications, the Observe Option additionally provides a sequence number for reordering detection. All notifications carry the token specified by the client, so the client can easily correlate them to the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
登録時の現在の状態と第一、及びリソースの状態に変更する際、2つ：図2は、以下CoAPクライアントがリソースにその関心を登録三の通知を受信する例を示しています。登録要求および通知の両方が、この文書で定義された観察オプションの存在によってそのように識別されます。通知では、観察オプションはさらに、検出を並べ替えるためのシーケンス番号を提供します。すべての通知は、クライアントによって指定されたトークンを運ぶので、クライアントは、簡単に要求にそれらを関連付けることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                       Client                Server
                          |                    |
                          |  GET /temperature  |
                          |    Token: 0x4a     |   Registration
                          |  Observe: 0        |
                          +-------------------&gt;|
                          |                    |
                          |    2.05 Content    |
                          |    Token: 0x4a     |   Notification of
                          |  Observe: 12       |   the current state
                          |  Payload: 22.9 Cel |
                          |&lt;-------------------+
                          |                    |
                          |    2.05 Content    |
                          |    Token: 0x4a     |   Notification upon
                          |  Observe: 44       |   a state change
                          |  Payload: 22.8 Cel |
                          |&lt;-------------------+
                          |                    |
                          |    2.05 Content    |
                          |    Token: 0x4a     |   Notification upon
                          |  Observe: 60       |   a state change
                          |  Payload: 23.1 Cel |
                          |&lt;-------------------+
                          |                    |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
Figure 2: Observing a Resource in CoAP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
図2：CoAPでのリソースを観察
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: In this document, &#34;Cel&#34; stands for &#34;degrees Celsius&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：この文書では、「セル画」を「摂氏温度」の略です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client remains on the list of observers as long as the server can determine the client&#39;s continued interest in the resource. The server may send a notification in a confirmable CoAP message to request an acknowledgement from the client. When the client deregisters, rejects a notification, or the transmission of a notification times out after several transmission attempts, the client is considered no longer interested in the resource and is removed by the server from the list of observers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがいる限り、サーバーがリソースで、クライアントの継続的な関心を決定することができますようオブザーバーのリストに残っています。サーバは、クライアントからの確認を要求するために確認できるCoAPメッセージで通知を送信することができます。クライアントが登録を解除すると、通知、または複数の送信試行後にタイムアウト通知回の送信を拒否し、クライアントがリソースでもはや興味みなされず、オブザーバーのリストからサーバーによって除去されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Consistency Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. 一貫性モデル
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While a client is in the list of observers of a resource, the goal of the protocol is to keep the resource state observed by the client as closely in sync with the actual state at the server as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはリソースのオブザーバーのリストであるが、プロトコルの目標は、可能な限り、サーバーでの実際の状態と同期として密接にクライアントによって観測されたリソースの状態を維持することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It cannot be avoided that the client and the server become out of sync at times: First, there is always some latency between the change of the resource state and the receipt of the notification. Second,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントとサーバーが常時同期しなくなることを避けることができない。まず、リソースの状態の変更と通知の受領の間にいくつかの待ち時間が常にあります。第二に、
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAP messages with notifications can get lost, which will cause the client to assume an old state until it receives a new notification. And third, the server may erroneously come to the conclusion that the client is no longer interested in the resource, which will cause the server to stop sending notifications and the client to assume an old state until it eventually registers its interest again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知とCoAPメッセージは、それが新しい通知を受信するまで、クライアントが古い状態を仮定する原因となる、迷子になることができます。そして第三に、サーバーが誤って、それが最終的に再び関心を登録するまで、通知の送信を停止するには、サーバーとクライアントが古い状態をとることになります、クライアントはもはや資源に興味があるという結論に来るかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol addresses this issue as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のようにプロトコルは、この問題に対処します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It follows a best-effort approach for sending the current representation to the client after a state change: clients should see the new state after a state change as soon as possible, and they should see as many states as possible. This is limited by congestion control, however, so a client cannot rely on observing every single state that a resource might go through.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはできるだけ早く状態の変更後に新しい状態が表示されるはずです、そして、彼らはできるだけ多くの状態を確認する必要があります。o状態変化の後にクライアントに現在の表現を送信するためのベストエフォート型のアプローチに従っています。これは、輻輳制御により制限され、しかし、そのクライアントは、リソースが通過可能性があることを一つ一つの状態を観察するに頼ることはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It labels notifications with a maximum duration up to which it is acceptable for the observed state and the actual state to be out of sync. When the age of the notification received reaches this limit, the client cannot use the enclosed representation until it receives a new notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは同期してあることが観察された状態と実際の状態に対して許容される最大期間で通知をラベル。受信した通知の年齢がこの制限に達すると、それは新しい通知を受信するまで、クライアントは、囲まれた表現を使用することはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is designed on the principle of eventual consistency: the protocol guarantees that if the resource does not undergo a new change in state, eventually all registered observers will have a current representation of the latest resource state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Oそれは結果整合性の原則に基づいて設計されています。このプロトコルは、リソースが状態の新しい変化を受けていない場合、最終的には全ての登録オブザーバーは、最新のリソース状態の現在の表現を持っていることを保証します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Observable Resources
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. 観測可能なリソース
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CoAP server is the authority for determining under what conditions resources change their state and thus when observers are notified of new resource states. The protocol does not offer explicit means for setting up triggers or thresholds; it is up to the server to expose observable resources that change their state in a way that is useful in the application context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAPサーバーは、オブザーバーが新しいリソースの状態が通知されたときに条件のリソースは、このように自分の状態を変更し、何の下で決定するための権限です。プロトコルは、トリガーまたはしきい値を設定するための明示的な手段を提供していません。それは、アプリケーションのコンテキストで有用な方法で自分の状態を変更する観察可能なリソースを公開するサーバー次第です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, a CoAP server with an attached temperature sensor could expose one or more of the following resources:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、取り付けられた温度センサとCoAPサーバは、次のリソースの一つ以上を公開できます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &lt;coap://server/temperature&gt;, which changes its state every few seconds to a current reading of the temperature sensor;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O &lt;coap：//サーバー/温度&gt;、温度センサーの現在の読み取りに数秒ごとにその状態を変化させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &lt;coap://server/temperature/felt&gt;, which changes its state to &#34;COLD&#34; whenever the temperature reading drops below a certain pre-configured threshold and to &#34;WARM&#34; whenever the reading exceeds a second, slightly higher threshold;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O &lt;coap：//サーバ/温度/フェルト&gt;、温度測定値が特定の事前設定された閾値を下回ったと「ウォーム」のたびに読み出しが第二、わずかに高い閾値を超えるたびに「COLD」にその状態を変化させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &lt;coap://server/temperature/critical?above=42&gt;, which changes its state based on the client-specified parameter value either every few seconds to the current temperature reading if the temperature exceeds the threshold or to &#34;OK&#34; when the reading drops below;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O：クライアントが指定したパラメータ値のいずれかの温度がしきい値またはに「OK」を超えた場合に読み出し電流の温度に数秒ごとに基づいてその状態を変更する&lt;coap = 42上記//サーバー/温度/クリティカルな？&gt;、読書は、以下に低下します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &lt;coap://server/?query=select+avg(temperature)+from+Sensor.window: time(30sec)&gt;, which accepts expressions of arbitrary complexity and changes its state accordingly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O &lt;coap：//サーバ/クエリ= + AVG（温度）を選択+ + Sensor.windowから：時間（30秒）&gt;、任意の複雑さの表現を受け入れ、それに応じてその状態を変化させます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, by designing CoAP resources that change their state on certain conditions, it is possible to update the client only when these conditions occur instead of supplying it continuously with raw sensor data. By parameterizing resources, this is not limited to conditions defined by the server, but can be extended to arbitrarily complex queries specified by the client. The application designer therefore can choose exactly the right level of complexity for the application envisioned and devices involved and is not constrained to a &#34;one size fits all&#34; mechanism built into the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
したがって、特定の条件にその状態を変更CoAPリソースを設計することにより、これらの条件は、生センサデータを連続的に供給するのではなく、発生した場合にのみクライアントを更新することができます。リソースをパラメータ化することで、これは、サーバーで定義された条件に限定されるものではなく、クライアントによって指定された任意の複雑なクエリに拡張することができます。アプリケーション設計者は、したがって、アプリケーションの複雑さの正確に正しいレベルを選択することができ想定し、デバイスが関与しに拘束されていないプロトコルに組み込まれたメカニズム「ワンサイズすべてに適合」。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. Requirements Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.5. 要件表記
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この文書のキーワード &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, および &#34;OPTIONAL&#34; はRFC 2119 [RFC2119]に記載されているように解釈されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. The Observe Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.オプションを守って
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Observe Option has the following properties. Its meaning depends on whether it is included in a GET request or in a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
観察オプションは、次のプロパティがあります。その意味は、それがGET要求または応答に含まれているかどうかに依存します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
       +-----+---+---+---+---+---------+--------+--------+---------+
       | No. | C | U | N | R | Name    | Format | Length | Default |
       +-----+---+---+---+---+---------+--------+--------+---------+
       |   6 |   | x | - |   | Observe | uint   | 0-3 B  | (none)  |
       +-----+---+---+---+---+---------+--------+--------+---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
C=Critical, U=Unsafe, N=No-Cache-Key, R=Repeatable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
C =クリティカル、U =安全でない、N =ノーキャッシュキー、R =再現
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Table 1: The Observe Option
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
表1：オプションを守って
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When included in a GET request, the Observe Option extends the GET method so it does not only retrieve a current representation of the target resource, but also requests the server to add or remove an entry in the list of observers of the resource depending on the option value. The list entry consists of the client endpoint and the token specified by the client in the request. Possible values are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GET要求に含まれる場合には、オプションを観察し、それが唯一のターゲットリソースの現在の表現を取得していないので、GETメソッドを拡張するだけでなく、追加またはに応じて、リソースのオブザーバーのリストのエントリを削除するには、サーバーを要求しますオプションの値。リストのエントリには、クライアントのエンドポイントと要求でクライアントによって指定されたトークンで構成されています。可能な値は以下のとおりです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0 (register) adds the entry to the list, if not present;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
存在しない場合は0（登録）、リストにエントリを追加します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1 (deregister) removes the entry from the list, if present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
存在する場合に1（登録解除）、リストからエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Observe Option is not critical for processing the request. If the server is unwilling or unable to add a new entry to the list of observers, then the request falls back to a normal GET request and the response does not include the Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
観察オプションは、要求を処理するために重要ではありません。サーバは不本意またはオブザーバーのリストに新しいエントリを追加することができない場合、その要求は正常に戻っGETリクエストに低下し、応答が観察オプションが含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Observe Option is not part of the Cache-Key: a cacheable response obtained with an Observe Option in the request can be used to satisfy a request without an Observe Option, and vice versa. When a stored response with an Observe Option is used to satisfy a normal GET request, the option MUST be removed before the response is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
観察オプションは、キャッシュキーの一部ではない：要求における観察オプションを用いて得られたキャッシュ可能な応答その逆観察オプションなしで要求を満たすために使用することができます。観察オプションと格納された応答は通常のGET要求を満たすために使用されたときに応答が返される前に、オプションが除去されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When included in a response, the Observe Option identifies the message as a notification. This implies that a matching entry exists in the list of observers and that the server will notify the client of changes to the resource state. The option value is a sequence number for reordering detection (see Sections 3.4 and 4.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
応答に含まれる場合、観察オプション通知としてメッセージを識別する。これは、一致するエントリがオブザーバーのリストに存在することを、サーバーがリソースの状態への変更をクライアントに通知することを意味します。オプションの値は、検出を並べ替えるためのシーケンス番号（セクション3.4および4.4を参照）です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value of the Observe Option is encoded as an unsigned integer in network byte order using a variable number of bytes (&#39;uint&#39; option format); see Section 3.2 of RFC 7252 [RFC7252].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
観察オプションの値は、バイトの可変数（「UINT」オプションの形式）を使用して、ネットワークバイト順に符号のない整数として符号化されます。 RFC 7252 [RFC7252]の3.2節を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Client-Side Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.クライアント側の要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client registers its interest in a resource by issuing a GET request with an Observe Option set to 0 (register). If the server returns a 2.xx response that includes an Observe Option as well, the server has successfully added an entry with the client endpoint and request token to the list of observers of the target resource, and the client will be notified of changes to the resource state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、0（レジスタ）に設定守っオプション付きGETリクエストを発行することにより、リソースに対する関心を登録します。サーバは、同様のオプションを守っ含ま2.xxの応答を返した場合、サーバーは、ターゲット・リソースのオブザーバーのリストにクライアントエンドポイントのエントリとリクエストトークンを正常に追加しました、そしてクライアントがへの変更が通知されますリソースの状態。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like a fresh response can be used to satisfy a request without contacting the server, the stream of updates resulting from one observation request can be used to satisfy another (observation or normal GET) request if the target resource is the same. A client MUST aggregate such requests and MUST NOT register more than once for the same target resource. The target resource is identified by all options in the request that are part of the Cache-Key. This includes, for example, the full request URI and the Accept Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新鮮な応答がサーバに接触することなく、要求を満たすために使用することができるように、ターゲット・リソースが同じであれば、一回の観察要求に起因する更新のストリームが別の（観察又は通常GET）要求を満たすために使用することができます。クライアントは、このような要求を集約しなければならなくて、同じターゲット・リソースに対して複数回登録してはなりません。ターゲット・リソースは、キャッシュキーの一部であるリクエストのすべてのオプションで識別されます。これは、例えば、完全なリクエストURIと受け入れるオプションが含まれています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Notifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notifications are additional responses sent by the server in reply to the single extended GET request that created the registration. Each notification includes the token specified by the client in the request. The only difference between a notification and a normal response is the presence of the Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知は、登録を作成した単一の拡張GETリクエストに応答してサーバから送信された追加的な応答です。各通知は、要求でクライアントによって指定されたトークンを含んでいます。通知と正常な応答との間の唯一の違いは観察オプションの存在です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notifications typically have a 2.05 (Content) response code. They include an Observe Option with a sequence number for reordering detection (see Section 3.4) and a payload in the same Content-Format as the initial response. If the client included one or more ETag Options in the GET request (see Section 3.3), notifications can have a 2.03 (Valid) response code rather than a 2.05 (Content) response code. Such notifications include an Observe Option with a sequence number but no payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知は通常、2.05（コンテンツ）応答コードを持っています。彼らは、最初の応答と同じ内容・形式で検出（3.4節を参照）、ペイロードを並べ替えるためのシーケンス番号とオプションを確認しています。クライアントが（3.3節を参照）GETリクエスト内の1つまたは複数のETagのオプションが含まれていた場合、通知は2.03（有効）応答コードではなく、2.05（コンテンツ）応答コードを持つことができます。このような通知は、シーケンス番号が、無ペイロードを持つ守っオプションが含まれます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that the resource changes in a way that would cause a normal GET request at that time to return a non-2.xx response (for example, when the resource is deleted), the server sends a notification with an appropriate response code (such as 4.04 Not Found) and removes the client&#39;s entry from the list of observers of the resource. Non-2.xx responses do not include an Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（リソースが削除されると、例えば）その時点で通常のGETリクエストを引き起こす方法で、リソースの変更が非2.xxの応答を返すようにした場合には、サーバが適切な応答コードで通知を送信します（例えば4.04は見つかりません）とリソースのオブザーバーのリストから、クライアントのエントリを削除します。非2.xxの応答が観察オプションが含まれていません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As notifications are just additional responses to a GET request, notifications partake in caching as defined in Section 5.6 of RFC 7252 [RFC7252]. Both the freshness model and the validation model are supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知はGETリクエストにだけ追加の応答であるとしてRFC 7252 [RFC7252]のセクション5.6で定義され、通知がキャッシュに参加します。鮮度モデルと検証モデルの両方がサポートされています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. Freshness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. 鮮度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client MAY store a notification like a response in its cache and use a stored notification that is fresh without contacting the server. Like a response, a notification is considered fresh while its age is not greater than the value indicated by the Max-Age Option (and no newer notification/response has been received).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、キャッシュ内の応答のような通知を保管し、サーバーに接触することなく、新鮮で保存された通知を使用するかもしれません。その年齢が最大年齢オプションによって示される値より大きくない場合（NOの新しい通知/応答が受信されていない）しながら反応と同様に、通知が新鮮であると考えられます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server will do its best to keep the resource state observed by the client as closely in sync with the actual state as possible. However, a client cannot rely on observing every single state that a resource might go through. For example, if the network is congested or the state changes more frequently than the network can handle, the server can skip notifications for any number of intermediate states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、可能な限り実際の状態と同期として密接にクライアントによって観測されたリソースの状態を維持するために最善を尽くします。ただし、クライアントはリソースが通過する可能性があるすべての単一の状態を観察するに頼ることはできません。ネットワークが輻輳しているかの状態がより頻繁にネットワークが処理できるよりも変化した場合、サーバーは、中間状態の任意の数の通知を省略することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server uses the Max-Age Option to indicate an age up to which it is acceptable that the observed state and the actual state are inconsistent. If the age of the latest notification becomes greater than its indicated Max-Age, then the client MUST NOT assume that the enclosed representation reflects the actual resource state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、年齢を示すために、マックス・年齢・オプションを使用することが観察状態と実際の状態が矛盾していることを許容されています。最新の通知の年齢が示されたマックス・年齢より大きくなった場合、クライアントは囲まれた表現は、実際のリソースの状態を反映していると仮定してはいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To make sure it has a current representation and/or to re-register its interest in a resource, a client MAY issue a new GET request with the same token as the original at any time. All options MUST be identical to those in the original request except for the set of ETag Options. It is RECOMMENDED that the client does not issue the request while it still has a fresh notification/response for the resource in its cache. Additionally, the client SHOULD at least wait for a random amount of time between 5 and 15 seconds after Max-Age expired to reduce collisions with other clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それは現在の表現を持っていることを確認するために、および/またはリソースに対する持分を再登録するために、クライアントは、いつでもオリジナルと同じトークンを使用して、新たなGETリクエストを発行することができます。すべてのオプションはETagのオプションのセットを除き、元の要求のものと同一でなければなりません。まだそのキャッシュ内のリソースのための新鮮な通知/応答を持っていながら、クライアントが要求を発行しないことが推奨されます。マックス・年齢は他のクライアントとの衝突を減らすために有効期限が切れた後さらに、クライアントは、少なくとも5秒から15秒の間でランダムな時間を待つべき。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. バリデーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a client has one or more notifications stored in its cache for a resource, it can use the ETag Option in the GET request to give the server an opportunity to select a stored notification to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがリソースにそのキャッシュに格納された1つの以上の通知を持っている場合は、サーバーに使用する保存された通知を選択する機会を与えるためにGET要求でのETagオプションを使用することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MAY include an ETag Option for each stored response that is applicable in the GET request. Whenever the observed resource changes to a representation identified by one of the ETag Options, the server can select a stored response by sending a 2.03 (Valid) notification with an appropriate ETag Option instead of a 2.05 (Content) notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、GETリクエストに適用可能である記憶された各応答のためのETagオプションを含むかもしれません。観察されたリソースのETagオプションのいずれかによって識別表現に変更するたびに、サーバは、代わり2.05（コンテンツ）通知の適切なETagをオプションで2.03（有効）通知を送信して記憶された応答を選択することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client implementation needs to keep all candidate responses in its cache until it is no longer interested in the target resource or it re-registers with a new set of entity tags.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
それはもはやターゲットリソースに興味を持っているか、それはエンティティタグの新しいセットに再登録されるまで、クライアントの実装は、そのキャッシュ内のすべての候補応答を維持する必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Reordering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 並べ替え
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Messages with notifications can arrive in a different order than they were sent. Since the goal is to keep the observed state as closely in sync with the actual state as possible, a client MUST consider the notification that was sent most recently as the freshest, regardless of the order of arrival.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知のメッセージは、送信された順序とは異なる順序で到着することができます。目標は、できるだけ実際の状態と同期してように観察状態を維持することですので、クライアントは関係なく、到着順の、新鮮として最近送られた通知を考慮しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide an order among notifications for the client, the server sets the value of the Observe Option in each notification to the 24 least significant bits of a strictly increasing sequence number. An incoming notification was sent more recently than the freshest notification so far when one of the following conditions is met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントの通知間の順序を提供するために、サーバは、厳密に増加するシーケンス番号の24個の最下位ビットにそれぞれ通知で観察オプションの値を設定します。次のいずれかの条件が満たされたときに着信通知は、これまでより最近では、新鮮な通知より送信されました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                      (V1 &lt; V2 and V2 - V1 &lt; 2^23) or
                      (V1 &gt; V2 and V1 - V2 &gt; 2^23) or
                      (T2 &gt; T1 + 128 seconds)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where V1 is the value of the Observe Option in the freshest notification so far, V2 is the value of the Observe Option in the incoming notification, T1 is a client-local timestamp for the freshest notification so far, and T2 is a client-local timestamp for the incoming notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
V1は、これまで新鮮な通知で観察オプションの値であり、V2は、着信通知に観察オプションの値は、T1は、これまで新鮮な通知のクライアントローカルタイムスタンプであり、T2は、クライアントローカルであります着信通知のタイムスタンプ。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Design Note: The first two conditions verify that V1 is less than V2 in 24-bit serial number arithmetic [RFC1982]. The third condition ensures that if the server is generating serial numbers based on a local clock, the time elapsed between the two incoming messages is not so large that the difference between V1 and V2 has become larger than the largest integer that it is meaningful to add to a 24-bit serial number; in other words, after 128 seconds have elapsed without any notification, a client does not need to check the sequence numbers to assume that an incoming notification was sent more recently than the freshest notification it has received so far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デザインノート：最初の2つの条件がV1は、24ビットのシリアル番号算術[RFC1982]でV2未満であることを確認してください。第三の条件は、サーバがローカル・クロックに基づいてシリアル番号を生成している場合、2つの入力メッセージ間の経過時間は、V1とV2との差が、追加する意味があることを最大の整数よりも大きくなったほど大きくないことを保証します24ビットのシリアル番号に、 128秒は任意の通知なしで経過した後に、他の言葉で、クライアントは、着信通知が最近になって、それがこれまでに受けた新鮮な通知より送信されたと仮定するシーケンス番号をチェックする必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The duration of 128 seconds was chosen as a nice round number greater than MAX_LATENCY (Section 4.8.2 of RFC 7252 [RFC7252]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
128秒の持続時間はMAX_LATENCYより大きいいいラウンド数（RFC 7252のセクション4.8.2 [RFC7252]）として選択しました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. トランスミッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A notification can be confirmable or non-confirmable, i.e., it can be sent in a confirmable or a non-confirmable message. The message type used for a notification is independent of the type used for the request and of any previous notification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知が確認可能または非確認可能とすることができる、すなわち、それが確認でき、または非確認できるメッセージで送信することができます。通知のために使用されるメッセージタイプが要求するため、任意の以前の通知に使用されるタイプとは無関係です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client does not recognize the token in a confirmable notification, it MUST NOT acknowledge the message and SHOULD reject it with a Reset message; otherwise, the client MUST acknowledge the message as usual. In the case of a non-confirmable notification, rejecting the message with a Reset message is OPTIONAL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが確認できる通知にトークンを認識しない場合は、メッセージを確認してはならないとリセットメッセージでそれを拒否すべきです。そうでない場合、クライアントは通常どおりメッセージを確認しなければなりません。非確認可能通知の場合には、リセットメッセージのメッセージを拒否することは任意です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An acknowledgement message signals to the server that the client is alive and interested in receiving further notifications; if the server does not receive an acknowledgement in reply to a confirmable notification, it will assume that the client is no longer interested and will eventually remove the associated entry from the list of observers (Section 4.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントが生きていると、さらに通知を受信することに関心があるサーバに確認メッセージ信号;サーバが確認できる通知への応答で確認応答を受信しない場合、クライアントはもはや興味を持っていないことを前提とし、最終的にはオブザーバー（4.5節）のリストから関連するエントリを削除します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Cancellation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 取り消し
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client that is no longer interested in receiving notifications for a resource can simply &#34;forget&#34; the observation. When the server then sends the next notification, the client will not recognize the token in the message and thus will return a Reset message. This causes the server to remove the associated entry from the list of observers. The entries in lists of observers are effectively &#34;garbage collected&#34; by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
もはやリソースの通知を受信することに関心があるクライアントは、単に観察を「忘れる」ことができます。サーバは、次の通知を送信すると、クライアントは、メッセージにトークンを認識しませんので、リセットメッセージを返します。これは、オブザーバーのリストから関連するエントリを削除するには、サーバーが発生します。オブザーバーのリスト内のエントリは、効果的にサーバによって「ガベージコレクション」です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: Due to potential message loss, the Reset message may not reach the server. The client may therefore have to reject multiple notifications, each with one Reset message, until the server finally removes the associated entry from the list of observers and stops sending notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：潜在的なメッセージの損失のため、リセットメッセージがサーバーに到達しない場合があります。サーバーが最終的にオブザーバーのリストから関連するエントリを削除し、通知の送信を停止するまで、クライアントはそのため、複数の通知、1つのリセットメッセージとそれぞれを拒否する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some circumstances, it may be desirable to cancel an observation and release the resources allocated by the server to it more eagerly. In this case, a client MAY explicitly deregister by issuing a GET request that has the Token field set to the token of the observation to be cancelled and includes an Observe Option with the value set to 1 (deregister). All other options MUST be identical to those in the registration request except for the set of ETag Options. When the server receives such a request, it will remove any matching entry from the list of observers and process the GET request as usual.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
いくつかの状況では、観察をキャンセルして、より熱心にそれにサーバによって割り当てられたリソースを解放することが望ましい場合があります。この場合、クライアントは、明示的にキャンセルされる観察のトークンに設定トークンフィールドを有しており、1（登録解除）に設定された値と観察オプションを含むGET要求を発行することにより、登録解除MAY。他のすべてのオプションは、ETagのオプションのセットを除き、登録要求のものと同一でなければなりません。サーバは、このような要求を受信すると、それはオブザーバーのリストから一致するエントリを削除し、いつものようにGETリクエストを処理します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Server-Side Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.サーバー側の要件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A GET request with an Observe Option set to 0 (register) requests the server not only to return a current representation of the target resource, but also to add the client to the list of observers of that resource. Upon success, the server returns a current representation of the resource and MUST keep this representation updated (as described in Section 1.3) as long as the client is on the list of observers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0（レジスタ）に設定守っオプション付きGETリクエストは、ターゲット・リソースの現在の表現を返すために、だけでなく、そのリソースのオブザーバーのリストにクライアントを追加するだけでなく、サーバに要求します。成功した場合、サーバーはリソースの現在の表現を返し、（セクション1.3で説明したように）限り、クライアントは、オブザーバーのリストにあるように更新この表現を維持しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The entry in the list of observers is keyed by the client endpoint and the token specified by the client in the request. If an entry with a matching endpoint/token pair is already present in the list (which, for example, happens when the client wishes to reinforce its interest in a resource), the server MUST NOT add a new entry but MUST replace or update the existing one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブザーバーのリスト内のエントリは、クライアントのエンドポイントと要求でクライアントによって指定されたトークンをキーとしています。一致するエンドポイント/トークンのペアを持つエントリが（クライアントがリソースに対する関心を強化したい場合例えば、たまたま、）リスト内にすでに存在している場合は、サーバが新しいエントリを追加してはなりませんが、交換または更新しなければなりません。既存のもの。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that is unable or unwilling to add a new entry to the list of observers of a resource MAY silently ignore the registration request and process the GET request as usual. The resulting response MUST NOT include an Observe Option, the absence of which signals to the client that it will not be notified of changes to the resource and, e.g., needs to poll the resource for its state instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースのオブザーバーのリストに新しいエントリを追加することができないか、不本意であるサーバが静かに登録要求を無視して、いつものようにGETリクエストを処理することができます。得られた応答は、それが例えばリソースと、への変更が通知されないクライアントに信号不在その観察オプションを含んではいけません、代わりに状態のリソースをポーリングする必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Observe Option in a GET request is set to 1 (deregister), then the server MUST remove any existing entry with a matching endpoint/ token pair from the list of observers and process the GET request as usual. The resulting response MUST NOT include an Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GETリクエストに観察オプションが（登録解除）1に設定されている場合、サーバは、観察者のリストから一致するエンドポイント/トークン対の既存のエントリを削除して、いつものようにGET要求を処理しなければなりません。結果の応答は観察オプションを含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Notifications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client is notified of changes to the resource state by additional responses sent by the server in reply to the GET request. Each such notification response (including the initial response) MUST echo the token specified by the client in the GET request. If there are multiple entries in the list of observers, the order in which the clients are notified is not defined; the server is free to use any method to determine the order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントがGET要求に応答してサーバから送信された追加の応答によるリソースの状態への変更が通知されます。 （初期応答を含む）それぞれのそのような通知応答がGET要求でクライアントによって指定されたトークンをエコーし​​なければなりません。複数のエントリは、オブザーバーのリストにある場合は、クライアントに通知される順序は定義されていません。サーバーは、順序を決定するための任意の方法を使用して自由です。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A notification SHOULD have a 2.05 (Content) or 2.03 (Valid) response code. However, in the event that the state of a resource changes in a way that would cause a normal GET request at that time to return a non-2.xx response (for example, when the resource is deleted), the server SHOULD notify the client by sending a notification with an appropriate response code (such as 4.04 Not Found) and subsequently MUST remove the associated entry from the list of observers of the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知2.05（コンテンツ）または2.03（有効）レスポンスコードを有しているべきです。しかし、（リソースが削除されると、例えば）その時点で通常のGETリクエストを引き起こす方法で、リソースの状態が変化したが、非2.xxの応答を返すようにした場合には、サーバが通知する必要がある（SHOULD）適切な応答コードで通知を送信することにより、クライアントはリソースのオブザーバーのリストから関連するエントリを削除する必要があり、その後（のような4.04は見つかりません）と。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Content-Format specified in a 2.xx notification MUST be the same as the one used in the initial response to the GET request. If the server is unable to continue sending notifications in this format, it SHOULD send a notification with a 4.06 (Not Acceptable) response code and subsequently MUST remove the associated entry from the list of observers of the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.xxの通知に指定されたコンテンツフォーマットは、GET要求への初期応答で使用したものと同じでなければなりません。サーバーは、この形式で通知を送り続けることができない場合は、4.06（許容できない）応答コードとの通知を送信すべきであり、その後、リソースのオブザーバーのリストから関連するエントリを削除する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A 2.xx notification MUST include an Observe Option with a sequence number as specified in Section 4.4 below; a non-2.xx notification MUST NOT include an Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.xxの通知は、以下のセクション4.4で指定されたシーケンス番号とオプションを確認し含める必要があります。非2.xxの通知が守っオプションを含んではいけません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Caching
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. キャッシング
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As notifications are just additional responses sent by the server in reply to a GET request, they are subject to caching as defined in Section 5.6 of RFC 7252 [RFC7252].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知がGET要求に対する応答でサーバーから送信されただけで、追加の応答であるとしてRFC 7252 [RFC7252]のセクション5.6で定義されているように、彼らは、キャッシングの対象となります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. Freshness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. 鮮度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After returning the initial response, the server MUST keep the resource state that is observed by the client as closely in sync with the actual resource state as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初期応答を返す後、サーバーは、可能な限り実際のリソースの状態と同期してのように密接にクライアントによって観察されたリソースの状態を維持しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since becoming out of sync at times cannot be avoided, the server MUST indicate for each representation an age up to which it is acceptable that the observed state and the actual state are inconsistent. This age is application dependent and MUST be specified in notifications using the Max-Age Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
避けることができない時期に同期していなってきているので、サーバはそれぞれの表現のために年齢を示しているしなければならないことが観察状態と実際の状態が矛盾していることを許容されています。この年齢では、アプリケーションに依存し、マックス・年齢・オプションを使用して、通知で指定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the resource does not change and the client has a current representation, the server does not need to send a notification. However, if the client does not receive a notification, the client cannot tell if the observed state and the actual state are still in sync. Thus, when the age of the latest notification becomes greater than its indicated Max-Age, the client no longer has a usable representation of the resource state. The server MAY wish to prevent that by sending a new notification with the unchanged representation and a new Max-Age just before the Max-Age indicated earlier expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースが変更されないと、クライアントが現在の表現を持っている場合は、サーバが通知を送信する必要はありません。クライアントが通知を受信しない場合に観察状態と実際の状態が同期して残っている場合は、クライアントが言うことができません。最新の通知の年齢が示されたマックス・年齢よりも大きくなったときにこのように、クライアントは、もはやリソース状態の使用可能な表現を持っていません。サーバーはそのまま表現し、前に示したマックス・エイジの有効期限が切れる直前に新しいマックス年齢で新しい通知を送信することによって、それを防ぐために望むことができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. Validation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. バリデーション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client can include a set of entity tags in its request using the ETag Option. When an observed resource changes its state and the origin server is about to send a 2.05 (Content) notification, then whenever that notification has an entity tag in the set of entity tags specified by the client, the server MAY send a 2.03 (Valid) response with an appropriate ETag Option instead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、ETagのオプションを使用して、その要求にエンティティタグのセットを含めることができます。観測されたリソースは、その状態を変更し、オリジンサーバが2.05（コンテンツ）通知を送信しようとするときは、その通知がクライアントによって指定されたエンティティタグのセットでのエンティティタグを持って、その後いつでも、サーバーは、2.03（有効な）を送るかもしれません代わりに、適切なETagのオプションと応答。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Reordering
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 並べ替え
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because messages can get reordered, the client needs a way to determine if a notification arrived later than a newer notification. For this purpose, the server MUST set the value of the Observe Option of each notification it sends to the 24 least significant bits of a strictly increasing sequence number. The sequence number MAY start at any value and MUST NOT increase so fast that it increases by more than 2^23 within less than 256 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
メッセージは並べ替えを取得することができるため、クライアントは、通知が後で新しい通知より到着したかどうかを判断する方法が必要です。この目的のために、サーバは、それが厳密に増加するシーケンス番号の24個の最下位ビットに送信する各通知の観察オプションの値を設定しなければなりません。シーケンス番号は、任意の値で開始することと非常に速く、それが未満256秒以内以上2 ^ 23で増加することを増やしてはなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence number selected for a notification MUST be greater than that of any preceding notification sent to the same client with the same token for the same resource. The value of the Observe Option MUST be current at the time of transmission; if a notification is retransmitted, the server MUST update the value of the option to the sequence number that is current at that time before retransmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知のために選択されたシーケンス番号は、同一のリソースに対して同じトークンで同じクライアントに送信される先行するいずれかの通知のそれよりも大きくなければなりません。観察オプションの値は、送信時の電流でなければなりません。通知が再送信された場合、サーバは再送信する前に、その時点で、現在のシーケンス番号にオプションの値を更新する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: A simple implementation that satisfies the requirements is to obtain a timestamp from a local clock. The sequence number then is the timestamp in ticks, where 1 tick = (256 seconds)/(2^23) = 30.52 microseconds. It is not necessary that the clock reflects the current time/date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：要件を満たす単純な実装は、ローカルクロックからのタイムスタンプを取得することです。シーケンス番号は、その後、ダニのタイムスタンプであり、ここで、1ティック=（256秒）/（2 ^ 23）= 30.52マイクロ秒。クロックが現在の時刻/日付を反映している必要はありません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Another valid implementation is to store a 24-bit unsigned integer variable per resource and increment this variable each time the resource undergoes a change of state (provided that the resource changes its state less than 2^23 times in the first 256 seconds after every state change). This removes the need to update the value of the Observe Option on retransmission when the resource state did not change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
別の有効な実装では、リソースがすべての状態の後の最初の256秒内のリソースの状態が変化すること未満の2 ^ 23回を設けた状態の変化を（受けリソース当たり24ビットの符号なし整数変数を格納し、この変数をインクリメントするたびにあります変化する）。これは、リソースの状態は変化しなかったときの再送に守ってオプションの値を更新する必要がなくなります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Design Note: The choice of a 24-bit option value and a time span of 256 seconds theoretically allows for a notification rate of up to 65536 notifications per second. Constrained nodes often have rather imprecise clocks, though, and inaccuracies of the client and server side may cancel out or add in effect. Therefore, the maximum notification rate is reduced to 32768 notifications per second. This is still well beyond the highest known design objective of around 1 kHz (most CoAP applications will be several orders of magnitude below that) but allows total clock inaccuracies of up to -50/+100%.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
デザインノート：24ビットのオプション値の選択と256秒の時間間隔は、理論的には最大毎秒65536の通知の通知・レートが可能になります。制約付きのノードは、多くの場合、しかし、かなり不正確なクロックを持っており、クライアント側とサーバー側の不正確さが相殺または効果に追加することができます。したがって、最大通知速度は、毎秒32768の通知に低減されます。これはよく1kHz前後の最高の知られている設計の目的を超えて（ほとんどのCoAPアプリケーションはその下数桁になります）はまだですが、最大で-50 / + 100％不正確総クロックすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. トランスミッション
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A notification can be sent in a confirmable or a non-confirmable message. The message type used is typically application dependent and may be determined by the server for each notification individually.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通知が確認可能または非確認できるメッセージで送信することができます。使用されるメッセージのタイプは、典型的には、アプリケーションに依存し、個々の通知のためにサーバーによって決定されてもよいです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, for resources that change in a somewhat predictable or regular fashion, notifications can be sent in non-confirmable messages; for resources that change infrequently, notifications can be sent in confirmable messages. The server can combine these two approaches depending on the frequency of state changes and the importance of individual notifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例えば、多少予測可能または規則的に変化するリソースのために、通知が非確認できるメッセージで送信することができます。あまり変更されないリソースのために、通知が確認できるメッセージで送信することができます。サーバーは、状態変化の頻度と個々の通知の重要性に応じて、これらの二つのアプローチを組み合わせることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server MAY choose to skip sending a notification if it knows that it will send another notification soon, for example, when the state of a resource is changing frequently. It also MAY choose to send more than one notification for the same resource state. However, above all, the server MUST ensure that a client in the list of observers of a resource eventually observes the latest state if the resource does not undergo a new change in state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバは、リソースの状態が頻繁に変更されたとき、それは、例えば、すぐに別の通知を送信することを知っている場合に通知を送信スキップすることを選択するかもしれません。また、同じリソースの状態のために複数の通知を送信するために選ぶかもしれません。しかし、すべての上に、サーバーリソースが状態の新しい変化を受けていない場合は、リソースのオブザーバーのリストで、クライアントは最終的に最新の状態を観察していることを確認しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, when state changes occur in bursts, the server can skip some notifications, send the notifications in non-confirmable messages, and make sure that the client observes the latest state change by repeating the last notification in a confirmable message when the burst is over.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態変化がバースト的に発生した場合たとえば、サーバーは、一部の通知を省略することができます非確認可能なメッセージで通知を送信し、クライアントはバーストがあるときに確認できるメッセージの最後の通知を繰り返すことで、最新の状態変化を観察していることを確認してくださいオーバー。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client&#39;s acknowledgement of a confirmable notification signals that the client is interested in receiving further notifications. If a client rejects a confirmable or non-confirmable notification with a Reset message, or if the last attempt to retransmit a confirmable notification times out, then the client is considered no longer interested and the server MUST remove the associated entry from the list of observers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントはさらに、通知を受信することに関心がある確認できる通知信号のクライアントの承認。クライアントは、リセットメッセージで確認でき、非確認できる通知を拒否し、または最後の試みが出て確認できる通知回数を再送信する場合、クライアントはもはや興味とみなされていないと、サーバーがオブザーバーのリストから関連するエントリを削除しなければならない場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: To properly process a Reset message that rejects a non-confirmable notification, a server needs to remember the message IDs of the non-confirmable notifications it sends. This may be challenging for a server with constrained resources. However, since Reset messages are transmitted unreliably, the client must be prepared in case the Reset messages are not received by the server. Thus, a server can always pretend that a Reset message rejecting a non-confirmable notification was lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
実装上の注意：適切に非確認できる通知を拒否リセットメッセージを処理するには、サーバは送信非確認できる通知のメッセージIDを覚えておく必要があります。これは、制約のリソースを持つサーバーの挑戦かもしれません。リセットメッセージが不確実に送信されているので、クライアントは、リセットのメッセージがサーバによって受信されない場合に準備する必要があります。したがって、サーバーは常に非確認できる通知を拒否するリセットメッセージが失われたことをふりをすることができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If a server does this, it could accelerate cancellation by sending the following notifications to that client in confirmable messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
サーバーがこれを行う場合は、それが確認できたメッセージにそのクライアントに次の通知を送信することにより、キャンセルを加速することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A server that transmits notifications mostly in non-confirmable messages MUST send a notification in a confirmable message instead of a non-confirmable message at least every 24 hours. This prevents a client that went away or is no longer interested from remaining in the list of observers indefinitely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大部分の非確認可能メッセージで通知を送信し、サーバではなく、非確認できるメッセージの確認可能メッセージは、少なくとも24時間ごとに通知を送信しなければなりません。これは離れていったか、もはや無期限オブザーバーのリストに残っているから、興味を持っていないクライアントを防ぎます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. 輻輳制御
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Basic congestion control for CoAP is provided by the exponential back-off mechanism in Section 4.2 of RFC 7252 [RFC7252] and the limitations in Section 4.7 of RFC 7252 [RFC7252]. However, CoAP places the responsibility of congestion control for simple request/ response interactions only on the clients: rate-limiting request transmission implicitly controls the transmission of the responses. When a single request yields a potentially infinite number of notifications, additional responsibility needs to be placed on the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAPための基本的な輻輳制御は、RFC 7252 [RFC7252]のセクション4.2に指数関数的なバックオフ機構によって提供され、制限RFC 7252 [RFC7252]のセクション4.7にされます。しかし、CoAPはクライアントだけに単純な要求/応答対話のための輻輳制御の責任を置く：律速リクエスト送信は、暗黙的に応答の送信を制御します。単一の要求は、通知の潜在的に無限の数を生成する場合、追加の責任は、サーバー上に配置する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order not to cause congestion, servers MUST strictly limit the number of simultaneous outstanding notifications/responses that they transmit to a given client to NSTART (1 by default; see Section 4.7 of RFC 7252 [RFC7252]). An outstanding notification/response is either a confirmable message for which an acknowledgement has not yet been received and whose last retransmission attempt has not yet timed out or a non-confirmable message for which the waiting time that results from the following rate-limiting rules has not yet elapsed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
渋滞を起こさないようにするために、サーバは、厳密に彼らがn始動に与えられたクライアントに送信し、同時に優れた通知/応答（; RFC 7252のセクション4.7 [RFC7252]を参照してくださいデフォルトでは1）の数を制限しなければなりません。抜群の通知/応答が確認応答がまだ受信されていないため確認できたメッセージとその最後の再試行がまだタイムアウトしていないか、以下のレート制限ルールから得られる待ち時間が持っている非確認できるメッセージのいずれかでありますまだ経過していません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The server SHOULD NOT send more than one non-confirmable notification per round-trip time (RTT) to a client on average. If the server cannot maintain an RTT estimate for a client, it SHOULD NOT send more than one non-confirmable notification every 3 seconds and SHOULD use an even less aggressive rate when possible (see also Section 3.1.2 of RFC 5405 [RFC5405]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーは、平均して、クライアントにラウンドトリップ時間（RTT）ごとに複数の非確認できる通知を送るべきではありません。サーバがクライアントのRTT推定値を維持することができない場合は、それが3秒ごとに複数の非確認できる通知を送信すべきではなく、可能な場合でも、あまり積極的でレートを使用すべきである（RFCのセクション3.1.2も参照5405 [RFC5405]） 。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further congestion control optimizations and considerations are expected in the future with advanced CoAP congestion control mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
また、輻輳制御の最適化と考察は、高度なCoAP輻輳制御メカニズムと、将来的に期待されています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. Advanced Transmission
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. 高度な伝送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The state of an observed resource may change while the number of simultaneous outstanding notifications/responses to a client on the list of observers is greater than or equal to NSTART. In this case, the server cannot notify the client of the new resource state immediately but has to wait for an outstanding notification/response to complete first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
オブザーバーのリスト上のクライアントへの同時優れ通知/応答の数がより多いまたはn始動に等しい一方で観測されたリソースの状態が変更されることがあります。この場合、サーバはすぐに新しいリソースの状態をクライアントに通知しますが、優れた通知/応答が最初に完了するのを待たなければならないことはできません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there exists an outstanding notification/response that the server transmits to the client and that pertains to the changed resource, then it is desirable for the server to stop working towards getting the representation of the old resource state to the client and to start transmitting the current representation to the client instead, so the resource state observed by the client stays closer in sync with the actual state at the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
抜群の通知/応答が存在する場合は、サーバーがクライアントに送信し、それが変更されたリソースに関係するサーバーがクライアントに古いリソース状態の表現を取得に向けた作業を停止すると送信を開始するために、それは望ましいこと現在の代わりにクライアントに表現するので、クライアントによって観測されたリソースの状態は、サーバーでの実際の状態と同期して近づいたままになります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this purpose, the server MAY optimize the transmission process by aborting the transmission of the old notification (but not before the current transmission attempt is completed) and starting a new transmission for the new notification (but with the retransmission timer and counter of the aborted transmission retained).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この目的のために、サーバは古い通知（ただし、現在の送信試行が完了する前）の送信を中止し、中止されたの新しい通知（ただし付き再送タイマーとカウンタのための新たな送信を開始することにより、送信処理を最適化することができますトランスミッション保持）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In more detail, a server MAY supersede an outstanding transmission that pertains to an observation as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
より詳細には、サーバーは、次のように観察に関係する優れた伝送に取って代わる可能性があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Wait for the current (re)transmission attempt to be acknowledged, rejected, or to time out (confirmable transmission); or, wait for the waiting time to elapse or the transmission to be rejected (non-confirmable transmission).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
現在の（再）送信試行1.待ちは、認め拒否、またはタイムアウト（確認できる伝送）にします。または、経過を待っている時間または拒否される送信（非確認できる伝送）を待ちます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the transmission is rejected or it was the last attempt to retransmit a notification, remove the associated entry from the list of observers of the observed resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2.送信が拒否されるか、通知を再送する最後の試みであった、観測されたリソースのオブザーバーのリストから関連するエントリを削除した場合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the entry is still in the list of observers, start to transmit a new notification with a representation of the current resource state. Should the resource have changed its state more than once in the meantime, the notifications for the intermediate states are silently skipped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3.エントリはオブザーバーのリストに残っている場合は、現在のリソース状態の表現で新しい通知を送信するために開始します。リソースは一度その間に比べて、その状態がより変更されている必要があり、中間状態の通知は黙ってスキップされます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. The new notification is transmitted with a new Message ID and the following transmission parameters: if the previous (re)transmission attempt timed out, retain its transmission parameters, increment the retransmission counter, and double the timeout; otherwise, initialize the transmission parameters as usual (see Section 4.2 of RFC 7252 [RFC7252]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前の（再）送信の試行がタイムアウトした場合、その送信パラメータを保持し、再送カウンタをインクリメントし、タイムアウトを倍増; 4.新しい通知が新しいメッセージIDと、次の送信パラメータで送信されますそうでない場合、（RFC 7252のセクション4.2 [RFC7252]を参照）を通常どおり送信パラメータを初期化します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible that the server later receives an acknowledgement for a confirmable notification that it superseded this way. Even though this does not signal consistency, it is valuable in that it signals the client&#39;s further interest in the resource. The server therefore should avoid inadvertently removing the associated entry from the list of observers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
サーバーが後でそれがこの方法を取っ確認できる通知の確認応答を受け取ることも可能です。これは、一貫性を通知しませんが、それはリソースで、クライアントの更なる関心を知らせることで価値があります。サーバーは、したがって、不注意オブザーバーのリストから関連するエントリを削除することは避けてください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Intermediaries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.仲介
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client may be interested in a resource in the namespace of a server that is reached through a chain of one or more CoAP intermediaries. In this case, the client registers its interest with the first intermediary towards the server, acting as if it was communicating with the server itself, as specified in Section 3. It is the task of this intermediary to provide the client with a current representation of the target resource and to keep the representation updated upon changes to the resource state, as specified in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クライアントは、1つまたは複数のCoAP仲介のチェーンを介して到達されているサーバの名前空間内のリソースに興味があるかもしれません。この場合、クライアントは、現在の表現をクライアントに提供するために、この仲介者の役割である第3節で指定され、それは、サーバー自体と通信していたかのように動作し、サーバーへの最初の中間でその関心を登録しますターゲット・リソースおよび第4節で指定されているように、リソースの状態への変更時に更新表現を維持します。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To perform this task, the intermediary SHOULD make use of the protocol specified in this document, taking the role of the client and registering its own interest in the target resource with the next hop towards the server. If the response returned by the next hop doesn&#39;t include an Observe Option, the intermediary MAY resort to polling the next hop or MAY itself return a response without an Observe Option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
このタスクを実行するには、仲介者は、クライアントの役割を取って、サーバーへの次のホップを使用してターゲットリソースで独自の関心を登録し、この文書で指定されたプロトコルを利用するべきです。次のホップから返された応答が観察オプションが含まれていない場合は、仲介者は、次のホップのポーリングに頼るか、あるいは自身が守っオプションなしで応答を返す場合があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The communication between each pair of hops is independent; each hop in the server role MUST determine individually how many notifications to send, of which message type, and so on. Each hop MUST generate its own values for the Observe Option in notifications and MUST set the value of the Max-Age Option according to the age of the local current representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ホップの各対の間の通信には無関係です。サーバーの役割の各ホップはように、のメッセージタイプを送信し、ためにどのように多くの通知を個別に判断しなければなりません。各ホップは、通知で観察オプションのために、独自の値を生成しなければならないし、地元の現在の表現の年齢に応じて最大エイジ・オプションの値を設定しなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If two or more clients have registered their interest in a resource with an intermediary, the intermediary MUST register itself only once with the next hop and fan out the notifications it receives to all registered clients. This relieves the next hop from sending the same notifications multiple times and thus enables scalability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
二つ以上のクライアントが仲介して、リソースへの関心を登録した場合は、仲介者は、それが登録されているすべてのクライアントに受信通知アウトネクストホップとファンとの一度だけ自分自身を登録する必要があります。これは、同じ通知を複数回送信から次のホップを軽減ので、スケーラビリティを可能にします。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An intermediary is not required to act on behalf of a client to observe a resource; an intermediary MAY observe a resource, for example, just to keep its own cache up to date.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲介は、リソースを観察するために、クライアントに代わって行動する必要はありません。仲介だけで最新の状態に独自のキャッシュを維持するために、例えば、リソースを観察することができます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Appendix A.2 for examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例については、付録A.2を参照してください。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Web Linking
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.ウェブリンク
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A web link [RFC5988] to a resource accessible over CoAP (for example, in a link-format document [RFC6690]) MAY include the target attribute &#34;obs&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CoAPを介してアクセス可能なリソースへのウェブリンク[RFC5988]（例えば、リンク形式の文書[RFC6690]で）ターゲット属性「OBS」を含むかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;obs&#34; attribute, when present, is a hint indicating that the destination of a link is useful for observation and thus, for example, should have a suitable graphical representation in a user interface. Note that this is only a hint; it is not a promise that the Observe Option can actually be used to perform the observation. A client may need to resort to polling the resource if the Observe Option is not returned in the response to the GET request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
「OBS」属性は、存在する場合、リンク先が観察のために有用であり、したがって、例えば、ユーザインタフェースにおける適切なグラフィカル表現を持つべきであることを示すヒントです。これは単なるヒントであることに注意してください。それは観察オプションが実際に観察を行うために使用することができます約束ではありません。クライアントは、観察オプションはGETリクエストに応答して返されていない場合、ポーリングにリソースを頼る必要があるかもしれません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A value MUST NOT be given for the &#34;obs&#34; attribute; any present value MUST be ignored by parsers. The &#34;obs&#34; attribute MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
値は、「OBS」属性のために与えられてはなりません。任意の現在価値は、パーサによって無視されなければなりません。 「OBS」属性は、一度与えられたリンク値でより多く見えてはいけません。最初の後の出現は、パーサによって無視されなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.セキュリティの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security considerations in Section 11 of [RFC7252], the CoAP specification, apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252]のセクション11のセキュリティの考慮事項は、CoAP仕様は、適用されます。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Observing resources can dramatically increase the negative effects of amplification attacks. That is, not only can notifications messages be much larger than the request message, but the nature of the protocol can cause a significant number of notifications to be generated. Without client authentication, a server therefore MUST strictly limit the number of notifications that it sends between receiving acknowledgements that confirm the actual interest of the client in the data; i.e., any notifications sent in non-confirmable messages MUST be interspersed with confirmable messages. Note that an attacker may still spoof the acknowledgements if the confirmable messages are sufficiently predictable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
観察のリソースが大幅に増幅攻撃の負の効果を高めることができます。それだけでなく、通知メッセージが要求メッセージよりもはるかに大きくなることが、ですが、プロトコルの性質は、通知のかなりの数が生成されることがあります。クライアント認証がなければ、サーバは、したがって、厳密には、データ内のクライアントの実際の関心を確認し、確認応答を受信するまで送信した通知の数を制限しなければなりません。すなわち、非確認できるメッセージで送信された通知が確認できるメッセージが点在しなければなりません。確認可能なメッセージは十分に予測可能である場合、攻撃者がまだ確認応答を偽装することがあります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol follows a best-effort approach for keeping the state observed by a client and the actual resource state at a server in sync. This may have the client and the server become out of sync at times. Depending on the sensitivity of the observed resource, operating on an old state might be a security threat. The client therefore must be careful not to use a representation after its Max-Age expires, and the server must set the Max-Age Option to a sensible value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
プロトコルは、同期サーバーで、クライアントと実際のリソース状態で観測された状態を維持するためのベストエフォート型のアプローチに従っています。これは、クライアントとの回で同期しなくなって、サーバを有することができます。観測されたリソースの感度に応じて、古い状態で動作することは、セキュリティ上の脅威であるかもしれません。クライアントは、したがって、その最大エイジの有効期限が切れた後の表現を使用しないように注意しなければならず、サーバが賢明な値にマックス・年齢・オプションを設定する必要があります。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with any protocol that creates state, attackers may attempt to exhaust the resources that the server has available for maintaining the list of observers for each resource. Servers may want to apply access controls to this creation of state. As degraded behavior, the server can always fall back to processing the request as a normal GET request (without an Observe Option) if it is unwilling or unable to add a client to the list of observers of a resource, including if system resources are exhausted or nearing exhaustion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状態を作成し、任意のプロトコルと同様に、攻撃者は、サーバーが各リソースのオブザーバーのリストを維持するために利用できる持っているリソースを使い果たししようとすることができます。サーバはこの状態の創造にアクセス制御を適用することもできます。システムリソースが枯渇している場合を含め、リソースのオブザーバーのリストにクライアントを追加したくないか、できない場合、劣化の挙動として、サーバは常にバック（お守りオプションなし）通常のGET要求として要求を処理する落ちることができますまたは枯渇に近づいて。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intermediaries must be careful to ensure that notifications cannot be employed to create a loop. A simple way to break any loops is to employ caches for forwarding notifications in intermediaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仲介は、通知がループを作成するために使用することができないことを保証するために注意しなければなりません。すべてのループを切断する簡単な方法は、仲介者に通知を転送するためのキャッシュを使用することです。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resources can be observed over CoAP that is secured by Datagram Transport Layer Security (DTLS) using any of the security modes described in Section 9 of RFC 7252. The use of DTLS is indicated by the &#34;coaps&#34; URI scheme. All notifications resulting from a GET request with an Observe Option MUST be returned within the same epoch of the same connection as the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
リソースがRFC 7252. DTLSの使用のセクション9に記載のセキュリティモードのいずれかを使用してデータグラムトランスポート層セキュリティ（DTLS）で固定されているCoAPにわたって観察することができますが、「coaps」URIスキームで示されます。守っオプション付きGETリクエストから生じたすべての通知は要求と同じ接続の同じエポック以内に戻らなければなりません。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. IANAの考慮事項
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following entry has been added to the CoAP Option Numbers registry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
次のエントリは、CoAPオプション番号のレジストリに追加されました：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
                     +--------+---------+-----------+
                     | Number | Name    | Reference |
                     +--------+---------+-----------+
                     |      6 | Observe | RFC 7641  |
                     +--------+---------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 引用規格
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]ブラドナーの、S.、 &#34;要件レベルを示すためにRFCsにおける使用のためのキーワード&#34;、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、&lt;http://www.rfc-editor.org/info/ RFC2119&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5988] Nottingham, M., &#34;Web Linking&#34;, RFC 5988, DOI 10.17487/RFC5988, October 2010, &lt;http://www.rfc-editor.org/info/rfc5988&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5988]ノッティンガム、M.、 &#34;ウェブリンク&#34;、RFC 5988、DOI 10.17487 / RFC5988、2010年10月、&lt;http://www.rfc-editor.org/info/rfc5988&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, &#34;The Constrained Application Protocol (CoAP)&#34;, RFC 7252, DOI 10.17487/RFC7252, June 2014, &lt;http://www.rfc-editor.org/info/rfc7252&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7252]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 &#34;制約アプリケーションプロトコル（CoAP）&#34;、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、&lt;HTTP：//www.rfc-editor。組織/情報/ rfc7252&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 参考文献
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GOF] Gamma, E., Helm, R., Johnson, R., and J. Vlissides, &#34;Design Patterns: Elements of Reusable Object-Oriented Software&#34;, Addison-Wesley Professional Computing Series, 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[GOF]ガンマ、E.、ヘルム、R.、ジョンソン、R.、およびJ. Vlissides、 &#34;デザインパターン：オブジェクト指向における再利用のための&#34;、アディソン・ウェズリープロフェッショナルコンピューティングシリーズ、1994。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REST] Fielding, R., &#34;Architectural Styles and the Design of Network-based Software Architectures&#34;, Ph.D. Dissertation, University of California, Irvine, 2000, &lt;http://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REST]フィールディング、R.、「建築スタイルとネットワークベースのソフトウェアアーキテクチャの設計」、博士論文、カリフォルニア大学アーバイン校、2000年、&lt;http://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1982] Elz, R. and R. Bush, &#34;Serial Number Arithmetic&#34;, RFC 1982, DOI 10.17487/RFC1982, August 1996, &lt;http://www.rfc-editor.org/info/rfc1982&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1982]エルツ、R.とR.ブッシュ大統領、 &#34;シリアル番号演算&#34;、RFC 1982、DOI 10.17487 / RFC1982、1996年8月、&lt;http://www.rfc-editor.org/info/rfc1982&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] Eggert, L. and G. Fairhurst, &#34;Unicast UDP Usage Guidelines for Application Designers&#34;, BCP 145, RFC 5405, DOI 10.17487/RFC5405, November 2008, &lt;http://www.rfc-editor.org/info/rfc5405&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405]エッゲルト、L.とG. Fairhurst、 &#34;アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項&#34;、BCP 145、RFC 5405、DOI 10.17487 / RFC5405、2008年11月、&lt;http://www.rfc-editor.org/info / rfc5405&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5989] Roach, A., &#34;A SIP Event Package for Subscribing to Changes to an HTTP Resource&#34;, RFC 5989, DOI 10.17487/RFC5989, October 2010, &lt;http://www.rfc-editor.org/info/rfc5989&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5989]ローチ、A.、 &#34;HTTPリソースへの変更への登録のためのSIPイベントパッケージ&#34;、RFC 5989、DOI 10.17487 / RFC5989、2010年10月、&lt;http://www.rfc-editor.org/info/rfc5989 &gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6202] Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins, &#34;Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP&#34;, RFC 6202, DOI 10.17487/RFC6202, April 2011, &lt;http://www.rfc-editor.org/info/rfc6202&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6202] &#34;双方向HTTPでの既知の問題とベストプラクティスロングポーリングの使用のためとストリーミング&#34; ロレート、S.、サン・アンドレ、P.、Salsano、S.、およびG.ウィルキンス、RFC 6202、DOI 10.17487 / RFC6202、2011年4月、&lt;http://www.rfc-editor.org/info/rfc6202&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6690] Shelby, Z., &#34;Constrained RESTful Environments (CoRE) Link Format&#34;, RFC 6690, DOI 10.17487/RFC6690, August 2012, &lt;http://www.rfc-editor.org/info/rfc6690&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6690]シェルビー、Z.、 &#34;制約RESTfulな環境（コア）リンク・フォーマット&#34;、RFC 6690、DOI 10.17487 / RFC6690、2012年8月、&lt;http://www.rfc-editor.org/info/rfc6690&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7228] Bormann, C., Ersue, M., and A. Keranen, &#34;Terminology for Constrained-Node Networks&#34;, RFC 7228, DOI 10.17487/RFC7228, May 2014, &lt;http://www.rfc-editor.org/info/rfc7228&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7228]ボルマン、C.、Ersue、M.、およびA. Keranen、 &#34;制約ノードのネットワークのための用語&#34;、RFC 7228、DOI 10.17487 / RFC7228、2014年5月、&lt;http://www.rfc-editor.org /情報/ rfc7228&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., &#34;Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing&#34;, RFC 7230, DOI 10.17487/RFC7230, June 2014, &lt;http://www.rfc-editor.org/info/rfc7230&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 &#34;ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング&#34;、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、&lt;http://www.rfc-editor.org/info/ rfc7230&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix A. Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
付録A.例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1. Client/Server Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.1。クライアント/サーバーの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Observed   CLIENT  SERVER     Actual
     t   State         |      |         State
         ____________  |      |  ____________
     1                 |      |
     2    unknown      |      |     18.5 Cel
     3                 +-----&gt;|                  Header: GET 0x41011633
     4                 | GET  |                   Token: 0x4a
     5                 |      |                Uri-Path: temperature
     6                 |      |                 Observe: 0 (register)
     7                 |      |
     8                 |      |
     9   ____________  |&lt;-----+                  Header: 2.05 0x61451633
    10                 | 2.05 |                   Token: 0x4a
    11    18.5 Cel     |      |                 Observe: 9
    12                 |      |                 Max-Age: 15
    13                 |      |                 Payload: &#34;18.5 Cel&#34;
    14                 |      |
    15                 |      |  ____________
    16   ____________  |&lt;-----+                  Header: 2.05 0x51457b50
    17                 | 2.05 |     19.2 Cel      Token: 0x4a
    18    19.2 Cel     |      |                 Observe: 16
    29                 |      |                 Max-Age: 15
    20                 |      |                 Payload: &#34;19.2 Cel&#34;
    21                 |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Figure 3: A Client Registers and Receives One Notification of the Current State and One of a New State upon a State Change
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
図3：クライアントのレジスタとは状態変更時にワン現状の通知と新国家のひとつを受け取ります
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Observed   CLIENT  SERVER     Actual
     t   State         |      |         State
         ____________  |      |  ____________
    22                 |      |
    23    19.2 Cel     |      |     19.2 Cel
    24                 |      |  ____________
    25                 | X----+                  Header: 2.05 0x51457b51
    26                 | 2.05 |     19.7 Cel      Token: 0x4a
    27                 |      |                 Observe: 25
    28                 |      |                 Max-Age: 15
    29                 |      |                 Payload: &#34;19.7 Cel&#34;
    30                 |      |
    31   ____________  |      |
    32                 |      |
    33    19.2 Cel     |      |
    34    (stale)      |      |
    35                 |      |
    36                 |      |
    37                 |      |
    38                 +-----&gt;|                  Header: GET 0x41011634
    39                 | GET  |                   Token: 0xb2
    40                 |      |                Uri-Path: temperature
    41                 |      |                 Observe: 0 (register)
    42                 |      |
    43                 |      |
    44   ____________  |&lt;-----+                  Header: 2.05 0x61451634
    45                 | 2.05 |                   Token: 0xb2
    46    19.7 Cel     |      |                 Observe: 44
    47                 |      |                 Max-Age: 15
    48                 |      |                    ETag: 0x78797a7a79
    49                 |      |                 Payload: &#34;19.7 Cel&#34;
    50                 |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Figure 4: The Client Re-registers after Max-Age Ends
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
図4：最大エージング終了後のクライアントの再登録
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Observed   CLIENT  SERVER     Actual
     t   State         |      |         State
         ____________  |      |  ____________
    51                 |      |
    52    19.7 Cel     |      |     19.7 Cel
    53                 |      |
    54                 |      |  ____________
    55                 |    crash
    56                 |
    57                 |
    58                 |
    59   ____________  |
    60                 |
    61    19.7 Cel     |
    62    (stale)      |
    63                 |   reboot____________
    64                 |      |
    65                 |      |     20.0 Cel
    66                 |      |
    67                 +-----&gt;|                  Header: GET 0x41011635
    68                 | GET  |                   Token: 0xf9
    69                 |      |                Uri-Path: temperature
    70                 |      |                 Observe: 0 (register)
    71                 |      |                    ETag: 0x78797a7a79
    72                 |      |
    73                 |      |
    74   ____________  |&lt;-----+                  Header: 2.05 0x61451635
    75                 | 2.05 |                   Token: 0xf9
    76    20.0 Cel     |      |                 Observe: 74
    77                 |      |                 Max-Age: 15
    78                 |      |                 Payload: &#34;20.0 Cel&#34;
    79                 |      |
    80                 |      |  ____________
    81   ____________  |&lt;-----+                  Header: 2.03 0x5143aa0c
    82                 | 2.03 |     19.7 Cel      Token: 0xf9
    83    19.7 Cel     |      |                 Observe: 81
    84                 |      |                    ETag: 0x78797a7a79
    85                 |      |                 Max-Age: 15
    86                 |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
        Figure 5: The Client Re-registers and Gives the Server the
                  Opportunity to Select a Stored Response
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
         Observed   CLIENT  SERVER     Actual
     t   State         |      |         State
         ____________  |      |  ____________
    87                 |      |
    88    19.7 Cel     |      |     19.7 Cel
    89                 |      |
    90                 |      |  ____________
    91   ____________  |&lt;-----+                  Header: 2.05 0x4145aa0f
    92                 | 2.05 |     19.3 Cel      Token: 0xf9
    93    19.3 Cel     |      |                 Observe: 91
    94                 |      |                 Max-Age: 15
    95                 |      |                 Payload: &#34;19.3 Cel&#34;
    96                 |      |
    97                 |      |
    98                 +- - -&gt;|                  Header: 0x7000aa0f
    99                 |      |
   100                 |      |
   101                 |      |
   102                 |      |  ____________
   103                 |      |
   104                 |      |     19.0 Cel
   105                 |      |
   106   ____________  |      |
   107                 |      |
   108    19.3 Cel     |      |
   109    (stale)      |      |
   110                 |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Figure 6: The Client Rejects a Notification and Thereby Cancels the Observation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
図6：クライアントが通知を拒否し、これにより観察を取り消し
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2. Proxy Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.2。プロキシの例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CLIENT  PROXY  SERVER
      |      |      |
      |      +-----&gt;|     Header: GET 0x41015fb8
      |      | GET  |      Token: 0x1a
      |      |      |   Uri-Host: sensor.example
      |      |      |   Uri-Path: status
      |      |      |    Observe: 0 (register)
      |      |      |
      |      |&lt;-----+     Header: 2.05 0x61455fb8
      |      | 2.05 |      Token: 0x1a
      |      |      |    Observe: 42
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;ready&#34;
      |      |      |
      +-----&gt;|      |     Header: GET 0x41011633
      | GET  |      |      Token: 0x9a
      |      |      |  Proxy-Uri: coap://sensor.example/status
      |      |      |
      |&lt;-----+      |     Header: 2.05 0x61451633
      | 2.05 |      |      Token: 0x9a
      |      |      |    Max-Age: 53
      |      |      |    Payload: &#34;ready&#34;
      |      |      |
      |      |&lt;-----+     Header: 2.05 0x514505fc0
      |      | 2.05 |      Token: 0x1a
      |      |      |    Observe: 135
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;busy&#34;
      |      |      |
      +-----&gt;|      |     Header: GET 0x41011634
      | GET  |      |      Token: 0x9b
      |      |      |  Proxy-Uri: coap://sensor.example/status
      |      |      |
      |&lt;-----+      |     Header: 2.05 0x61451634
      | 2.05 |      |      Token: 0x9b
      |      |      |    Max-Age: 49
      |      |      |    Payload: &#34;busy&#34;
      |      |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Figure 7: A Proxy Observes a Resource to Keep its Cache Up to Date
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
図7：プロキシが最新のキャッシュを維持するためにリソースを観察
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-12">
        <pre class="text text-monospace">
   CLIENT  PROXY  SERVER
      |      |      |
      +-----&gt;|      |     Header: GET 0x41011635
      | GET  |      |      Token: 0x6a
      |      |      |  Proxy-Uri: coap://sensor.example/status
      |      |      |    Observe: 0 (register)
      |      |      |
      |&lt;- - -+      |     Header: 0x60001635
      |      |      |
      |      +-----&gt;|     Header: GET 0x4101af90
      |      | GET  |      Token: 0xaa
      |      |      |   Uri-Host: sensor.example
      |      |      |   Uri-Path: status
      |      |      |    Observe: 0 (register)
      |      |      |
      |      |&lt;-----+     Header: 2.05 0x6145af90
      |      | 2.05 |      Token: 0xaa
      |      |      |    Observe: 67
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;ready&#34;
      |      |      |
      |&lt;-----+      |     Header: 2.05 0x4145af94
      | 2.05 |      |      Token: 0x6a
      |      |      |    Observe: 17346
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;ready&#34;
      |      |      |
      +- - -&gt;|      |     Header: 0x6000af94
      |      |      |
      |      |&lt;-----+     Header: 2.05 0x51455a20
      |      | 2.05 |      Token: 0xaa
      |      |      |    Observe: 157
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;busy&#34;
      |      |      |
      |&lt;-----+      |     Header: 2.05 0x5145af9b
      | 2.05 |      |      Token: 0x6a
      |      |      |    Observe: 17436
      |      |      |    Max-Age: 60
      |      |      |    Payload: &#34;busy&#34;
      |      |      |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Figure 8: A Client Observes a Resource through a Proxy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
図8：クライアントがプロキシを通じてリソースを観察
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
謝辞
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Carsten Bormann was an original author of this document and is acknowledged for significant contribution to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
カルステンボルマンは、このドキュメントの原作者であり、このドキュメントへの重要な貢献を認められています。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Daniele Alessandrelli, Jari Arkko, Peter A. Bigot, Angelo P. Castellani, Gilbert Clark, Esko Dijk, Thomas Fossati, Brian Frank, Bert Greevenbosch, Jeroen Hoebeke, Cullen Jennings, Matthias Kovatsch, Barry Leiba, Salvatore Loreto, Charles Palmer, Akbar Rahman, Zach Shelby, and Floris Van den Abeele for helpful comments and discussions that have shaped the document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ダニエルAlessandrelliのおかげで、ヤリArkko、ピーター・A.ビゴ、アンジェロP.カステラーニ、ギルバート・クラーク、エスコダイク、トーマス・フォッサーティ、ブライアン・フランク、バートGreevenbosch、イェルーンHoebeke、カレン・ジェニングス、マティアスKovatsch、バリー・レイバ、サルヴァトーレ・ロレート、チャールズ・パーマー文書を形作ってきた有益なコメントや議論のために、アクバル・ラーマン、ザックシェルビー、およびフロリスヴァンデンAbeele。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This work was supported in part by Klaus Tschira Foundation, Intel, Cisco, and Nokia.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
この作品は、クラウス・ツシラ財団、インテル、シスコ、およびNokiaによって部分的にサポートされていました。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
著者のアドレス
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Klaus Hartke Universitaet Bremen TZI Postfach 330440 Bremen D-28359 Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
クラウスHARTKE UniversitaetブレーメンTZI POSTFACH 330440 D-28359ブレーメンドイツ
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: +49-421-218-63905 Email: hartke@tzi.org
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
電話：+ 49-421-218-63905 Eメール：hartke@tzi.org
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
